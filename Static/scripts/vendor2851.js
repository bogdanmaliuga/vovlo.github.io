/*!
 * jQuery Transit - CSS3 transitions and transformations
 * (c) 2011-2014 Rico Sta. Cruz
 * MIT Licensed.
 *
 * http://ricostacruz.com/jquery.transit
 * http://github.com/rstacruz/jquery.transit
 */
/* jshint expr: true */
;
(function(root, factory) {

    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('jquery'));
    } else {
        factory(root.jQuery);
    }

}(this, function($) {

    $.transit = {
        version: "0.9.12",

        // Map of $.css() keys to values for 'transitionProperty'.
        // See https://developer.mozilla.org/en/CSS/CSS_transitions#Properties_that_can_be_animated
        propertyMap: {
            marginLeft: 'margin',
            marginRight: 'margin',
            marginBottom: 'margin',
            marginTop: 'margin',
            paddingLeft: 'padding',
            paddingRight: 'padding',
            paddingBottom: 'padding',
            paddingTop: 'padding'
        },

        // Will simply transition "instantly" if false
        enabled: true,

        // Set this to false if you don't want to use the transition end property.
        useTransitionEnd: false
    };

    var div = document.createElement('div');
    var support = {};

    // Helper function to get the proper vendor property name.
    // (`transition` => `WebkitTransition`)
    function getVendorPropertyName(prop) {
        // Handle unprefixed versions (FF16+, for example)
        if (prop in div.style) return prop;

        var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
        var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);

        for (var i = 0; i < prefixes.length; ++i) {
            var vendorProp = prefixes[i] + prop_;
            if (vendorProp in div.style) {
                return vendorProp;
            }
        }
    }

    // Helper function to check if transform3D is supported.
    // Should return true for Webkits and Firefox 10+.
    function checkTransform3dSupport() {
        div.style[support.transform] = '';
        div.style[support.transform] = 'rotateY(90deg)';
        return div.style[support.transform] !== '';
    }

    var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

    // Check for the browser's transitions support.
    support.transition = getVendorPropertyName('transition');
    support.transitionDelay = getVendorPropertyName('transitionDelay');
    support.transform = getVendorPropertyName('transform');
    support.transformOrigin = getVendorPropertyName('transformOrigin');
    support.filter = getVendorPropertyName('Filter');
    support.transform3d = checkTransform3dSupport();

    var eventNames = {
        'transition': 'transitionend',
        'MozTransition': 'transitionend',
        'OTransition': 'oTransitionEnd',
        'WebkitTransition': 'webkitTransitionEnd',
        'msTransition': 'MSTransitionEnd'
    };

    // Detect the 'transitionend' event needed.
    var transitionEnd = support.transitionEnd = eventNames[support.transition] || null;

    // Populate jQuery's `$.support` with the vendor prefixes we know.
    // As per [jQuery's cssHooks documentation](http://api.jquery.com/jQuery.cssHooks/),
    // we set $.support.transition to a string of the actual property name used.
    for (var key in support) {
        if (support.hasOwnProperty(key) && typeof $.support[key] === 'undefined') {
            $.support[key] = support[key];
        }
    }

    // Avoid memory leak in IE.
    div = null;

    // ## $.cssEase
    // List of easing aliases that you can use with `$.fn.transition`.
    $.cssEase = {
        '_default': 'ease',
        'in': 'ease-in',
        'out': 'ease-out',
        'in-out': 'ease-in-out',
        'snap': 'cubic-bezier(0,1,.5,1)',
        // Penner equations
        'easeInCubic': 'cubic-bezier(.550,.055,.675,.190)',
        'easeOutCubic': 'cubic-bezier(.215,.61,.355,1)',
        'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
        'easeInCirc': 'cubic-bezier(.6,.04,.98,.335)',
        'easeOutCirc': 'cubic-bezier(.075,.82,.165,1)',
        'easeInOutCirc': 'cubic-bezier(.785,.135,.15,.86)',
        'easeInExpo': 'cubic-bezier(.95,.05,.795,.035)',
        'easeOutExpo': 'cubic-bezier(.19,1,.22,1)',
        'easeInOutExpo': 'cubic-bezier(1,0,0,1)',
        'easeInQuad': 'cubic-bezier(.55,.085,.68,.53)',
        'easeOutQuad': 'cubic-bezier(.25,.46,.45,.94)',
        'easeInOutQuad': 'cubic-bezier(.455,.03,.515,.955)',
        'easeInQuart': 'cubic-bezier(.895,.03,.685,.22)',
        'easeOutQuart': 'cubic-bezier(.165,.84,.44,1)',
        'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
        'easeInQuint': 'cubic-bezier(.755,.05,.855,.06)',
        'easeOutQuint': 'cubic-bezier(.23,1,.32,1)',
        'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
        'easeInSine': 'cubic-bezier(.47,0,.745,.715)',
        'easeOutSine': 'cubic-bezier(.39,.575,.565,1)',
        'easeInOutSine': 'cubic-bezier(.445,.05,.55,.95)',
        'easeInBack': 'cubic-bezier(.6,-.28,.735,.045)',
        'easeOutBack': 'cubic-bezier(.175, .885,.32,1.275)',
        'easeInOutBack': 'cubic-bezier(.68,-.55,.265,1.55)'
    };

    // ## 'transform' CSS hook
    // Allows you to use the `transform` property in CSS.
    //
    //     $("#hello").css({ transform: "rotate(90deg)" });
    //
    //     $("#hello").css('transform');
    //     //=> { rotate: '90deg' }
    //
    $.cssHooks['transit:transform'] = {
        // The getter returns a `Transform` object.
        get: function(elem) {
            return $(elem).data('transform') || new Transform();
        },

        // The setter accepts a `Transform` object or a string.
        set: function(elem, v) {
            var value = v;

            if (!(value instanceof Transform)) {
                value = new Transform(value);
            }

            // We've seen the 3D version of Scale() not work in Chrome when the
            // element being scaled extends outside of the viewport.  Thus, we're
            // forcing Chrome to not use the 3d transforms as well.  Not sure if
            // translate is affectede, but not risking it.  Detection code from
            // http://davidwalsh.name/detecting-google-chrome-javascript
            if (support.transform === 'WebkitTransform' && !isChrome) {
                elem.style[support.transform] = value.toString(true);
            } else {
                elem.style[support.transform] = value.toString();
            }

            $(elem).data('transform', value);
        }
    };

    // Add a CSS hook for `.css({ transform: '...' })`.
    // In jQuery 1.8+, this will intentionally override the default `transform`
    // CSS hook so it'll play well with Transit. (see issue #62)
    $.cssHooks.transform = {
        set: $.cssHooks['transit:transform'].set
    };

    // ## 'filter' CSS hook
    // Allows you to use the `filter` property in CSS.
    //
    //     $("#hello").css({ filter: 'blur(10px)' });
    //
    $.cssHooks.filter = {
        get: function(elem) {
            return elem.style[support.filter];
        },
        set: function(elem, value) {
            elem.style[support.filter] = value;
        }
    };

    // jQuery 1.8+ supports prefix-free transitions, so these polyfills will not
    // be necessary.
    if ($.fn.jquery < "1.8") {
        // ## 'transformOrigin' CSS hook
        // Allows the use for `transformOrigin` to define where scaling and rotation
        // is pivoted.
        //
        //     $("#hello").css({ transformOrigin: '0 0' });
        //
        $.cssHooks.transformOrigin = {
            get: function(elem) {
                return elem.style[support.transformOrigin];
            },
            set: function(elem, value) {
                elem.style[support.transformOrigin] = value;
            }
        };

        // ## 'transition' CSS hook
        // Allows you to use the `transition` property in CSS.
        //
        //     $("#hello").css({ transition: 'all 0 ease 0' });
        //
        $.cssHooks.transition = {
            get: function(elem) {
                return elem.style[support.transition];
            },
            set: function(elem, value) {
                elem.style[support.transition] = value;
            }
        };
    }

    // ## Other CSS hooks
    // Allows you to rotate, scale and translate.
    registerCssHook('scale');
    registerCssHook('scaleX');
    registerCssHook('scaleY');
    registerCssHook('translate');
    registerCssHook('rotate');
    registerCssHook('rotateX');
    registerCssHook('rotateY');
    registerCssHook('rotate3d');
    registerCssHook('perspective');
    registerCssHook('skewX');
    registerCssHook('skewY');
    registerCssHook('x', true);
    registerCssHook('y', true);

    // ## Transform class
    // This is the main class of a transformation property that powers
    // `$.fn.css({ transform: '...' })`.
    //
    // This is, in essence, a dictionary object with key/values as `-transform`
    // properties.
    //
    //     var t = new Transform("rotate(90) scale(4)");
    //
    //     t.rotate             //=> "90deg"
    //     t.scale              //=> "4,4"
    //
    // Setters are accounted for.
    //
    //     t.set('rotate', 4)
    //     t.rotate             //=> "4deg"
    //
    // Convert it to a CSS string using the `toString()` and `toString(true)` (for WebKit)
    // functions.
    //
    //     t.toString()         //=> "rotate(90deg) scale(4,4)"
    //     t.toString(true)     //=> "rotate(90deg) scale3d(4,4,0)" (WebKit version)
    //
    function Transform(str) {
        if (typeof str === 'string') {
            this.parse(str);
        }
        return this;
    }

    Transform.prototype = {
        // ### setFromString()
        // Sets a property from a string.
        //
        //     t.setFromString('scale', '2,4');
        //     // Same as set('scale', '2', '4');
        //
        setFromString: function(prop, val) {
            var args =
                (typeof val === 'string') ? val.split(',') :
                (val.constructor === Array) ? val : [val];

            args.unshift(prop);

            Transform.prototype.set.apply(this, args);
        },

        // ### set()
        // Sets a property.
        //
        //     t.set('scale', 2, 4);
        //
        set: function(prop) {
            var args = Array.prototype.slice.apply(arguments, [1]);
            if (this.setter[prop]) {
                this.setter[prop].apply(this, args);
            } else {
                this[prop] = args.join(',');
            }
        },

        get: function(prop) {
            if (this.getter[prop]) {
                return this.getter[prop].apply(this);
            } else {
                return this[prop] || 0;
            }
        },

        setter: {
            // ### rotate
            //
            //     .css({ rotate: 30 })
            //     .css({ rotate: "30" })
            //     .css({ rotate: "30deg" })
            //     .css({ rotate: "30deg" })
            //
            rotate: function(theta) {
                this.rotate = unit(theta, 'deg');
            },

            rotateX: function(theta) {
                this.rotateX = unit(theta, 'deg');
            },

            rotateY: function(theta) {
                this.rotateY = unit(theta, 'deg');
            },

            // ### scale
            //
            //     .css({ scale: 9 })      //=> "scale(9,9)"
            //     .css({ scale: '3,2' })  //=> "scale(3,2)"
            //
            scale: function(x, y) {
                if (y === undefined) {
                    y = x;
                }
                this.scale = x + "," + y;
            },

            // ### skewX + skewY
            skewX: function(x) {
                this.skewX = unit(x, 'deg');
            },

            skewY: function(y) {
                this.skewY = unit(y, 'deg');
            },

            // ### perspectvie
            perspective: function(dist) {
                this.perspective = unit(dist, 'px');
            },

            // ### x / y
            // Translations. Notice how this keeps the other value.
            //
            //     .css({ x: 4 })       //=> "translate(4px, 0)"
            //     .css({ y: 10 })      //=> "translate(4px, 10px)"
            //
            x: function(x) {
                this.set('translate', x, null);
            },

            y: function(y) {
                this.set('translate', null, y);
            },

            // ### translate
            // Notice how this keeps the other value.
            //
            //     .css({ translate: '2, 5' })    //=> "translate(2px, 5px)"
            //
            translate: function(x, y) {
                if (this._translateX === undefined) {
                    this._translateX = 0;
                }
                if (this._translateY === undefined) {
                    this._translateY = 0;
                }

                if (x !== null && x !== undefined) {
                    this._translateX = unit(x, 'px');
                }
                if (y !== null && y !== undefined) {
                    this._translateY = unit(y, 'px');
                }

                this.translate = this._translateX + "," + this._translateY;
            }
        },

        getter: {
            x: function() {
                return this._translateX || 0;
            },

            y: function() {
                return this._translateY || 0;
            },

            scale: function() {
                var s = (this.scale || "1,1").split(',');
                if (s[0]) {
                    s[0] = parseFloat(s[0]);
                }
                if (s[1]) {
                    s[1] = parseFloat(s[1]);
                }

                // "2.5,2.5" => 2.5
                // "2.5,1" => [2.5,1]
                return (s[0] === s[1]) ? s[0] : s;
            },

            rotate3d: function() {
                var s = (this.rotate3d || "0,0,0,0deg").split(',');
                for (var i = 0; i <= 3; ++i) {
                    if (s[i]) {
                        s[i] = parseFloat(s[i]);
                    }
                }
                if (s[3]) {
                    s[3] = unit(s[3], 'deg');
                }

                return s;
            }
        },

        // ### parse()
        // Parses from a string. Called on constructor.
        parse: function(str) {
            var self = this;
            str.replace(/([a-zA-Z0-9]+)\((.*?)\)/g, function(x, prop, val) {
                self.setFromString(prop, val);
            });
        },

        // ### toString()
        // Converts to a `transition` CSS property string. If `use3d` is given,
        // it converts to a `-webkit-transition` CSS property string instead.
        toString: function(use3d) {
            var re = [];

            for (var i in this) {
                if (this.hasOwnProperty(i)) {
                    // Don't use 3D transformations if the browser can't support it.
                    if ((!support.transform3d) && (
                            (i === 'rotateX') ||
                            (i === 'rotateY') ||
                            (i === 'perspective') ||
                            (i === 'transformOrigin'))) {
                        continue;
                    }

                    if (i[0] !== '_') {
                        if (use3d && (i === 'scale')) {
                            re.push(i + "3d(" + this[i] + ",1)");
                        } else if (use3d && (i === 'translate')) {
                            re.push(i + "3d(" + this[i] + ",0)");
                        } else {
                            re.push(i + "(" + this[i] + ")");
                        }
                    }
                }
            }

            return re.join(" ");
        }
    };

    function callOrQueue(self, queue, fn) {
        if (queue === true) {
            self.queue(fn);
        } else if (queue) {
            self.queue(queue, fn);
        } else {
            self.each(function() {
                fn.call(this);
            });
        }
    }

    // ### getProperties(dict)
    // Returns properties (for `transition-property`) for dictionary `props`. The
    // value of `props` is what you would expect in `$.css(...)`.
    function getProperties(props) {
        var re = [];

        $.each(props, function(key) {
            key = $.camelCase(key); // Convert "text-align" => "textAlign"
            key = $.transit.propertyMap[key] || $.cssProps[key] || key;
            key = uncamel(key); // Convert back to dasherized

            // Get vendor specify propertie
            if (support[key])
                key = uncamel(support[key]);

            if ($.inArray(key, re) === -1) {
                re.push(key);
            }
        });

        return re;
    }

    // ### getTransition()
    // Returns the transition string to be used for the `transition` CSS property.
    //
    // Example:
    //
    //     getTransition({ opacity: 1, rotate: 30 }, 500, 'ease');
    //     //=> 'opacity 500ms ease, -webkit-transform 500ms ease'
    //
    function getTransition(properties, duration, easing, delay) {
        // Get the CSS properties needed.
        var props = getProperties(properties);

        // Account for aliases (`in` => `ease-in`).
        if ($.cssEase[easing]) {
            easing = $.cssEase[easing];
        }

        // Build the duration/easing/delay attributes for it.
        var attribs = '' + toMS(duration) + ' ' + easing;
        if (parseInt(delay, 10) > 0) {
            attribs += ' ' + toMS(delay);
        }

        // For more properties, add them this way:
        // "margin 200ms ease, padding 200ms ease, ..."
        var transitions = [];
        $.each(props, function(i, name) {
            transitions.push(name + ' ' + attribs);
        });

        return transitions.join(', ');
    }

    // ## $.fn.transition
    // Works like $.fn.animate(), but uses CSS transitions.
    //
    //     $("...").transition({ opacity: 0.1, scale: 0.3 });
    //
    //     // Specific duration
    //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500);
    //
    //     // With duration and easing
    //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in');
    //
    //     // With callback
    //     $("...").transition({ opacity: 0.1, scale: 0.3 }, function() { ... });
    //
    //     // With everything
    //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in', function() { ... });
    //
    //     // Alternate syntax
    //     $("...").transition({
    //       opacity: 0.1,
    //       duration: 200,
    //       delay: 40,
    //       easing: 'in',
    //       complete: function() { /* ... */ }
    //      });
    //
    $.fn.transition = $.fn.transit = function(properties, duration, easing, callback) {
        var self = this;
        var delay = 0;
        var queue = true;

        var theseProperties = $.extend(true, {}, properties);

        // Account for `.transition(properties, callback)`.
        if (typeof duration === 'function') {
            callback = duration;
            duration = undefined;
        }

        // Account for `.transition(properties, options)`.
        if (typeof duration === 'object') {
            easing = duration.easing;
            delay = duration.delay || 0;
            queue = typeof duration.queue === "undefined" ? true : duration.queue;
            callback = duration.complete;
            duration = duration.duration;
        }

        // Account for `.transition(properties, duration, callback)`.
        if (typeof easing === 'function') {
            callback = easing;
            easing = undefined;
        }

        // Alternate syntax.
        if (typeof theseProperties.easing !== 'undefined') {
            easing = theseProperties.easing;
            delete theseProperties.easing;
        }

        if (typeof theseProperties.duration !== 'undefined') {
            duration = theseProperties.duration;
            delete theseProperties.duration;
        }

        if (typeof theseProperties.complete !== 'undefined') {
            callback = theseProperties.complete;
            delete theseProperties.complete;
        }

        if (typeof theseProperties.queue !== 'undefined') {
            queue = theseProperties.queue;
            delete theseProperties.queue;
        }

        if (typeof theseProperties.delay !== 'undefined') {
            delay = theseProperties.delay;
            delete theseProperties.delay;
        }

        // Set defaults. (`400` duration, `ease` easing)
        if (typeof duration === 'undefined') {
            duration = $.fx.speeds._default;
        }
        if (typeof easing === 'undefined') {
            easing = $.cssEase._default;
        }

        duration = toMS(duration);

        // Build the `transition` property.
        var transitionValue = getTransition(theseProperties, duration, easing, delay);

        // Compute delay until callback.
        // If this becomes 0, don't bother setting the transition property.
        var work = $.transit.enabled && support.transition;
        var i = work ? (parseInt(duration, 10) + parseInt(delay, 10)) : 0;

        // If there's nothing to do...
        if (i === 0) {
            var fn = function(next) {
                self.css(theseProperties);
                if (callback) {
                    callback.apply(self);
                }
                if (next) {
                    next();
                }
            };

            callOrQueue(self, queue, fn);
            return self;
        }

        // Save the old transitions of each element so we can restore it later.
        var oldTransitions = {};

        var run = function(nextCall) {
            var bound = false;

            // Prepare the callback.
            var cb = function() {
                if (bound) {
                    self.unbind(transitionEnd, cb);
                }

                if (i > 0) {
                    self.each(function() {
                        this.style[support.transition] = (oldTransitions[this] || null);
                    });
                }

                if (typeof callback === 'function') {
                    callback.apply(self);
                }
                if (typeof nextCall === 'function') {
                    nextCall();
                }
            };

            if ((i > 0) && (transitionEnd) && ($.transit.useTransitionEnd)) {
                // Use the 'transitionend' event if it's available.
                bound = true;
                self.bind(transitionEnd, cb);
            } else {
                // Fallback to timers if the 'transitionend' event isn't supported.
                window.setTimeout(cb, i);
            }

            // Apply transitions.
            self.each(function() {
                if (i > 0) {
                    this.style[support.transition] = transitionValue;
                }
                $(this).css(theseProperties);
            });
        };

        // Defer running. This allows the browser to paint any pending CSS it hasn't
        // painted yet before doing the transitions.
        var deferredRun = function(next) {
            this.offsetWidth; // force a repaint
            run(next);
        };

        // Use jQuery's fx queue.
        callOrQueue(self, queue, deferredRun);

        // Chainability.
        return this;
    };

    function registerCssHook(prop, isPixels) {
        // For certain properties, the 'px' should not be implied.
        if (!isPixels) {
            $.cssNumber[prop] = true;
        }

        $.transit.propertyMap[prop] = support.transform;

        $.cssHooks[prop] = {
            get: function(elem) {
                var t = $(elem).css('transit:transform');
                return t.get(prop);
            },

            set: function(elem, value) {
                var t = $(elem).css('transit:transform');
                t.setFromString(prop, value);

                $(elem).css({
                    'transit:transform': t
                });
            }
        };

    }

    // ### uncamel(str)
    // Converts a camelcase string to a dasherized string.
    // (`marginLeft` => `margin-left`)
    function uncamel(str) {
        return str.replace(/([A-Z])/g, function(letter) {
            return '-' + letter.toLowerCase();
        });
    }

    // ### unit(number, unit)
    // Ensures that number `number` has a unit. If no unit is found, assume the
    // default is `unit`.
    //
    //     unit(2, 'px')          //=> "2px"
    //     unit("30deg", 'rad')   //=> "30deg"
    //
    function unit(i, units) {
        if ((typeof i === "string") && (!i.match(/^[\-0-9\.]+$/))) {
            return i;
        } else {
            return "" + i + units;
        }
    }

    // ### toMS(duration)
    // Converts given `duration` to a millisecond string.
    //
    // toMS('fast') => $.fx.speeds[i] => "200ms"
    // toMS('normal') //=> $.fx.speeds._default => "400ms"
    // toMS(10) //=> '10ms'
    // toMS('100ms') //=> '100ms'  
    //
    function toMS(duration) {
        var i = duration;

        // Allow string durations like 'fast' and 'slow', without overriding numeric values.
        if (typeof i === 'string' && (!i.match(/^[\-0-9\.]+/))) {
            i = $.fx.speeds[i] || $.fx.speeds._default;
        }

        return unit(i, 'ms');
    }

    // Export some functions for testable-ness.
    $.transit.getTransitionValue = getTransition;

    return $;
}));

// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function(definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /* jshint strict: false */

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

        // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

        // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

        // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

        // <script>
    } else {
        Q = definition();
    }

})(function() {
    "use strict";

    var hasStacks = false;
    try {
        throw new Error();
    } catch (e) {
        hasStacks = !!e.stack;
    }

    // All code after this point will be filtered from stack traces reported
    // by Q.
    var qStartingLine = captureLine();
    var qFileName;

    // shims

    // used for fallback in "allResolved"
    var noop = function() {};

    // Use the fastest possible means to execute a task in a future turn
    // of the event loop.
    var nextTick = (function() {
        // linked list of tasks (single, with head node)
        var head = {
            task: void 0,
            next: null
        };
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;

        function flush() {
            /* jshint loopfunc: true */

            while (head.next) {
                head = head.next;
                var task = head.task;
                head.task = void 0;
                var domain = head.domain;

                if (domain) {
                    head.domain = void 0;
                    domain.enter();
                }

                try {
                    task();

                } catch (e) {
                    if (isNodeJS) {
                        // In node, uncaught exceptions are considered fatal errors.
                        // Re-throw them synchronously to interrupt flushing!

                        // Ensure continuation if the uncaught exception is suppressed
                        // listening "uncaughtException" events (as domains does).
                        // Continue in next event to avoid tick recursion.
                        if (domain) {
                            domain.exit();
                        }
                        setTimeout(flush, 0);
                        if (domain) {
                            domain.enter();
                        }

                        throw e;

                    } else {
                        // In browsers, uncaught exceptions are not fatal.
                        // Re-throw them asynchronously to avoid slow-downs.
                        setTimeout(function() {
                            throw e;
                        }, 0);
                    }
                }

                if (domain) {
                    domain.exit();
                }
            }

            flushing = false;
        }

        nextTick = function(task) {
            tail = tail.next = {
                task: task,
                domain: isNodeJS && process.domain,
                next: null
            };

            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };

        if (typeof process !== "undefined" && process.nextTick) {
            // Node.js before 0.9. Note that some fake-Node environments, like the
            // Mocha test runner, introduce a `process` global without a `nextTick`.
            isNodeJS = true;

            requestTick = function() {
                process.nextTick(flush);
            };

        } else if (typeof setImmediate === "function") {
            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
            if (typeof window !== "undefined") {
                requestTick = setImmediate.bind(window, flush);
            } else {
                requestTick = function() {
                    setImmediate(flush);
                };
            }

        } else if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
            // working message ports the first time a page loads.
            channel.port1.onmessage = function() {
                requestTick = requestPortTick;
                channel.port1.onmessage = flush;
                flush();
            };
            var requestPortTick = function() {
                // Opera requires us to provide a message payload, regardless of
                // whether we use it.
                channel.port2.postMessage(0);
            };
            requestTick = function() {
                setTimeout(flush, 0);
                requestPortTick();
            };

        } else {
            // old browsers
            requestTick = function() {
                setTimeout(flush, 0);
            };
        }

        return nextTick;
    })();

    // Attempt to make generics safe in the face of downstream
    // modifications.
    // There is no situation where this is necessary.
    // If you need a security guarantee, these primordials need to be
    // deeply frozen anyway, and if you don’t need a security guarantee,
    // this is just plain paranoid.
    // However, this **might** have the nice side-effect of reducing the size of
    // the minified code by reducing x.call() to merely x()
    // See Mark Miller’s explanation of what this does.
    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
    var call = Function.call;

    function uncurryThis(f) {
        return function() {
            return call.apply(f, arguments);
        };
    }
    // This is equivalent, but slower:
    // uncurryThis = Function_bind.bind(Function_bind.call);
    // http://jsperf.com/uncurrythis

    var array_slice = uncurryThis(Array.prototype.slice);

    var array_reduce = uncurryThis(
        Array.prototype.reduce || function(callback, basis) {
            var index = 0,
                length = this.length;
            // concerning the initial value, if one is not provided
            if (arguments.length === 1) {
                // seek to the first value in the array, accounting
                // for the possibility that is is a sparse array
                do {
                    if (index in this) {
                        basis = this[index++];
                        break;
                    }
                    if (++index >= length) {
                        throw new TypeError();
                    }
                } while (1);
            }
            // reduce
            for (; index < length; index++) {
                // account for the possibility that the array is sparse
                if (index in this) {
                    basis = callback(basis, this[index], index);
                }
            }
            return basis;
        }
    );

    var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function(value) {
            // not a very good shim, but good enough for our one use of it
            for (var i = 0; i < this.length; i++) {
                if (this[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    );

    var array_map = uncurryThis(
        Array.prototype.map || function(callback, thisp) {
            var self = this;
            var collect = [];
            array_reduce(self, function(undefined, value, index) {
                collect.push(callback.call(thisp, value, index, self));
            }, void 0);
            return collect;
        }
    );

    var object_create = Object.create || function(prototype) {
        function Type() {}
        Type.prototype = prototype;
        return new Type();
    };

    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

    var object_keys = Object.keys || function(object) {
        var keys = [];
        for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };

    var object_toString = uncurryThis(Object.prototype.toString);

    function isObject(value) {
        return value === Object(value);
    }

    // generator related shims

    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
    function isStopIteration(exception) {
        return (
            object_toString(exception) === "[object StopIteration]" ||
            exception instanceof QReturnValue
        );
    }

    // FIXME: Remove this helper and Q.return once ES6 generators are in
    // SpiderMonkey.
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
    } else {
        QReturnValue = function(value) {
            this.value = value;
        };
    }

    // long stack traces

    var STACK_JUMP_SEPARATOR = "From previous event:";

    function makeStackTraceLong(error, promise) {
        // If possible, transform the error stack trace by removing Node and Q
        // cruft, then concatenating with the stack trace of `promise`. See #57.
        if (hasStacks &&
            promise.stack &&
            typeof error === "object" &&
            error !== null &&
            error.stack &&
            error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
        ) {
            var stacks = [];
            for (var p = promise; !!p; p = p.source) {
                if (p.stack) {
                    stacks.unshift(p.stack);
                }
            }
            stacks.unshift(error.stack);

            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            error.stack = filterStackString(concatedStacks);
        }
    }

    function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];

            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join("\n");
    }

    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 ||
            stackLine.indexOf("(node.js:") !== -1;
    }

    function getFileNameAndLineNumber(stackLine) {
        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
        // In IE10 function name can have spaces ("Anonymous function") O_o
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [attempt1[1], Number(attempt1[2])];
        }

        // Anonymous functions: "at filename:lineNumber:columnNumber"
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [attempt2[1], Number(attempt2[2])];
        }

        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [attempt3[1], Number(attempt3[2])];
        }
    }

    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

        if (!fileNameAndLineNumber) {
            return false;
        }

        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];

        return fileName === qFileName &&
            lineNumber >= qStartingLine &&
            lineNumber <= qEndingLine;
    }

    // discover own file name and line number range for filtering stack
    // traces
    function captureLine() {
        if (!hasStacks) {
            return;
        }

        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }

            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }

    function deprecate(callback, name, alternative) {
        return function() {
            if (typeof console !== "undefined" &&
                typeof console.warn === "function") {
                console.warn(name + " is deprecated, use " + alternative +
                    " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
        };
    }

    // end of shims
    // beginning of real work

    /**
     * Constructs a promise for an immediate reference, passes promises through, or
     * coerces promises from different systems.
     * @param value immediate reference or promise
     */
    function Q(value) {
        // If the object is already a Promise, return it directly.  This enables
        // the resolve function to both be used to created references from objects,
        // but to tolerably coerce non-promises to promises.
        if (isPromise(value)) {
            return value;
        }

        // assimilate thenables
        if (isPromiseAlike(value)) {
            return coerce(value);
        } else {
            return fulfill(value);
        }
    }
    Q.resolve = Q;

    /**
     * Performs a task in a future turn of the event loop.
     * @param {Function} task
     */
    Q.nextTick = nextTick;

    /**
     * Controls whether or not long stack traces will be on
     */
    Q.longStackSupport = false;

    /**
     * Constructs a {promise, resolve, reject} object.
     *
     * `resolve` is a callback to invoke with a more resolved value for the
     * promise. To fulfill the promise, invoke `resolve` with any value that is
     * not a thenable. To reject the promise, invoke `resolve` with a rejected
     * thenable, or invoke `reject` with the reason directly. To resolve the
     * promise to another thenable, thus putting it in the same state, invoke
     * `resolve` with that other thenable.
     */
    Q.defer = defer;

    function defer() {
        // if "messages" is an "Array", that indicates that the promise has not yet
        // been resolved.  If it is "undefined", it has been resolved.  Each
        // element of the messages array is itself an array of complete arguments to
        // forward to the resolved promise.  We coerce the resolution value to a
        // promise using the `resolve` function because it handles both fully
        // non-thenable values and other thenables gracefully.
        var messages = [],
            progressListeners = [],
            resolvedPromise;

        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);

        promise.promiseDispatch = function(resolve, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
                messages.push(args);
                if (op === "when" && operands[1]) { // progress operand
                    progressListeners.push(operands[1]);
                }
            } else {
                nextTick(function() {
                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
                });
            }
        };

        // XXX deprecated
        promise.valueOf = function() {
            if (messages) {
                return promise;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
                resolvedPromise = nearerValue; // shorten chain
            }
            return nearerValue;
        };

        promise.inspect = function() {
            if (!resolvedPromise) {
                return {
                    state: "pending"
                };
            }
            return resolvedPromise.inspect();
        };

        if (Q.longStackSupport && hasStacks) {
            try {
                throw new Error();
            } catch (e) {
                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
                // accessor around; that causes memory leaks as per GH-111. Just
                // reify the stack trace as a string ASAP.
                //
                // At the same time, cut off the first line; it's always just
                // "[object Promise]\n", as per the `toString`.
                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
        }

        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
        // consolidating them into `become`, since otherwise we'd create new
        // promises with the lines `become(whatever(value))`. See e.g. GH-252.

        function become(newPromise) {
            resolvedPromise = newPromise;
            promise.source = newPromise;

            array_reduce(messages, function(undefined, message) {
                nextTick(function() {
                    newPromise.promiseDispatch.apply(newPromise, message);
                });
            }, void 0);

            messages = void 0;
            progressListeners = void 0;
        }

        deferred.promise = promise;
        deferred.resolve = function(value) {
            if (resolvedPromise) {
                return;
            }

            become(Q(value));
        };

        deferred.fulfill = function(value) {
            if (resolvedPromise) {
                return;
            }

            become(fulfill(value));
        };
        deferred.reject = function(reason) {
            if (resolvedPromise) {
                return;
            }

            become(reject(reason));
        };
        deferred.notify = function(progress) {
            if (resolvedPromise) {
                return;
            }

            array_reduce(progressListeners, function(undefined, progressListener) {
                nextTick(function() {
                    progressListener(progress);
                });
            }, void 0);
        };

        return deferred;
    }

    /**
     * Creates a Node-style callback that will resolve or reject the deferred
     * promise.
     * @returns a nodeback
     */
    defer.prototype.makeNodeResolver = function() {
        var self = this;
        return function(error, value) {
            if (error) {
                self.reject(error);
            } else if (arguments.length > 2) {
                self.resolve(array_slice(arguments, 1));
            } else {
                self.resolve(value);
            }
        };
    };

    /**
     * @param resolver {Function} a function that returns nothing and accepts
     * the resolve, reject, and notify functions for a deferred.
     * @returns a promise that may be resolved with the given resolve and reject
     * functions, or rejected by a thrown exception in resolver
     */
    Q.Promise = promise; // ES6
    Q.promise = promise;

    function promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
            deferred.reject(reason);
        }
        return deferred.promise;
    }

    promise.race = race; // ES6
    promise.all = all; // ES6
    promise.reject = reject; // ES6
    promise.resolve = Q; // ES6

    // XXX experimental.  This method is a way to denote that a local value is
    // serializable and should be immediately dispatched to a remote upon request,
    // instead of passing a reference.
    Q.passByCopy = function(object) {
        //freeze(object);
        //passByCopies.set(object, true);
        return object;
    };

    Promise.prototype.passByCopy = function() {
        //freeze(object);
        //passByCopies.set(object, true);
        return this;
    };

    /**
     * If two promises eventually fulfill to the same value, promises that value,
     * but otherwise rejects.
     * @param x {Any*}
     * @param y {Any*}
     * @returns {Any*} a promise for x and y if they are the same, but a rejection
     * otherwise.
     *
     */
    Q.join = function(x, y) {
        return Q(x).join(y);
    };

    Promise.prototype.join = function(that) {
        return Q([this, that]).spread(function(x, y) {
            if (x === y) {
                // TODO: "===" should be Object.is or equiv
                return x;
            } else {
                throw new Error("Can't join: not the same: " + x + " " + y);
            }
        });
    };

    /**
     * Returns a promise for the first of an array of promises to become fulfilled.
     * @param answers {Array[Any*]} promises to race
     * @returns {Any*} the first promise to be fulfilled
     */
    Q.race = race;

    function race(answerPs) {
        return promise(function(resolve, reject) {
            // Switch to this once we can assume at least ES5
            // answerPs.forEach(function(answerP) {
            //     Q(answerP).then(resolve, reject);
            // });
            // Use this in the meantime
            for (var i = 0, len = answerPs.length; i < len; i++) {
                Q(answerPs[i]).then(resolve, reject);
            }
        });
    }

    Promise.prototype.race = function() {
        return this.then(Q.race);
    };

    /**
     * Constructs a Promise with a promise descriptor object and optional fallback
     * function.  The descriptor contains methods like when(rejected), get(name),
     * set(name, value), post(name, args), and delete(name), which all
     * return either a value, a promise for a value, or a rejection.  The fallback
     * accepts the operation name, a resolver, and any further arguments that would
     * have been forwarded to the appropriate method above had a method been
     * provided with the proper name.  The API makes no guarantees about the nature
     * of the returned object, apart from that it is usable whereever promises are
     * bought and sold.
     */
    Q.makePromise = Promise;

    function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
            fallback = function(op) {
                return reject(new Error(
                    "Promise does not support operation: " + op
                ));
            };
        }
        if (inspect === void 0) {
            inspect = function() {
                return {
                    state: "unknown"
                };
            };
        }

        var promise = object_create(Promise.prototype);

        promise.promiseDispatch = function(resolve, op, args) {
            var result;
            try {
                if (descriptor[op]) {
                    result = descriptor[op].apply(promise, args);
                } else {
                    result = fallback.call(promise, op, args);
                }
            } catch (exception) {
                result = reject(exception);
            }
            if (resolve) {
                resolve(result);
            }
        };

        promise.inspect = inspect;

        // XXX deprecated `valueOf` and `exception` support
        if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
                promise.exception = inspected.reason;
            }

            promise.valueOf = function() {
                var inspected = inspect();
                if (inspected.state === "pending" ||
                    inspected.state === "rejected") {
                    return promise;
                }
                return inspected.value;
            };
        }

        return promise;
    }

    Promise.prototype.toString = function() {
        return "[object Promise]";
    };

    Promise.prototype.then = function(fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false; // ensure the untrusted promise makes at most a
        // single call to one of the callbacks

        function _fulfilled(value) {
            try {
                return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
                return reject(exception);
            }
        }

        function _rejected(exception) {
            if (typeof rejected === "function") {
                makeStackTraceLong(exception, self);
                try {
                    return rejected(exception);
                } catch (newException) {
                    return reject(newException);
                }
            }
            return reject(exception);
        }

        function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
        }

        nextTick(function() {
            self.promiseDispatch(function(value) {
                if (done) {
                    return;
                }
                done = true;

                deferred.resolve(_fulfilled(value));
            }, "when", [function(exception) {
                if (done) {
                    return;
                }
                done = true;

                deferred.resolve(_rejected(exception));
            }]);
        });

        // Progress propagator need to be attached in the current tick.
        self.promiseDispatch(void 0, "when", [void 0, function(value) {
            var newValue;
            var threw = false;
            try {
                newValue = _progressed(value);
            } catch (e) {
                threw = true;
                if (Q.onerror) {
                    Q.onerror(e);
                } else {
                    throw e;
                }
            }

            if (!threw) {
                deferred.notify(newValue);
            }
        }]);

        return deferred.promise;
    };

    /**
     * Registers an observer on a promise.
     *
     * Guarantees:
     *
     * 1. that fulfilled and rejected will be called only once.
     * 2. that either the fulfilled callback or the rejected callback will be
     *    called, but not both.
     * 3. that fulfilled and rejected will not be called in this turn.
     *
     * @param value      promise or immediate reference to observe
     * @param fulfilled  function to be called with the fulfilled value
     * @param rejected   function to be called with the rejection exception
     * @param progressed function to be called on any progress notifications
     * @return promise for the return value from the invoked callback
     */
    Q.when = when;

    function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
    }

    Promise.prototype.thenResolve = function(value) {
        return this.then(function() {
            return value;
        });
    };

    Q.thenResolve = function(promise, value) {
        return Q(promise).thenResolve(value);
    };

    Promise.prototype.thenReject = function(reason) {
        return this.then(function() {
            throw reason;
        });
    };

    Q.thenReject = function(promise, reason) {
        return Q(promise).thenReject(reason);
    };

    /**
     * If an object is not a promise, it is as "near" as possible.
     * If a promise is rejected, it is as "near" as possible too.
     * If it’s a fulfilled promise, the fulfillment value is nearer.
     * If it’s a deferred promise and the deferred has been resolved, the
     * resolution is "nearer".
     * @param object
     * @returns most resolved (nearest) form of the object
     */

    // XXX should we re-do this?
    Q.nearer = nearer;

    function nearer(value) {
        if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
                return inspected.value;
            }
        }
        return value;
    }

    /**
     * @returns whether the given object is a promise.
     * Otherwise it is a fulfilled value.
     */
    Q.isPromise = isPromise;

    function isPromise(object) {
        return isObject(object) &&
            typeof object.promiseDispatch === "function" &&
            typeof object.inspect === "function";
    }

    Q.isPromiseAlike = isPromiseAlike;

    function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
    }

    /**
     * @returns whether the given object is a pending promise, meaning not
     * fulfilled or rejected.
     */
    Q.isPending = isPending;

    function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
    }

    Promise.prototype.isPending = function() {
        return this.inspect().state === "pending";
    };

    /**
     * @returns whether the given object is a value or fulfilled
     * promise.
     */
    Q.isFulfilled = isFulfilled;

    function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
    }

    Promise.prototype.isFulfilled = function() {
        return this.inspect().state === "fulfilled";
    };

    /**
     * @returns whether the given object is a rejected promise.
     */
    Q.isRejected = isRejected;

    function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
    }

    Promise.prototype.isRejected = function() {
        return this.inspect().state === "rejected";
    };

    //// BEGIN UNHANDLED REJECTION TRACKING

    // This promise library consumes exceptions thrown in handlers so they can be
    // handled by a subsequent promise.  The exceptions get added to this array when
    // they are created, and removed when they are handled.  Note that in ES6 or
    // shimmed environments, this would naturally be a `Set`.
    var unhandledReasons = [];
    var unhandledRejections = [];
    var trackUnhandledRejections = true;

    function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;

        if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
        }
    }

    function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
            return;
        }

        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
        } else {
            unhandledReasons.push("(no stack) " + reason);
        }
    }

    function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
            return;
        }

        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
        }
    }

    Q.resetUnhandledRejections = resetUnhandledRejections;

    Q.getUnhandledReasons = function() {
        // Make a copy so that consumers can't interfere with our internal state.
        return unhandledReasons.slice();
    };

    Q.stopUnhandledRejectionTracking = function() {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
    };

    resetUnhandledRejections();

    //// END UNHANDLED REJECTION TRACKING

    /**
     * Constructs a rejected promise.
     * @param reason value describing the failure
     */
    Q.reject = reject;

    function reject(reason) {
        var rejection = Promise({
            "when": function(rejected) {
                // note that the error has been handled
                if (rejected) {
                    untrackRejection(this);
                }
                return rejected ? rejected(reason) : this;
            }
        }, function fallback() {
            return this;
        }, function inspect() {
            return {
                state: "rejected",
                reason: reason
            };
        });

        // Note that the reason has not been handled.
        trackRejection(rejection, reason);

        return rejection;
    }

    /**
     * Constructs a fulfilled promise for an immediate reference.
     * @param value immediate reference
     */
    Q.fulfill = fulfill;

    function fulfill(value) {
        return Promise({
            "when": function() {
                return value;
            },
            "get": function(name) {
                return value[name];
            },
            "set": function(name, rhs) {
                value[name] = rhs;
            },
            "delete": function(name) {
                delete value[name];
            },
            "post": function(name, args) {
                // Mark Miller proposes that post with no name should apply a
                // promised function.
                if (name === null || name === void 0) {
                    return value.apply(void 0, args);
                } else {
                    return value[name].apply(value, args);
                }
            },
            "apply": function(thisp, args) {
                return value.apply(thisp, args);
            },
            "keys": function() {
                return object_keys(value);
            }
        }, void 0, function inspect() {
            return {
                state: "fulfilled",
                value: value
            };
        });
    }

    /**
     * Converts thenables to Q promises.
     * @param promise thenable promise
     * @returns a Q promise
     */
    function coerce(promise) {
        var deferred = defer();
        nextTick(function() {
            try {
                promise.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
                deferred.reject(exception);
            }
        });
        return deferred.promise;
    }

    /**
     * Annotates an object such that it will never be
     * transferred away from this process over any promise
     * communication channel.
     * @param object
     * @returns promise a wrapping of that object that
     * additionally responds to the "isDef" message
     * without a rejection.
     */
    Q.master = master;

    function master(object) {
        return Promise({
            "isDef": function() {}
        }, function fallback(op, args) {
            return dispatch(object, op, args);
        }, function() {
            return Q(object).inspect();
        });
    }

    /**
     * Spreads the values of a promised array of arguments into the
     * fulfillment callback.
     * @param fulfilled callback that receives variadic arguments from the
     * promised array
     * @param rejected callback that receives the exception if the promise
     * is rejected.
     * @returns a promise for the return value or thrown exception of
     * either callback.
     */
    Q.spread = spread;

    function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
    }

    Promise.prototype.spread = function(fulfilled, rejected) {
        return this.all().then(function(array) {
            return fulfilled.apply(void 0, array);
        }, rejected);
    };

    /**
     * The async function is a decorator for generator functions, turning
     * them into asynchronous generators.  Although generators are only part
     * of the newest ECMAScript 6 drafts, this code does not cause syntax
     * errors in older engines.  This code should continue to work and will
     * in fact improve over time as the language improves.
     *
     * ES6 generators are currently part of V8 version 3.19 with the
     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
     * for longer, but under an older Python-inspired form.  This function
     * works on both kinds of generators.
     *
     * Decorates a generator function such that:
     *  - it may yield promises
     *  - execution will continue when that promise is fulfilled
     *  - the value of the yield expression will be the fulfilled value
     *  - it returns a promise for the return value (when the generator
     *    stops iterating)
     *  - the decorated function returns a promise for the return value
     *    of the generator or the first rejected promise among those
     *    yielded.
     *  - if an error is thrown in the generator, it propagates through
     *    every following yield until it is caught, or until it escapes
     *    the generator function altogether, and is translated into a
     *    rejection for the promise returned by the decorated generator.
     */
    Q.async = async;

    function async(makeGenerator) {
        return function() {
            // when verb is "send", arg is a value
            // when verb is "throw", arg is an exception
            function continuer(verb, arg) {
                var result;

                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
                // engine that has a deployed base of browsers that support generators.
                // However, SM's generators use the Python-inspired semantics of
                // outdated ES6 drafts.  We would like to support ES6, but we'd also
                // like to make it possible to use generators in deployed browsers, so
                // we also support Python-style generators.  At some point we can remove
                // this block.

                if (typeof StopIteration === "undefined") {
                    // ES6 Generators
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        return reject(exception);
                    }
                    if (result.done) {
                        return result.value;
                    } else {
                        return when(result.value, callback, errback);
                    }
                } else {
                    // SpiderMonkey Generators
                    // FIXME: Remove this case when SM does ES6 generators.
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        if (isStopIteration(exception)) {
                            return exception.value;
                        } else {
                            return reject(exception);
                        }
                    }
                    return when(result, callback, errback);
                }
            }
            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
        };
    }

    /**
     * The spawn function is a small wrapper around async that immediately
     * calls the generator and also ends the promise chain, so that any
     * unhandled errors are thrown instead of forwarded to the error
     * handler. This is useful because it's extremely common to run
     * generators at the top-level to work with libraries.
     */
    Q.spawn = spawn;

    function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
    }

    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
    /**
     * Throws a ReturnValue exception to stop an asynchronous generator.
     *
     * This interface is a stop-gap measure to support generator return
     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
     * generators like Chromium 29, just use "return" in your generator
     * functions.
     *
     * @param value the return value for the surrounding generator
     * @throws ReturnValue exception with the value.
     * @example
     * // ES6 style
     * Q.async(function* () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      return foo + bar;
     * })
     * // Older SpiderMonkey style
     * Q.async(function () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      Q.return(foo + bar);
     * })
     */
    Q["return"] = _return;

    function _return(value) {
        throw new QReturnValue(value);
    }

    /**
     * The promised function decorator ensures that any promise arguments
     * are settled and passed as values (`this` is also settled and passed
     * as a value).  It will also ensure that the result of a function is
     * always a promise.
     *
     * @example
     * var add = Q.promised(function (a, b) {
     *     return a + b;
     * });
     * add(Q(a), Q(B));
     *
     * @param {function} callback The function to decorate
     * @returns {function} a function that has been decorated.
     */
    Q.promised = promised;

    function promised(callback) {
        return function() {
            return spread([this, all(arguments)], function(self, args) {
                return callback.apply(self, args);
            });
        };
    }

    /**
     * sends a message to a value in a future turn
     * @param object* the recipient
     * @param op the name of the message operation, e.g., "when",
     * @param args further arguments to be forwarded to the operation
     * @returns result {Promise} a promise for the result of the operation
     */
    Q.dispatch = dispatch;

    function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
    }

    Promise.prototype.dispatch = function(op, args) {
        var self = this;
        var deferred = defer();
        nextTick(function() {
            self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
    };

    /**
     * Gets the value of a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to get
     * @return promise for the property value
     */
    Q.get = function(object, key) {
        return Q(object).dispatch("get", [key]);
    };

    Promise.prototype.get = function(key) {
        return this.dispatch("get", [key]);
    };

    /**
     * Sets the value of a property in a future turn.
     * @param object    promise or immediate reference for object object
     * @param name      name of property to set
     * @param value     new value of property
     * @return promise for the return value
     */
    Q.set = function(object, key, value) {
        return Q(object).dispatch("set", [key, value]);
    };

    Promise.prototype.set = function(key, value) {
        return this.dispatch("set", [key, value]);
    };

    /**
     * Deletes a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to delete
     * @return promise for the return value
     */
    Q.del = // XXX legacy
        Q["delete"] = function(object, key) {
            return Q(object).dispatch("delete", [key]);
        };

    Promise.prototype.del = // XXX legacy
        Promise.prototype["delete"] = function(key) {
            return this.dispatch("delete", [key]);
        };

    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param value     a value to post, typically an array of
     *                  invocation arguments for promises that
     *                  are ultimately backed with `resolve` values,
     *                  as opposed to those backed with URLs
     *                  wherein the posted value can be any
     *                  JSON serializable object.
     * @return promise for the return value
     */
    // bound locally because it is used by other methods
    Q.mapply = // XXX As proposed by "Redsandro"
        Q.post = function(object, name, args) {
            return Q(object).dispatch("post", [name, args]);
        };

    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
        Promise.prototype.post = function(name, args) {
            return this.dispatch("post", [name, args]);
        };

    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param ...args   array of invocation arguments
     * @return promise for the return value
     */
    Q.send = // XXX Mark Miller's proposed parlance
        Q.mcall = // XXX As proposed by "Redsandro"
        Q.invoke = function(object, name /*...args*/ ) {
            return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
        };

    Promise.prototype.send = // XXX Mark Miller's proposed parlance
        Promise.prototype.mcall = // XXX As proposed by "Redsandro"
        Promise.prototype.invoke = function(name /*...args*/ ) {
            return this.dispatch("post", [name, array_slice(arguments, 1)]);
        };

    /**
     * Applies the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param args      array of application arguments
     */
    Q.fapply = function(object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
    };

    Promise.prototype.fapply = function(args) {
        return this.dispatch("apply", [void 0, args]);
    };

    /**
     * Calls the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q["try"] =
        Q.fcall = function(object /* ...args*/ ) {
            return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
        };

    Promise.prototype.fcall = function( /*...args*/ ) {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
    };

    /**
     * Binds the promised function, transforming return values into a fulfilled
     * promise and thrown errors into a rejected one.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q.fbind = function(object /*...args*/ ) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    Promise.prototype.fbind = function( /*...args*/ ) {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };

    /**
     * Requests the names of the owned properties of a promised
     * object in a future turn.
     * @param object    promise or immediate reference for target object
     * @return promise for the keys of the eventually settled object
     */
    Q.keys = function(object) {
        return Q(object).dispatch("keys", []);
    };

    Promise.prototype.keys = function() {
        return this.dispatch("keys", []);
    };

    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     * @param {Array*} an array (or promise for an array) of values (or
     * promises for values)
     * @returns a promise for an array of the corresponding values
     */
    // By Mark Miller
    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
    Q.all = all;

    function all(promises) {
        return when(promises, function(promises) {
            var countDown = 0;
            var deferred = defer();
            array_reduce(promises, function(undefined, promise, index) {
                var snapshot;
                if (
                    isPromise(promise) &&
                    (snapshot = promise.inspect()).state === "fulfilled"
                ) {
                    promises[index] = snapshot.value;
                } else {
                    ++countDown;
                    when(
                        promise,
                        function(value) {
                            promises[index] = value;
                            if (--countDown === 0) {
                                deferred.resolve(promises);
                            }
                        },
                        deferred.reject,
                        function(progress) {
                            deferred.notify({
                                index: index,
                                value: progress
                            });
                        }
                    );
                }
            }, void 0);
            if (countDown === 0) {
                deferred.resolve(promises);
            }
            return deferred.promise;
        });
    }

    Promise.prototype.all = function() {
        return all(this);
    };

    /**
     * Waits for all promises to be settled, either fulfilled or
     * rejected.  This is distinct from `all` since that would stop
     * waiting at the first rejection.  The promise returned by
     * `allResolved` will never be rejected.
     * @param promises a promise for an array (or an array) of promises
     * (or values)
     * @return a promise for an array of promises
     */
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");

    function allResolved(promises) {
        return when(promises, function(promises) {
            promises = array_map(promises, Q);
            return when(all(array_map(promises, function(promise) {
                return when(promise, noop, noop);
            })), function() {
                return promises;
            });
        });
    }

    Promise.prototype.allResolved = function() {
        return allResolved(this);
    };

    /**
     * @see Promise#allSettled
     */
    Q.allSettled = allSettled;

    function allSettled(promises) {
        return Q(promises).allSettled();
    }

    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     * @param {Array[Any*]} values an array (or promise for an array) of values (or
     * promises for values)
     * @returns {Array[State]} an array of states for the respective values.
     */
    Promise.prototype.allSettled = function() {
        return this.then(function(promises) {
            return all(array_map(promises, function(promise) {
                promise = Q(promise);

                function regardless() {
                    return promise.inspect();
                }
                return promise.then(regardless, regardless);
            }));
        });
    };

    /**
     * Captures the failure of a promise, giving an oportunity to recover
     * with a callback.  If the given promise is fulfilled, the returned
     * promise is fulfilled.
     * @param {Any*} promise for something
     * @param {Function} callback to fulfill the returned promise if the
     * given promise is rejected
     * @returns a promise for the return value of the callback
     */
    Q.fail = // XXX legacy
        Q["catch"] = function(object, rejected) {
            return Q(object).then(void 0, rejected);
        };

    Promise.prototype.fail = // XXX legacy
        Promise.prototype["catch"] = function(rejected) {
            return this.then(void 0, rejected);
        };

    /**
     * Attaches a listener that can respond to progress notifications from a
     * promise's originating deferred. This listener receives the exact arguments
     * passed to ``deferred.notify``.
     * @param {Any*} promise for something
     * @param {Function} callback to receive any progress notifications
     * @returns the given promise, unchanged
     */
    Q.progress = progress;

    function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
    }

    Promise.prototype.progress = function(progressed) {
        return this.then(void 0, void 0, progressed);
    };

    /**
     * Provides an opportunity to observe the settling of a promise,
     * regardless of whether the promise is fulfilled or rejected.  Forwards
     * the resolution to the returned promise when the callback is done.
     * The callback can return a promise to defer completion.
     * @param {Any*} promise
     * @param {Function} callback to observe the resolution of the given
     * promise, takes no arguments.
     * @returns a promise for the resolution of the given promise when
     * ``fin`` is done.
     */
    Q.fin = // XXX legacy
        Q["finally"] = function(object, callback) {
            return Q(object)["finally"](callback);
        };

    Promise.prototype.fin = // XXX legacy
        Promise.prototype["finally"] = function(callback) {
            callback = Q(callback);
            return this.then(function(value) {
                return callback.fcall().then(function() {
                    return value;
                });
            }, function(reason) {
                // TODO attempt to recycle the rejection with "this".
                return callback.fcall().then(function() {
                    throw reason;
                });
            });
        };

    /**
     * Terminates a chain of promises, forcing rejections to be
     * thrown as exceptions.
     * @param {Any*} promise at the end of a chain of promises
     * @returns nothing
     */
    Q.done = function(object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
    };

    Promise.prototype.done = function(fulfilled, rejected, progress) {
        var onUnhandledError = function(error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            nextTick(function() {
                makeStackTraceLong(error, promise);
                if (Q.onerror) {
                    Q.onerror(error);
                } else {
                    throw error;
                }
            });
        };

        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        var promise = fulfilled || rejected || progress ?
            this.then(fulfilled, rejected, progress) :
            this;

        if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
        }

        promise.then(void 0, onUnhandledError);
    };

    /**
     * Causes a promise to be rejected if it does not get fulfilled before
     * some milliseconds time out.
     * @param {Any*} promise
     * @param {Number} milliseconds timeout
     * @param {String} custom error message (optional)
     * @returns a promise for the resolution of the given promise if it is
     * fulfilled before the timeout, otherwise rejected.
     */
    Q.timeout = function(object, ms, message) {
        return Q(object).timeout(ms, message);
    };

    Promise.prototype.timeout = function(ms, message) {
        var deferred = defer();
        var timeoutId = setTimeout(function() {
            deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
        }, ms);

        this.then(function(value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
        }, function(exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
        }, deferred.notify);

        return deferred.promise;
    };

    /**
     * Returns a promise for the given value (or promised value), some
     * milliseconds after it resolved. Passes rejections immediately.
     * @param {Any*} promise
     * @param {Number} milliseconds
     * @returns a promise for the resolution of the given promise after milliseconds
     * time has elapsed since the resolution of the given promise.
     * If the given promise rejects, that is passed immediately.
     */
    Q.delay = function(object, timeout) {
        if (timeout === void 0) {
            timeout = object;
            object = void 0;
        }
        return Q(object).delay(timeout);
    };

    Promise.prototype.delay = function(timeout) {
        return this.then(function(value) {
            var deferred = defer();
            setTimeout(function() {
                deferred.resolve(value);
            }, timeout);
            return deferred.promise;
        });
    };

    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided as an array, and returns a promise.
     *
     *      Q.nfapply(FS.readFile, [__filename])
     *      .then(function (content) {
     *      })
     *
     */
    Q.nfapply = function(callback, args) {
        return Q(callback).nfapply(args);
    };

    Promise.prototype.nfapply = function(args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided individually, and returns a promise.
     * @example
     * Q.nfcall(FS.readFile, __filename)
     * .then(function (content) {
     * })
     *
     */
    Q.nfcall = function(callback /*...args*/ ) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
    };

    Promise.prototype.nfcall = function( /*...args*/ ) {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Wraps a NodeJS continuation passing function and returns an equivalent
     * version that returns a promise.
     * @example
     * Q.nfbind(FS.readFile, __filename)("utf-8")
     * .then(console.log)
     * .done()
     */
    Q.nfbind =
        Q.denodeify = function(callback /*...args*/ ) {
            var baseArgs = array_slice(arguments, 1);
            return function() {
                var nodeArgs = baseArgs.concat(array_slice(arguments));
                var deferred = defer();
                nodeArgs.push(deferred.makeNodeResolver());
                Q(callback).fapply(nodeArgs).fail(deferred.reject);
                return deferred.promise;
            };
        };

    Promise.prototype.nfbind =
        Promise.prototype.denodeify = function( /*...args*/ ) {
            var args = array_slice(arguments);
            args.unshift(this);
            return Q.denodeify.apply(void 0, args);
        };

    Q.nbind = function(callback, thisp /*...args*/ ) {
        var baseArgs = array_slice(arguments, 2);
        return function() {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());

            function bound() {
                return callback.apply(thisp, arguments);
            }
            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };

    Promise.prototype.nbind = function( /*thisp, ...args*/ ) {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
    };

    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback with a given array of arguments, plus a provided callback.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param {Array} args arguments to pass to the method; the callback
     * will be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nmapply = // XXX As proposed by "Redsandro"
        Q.npost = function(object, name, args) {
            return Q(object).npost(name, args);
        };

    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
        Promise.prototype.npost = function(name, args) {
            var nodeArgs = array_slice(args || []);
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
            return deferred.promise;
        };

    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback, forwarding the given variadic arguments, plus a provided
     * callback argument.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param ...args arguments to pass to the method; the callback will
     * be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nsend = // XXX Based on Mark Miller's proposed "send"
        Q.nmcall = // XXX Based on "Redsandro's" proposal
        Q.ninvoke = function(object, name /*...args*/ ) {
            var nodeArgs = array_slice(arguments, 2);
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
            return deferred.promise;
        };

    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
        Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
        Promise.prototype.ninvoke = function(name /*...args*/ ) {
            var nodeArgs = array_slice(arguments, 1);
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
            return deferred.promise;
        };

    /**
     * If a function would like to support both Node continuation-passing-style and
     * promise-returning-style, it can end its internal promise chain with
     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
     * elects to use a nodeback, the result will be sent there.  If they do not
     * pass a nodeback, they will receive the result promise.
     * @param object a result (or a promise for a result)
     * @param {Function} nodeback a Node.js-style callback
     * @returns either the promise or nothing
     */
    Q.nodeify = nodeify;

    function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
    }

    Promise.prototype.nodeify = function(nodeback) {
        if (nodeback) {
            this.then(function(value) {
                nextTick(function() {
                    nodeback(null, value);
                });
            }, function(error) {
                nextTick(function() {
                    nodeback(error);
                });
            });
        } else {
            return this;
        }
    };

    // All code before this point will be filtered from stack traces.
    var qEndingLine = captureLine();

    return Q;

});

;
(function() {
    'use strict';

    /**
     * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
     *
     * @codingstandard ftlabs-jsv2
     * @copyright The Financial Times Limited [All Rights Reserved]
     * @license MIT License (see LICENSE.txt)
     */

    /*jslint browser:true, node:true*/
    /*global define, Event, Node*/


    /**
     * Instantiate fast-clicking listeners on the specified layer.
     *
     * @constructor
     * @param {Element} layer The layer to listen on
     * @param {Object} [options={}] The options to override the defaults
     */
    function FastClick(layer, options) {
        var oldOnClick;

        options = options || {};

        /**
         * Whether a click is currently being tracked.
         *
         * @type boolean
         */
        this.trackingClick = false;


        /**
         * Timestamp for when click tracking started.
         *
         * @type number
         */
        this.trackingClickStart = 0;


        /**
         * The element being tracked for a click.
         *
         * @type EventTarget
         */
        this.targetElement = null;


        /**
         * X-coordinate of touch start event.
         *
         * @type number
         */
        this.touchStartX = 0;


        /**
         * Y-coordinate of touch start event.
         *
         * @type number
         */
        this.touchStartY = 0;


        /**
         * ID of the last touch, retrieved from Touch.identifier.
         *
         * @type number
         */
        this.lastTouchIdentifier = 0;


        /**
         * Touchmove boundary, beyond which a click will be cancelled.
         *
         * @type number
         */
        this.touchBoundary = options.touchBoundary || 10;


        /**
         * The FastClick layer.
         *
         * @type Element
         */
        this.layer = layer;

        /**
         * The minimum time between tap(touchstart and touchend) events
         *
         * @type number
         */
        this.tapDelay = options.tapDelay || 200;

        /**
         * The maximum time for a tap
         *
         * @type number
         */
        this.tapTimeout = options.tapTimeout || 700;

        if (FastClick.notNeeded(layer)) {
            return;
        }

        // Some old versions of Android don't have Function.prototype.bind
        function bind(method, context) {
            return function() {
                return method.apply(context, arguments);
            };
        }


        var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
        var context = this;
        for (var i = 0, l = methods.length; i < l; i++) {
            context[methods[i]] = bind(context[methods[i]], context);
        }

        // Set up event handlers as required
        if (deviceIsAndroid) {
            layer.addEventListener('mouseover', this.onMouse, true);
            layer.addEventListener('mousedown', this.onMouse, true);
            layer.addEventListener('mouseup', this.onMouse, true);
        }

        layer.addEventListener('click', this.onClick, true);
        layer.addEventListener('touchstart', this.onTouchStart, false);
        layer.addEventListener('touchmove', this.onTouchMove, false);
        layer.addEventListener('touchend', this.onTouchEnd, false);
        layer.addEventListener('touchcancel', this.onTouchCancel, false);

        // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
        // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
        // layer when they are cancelled.
        if (!Event.prototype.stopImmediatePropagation) {
            layer.removeEventListener = function(type, callback, capture) {
                var rmv = Node.prototype.removeEventListener;
                if (type === 'click') {
                    rmv.call(layer, type, callback.hijacked || callback, capture);
                } else {
                    rmv.call(layer, type, callback, capture);
                }
            };

            layer.addEventListener = function(type, callback, capture) {
                var adv = Node.prototype.addEventListener;
                if (type === 'click') {
                    adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
                        if (!event.propagationStopped) {
                            callback(event);
                        }
                    }), capture);
                } else {
                    adv.call(layer, type, callback, capture);
                }
            };
        }

        // If a handler is already declared in the element's onclick attribute, it will be fired before
        // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
        // adding it as listener.
        if (typeof layer.onclick === 'function') {

            // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
            // - the old one won't work if passed to addEventListener directly.
            oldOnClick = layer.onclick;
            layer.addEventListener('click', function(event) {
                oldOnClick(event);
            }, false);
            layer.onclick = null;
        }
    }

    /**
     * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
     *
     * @type boolean
     */
    var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

    /**
     * Android requires exceptions.
     *
     * @type boolean
     */
    var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


    /**
     * iOS requires exceptions.
     *
     * @type boolean
     */
    var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


    /**
     * iOS 4 requires an exception for select elements.
     *
     * @type boolean
     */
    var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


    /**
     * iOS 6.0-7.* requires the target element to be manually derived
     *
     * @type boolean
     */
    var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

    /**
     * BlackBerry requires exceptions.
     *
     * @type boolean
     */
    var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

    /**
     * Determine whether a given element requires a native click.
     *
     * @param {EventTarget|Element} target Target DOM element
     * @returns {boolean} Returns true if the element needs a native click
     */
    FastClick.prototype.needsClick = function(target) {
        switch (target.nodeName.toLowerCase()) {

            // Don't send a synthetic click to disabled inputs (issue #62)
            case 'button':
            case 'select':
            case 'textarea':
                if (target.disabled) {
                    return true;
                }

                break;
            case 'input':

                // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
                if ((deviceIsIOS && target.type === 'file') || target.disabled) {
                    return true;
                }

                break;
            case 'label':
            case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
            case 'video':
                return true;
        }

        return (/\bneedsclick\b/).test(target.className);
    };


    /**
     * Determine whether a given element requires a call to focus to simulate click into element.
     *
     * @param {EventTarget|Element} target Target DOM element
     * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
     */
    FastClick.prototype.needsFocus = function(target) {
        switch (target.nodeName.toLowerCase()) {
            case 'textarea':
                return true;
            case 'select':
                return !deviceIsAndroid;
            case 'input':
                switch (target.type) {
                    case 'button':
                    case 'checkbox':
                    case 'file':
                    case 'image':
                    case 'radio':
                    case 'submit':
                        return false;
                }

                // No point in attempting to focus disabled inputs
                return !target.disabled && !target.readOnly;
            default:
                return (/\bneedsfocus\b/).test(target.className);
        }
    };


    /**
     * Send a click event to the specified element.
     *
     * @param {EventTarget|Element} targetElement
     * @param {Event} event
     */
    FastClick.prototype.sendClick = function(targetElement, event) {
        var clickEvent, touch;

        // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
        if (document.activeElement && document.activeElement !== targetElement) {
            document.activeElement.blur();
        }

        touch = event.changedTouches[0];

        // Synthesise a click event, with an extra attribute so it can be tracked
        clickEvent = document.createEvent('MouseEvents');
        clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
        clickEvent.forwardedTouchEvent = true;
        targetElement.dispatchEvent(clickEvent);
    };

    FastClick.prototype.determineEventType = function(targetElement) {

        //Issue #159: Android Chrome Select Box does not open with a synthetic click event
        if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
            return 'mousedown';
        }

        return 'click';
    };


    /**
     * @param {EventTarget|Element} targetElement
     */
    FastClick.prototype.focus = function(targetElement) {
        var length;

        // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
        if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
            length = targetElement.value.length;
            targetElement.setSelectionRange(length, length);
        } else {
            targetElement.focus();
        }
    };


    /**
     * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
     *
     * @param {EventTarget|Element} targetElement
     */
    FastClick.prototype.updateScrollParent = function(targetElement) {
        var scrollParent, parentElement;

        scrollParent = targetElement.fastClickScrollParent;

        // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
        // target element was moved to another parent.
        if (!scrollParent || !scrollParent.contains(targetElement)) {
            parentElement = targetElement;
            do {
                if (parentElement.scrollHeight > parentElement.offsetHeight) {
                    scrollParent = parentElement;
                    targetElement.fastClickScrollParent = parentElement;
                    break;
                }

                parentElement = parentElement.parentElement;
            } while (parentElement);
        }

        // Always update the scroll top tracker if possible.
        if (scrollParent) {
            scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
        }
    };


    /**
     * @param {EventTarget} targetElement
     * @returns {Element|EventTarget}
     */
    FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

        // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
        if (eventTarget.nodeType === Node.TEXT_NODE) {
            return eventTarget.parentNode;
        }

        return eventTarget;
    };


    /**
     * On touch start, record the position and scroll offset.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onTouchStart = function(event) {
        var targetElement, touch, selection;

        // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
        if (event.targetTouches.length > 1) {
            return true;
        }

        targetElement = this.getTargetElementFromEventTarget(event.target);
        touch = event.targetTouches[0];

        if (deviceIsIOS) {

            // Only trusted events will deselect text on iOS (issue #49)
            selection = window.getSelection();
            if (selection.rangeCount && !selection.isCollapsed) {
                return true;
            }

            if (!deviceIsIOS4) {

                // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
                // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
                // with the same identifier as the touch event that previously triggered the click that triggered the alert.
                // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
                // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
                // Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
                // which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
                // random integers, it's safe to to continue if the identifier is 0 here.
                if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
                    event.preventDefault();
                    return false;
                }

                this.lastTouchIdentifier = touch.identifier;

                // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
                // 1) the user does a fling scroll on the scrollable layer
                // 2) the user stops the fling scroll with another tap
                // then the event.target of the last 'touchend' event will be the element that was under the user's finger
                // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
                // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
                this.updateScrollParent(targetElement);
            }
        }

        this.trackingClick = true;
        this.trackingClickStart = event.timeStamp;
        this.targetElement = targetElement;

        this.touchStartX = touch.pageX;
        this.touchStartY = touch.pageY;

        // Prevent phantom clicks on fast double-tap (issue #36)
        if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
            event.preventDefault();
        }

        return true;
    };


    /**
     * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.touchHasMoved = function(event) {
        var touch = event.changedTouches[0],
            boundary = this.touchBoundary;

        if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
            return true;
        }

        return false;
    };


    /**
     * Update the last position.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onTouchMove = function(event) {
        if (!this.trackingClick) {
            return true;
        }

        // If the touch has moved, cancel the click tracking
        if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
            this.trackingClick = false;
            this.targetElement = null;
        }

        return true;
    };


    /**
     * Attempt to find the labelled control for the given label element.
     *
     * @param {EventTarget|HTMLLabelElement} labelElement
     * @returns {Element|null}
     */
    FastClick.prototype.findControl = function(labelElement) {

        // Fast path for newer browsers supporting the HTML5 control attribute
        if (labelElement.control !== undefined) {
            return labelElement.control;
        }

        // All browsers under test that support touch events also support the HTML5 htmlFor attribute
        if (labelElement.htmlFor) {
            return document.getElementById(labelElement.htmlFor);
        }

        // If no for attribute exists, attempt to retrieve the first labellable descendant element
        // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
        return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
    };


    /**
     * On touch end, determine whether to send a click event at once.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onTouchEnd = function(event) {
        var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

        if (!this.trackingClick) {
            return true;
        }

        // Prevent phantom clicks on fast double-tap (issue #36)
        if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
            this.cancelNextClick = true;
            return true;
        }

        if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
            return true;
        }

        // Reset to prevent wrong click cancel on input (issue #156).
        this.cancelNextClick = false;

        this.lastClickTime = event.timeStamp;

        trackingClickStart = this.trackingClickStart;
        this.trackingClick = false;
        this.trackingClickStart = 0;

        // On some iOS devices, the targetElement supplied with the event is invalid if the layer
        // is performing a transition or scroll, and has to be re-detected manually. Note that
        // for this to function correctly, it must be called *after* the event target is checked!
        // See issue #57; also filed as rdar://13048589 .
        if (deviceIsIOSWithBadTarget) {
            touch = event.changedTouches[0];

            // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
            targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
            targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
        }

        targetTagName = targetElement.tagName.toLowerCase();
        if (targetTagName === 'label') {
            forElement = this.findControl(targetElement);
            if (forElement) {
                this.focus(targetElement);
                if (deviceIsAndroid) {
                    return false;
                }

                targetElement = forElement;
            }
        } else if (this.needsFocus(targetElement)) {

            // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
            // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
            if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
                this.targetElement = null;
                return false;
            }

            this.focus(targetElement);
            this.sendClick(targetElement, event);

            // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
            // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
            if (!deviceIsIOS || targetTagName !== 'select') {
                this.targetElement = null;
                event.preventDefault();
            }

            return false;
        }

        if (deviceIsIOS && !deviceIsIOS4) {

            // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
            // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
            scrollParent = targetElement.fastClickScrollParent;
            if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
                return true;
            }
        }

        // Prevent the actual click from going though - unless the target node is marked as requiring
        // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
        if (!this.needsClick(targetElement)) {
            event.preventDefault();
            this.sendClick(targetElement, event);
        }

        return false;
    };


    /**
     * On touch cancel, stop tracking the click.
     *
     * @returns {void}
     */
    FastClick.prototype.onTouchCancel = function() {
        this.trackingClick = false;
        this.targetElement = null;
    };


    /**
     * Determine mouse events which should be permitted.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onMouse = function(event) {

        // If a target element was never set (because a touch event was never fired) allow the event
        if (!this.targetElement) {
            return true;
        }

        if (event.forwardedTouchEvent) {
            return true;
        }

        // Programmatically generated events targeting a specific element should be permitted
        if (!event.cancelable) {
            return true;
        }

        // Derive and check the target element to see whether the mouse event needs to be permitted;
        // unless explicitly enabled, prevent non-touch click events from triggering actions,
        // to prevent ghost/doubleclicks.
        if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

            // Prevent any user-added listeners declared on FastClick element from being fired.
            if (event.stopImmediatePropagation) {
                event.stopImmediatePropagation();
            } else {

                // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
                event.propagationStopped = true;
            }

            // Cancel the event
            event.stopPropagation();
            event.preventDefault();

            return false;
        }

        // If the mouse event is permitted, return true for the action to go through.
        return true;
    };


    /**
     * On actual clicks, determine whether this is a touch-generated click, a click action occurring
     * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
     * an actual click which should be permitted.
     *
     * @param {Event} event
     * @returns {boolean}
     */
    FastClick.prototype.onClick = function(event) {
        var permitted;

        // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
        if (this.trackingClick) {
            this.targetElement = null;
            this.trackingClick = false;
            return true;
        }

        // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
        if (event.target.type === 'submit' && event.detail === 0) {
            return true;
        }

        permitted = this.onMouse(event);

        // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
        if (!permitted) {
            this.targetElement = null;
        }

        // If clicks are permitted, return true for the action to go through.
        return permitted;
    };


    /**
     * Remove all FastClick's event listeners.
     *
     * @returns {void}
     */
    FastClick.prototype.destroy = function() {
        var layer = this.layer;

        if (deviceIsAndroid) {
            layer.removeEventListener('mouseover', this.onMouse, true);
            layer.removeEventListener('mousedown', this.onMouse, true);
            layer.removeEventListener('mouseup', this.onMouse, true);
        }

        layer.removeEventListener('click', this.onClick, true);
        layer.removeEventListener('touchstart', this.onTouchStart, false);
        layer.removeEventListener('touchmove', this.onTouchMove, false);
        layer.removeEventListener('touchend', this.onTouchEnd, false);
        layer.removeEventListener('touchcancel', this.onTouchCancel, false);
    };


    /**
     * Check whether FastClick is needed.
     *
     * @param {Element} layer The layer to listen on
     */
    FastClick.notNeeded = function(layer) {
        var metaViewport;
        var chromeVersion;
        var blackberryVersion;
        var firefoxVersion;

        // Devices that don't support touch don't need FastClick
        if (typeof window.ontouchstart === 'undefined') {
            return true;
        }

        // Chrome version - zero for other browsers
        chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

        if (chromeVersion) {

            if (deviceIsAndroid) {
                metaViewport = document.querySelector('meta[name=viewport]');

                if (metaViewport) {
                    // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
                    if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
                        return true;
                    }
                    // Chrome 32 and above with width=device-width or less don't need FastClick
                    if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
                        return true;
                    }
                }

                // Chrome desktop doesn't need FastClick (issue #15)
            } else {
                return true;
            }
        }

        if (deviceIsBlackBerry10) {
            blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

            // BlackBerry 10.3+ does not require Fastclick library.
            // https://github.com/ftlabs/fastclick/issues/251
            if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
                metaViewport = document.querySelector('meta[name=viewport]');

                if (metaViewport) {
                    // user-scalable=no eliminates click delay.
                    if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
                        return true;
                    }
                    // width=device-width (or less than device-width) eliminates click delay.
                    if (document.documentElement.scrollWidth <= window.outerWidth) {
                        return true;
                    }
                }
            }
        }

        // IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
        if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
            return true;
        }

        // Firefox version - zero for other browsers
        firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

        if (firefoxVersion >= 27) {
            // Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

            metaViewport = document.querySelector('meta[name=viewport]');
            if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
                return true;
            }
        }

        // IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
        // http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
        if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
            return true;
        }

        return false;
    };


    /**
     * Factory method for creating a FastClick object
     *
     * @param {Element} layer The layer to listen on
     * @param {Object} [options={}] The options to override the defaults
     */
    FastClick.attach = function(layer, options) {
        return new FastClick(layer, options);
    };


    if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {

        // AMD. Register as an anonymous module.
        define(function() {
            return FastClick;
        });
    } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = FastClick.attach;
        module.exports.FastClick = FastClick;
    } else {
        window.FastClick = FastClick;
    }
}());

/*! Hammer.JS - v1.1.3 - 2014-05-20
 * http://eightmedia.github.io/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(window, undefined) {
    'use strict';

    /**
     * @main
     * @module hammer
     *
     * @class Hammer
     * @static
     */

    /**
     * Hammer, use this to create instances
     * ````
     * var hammertime = new Hammer(myElement);
     * ````
     *
     * @method Hammer
     * @param {HTMLElement} element
     * @param {Object} [options={}]
     * @return {Hammer.Instance}
     */
    var Hammer = function Hammer(element, options) {
        return new Hammer.Instance(element, options || {});
    };

    /**
     * version, as defined in package.json
     * the value will be set at each build
     * @property VERSION
     * @final
     * @type {String}
     */
    Hammer.VERSION = '1.1.3';

    /**
     * default settings.
     * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
     * by setting it's name (like `swipe`) to false.
     * You can set the defaults for all instances by changing this object before creating an instance.
     * @example
     * ````
     *  Hammer.defaults.drag = false;
     *  Hammer.defaults.behavior.touchAction = 'pan-y';
     *  delete Hammer.defaults.behavior.userSelect;
     * ````
     * @property defaults
     * @type {Object}
     */
    Hammer.defaults = {
        /**
         * this setting object adds styles and attributes to the element to prevent the browser from doing
         * its native behavior. The css properties are auto prefixed for the browsers when needed.
         * @property defaults.behavior
         * @type {Object}
         */
        behavior: {
            /**
             * Disables text selection to improve the dragging gesture. When the value is `none` it also sets
             * `onselectstart=false` for IE on the element. Mainly for desktop browsers.
             * @property defaults.behavior.userSelect
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Specifies whether and how a given region can be manipulated by the user (for instance, by panning or zooming).
             * Used by Chrome 35> and IE10>. By default this makes the element blocking any touch event.
             * @property defaults.behavior.touchAction
             * @type {String}
             * @default: 'pan-y'
             */
            touchAction: 'pan-y',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @property defaults.behavior.touchCallout
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @property defaults.behavior.contentZooming
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents.
             * Mainly for desktop browsers.
             * @property defaults.behavior.userDrag
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in Safari on iPhone. This property obeys the alpha value, if specified.
             *
             * If you don't specify an alpha value, Safari on iPhone applies a default alpha value
             * to the color. To disable tap highlighting, set the alpha value to 0 (invisible).
             * If you set the alpha value to 1.0 (opaque), the element is not visible when tapped.
             * @property defaults.behavior.tapHighlightColor
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };

    /**
     * hammer document where the base events are added at
     * @property DOCUMENT
     * @type {HTMLElement}
     * @default window.document
     */
    Hammer.DOCUMENT = document;

    /**
     * detect support for pointer events
     * @property HAS_POINTEREVENTS
     * @type {Boolean}
     */
    Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

    /**
     * detect support for touch events
     * @property HAS_TOUCHEVENTS
     * @type {Boolean}
     */
    Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

    /**
     * detect mobile browsers
     * @property IS_MOBILE
     * @type {Boolean}
     */
    Hammer.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

    /**
     * detect if we want to support mouseevents at all
     * @property NO_MOUSEEVENTS
     * @type {Boolean}
     */
    Hammer.NO_MOUSEEVENTS = (Hammer.HAS_TOUCHEVENTS && Hammer.IS_MOBILE) || Hammer.HAS_POINTEREVENTS;

    /**
     * interval in which Hammer recalculates current velocity/direction/angle in ms
     * @property CALCULATE_INTERVAL
     * @type {Number}
     * @default 25
     */
    Hammer.CALCULATE_INTERVAL = 25;

    /**
     * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
     * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
     * @property EVENT_TYPES
     * @private
     * @writeOnce
     * @type {Object}
     */
    var EVENT_TYPES = {};

    /**
     * direction strings, for safe comparisons
     * @property DIRECTION_DOWN|LEFT|UP|RIGHT
     * @final
     * @type {String}
     * @default 'down' 'left' 'up' 'right'
     */
    var DIRECTION_DOWN = Hammer.DIRECTION_DOWN = 'down';
    var DIRECTION_LEFT = Hammer.DIRECTION_LEFT = 'left';
    var DIRECTION_UP = Hammer.DIRECTION_UP = 'up';
    var DIRECTION_RIGHT = Hammer.DIRECTION_RIGHT = 'right';

    /**
     * pointertype strings, for safe comparisons
     * @property POINTER_MOUSE|TOUCH|PEN
     * @final
     * @type {String}
     * @default 'mouse' 'touch' 'pen'
     */
    var POINTER_MOUSE = Hammer.POINTER_MOUSE = 'mouse';
    var POINTER_TOUCH = Hammer.POINTER_TOUCH = 'touch';
    var POINTER_PEN = Hammer.POINTER_PEN = 'pen';

    /**
     * eventtypes
     * @property EVENT_START|MOVE|END|RELEASE|TOUCH
     * @final
     * @type {String}
     * @default 'start' 'change' 'move' 'end' 'release' 'touch'
     */
    var EVENT_START = Hammer.EVENT_START = 'start';
    var EVENT_MOVE = Hammer.EVENT_MOVE = 'move';
    var EVENT_END = Hammer.EVENT_END = 'end';
    var EVENT_RELEASE = Hammer.EVENT_RELEASE = 'release';
    var EVENT_TOUCH = Hammer.EVENT_TOUCH = 'touch';

    /**
     * if the window events are set...
     * @property READY
     * @writeOnce
     * @type {Boolean}
     * @default false
     */
    Hammer.READY = false;

    /**
     * plugins namespace
     * @property plugins
     * @type {Object}
     */
    Hammer.plugins = Hammer.plugins || {};

    /**
     * gestures namespace
     * see `/gestures` for the definitions
     * @property gestures
     * @type {Object}
     */
    Hammer.gestures = Hammer.gestures || {};

    /**
     * setup events to detect gestures on the document
     * this function is called when creating an new instance
     * @private
     */
    function setup() {
        if (Hammer.READY) {
            return;
        }

        // find what eventtypes we add listeners to
        Event.determineEventTypes();

        // Register all gestures inside Hammer.gestures
        Utils.each(Hammer.gestures, function(gesture) {
            Detection.register(gesture);
        });

        // Add touch events on the document
        Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);
        Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);

        // Hammer is ready...!
        Hammer.READY = true;
    }

    /**
     * @module hammer
     *
     * @class Utils
     * @static
     */
    var Utils = Hammer.utils = {
        /**
         * extend method, could also be used for cloning when `dest` is an empty object.
         * changes the dest object
         * @method extend
         * @param {Object} dest
         * @param {Object} src
         * @param {Boolean} [merge=false]  do a merge
         * @return {Object} dest
         */
        extend: function extend(dest, src, merge) {
            for (var key in src) {
                if (!src.hasOwnProperty(key) || (dest[key] !== undefined && merge)) {
                    continue;
                }
                dest[key] = src[key];
            }
            return dest;
        },

        /**
         * simple addEventListener wrapper
         * @method on
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         */
        on: function on(element, type, handler) {
            element.addEventListener(type, handler, false);
        },

        /**
         * simple removeEventListener wrapper
         * @method off
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         */
        off: function off(element, type, handler) {
            element.removeEventListener(type, handler, false);
        },

        /**
         * forEach over arrays and objects
         * @method each
         * @param {Object|Array} obj
         * @param {Function} iterator
         * @param {any} iterator.item
         * @param {Number} iterator.index
         * @param {Object|Array} iterator.obj the source object
         * @param {Object} context value to use as `this` in the iterator
         */
        each: function each(obj, iterator, context) {
            var i, len;

            // native forEach on arrays
            if ('forEach' in obj) {
                obj.forEach(iterator, context);
                // arrays
            } else if (obj.length !== undefined) {
                for (i = 0, len = obj.length; i < len; i++) {
                    if (iterator.call(context, obj[i], i, obj) === false) {
                        return;
                    }
                }
                // objects
            } else {
                for (i in obj) {
                    if (obj.hasOwnProperty(i) &&
                        iterator.call(context, obj[i], i, obj) === false) {
                        return;
                    }
                }
            }
        },

        /**
         * find if a string contains the string using indexOf
         * @method inStr
         * @param {String} src
         * @param {String} find
         * @return {Boolean} found
         */
        inStr: function inStr(src, find) {
            return src.indexOf(find) > -1;
        },

        /**
         * find if a array contains the object using indexOf or a simple polyfill
         * @method inArray
         * @param {String} src
         * @param {String} find
         * @return {Boolean|Number} false when not found, or the index
         */
        inArray: function inArray(src, find) {
            if (src.indexOf) {
                var index = src.indexOf(find);
                return (index === -1) ? false : index;
            } else {
                for (var i = 0, len = src.length; i < len; i++) {
                    if (src[i] === find) {
                        return i;
                    }
                }
                return false;
            }
        },

        /**
         * convert an array-like object (`arguments`, `touchlist`) to an array
         * @method toArray
         * @param {Object} obj
         * @return {Array}
         */
        toArray: function toArray(obj) {
            return Array.prototype.slice.call(obj, 0);
        },

        /**
         * find if a node is in the given parent
         * @method hasParent
         * @param {HTMLElement} node
         * @param {HTMLElement} parent
         * @return {Boolean} found
         */
        hasParent: function hasParent(node, parent) {
            while (node) {
                if (node == parent) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        },

        /**
         * get the center of all the touches
         * @method getCenter
         * @param {Array} touches
         * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
         */
        getCenter: function getCenter(touches) {
            var pageX = [],
                pageY = [],
                clientX = [],
                clientY = [],
                min = Math.min,
                max = Math.max;

            // no need to loop when only one touch
            if (touches.length === 1) {
                return {
                    pageX: touches[0].pageX,
                    pageY: touches[0].pageY,
                    clientX: touches[0].clientX,
                    clientY: touches[0].clientY
                };
            }

            Utils.each(touches, function(touch) {
                pageX.push(touch.pageX);
                pageY.push(touch.pageY);
                clientX.push(touch.clientX);
                clientY.push(touch.clientY);
            });

            return {
                pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
                pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
                clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
                clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
            };
        },

        /**
         * calculate the velocity between two points. unit is in px per ms.
         * @method getVelocity
         * @param {Number} deltaTime
         * @param {Number} deltaX
         * @param {Number} deltaY
         * @return {Object} velocity `x` and `y`
         */
        getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
            return {
                x: Math.abs(deltaX / deltaTime) || 0,
                y: Math.abs(deltaY / deltaTime) || 0
            };
        },

        /**
         * calculate the angle between two coordinates
         * @method getAngle
         * @param {Touch} touch1
         * @param {Touch} touch2
         * @return {Number} angle
         */
        getAngle: function getAngle(touch1, touch2) {
            var x = touch2.clientX - touch1.clientX,
                y = touch2.clientY - touch1.clientY;

            return Math.atan2(y, x) * 180 / Math.PI;
        },

        /**
         * do a small comparision to get the direction between two touches.
         * @method getDirection
         * @param {Touch} touch1
         * @param {Touch} touch2
         * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
         */
        getDirection: function getDirection(touch1, touch2) {
            var x = Math.abs(touch1.clientX - touch2.clientX),
                y = Math.abs(touch1.clientY - touch2.clientY);

            if (x >= y) {
                return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            }
            return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
        },

        /**
         * calculate the distance between two touches
         * @method getDistance
         * @param {Touch}touch1
         * @param {Touch} touch2
         * @return {Number} distance
         */
        getDistance: function getDistance(touch1, touch2) {
            var x = touch2.clientX - touch1.clientX,
                y = touch2.clientY - touch1.clientY;

            return Math.sqrt((x * x) + (y * y));
        },

        /**
         * calculate the scale factor between two touchLists
         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
         * @method getScale
         * @param {Array} start array of touches
         * @param {Array} end array of touches
         * @return {Number} scale
         */
        getScale: function getScale(start, end) {
            // need two fingers...
            if (start.length >= 2 && end.length >= 2) {
                return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
            }
            return 1;
        },

        /**
         * calculate the rotation degrees between two touchLists
         * @method getRotation
         * @param {Array} start array of touches
         * @param {Array} end array of touches
         * @return {Number} rotation
         */
        getRotation: function getRotation(start, end) {
            // need two fingers
            if (start.length >= 2 && end.length >= 2) {
                return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
            }
            return 0;
        },

        /**
         * find out if the direction is vertical   *
         * @method isVertical
         * @param {String} direction matches `DIRECTION_UP|DOWN`
         * @return {Boolean} is_vertical
         */
        isVertical: function isVertical(direction) {
            return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
        },

        /**
         * set css properties with their prefixes
         * @param {HTMLElement} element
         * @param {String} prop
         * @param {String} value
         * @param {Boolean} [toggle=true]
         * @return {Boolean}
         */
        setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
            var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
            prop = Utils.toCamelCase(prop);

            for (var i = 0; i < prefixes.length; i++) {
                var p = prop;
                // prefixes
                if (prefixes[i]) {
                    p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
                }

                // test the style
                if (p in element.style) {
                    element.style[p] = (toggle == null || toggle) && value || '';
                    break;
                }
            }
        },

        /**
         * toggle browser default behavior by setting css properties.
         * `userSelect='none'` also sets `element.onselectstart` to false
         * `userDrag='none'` also sets `element.ondragstart` to false
         *
         * @method toggleBehavior
         * @param {HtmlElement} element
         * @param {Object} props
         * @param {Boolean} [toggle=true]
         */
        toggleBehavior: function toggleBehavior(element, props, toggle) {
            if (!props || !element || !element.style) {
                return;
            }

            // set the css properties
            Utils.each(props, function(value, prop) {
                Utils.setPrefixedCss(element, prop, value, toggle);
            });

            var falseFn = toggle && function() {
                return false;
            };

            // also the disable onselectstart
            if (props.userSelect == 'none') {
                element.onselectstart = falseFn;
            }
            // and disable ondragstart
            if (props.userDrag == 'none') {
                element.ondragstart = falseFn;
            }
        },

        /**
         * convert a string with underscores to camelCase
         * so prevent_default becomes preventDefault
         * @param {String} str
         * @return {String} camelCaseStr
         */
        toCamelCase: function toCamelCase(str) {
            return str.replace(/[_-]([a-z])/g, function(s) {
                return s[1].toUpperCase();
            });
        }
    };


    /**
     * @module hammer
     */
    /**
     * @class Event
     * @static
     */
    var Event = Hammer.event = {
        /**
         * when touch events have been fired, this is true
         * this is used to stop mouse events
         * @property prevent_mouseevents
         * @private
         * @type {Boolean}
         */
        preventMouseEvents: false,

        /**
         * if EVENT_START has been fired
         * @property started
         * @private
         * @type {Boolean}
         */
        started: false,

        /**
         * when the mouse is hold down, this is true
         * @property should_detect
         * @private
         * @type {Boolean}
         */
        shouldDetect: false,

        /**
         * simple event binder with a hook and support for multiple types
         * @method on
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         * @param {Function} [hook]
         * @param {Object} hook.type
         */
        on: function on(element, type, handler, hook) {
            var types = type.split(' ');
            Utils.each(types, function(type) {
                Utils.on(element, type, handler);
                hook && hook(type);
            });
        },

        /**
         * simple event unbinder with a hook and support for multiple types
         * @method off
         * @param {HTMLElement} element
         * @param {String} type
         * @param {Function} handler
         * @param {Function} [hook]
         * @param {Object} hook.type
         */
        off: function off(element, type, handler, hook) {
            var types = type.split(' ');
            Utils.each(types, function(type) {
                Utils.off(element, type, handler);
                hook && hook(type);
            });
        },

        /**
         * the core touch event handler.
         * this finds out if we should to detect gestures
         * @method onTouch
         * @param {HTMLElement} element
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Function} handler
         * @return onTouchHandler {Function} the core event handler
         */
        onTouch: function onTouch(element, eventType, handler) {
            var self = this;

            var onTouchHandler = function onTouchHandler(ev) {
                var srcType = ev.type.toLowerCase(),
                    isPointer = Hammer.HAS_POINTEREVENTS,
                    isMouse = Utils.inStr(srcType, 'mouse'),
                    triggerType;

                // if we are in a mouseevent, but there has been a touchevent triggered in this session
                // we want to do nothing. simply break out of the event.
                if (isMouse && self.preventMouseEvents) {
                    return;

                    // mousebutton must be down
                } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
                    self.preventMouseEvents = false;
                    self.shouldDetect = true;
                } else if (isPointer && eventType == EVENT_START) {
                    self.shouldDetect = (ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev));
                    // just a valid start event, but no mouse
                } else if (!isMouse && eventType == EVENT_START) {
                    self.preventMouseEvents = true;
                    self.shouldDetect = true;
                }

                // update the pointer event before entering the detection
                if (isPointer && eventType != EVENT_END) {
                    PointerEvent.updatePointer(eventType, ev);
                }

                // we are in a touch/down state, so allowed detection of gestures
                if (self.shouldDetect) {
                    triggerType = self.doDetect.call(self, ev, eventType, element, handler);
                }

                // ...and we are done with the detection
                // so reset everything to start each detection totally fresh
                if (triggerType == EVENT_END) {
                    self.preventMouseEvents = false;
                    self.shouldDetect = false;
                    PointerEvent.reset();
                    // update the pointerevent object after the detection
                }

                if (isPointer && eventType == EVENT_END) {
                    PointerEvent.updatePointer(eventType, ev);
                }
            };

            this.on(element, EVENT_TYPES[eventType], onTouchHandler);
            return onTouchHandler;
        },

        /**
         * the core detection method
         * this finds out what hammer-touch-events to trigger
         * @method doDetect
         * @param {Object} ev
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {HTMLElement} element
         * @param {Function} handler
         * @return {String} triggerType matches `EVENT_START|MOVE|END`
         */
        doDetect: function doDetect(ev, eventType, element, handler) {
            var touchList = this.getTouchList(ev, eventType);
            var touchListLength = touchList.length;
            var triggerType = eventType;
            var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
            var changedLength = touchListLength;

            // at each touchstart-like event we want also want to trigger a TOUCH event...
            if (eventType == EVENT_START) {
                triggerChange = EVENT_TOUCH;
                // ...the same for a touchend-like event
            } else if (eventType == EVENT_END) {
                triggerChange = EVENT_RELEASE;

                // keep track of how many touches have been removed
                changedLength = touchList.length - ((ev.changedTouches) ? ev.changedTouches.length : 1);
            }

            // after there are still touches on the screen,
            // we just want to trigger a MOVE event. so change the START or END to a MOVE
            // but only after detection has been started, the first time we actualy want a START
            if (changedLength > 0 && this.started) {
                triggerType = EVENT_MOVE;
            }

            // detection has been started, we keep track of this, see above
            this.started = true;

            // generate some event data, some basic information
            var evData = this.collectEventData(element, triggerType, touchList, ev);

            // trigger the triggerType event before the change (TOUCH, RELEASE) events
            // but the END event should be at last
            if (eventType != EVENT_END) {
                handler.call(Detection, evData);
            }

            // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
            if (triggerChange) {
                evData.changedLength = changedLength;
                evData.eventType = triggerChange;

                handler.call(Detection, evData);

                evData.eventType = triggerType;
                delete evData.changedLength;
            }

            // trigger the END event
            if (triggerType == EVENT_END) {
                handler.call(Detection, evData);

                // ...and we are done with the detection
                // so reset everything to start each detection totally fresh
                this.started = false;
            }

            return triggerType;
        },

        /**
         * we have different events for each device/browser
         * determine what we need and set them in the EVENT_TYPES constant
         * the `onTouch` method is bind to these properties.
         * @method determineEventTypes
         * @return {Object} events
         */
        determineEventTypes: function determineEventTypes() {
            var types;
            if (Hammer.HAS_POINTEREVENTS) {
                if (window.PointerEvent) {
                    types = [
                        'pointerdown',
                        'pointermove',
                        'pointerup pointercancel lostpointercapture'
                    ];
                } else {
                    types = [
                        'MSPointerDown',
                        'MSPointerMove',
                        'MSPointerUp MSPointerCancel MSLostPointerCapture'
                    ];
                }
            } else if (Hammer.NO_MOUSEEVENTS) {
                types = [
                    'touchstart',
                    'touchmove',
                    'touchend touchcancel'
                ];
            } else {
                types = [
                    'touchstart mousedown',
                    'touchmove mousemove',
                    'touchend touchcancel mouseup'
                ];
            }

            EVENT_TYPES[EVENT_START] = types[0];
            EVENT_TYPES[EVENT_MOVE] = types[1];
            EVENT_TYPES[EVENT_END] = types[2];
            return EVENT_TYPES;
        },

        /**
         * create touchList depending on the event
         * @method getTouchList
         * @param {Object} ev
         * @param {String} eventType
         * @return {Array} touches
         */
        getTouchList: function getTouchList(ev, eventType) {
            // get the fake pointerEvent touchlist
            if (Hammer.HAS_POINTEREVENTS) {
                return PointerEvent.getTouchList();
            }

            // get the touchlist
            if (ev.touches) {
                if (eventType == EVENT_MOVE) {
                    return ev.touches;
                }

                var identifiers = [];
                var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
                var touchList = [];

                Utils.each(concat, function(touch) {
                    if (Utils.inArray(identifiers, touch.identifier) === false) {
                        touchList.push(touch);
                    }
                    identifiers.push(touch.identifier);
                });

                return touchList;
            }

            // make fake touchList from mouse position
            ev.identifier = 1;
            return [ev];
        },

        /**
         * collect basic event data
         * @method collectEventData
         * @param {HTMLElement} element
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Array} touches
         * @param {Object} ev
         * @return {Object} ev
         */
        collectEventData: function collectEventData(element, eventType, touches, ev) {
            // find out pointerType
            var pointerType = POINTER_TOUCH;
            if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
                pointerType = POINTER_MOUSE;
            } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
                pointerType = POINTER_PEN;
            }

            return {
                center: Utils.getCenter(touches),
                timeStamp: Date.now(),
                target: ev.target,
                touches: touches,
                eventType: eventType,
                pointerType: pointerType,
                srcEvent: ev,

                /**
                 * prevent the browser default actions
                 * mostly used to disable scrolling of the browser
                 */
                preventDefault: function() {
                    var srcEvent = this.srcEvent;
                    srcEvent.preventManipulation && srcEvent.preventManipulation();
                    srcEvent.preventDefault && srcEvent.preventDefault();
                },

                /**
                 * stop bubbling the event up to its parents
                 */
                stopPropagation: function() {
                    this.srcEvent.stopPropagation();
                },

                /**
                 * immediately stop gesture detection
                 * might be useful after a swipe was detected
                 * @return {*}
                 */
                stopDetect: function() {
                    return Detection.stopDetect();
                }
            };
        }
    };


    /**
     * @module hammer
     *
     * @class PointerEvent
     * @static
     */
    var PointerEvent = Hammer.PointerEvent = {
        /**
         * holds all pointers, by `identifier`
         * @property pointers
         * @type {Object}
         */
        pointers: {},

        /**
         * get the pointers as an array
         * @method getTouchList
         * @return {Array} touchlist
         */
        getTouchList: function getTouchList() {
            var touchlist = [];
            // we can use forEach since pointerEvents only is in IE10
            Utils.each(this.pointers, function(pointer) {
                touchlist.push(pointer);
            });
            return touchlist;
        },

        /**
         * update the position of a pointer
         * @method updatePointer
         * @param {String} eventType matches `EVENT_START|MOVE|END`
         * @param {Object} pointerEvent
         */
        updatePointer: function updatePointer(eventType, pointerEvent) {
            if (eventType == EVENT_END || (eventType != EVENT_END && pointerEvent.buttons !== 1)) {
                delete this.pointers[pointerEvent.pointerId];
            } else {
                pointerEvent.identifier = pointerEvent.pointerId;
                this.pointers[pointerEvent.pointerId] = pointerEvent;
            }
        },

        /**
         * check if ev matches pointertype
         * @method matchType
         * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
         * @param {PointerEvent} ev
         */
        matchType: function matchType(pointerType, ev) {
            if (!ev.pointerType) {
                return false;
            }

            var pt = ev.pointerType,
                types = {};

            types[POINTER_MOUSE] = (pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE));
            types[POINTER_TOUCH] = (pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH));
            types[POINTER_PEN] = (pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN));
            return types[pointerType];
        },

        /**
         * reset the stored pointers
         * @method reset
         */
        reset: function resetList() {
            this.pointers = {};
        }
    };


    /**
     * @module hammer
     *
     * @class Detection
     * @static
     */
    var Detection = Hammer.detection = {
        // contains all registred Hammer.gestures in the correct order
        gestures: [],

        // data of the current Hammer.gesture detection session
        current: null,

        // the previous Hammer.gesture session data
        // is a full clone of the previous gesture.current object
        previous: null,

        // when this becomes true, no gestures are fired
        stopped: false,

        /**
         * start Hammer.gesture detection
         * @method startDetect
         * @param {Hammer.Instance} inst
         * @param {Object} eventData
         */
        startDetect: function startDetect(inst, eventData) {
            // already busy with a Hammer.gesture detection on an element
            if (this.current) {
                return;
            }

            this.stopped = false;

            // holds current session
            this.current = {
                inst: inst, // reference to HammerInstance we're working for
                startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
                lastEvent: false, // last eventData
                lastCalcEvent: false, // last eventData for calculations.
                futureCalcEvent: false, // last eventData for calculations.
                lastCalcData: {}, // last lastCalcData
                name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
            };

            this.detect(eventData);
        },

        /**
         * Hammer.gesture detection
         * @method detect
         * @param {Object} eventData
         * @return {any}
         */
        detect: function detect(eventData) {
            if (!this.current || this.stopped) {
                return;
            }

            // extend event data with calculations about scale, distance etc
            eventData = this.extendEventData(eventData);

            // hammer instance and instance options
            var inst = this.current.inst,
                instOptions = inst.options;

            // call Hammer.gesture handlers
            Utils.each(this.gestures, function triggerGesture(gesture) {
                // only when the instance options have enabled this gesture
                if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
                    gesture.handler.call(gesture, eventData, inst);
                }
            }, this);

            // store as previous event event
            if (this.current) {
                this.current.lastEvent = eventData;
            }

            if (eventData.eventType == EVENT_END) {
                this.stopDetect();
            }

            return eventData;
        },

        /**
         * clear the Hammer.gesture vars
         * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
         * to stop other Hammer.gestures from being fired
         * @method stopDetect
         */
        stopDetect: function stopDetect() {
            // clone current data to the store as the previous gesture
            // used for the double tap gesture, since this is an other gesture detect session
            this.previous = Utils.extend({}, this.current);

            // reset the current
            this.current = null;
            this.stopped = true;
        },

        /**
         * calculate velocity, angle and direction
         * @method getVelocityData
         * @param {Object} ev
         * @param {Object} center
         * @param {Number} deltaTime
         * @param {Number} deltaX
         * @param {Number} deltaY
         */
        getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
            var cur = this.current,
                recalc = false,
                calcEv = cur.lastCalcEvent,
                calcData = cur.lastCalcData;

            if (calcEv && ev.timeStamp - calcEv.timeStamp > Hammer.CALCULATE_INTERVAL) {
                center = calcEv.center;
                deltaTime = ev.timeStamp - calcEv.timeStamp;
                deltaX = ev.center.clientX - calcEv.center.clientX;
                deltaY = ev.center.clientY - calcEv.center.clientY;
                recalc = true;
            }

            if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
                cur.futureCalcEvent = ev;
            }

            if (!cur.lastCalcEvent || recalc) {
                calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
                calcData.angle = Utils.getAngle(center, ev.center);
                calcData.direction = Utils.getDirection(center, ev.center);

                cur.lastCalcEvent = cur.futureCalcEvent || ev;
                cur.futureCalcEvent = ev;
            }

            ev.velocityX = calcData.velocity.x;
            ev.velocityY = calcData.velocity.y;
            ev.interimAngle = calcData.angle;
            ev.interimDirection = calcData.direction;
        },

        /**
         * extend eventData for Hammer.gestures
         * @method extendEventData
         * @param {Object} ev
         * @return {Object} ev
         */
        extendEventData: function extendEventData(ev) {
            var cur = this.current,
                startEv = cur.startEvent,
                lastEv = cur.lastEvent || startEv;

            // update the start touchlist to calculate the scale/rotation
            if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
                startEv.touches = [];
                Utils.each(ev.touches, function(touch) {
                    startEv.touches.push({
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                });
            }

            var deltaTime = ev.timeStamp - startEv.timeStamp,
                deltaX = ev.center.clientX - startEv.center.clientX,
                deltaY = ev.center.clientY - startEv.center.clientY;

            this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

            Utils.extend(ev, {
                startEvent: startEv,

                deltaTime: deltaTime,
                deltaX: deltaX,
                deltaY: deltaY,

                distance: Utils.getDistance(startEv.center, ev.center),
                angle: Utils.getAngle(startEv.center, ev.center),
                direction: Utils.getDirection(startEv.center, ev.center),
                scale: Utils.getScale(startEv.touches, ev.touches),
                rotation: Utils.getRotation(startEv.touches, ev.touches)
            });

            return ev;
        },

        /**
         * register new gesture
         * @method register
         * @param {Object} gesture object, see `gestures/` for documentation
         * @return {Array} gestures
         */
        register: function register(gesture) {
            // add an enable gesture options if there is no given
            var options = gesture.defaults || {};
            if (options[gesture.name] === undefined) {
                options[gesture.name] = true;
            }

            // extend Hammer default options with the Hammer.gesture options
            Utils.extend(Hammer.defaults, options, true);

            // set its index
            gesture.index = gesture.index || 1000;

            // add Hammer.gesture to the list
            this.gestures.push(gesture);

            // sort the list by index
            this.gestures.sort(function(a, b) {
                if (a.index < b.index) {
                    return -1;
                }
                if (a.index > b.index) {
                    return 1;
                }
                return 0;
            });

            return this.gestures;
        }
    };


    /**
     * @module hammer
     */

    /**
     * create new hammer instance
     * all methods should return the instance itself, so it is chainable.
     *
     * @class Instance
     * @constructor
     * @param {HTMLElement} element
     * @param {Object} [options={}] options are merged with `Hammer.defaults`
     * @return {Hammer.Instance}
     */
    Hammer.Instance = function(element, options) {
        var self = this;

        // setup HammerJS window events and register all gestures
        // this also sets up the default options
        setup();

        /**
         * @property element
         * @type {HTMLElement}
         */
        this.element = element;

        /**
         * @property enabled
         * @type {Boolean}
         * @protected
         */
        this.enabled = true;

        /**
         * options, merged with the defaults
         * options with an _ are converted to camelCase
         * @property options
         * @type {Object}
         */
        Utils.each(options, function(value, name) {
            delete options[name];
            options[Utils.toCamelCase(name)] = value;
        });

        this.options = Utils.extend(Utils.extend({}, Hammer.defaults), options || {});

        // add some css to the element to prevent the browser from doing its native behavoir
        if (this.options.behavior) {
            Utils.toggleBehavior(this.element, this.options.behavior, true);
        }

        /**
         * event start handler on the element to start the detection
         * @property eventStartHandler
         * @type {Object}
         */
        this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {
            if (self.enabled && ev.eventType == EVENT_START) {
                Detection.startDetect(self, ev);
            } else if (ev.eventType == EVENT_TOUCH) {
                Detection.detect(ev);
            }
        });

        /**
         * keep a list of user event handlers which needs to be removed when calling 'dispose'
         * @property eventHandlers
         * @type {Array}
         */
        this.eventHandlers = [];
    };

    Hammer.Instance.prototype = {
        /**
         * bind events to the instance
         * @method on
         * @chainable
         * @param {String} gestures multiple gestures by splitting with a space
         * @param {Function} handler
         * @param {Object} handler.ev event object
         */
        on: function onEvent(gestures, handler) {
            var self = this;
            Event.on(self.element, gestures, handler, function(type) {
                self.eventHandlers.push({
                    gesture: type,
                    handler: handler
                });
            });
            return self;
        },

        /**
         * unbind events to the instance
         * @method off
         * @chainable
         * @param {String} gestures
         * @param {Function} handler
         */
        off: function offEvent(gestures, handler) {
            var self = this;

            Event.off(self.element, gestures, handler, function(type) {
                var index = Utils.inArray({
                    gesture: type,
                    handler: handler
                });
                if (index !== false) {
                    self.eventHandlers.splice(index, 1);
                }
            });
            return self;
        },

        /**
         * trigger gesture event
         * @method trigger
         * @chainable
         * @param {String} gesture
         * @param {Object} [eventData]
         */
        trigger: function triggerEvent(gesture, eventData) {
            // optional
            if (!eventData) {
                eventData = {};
            }

            // create DOM event
            var event = Hammer.DOCUMENT.createEvent('Event');
            event.initEvent(gesture, true, true);
            event.gesture = eventData;

            // trigger on the target if it is in the instance element,
            // this is for event delegation tricks
            var element = this.element;
            if (Utils.hasParent(eventData.target, element)) {
                element = eventData.target;
            }

            element.dispatchEvent(event);
            return this;
        },

        /**
         * enable of disable hammer.js detection
         * @method enable
         * @chainable
         * @param {Boolean} state
         */
        enable: function enable(state) {
            this.enabled = state;
            return this;
        },

        /**
         * dispose this hammer instance
         * @method dispose
         * @return {Null}
         */
        dispose: function dispose() {
            var i, eh;

            // undo all changes made by stop_browser_behavior
            Utils.toggleBehavior(this.element, this.options.behavior, false);

            // unbind all custom event handlers
            for (i = -1;
                (eh = this.eventHandlers[++i]);) {
                Utils.off(this.element, eh.gesture, eh.handler);
            }

            this.eventHandlers = [];

            // unbind the start event listener
            Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

            return null;
        }
    };


    /**
     * @module gestures
     */
    /**
     * Move with x fingers (default 1) around on the page.
     * Preventing the default browser behavior is a good way to improve feel and working.
     * ````
     *  hammertime.on("drag", function(ev) {
     *    console.log(ev);
     *    ev.gesture.preventDefault();
     *  });
     * ````
     *
     * @class Drag
     * @static
     */
    /**
     * @event drag
     * @param {Object} ev
     */
    /**
     * @event dragstart
     * @param {Object} ev
     */
    /**
     * @event dragend
     * @param {Object} ev
     */
    /**
     * @event drapleft
     * @param {Object} ev
     */
    /**
     * @event dragright
     * @param {Object} ev
     */
    /**
     * @event dragup
     * @param {Object} ev
     */
    /**
     * @event dragdown
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function(name) {
        var triggered = false;

        function dragGesture(ev, inst) {
            var cur = Detection.current;

            // max touches
            if (inst.options.dragMaxTouches > 0 &&
                ev.touches.length > inst.options.dragMaxTouches) {
                return;
            }

            switch (ev.eventType) {
                case EVENT_START:
                    triggered = false;
                    break;

                case EVENT_MOVE:
                    // when the distance we moved is too small we skip this gesture
                    // or we can be already in dragging
                    if (ev.distance < inst.options.dragMinDistance &&
                        cur.name != name) {
                        return;
                    }

                    var startCenter = cur.startEvent.center;

                    // we are dragging!
                    if (cur.name != name) {
                        cur.name = name;
                        if (inst.options.dragDistanceCorrection && ev.distance > 0) {
                            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
                            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
                            // It might be useful to save the original start point somewhere
                            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
                            startCenter.pageX += ev.deltaX * factor;
                            startCenter.pageY += ev.deltaY * factor;
                            startCenter.clientX += ev.deltaX * factor;
                            startCenter.clientY += ev.deltaY * factor;

                            // recalculate event data using new start point
                            ev = Detection.extendEventData(ev);
                        }
                    }

                    // lock drag to axis?
                    if (cur.lastEvent.dragLockToAxis ||
                        (inst.options.dragLockToAxis &&
                            inst.options.dragLockMinDistance <= ev.distance
                        )) {
                        ev.dragLockToAxis = true;
                    }

                    // keep direction on the axis that the drag gesture started on
                    var lastDirection = cur.lastEvent.direction;
                    if (ev.dragLockToAxis && lastDirection !== ev.direction) {
                        if (Utils.isVertical(lastDirection)) {
                            ev.direction = (ev.deltaY < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                        } else {
                            ev.direction = (ev.deltaX < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                        }
                    }

                    // first time, trigger dragstart event
                    if (!triggered) {
                        inst.trigger(name + 'start', ev);
                        triggered = true;
                    }

                    // trigger events
                    inst.trigger(name, ev);
                    inst.trigger(name + ev.direction, ev);

                    var isVertical = Utils.isVertical(ev.direction);

                    // block the browser events
                    if ((inst.options.dragBlockVertical && isVertical) ||
                        (inst.options.dragBlockHorizontal && !isVertical)) {
                        ev.preventDefault();
                    }
                    break;

                case EVENT_RELEASE:
                    if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
                        inst.trigger(name + 'end', ev);
                        triggered = false;
                    }
                    break;

                case EVENT_END:
                    triggered = false;
                    break;
            }
        }

        Hammer.gestures.Drag = {
            name: name,
            index: 50,
            handler: dragGesture,
            defaults: {
                /**
                 * minimal movement that have to be made before the drag event gets triggered
                 * @property dragMinDistance
                 * @type {Number}
                 * @default 10
                 */
                dragMinDistance: 10,

                /**
                 * Set dragDistanceCorrection to true to make the starting point of the drag
                 * be calculated from where the drag was triggered, not from where the touch started.
                 * Useful to avoid a jerk-starting drag, which can make fine-adjustments
                 * through dragging difficult, and be visually unappealing.
                 * @property dragDistanceCorrection
                 * @type {Boolean}
                 * @default true
                 */
                dragDistanceCorrection: true,

                /**
                 * set 0 for unlimited, but this can conflict with transform
                 * @property dragMaxTouches
                 * @type {Number}
                 * @default 1
                 */
                dragMaxTouches: 1,

                /**
                 * prevent default browser behavior when dragging occurs
                 * be careful with it, it makes the element a blocking element
                 * when you are using the drag gesture, it is a good practice to set this true
                 * @property dragBlockHorizontal
                 * @type {Boolean}
                 * @default false
                 */
                dragBlockHorizontal: false,

                /**
                 * same as `dragBlockHorizontal`, but for vertical movement
                 * @property dragBlockVertical
                 * @type {Boolean}
                 * @default false
                 */
                dragBlockVertical: false,

                /**
                 * dragLockToAxis keeps the drag gesture on the axis that it started on,
                 * It disallows vertical directions if the initial direction was horizontal, and vice versa.
                 * @property dragLockToAxis
                 * @type {Boolean}
                 * @default false
                 */
                dragLockToAxis: false,

                /**
                 * drag lock only kicks in when distance > dragLockMinDistance
                 * This way, locking occurs only when the distance has become large enough to reliably determine the direction
                 * @property dragLockMinDistance
                 * @type {Number}
                 * @default 25
                 */
                dragLockMinDistance: 25
            }
        };
    })('drag');

    /**
     * @module gestures
     */
    /**
     * trigger a simple gesture event, so you can do anything in your handler.
     * only usable if you know what your doing...
     *
     * @class Gesture
     * @static
     */
    /**
     * @event gesture
     * @param {Object} ev
     */
    Hammer.gestures.Gesture = {
        name: 'gesture',
        index: 1337,
        handler: function releaseGesture(ev, inst) {
            inst.trigger(this.name, ev);
        }
    };

    /**
     * @module gestures
     */
    /**
     * Touch stays at the same place for x time
     *
     * @class Hold
     * @static
     */
    /**
     * @event hold
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function(name) {
        var timer;

        function holdGesture(ev, inst) {
            var options = inst.options,
                current = Detection.current;

            switch (ev.eventType) {
                case EVENT_START:
                    clearTimeout(timer);

                    // set the gesture so we can check in the timeout if it still is
                    current.name = name;

                    // set timer and if after the timeout it still is hold,
                    // we trigger the hold event
                    timer = setTimeout(function() {
                        if (current && current.name == name) {
                            inst.trigger(name, ev);
                        }
                    }, options.holdTimeout);
                    break;

                case EVENT_MOVE:
                    if (ev.distance > options.holdThreshold) {
                        clearTimeout(timer);
                    }
                    break;

                case EVENT_RELEASE:
                    clearTimeout(timer);
                    break;
            }
        }

        Hammer.gestures.Hold = {
            name: name,
            index: 10,
            defaults: {
                /**
                 * @property holdTimeout
                 * @type {Number}
                 * @default 500
                 */
                holdTimeout: 500,

                /**
                 * movement allowed while holding
                 * @property holdThreshold
                 * @type {Number}
                 * @default 2
                 */
                holdThreshold: 2
            },
            handler: holdGesture
        };
    })('hold');

    /**
     * @module gestures
     */
    /**
     * when a touch is being released from the page
     *
     * @class Release
     * @static
     */
    /**
     * @event release
     * @param {Object} ev
     */
    Hammer.gestures.Release = {
        name: 'release',
        index: Infinity,
        handler: function releaseGesture(ev, inst) {
            if (ev.eventType == EVENT_RELEASE) {
                inst.trigger(this.name, ev);
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * triggers swipe events when the end velocity is above the threshold
     * for best usage, set `preventDefault` (on the drag gesture) to `true`
     * ````
     *  hammertime.on("dragleft swipeleft", function(ev) {
     *    console.log(ev);
     *    ev.gesture.preventDefault();
     *  });
     * ````
     *
     * @class Swipe
     * @static
     */
    /**
     * @event swipe
     * @param {Object} ev
     */
    /**
     * @event swipeleft
     * @param {Object} ev
     */
    /**
     * @event swiperight
     * @param {Object} ev
     */
    /**
     * @event swipeup
     * @param {Object} ev
     */
    /**
     * @event swipedown
     * @param {Object} ev
     */
    Hammer.gestures.Swipe = {
        name: 'swipe',
        index: 40,
        defaults: {
            /**
             * @property swipeMinTouches
             * @type {Number}
             * @default 1
             */
            swipeMinTouches: 1,

            /**
             * @property swipeMaxTouches
             * @type {Number}
             * @default 1
             */
            swipeMaxTouches: 1,

            /**
             * horizontal swipe velocity
             * @property swipeVelocityX
             * @type {Number}
             * @default 0.6
             */
            swipeVelocityX: 0.6,

            /**
             * vertical swipe velocity
             * @property swipeVelocityY
             * @type {Number}
             * @default 0.6
             */
            swipeVelocityY: 0.6
        },

        handler: function swipeGesture(ev, inst) {
            if (ev.eventType == EVENT_RELEASE) {
                var touches = ev.touches.length,
                    options = inst.options;

                // max touches
                if (touches < options.swipeMinTouches ||
                    touches > options.swipeMaxTouches) {
                    return;
                }

                // when the distance we moved is too small we skip this gesture
                // or we can be already in dragging
                if (ev.velocityX > options.swipeVelocityX ||
                    ev.velocityY > options.swipeVelocityY) {
                    // trigger swipe events
                    inst.trigger(this.name, ev);
                    inst.trigger(this.name + ev.direction, ev);
                }
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * Single tap and a double tap on a place
     *
     * @class Tap
     * @static
     */
    /**
     * @event tap
     * @param {Object} ev
     */
    /**
     * @event doubletap
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function(name) {
        var hasMoved = false;

        function tapGesture(ev, inst) {
            var options = inst.options,
                current = Detection.current,
                prev = Detection.previous,
                sincePrev,
                didDoubleTap;

            switch (ev.eventType) {
                case EVENT_START:
                    hasMoved = false;
                    break;

                case EVENT_MOVE:
                    hasMoved = hasMoved || (ev.distance > options.tapMaxDistance);
                    break;

                case EVENT_END:
                    if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
                        // previous gesture, for the double tap since these are two different gesture detections
                        sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
                        didDoubleTap = false;

                        // check if double tap
                        if (prev && prev.name == name &&
                            (sincePrev && sincePrev < options.doubleTapInterval) &&
                            ev.distance < options.doubleTapDistance) {
                            inst.trigger('doubletap', ev);
                            didDoubleTap = true;
                        }

                        // do a single tap
                        if (!didDoubleTap || options.tapAlways) {
                            current.name = name;
                            inst.trigger(current.name, ev);
                        }
                    }
                    break;
            }
        }

        Hammer.gestures.Tap = {
            name: name,
            index: 100,
            handler: tapGesture,
            defaults: {
                /**
                 * max time of a tap, this is for the slow tappers
                 * @property tapMaxTime
                 * @type {Number}
                 * @default 250
                 */
                tapMaxTime: 250,

                /**
                 * max distance of movement of a tap, this is for the slow tappers
                 * @property tapMaxDistance
                 * @type {Number}
                 * @default 10
                 */
                tapMaxDistance: 10,

                /**
                 * always trigger the `tap` event, even while double-tapping
                 * @property tapAlways
                 * @type {Boolean}
                 * @default true
                 */
                tapAlways: true,

                /**
                 * max distance between two taps
                 * @property doubleTapDistance
                 * @type {Number}
                 * @default 20
                 */
                doubleTapDistance: 20,

                /**
                 * max time between two taps
                 * @property doubleTapInterval
                 * @type {Number}
                 * @default 300
                 */
                doubleTapInterval: 300
            }
        };
    })('tap');

    /**
     * @module gestures
     */
    /**
     * when a touch is being touched at the page
     *
     * @class Touch
     * @static
     */
    /**
     * @event touch
     * @param {Object} ev
     */
    Hammer.gestures.Touch = {
        name: 'touch',
        index: -Infinity,
        defaults: {
            /**
             * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
             * but it improves gestures like transforming and dragging.
             * be careful with using this, it can be very annoying for users to be stuck on the page
             * @property preventDefault
             * @type {Boolean}
             * @default false
             */
            preventDefault: false,

            /**
             * disable mouse events, so only touch (or pen!) input triggers events
             * @property preventMouse
             * @type {Boolean}
             * @default false
             */
            preventMouse: false
        },
        handler: function touchGesture(ev, inst) {
            if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
                ev.stopDetect();
                return;
            }

            if (inst.options.preventDefault) {
                ev.preventDefault();
            }

            if (ev.eventType == EVENT_TOUCH) {
                inst.trigger('touch', ev);
            }
        }
    };

    /**
     * @module gestures
     */
    /**
     * User want to scale or rotate with 2 fingers
     * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
     * `preventDefault` option.
     *
     * @class Transform
     * @static
     */
    /**
     * @event transform
     * @param {Object} ev
     */
    /**
     * @event transformstart
     * @param {Object} ev
     */
    /**
     * @event transformend
     * @param {Object} ev
     */
    /**
     * @event pinchin
     * @param {Object} ev
     */
    /**
     * @event pinchout
     * @param {Object} ev
     */
    /**
     * @event rotate
     * @param {Object} ev
     */

    /**
     * @param {String} name
     */
    (function(name) {
        var triggered = false;

        function transformGesture(ev, inst) {
            switch (ev.eventType) {
                case EVENT_START:
                    triggered = false;
                    break;

                case EVENT_MOVE:
                    // at least multitouch
                    if (ev.touches.length < 2) {
                        return;
                    }

                    var scaleThreshold = Math.abs(1 - ev.scale);
                    var rotationThreshold = Math.abs(ev.rotation);

                    // when the distance we moved is too small we skip this gesture
                    // or we can be already in dragging
                    if (scaleThreshold < inst.options.transformMinScale &&
                        rotationThreshold < inst.options.transformMinRotation) {
                        return;
                    }

                    // we are transforming!
                    Detection.current.name = name;

                    // first time, trigger dragstart event
                    if (!triggered) {
                        inst.trigger(name + 'start', ev);
                        triggered = true;
                    }

                    inst.trigger(name, ev); // basic transform event

                    // trigger rotate event
                    if (rotationThreshold > inst.options.transformMinRotation) {
                        inst.trigger('rotate', ev);
                    }

                    // trigger pinch event
                    if (scaleThreshold > inst.options.transformMinScale) {
                        inst.trigger('pinch', ev);
                        inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
                    }
                    break;

                case EVENT_RELEASE:
                    if (triggered && ev.changedLength < 2) {
                        inst.trigger(name + 'end', ev);
                        triggered = false;
                    }
                    break;
            }
        }

        Hammer.gestures.Transform = {
            name: name,
            index: 45,
            defaults: {
                /**
                 * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
                 * @property transformMinScale
                 * @type {Number}
                 * @default 0.01
                 */
                transformMinScale: 0.01,

                /**
                 * rotation in degrees
                 * @property transformMinRotation
                 * @type {Number}
                 * @default 1
                 */
                transformMinRotation: 1
            },

            handler: transformGesture
        };
    })('transform');

    /**
     * @module hammer
     */

    // AMD export
    if (typeof define == 'function' && define.amd) {
        define(function() {
            return Hammer;
        });
        // commonjs export
    } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = Hammer;
        // browser export
    } else {
        window.Hammer = Hammer;
    }

})(window);
/*global define:false */
/**
 * Copyright 2013 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.4.6
 * @url craig.is/killing/mice
 */
(function(window, document, undefined) {

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
            8: 'backspace',
            9: 'tab',
            13: 'enter',
            16: 'shift',
            17: 'ctrl',
            18: 'alt',
            20: 'capslock',
            27: 'esc',
            32: 'space',
            33: 'pageup',
            34: 'pagedown',
            35: 'end',
            36: 'home',
            37: 'left',
            38: 'up',
            39: 'right',
            40: 'down',
            45: 'ins',
            46: 'del',
            91: 'meta',
            93: 'meta',
            224: 'meta'
        },

        /**
         * mapping for special characters so they can support
         *
         * this dictionary is only used incase you want to bind a
         * keyup or keydown event to one of these keys
         *
         * @type {Object}
         */
        _KEYCODE_MAP = {
            106: '*',
            107: '+',
            109: '-',
            110: '.',
            111: '/',
            186: ';',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: '\''
        },

        /**
         * this is a mapping of keys that require shift on a US keypad
         * back to the non shift equivelents
         *
         * this is so you can use keyup events with these keys
         *
         * note that this will only work reliably on US keyboards
         *
         * @type {Object}
         */
        _SHIFT_MAP = {
            '~': '`',
            '!': '1',
            '@': '2',
            '#': '3',
            '$': '4',
            '%': '5',
            '^': '6',
            '&': '7',
            '*': '8',
            '(': '9',
            ')': '0',
            '_': '-',
            '+': '=',
            ':': ';',
            '\"': '\'',
            '<': ',',
            '>': '.',
            '?': '/',
            '|': '\\'
        },

        /**
         * this is a list of special strings you can use to map
         * to modifier keys when you specify your keyboard shortcuts
         *
         * @type {Object}
         */
        _SPECIAL_ALIASES = {
            'option': 'alt',
            'command': 'meta',
            'return': 'enter',
            'escape': 'esc',
            'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
        },

        /**
         * variable to store the flipped version of _MAP from above
         * needed to check if we should use keypress or not when no action
         * is specified
         *
         * @type {Object|undefined}
         */
        _REVERSE_MAP,

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        _callbacks = {},

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        _directMap = {},

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        _sequenceLevels = {},

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        _resetTimer,

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        _ignoreNextKeyup = false,

        /**
         * temporary state where we will ignore the next keypress
         *
         * @type {boolean}
         */
        _ignoreNextKeypress = false,

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        _nextExpectedAction = false;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {
        _MAP[i + 96] = i;
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);

            // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }

            return character;
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map

        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * resets all sequence counters except for the ones passed in
     *
     * @param {Object} doNotReset
     * @returns void
     */
    function _resetSequences(doNotReset) {
        doNotReset = doNotReset || {};

        var activeSequences = false,
            key;

        for (key in _sequenceLevels) {
            if (doNotReset[key]) {
                activeSequences = true;
                continue;
            }
            _sequenceLevels[key] = 0;
        }

        if (!activeSequences) {
            _nextExpectedAction = false;
        }
    }

    /**
     * finds all callbacks that match based on the keycode, modifiers,
     * and action
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event|Object} e
     * @param {string=} sequenceName - name of the sequence we are looking for
     * @param {string=} combination
     * @param {number=} level
     * @returns {Array}
     */
    function _getMatches(character, modifiers, e, sequenceName, combination, level) {
        var i,
            callback,
            matches = [],
            action = e.type;

        // if there are no events related to this keycode
        if (!_callbacks[character]) {
            return [];
        }

        // if a modifier key is coming up on its own we should allow it
        if (action == 'keyup' && _isModifier(character)) {
            modifiers = [character];
        }

        // loop through all callbacks for the key that was pressed
        // and see if any of them match
        for (i = 0; i < _callbacks[character].length; ++i) {
            callback = _callbacks[character][i];

            // if a sequence name is not specified, but this is a sequence at
            // the wrong level then move onto the next match
            if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                continue;
            }

            // if the action we are looking for doesn't match the action we got
            // then we should keep going
            if (action != callback.action) {
                continue;
            }

            // if this is a keypress event and the meta key and control key
            // are not pressed that means that we need to only look at the
            // character, otherwise check the modifiers as well
            //
            // chrome will not fire a keypress if meta or control is down
            // safari will fire a keypress if meta or meta+shift is down
            // firefox will fire a keypress if meta or control is down
            if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                // when you bind a combination or sequence a second time it
                // should overwrite the first one.  if a sequenceName or
                // combination is specified in this call it does just that
                //
                // @todo make deleting its own method?
                var deleteCombo = !sequenceName && callback.combo == combination;
                var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                if (deleteCombo || deleteSequence) {
                    _callbacks[character].splice(i, 1);
                }

                matches.push(callback);
            }
        }

        return matches;
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * prevents default for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }

        e.returnValue = false;
    }

    /**
     * stops propogation for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }

        e.cancelBubble = true;
    }

    /**
     * actually calls the callback function
     *
     * if your callback function returns false this will use the jquery
     * convention - prevent default and stop propogation on the event
     *
     * @param {Function} callback
     * @param {Event} e
     * @returns void
     */
    function _fireCallback(callback, e, combo, sequence) {

        // if this event should not happen stop here
        if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
            return;
        }

        if (callback(e, combo) === false) {
            _preventDefault(e);
            _stopPropagation(e);
        }
    }

    /**
     * handles a character key event
     *
     * @param {string} character
     * @param {Array} modifiers
     * @param {Event} e
     * @returns void
     */
    function _handleKey(character, modifiers, e) {
        var callbacks = _getMatches(character, modifiers, e),
            i,
            doNotReset = {},
            maxLevel = 0,
            processedSequenceCallback = false;

        // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
        for (i = 0; i < callbacks.length; ++i) {
            if (callbacks[i].seq) {
                maxLevel = Math.max(maxLevel, callbacks[i].level);
            }
        }

        // loop through matching callbacks for this key event
        for (i = 0; i < callbacks.length; ++i) {

            // fire for all sequence callbacks
            // this is because if for example you have multiple sequences
            // bound such as "g i" and "g t" they both need to fire the
            // callback for matching g cause otherwise you can only ever
            // match the first one
            if (callbacks[i].seq) {

                // only fire callbacks for the maxLevel to prevent
                // subsequences from also firing
                //
                // for example 'a option b' should not cause 'option b' to fire
                // even though 'option b' is part of the other sequence
                //
                // any sequences that do not match here will be discarded
                // below by the _resetSequences call
                if (callbacks[i].level != maxLevel) {
                    continue;
                }

                processedSequenceCallback = true;

                // keep a list of which sequences were matches for later
                doNotReset[callbacks[i].seq] = 1;
                _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                continue;
            }

            // if there were no sequence matches but we are still here
            // that means this is a regular match so we should fire that
            if (!processedSequenceCallback) {
                _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
            }
        }

        // if the key you pressed matches the type of sequence without
        // being a modifier (ie "keyup" or "keypress") then we should
        // reset all sequences that were not matched by this event
        //
        // this is so, for example, if you have the sequence "h a t" and you
        // type "h e a r t" it does not match.  in this case the "e" will
        // cause the sequence to reset
        //
        // modifier keys are ignored because you can have a sequence
        // that contains modifiers such as "enter ctrl+space" and in most
        // cases the modifier key will be pressed before the next key
        //
        // also if you have a sequence such as "ctrl+b a" then pressing the
        // "b" key will trigger a "keypress" and a "keydown"
        //
        // the "keydown" is expected when there is a modifier, but the
        // "keypress" ends up matching the _nextExpectedAction since it occurs
        // after and that causes the sequence to reset
        //
        // we ignore keypresses in a sequence that directly follow a keydown
        // for the same character
        var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
        if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
            _resetSequences(doNotReset);
        }

        _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
    }

    /**
     * handles a keydown event
     *
     * @param {Event} e
     * @returns void
     */
    function _handleKeyEvent(e) {

        // normalize e.which for key events
        // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
        if (typeof e.which !== 'number') {
            e.which = e.keyCode;
        }

        var character = _characterFromEvent(e);

        // no character found then stop
        if (!character) {
            return;
        }

        // need to use === for the character check because the character can be 0
        if (e.type == 'keyup' && _ignoreNextKeyup === character) {
            _ignoreNextKeyup = false;
            return;
        }

        Mousetrap.handleKey(character, _eventModifiers(e), e);
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * called to set a 1 second timeout on the specified sequence
     *
     * this is so after each key press in the sequence you have 1 second
     * to press the next key before you have to start over
     *
     * @returns void
     */
    function _resetSequenceTimer() {
        clearTimeout(_resetTimer);
        _resetTimer = setTimeout(_resetSequences, 1000);
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * binds a key sequence to an event
     *
     * @param {string} combo - combo specified in bind call
     * @param {Array} keys
     * @param {Function} callback
     * @param {string=} action
     * @returns void
     */
    function _bindSequence(combo, keys, callback, action) {

        // start off by adding a sequence level record for this combination
        // and setting the level to 0
        _sequenceLevels[combo] = 0;

        /**
         * callback to increase the sequence level for this sequence and reset
         * all other sequences that were active
         *
         * @param {string} nextAction
         * @returns {Function}
         */
        function _increaseSequence(nextAction) {
            return function() {
                _nextExpectedAction = nextAction;
                ++_sequenceLevels[combo];
                _resetSequenceTimer();
            };
        }

        /**
         * wraps the specified callback inside of another function in order
         * to reset all sequence counters as soon as this sequence is done
         *
         * @param {Event} e
         * @returns void
         */
        function _callbackAndReset(e) {
            _fireCallback(callback, e, combo);

            // we should ignore the next key up if the action is key down
            // or keypress.  this is so if you finish a sequence and
            // release the key the final key will not trigger a keyup
            if (action !== 'keyup') {
                _ignoreNextKeyup = _characterFromEvent(e);
            }

            // weird race condition if a sequence ends with the key
            // another sequence begins with
            setTimeout(_resetSequences, 10);
        }

        // loop through keys one at a time and bind the appropriate callback
        // function.  for any key leading up to the final one it should
        // increase the sequence. after the final, it should reset all sequences
        //
        // if an action is specified in the original bind call then that will
        // be used throughout.  otherwise we will pass the action that the
        // next key in the sequence should match.  this allows a sequence
        // to mix and match keypress and keydown events depending on which
        // ones are better suited to the key provided
        for (var i = 0; i < keys.length; ++i) {
            var isFinal = i + 1 === keys.length;
            var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
            _bindSingle(keys[i], wrappedCallback, action, combo, i);
        }
    }

    /**
     * Converts from a string key combination to an array
     *
     * @param  {string} combination like "command+shift+l"
     * @return {Array}
     */
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }

        return combination.split('+');
    }

    /**
     * Gets info for a specific key combination
     *
     * @param  {string} combination key combination ("command+s" or "a" or "*")
     * @param  {string=} action
     * @returns {Object}
     */
    function _getKeyInfo(combination, action) {
        var keys,
            key,
            i,
            modifiers = [];

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = _keysFromString(combination);

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }

    /**
     * binds a single keyboard combination
     *
     * @param {string} combination
     * @param {Function} callback
     * @param {string=} action
     * @param {string=} sequenceName - name of sequence if part of sequence
     * @param {number=} level - what part of the sequence the command is
     * @returns void
     */
    function _bindSingle(combination, callback, action, sequenceName, level) {

        // store a direct mapped reference for use with Mousetrap.trigger
        _directMap[combination + ':' + action] = callback;

        // make sure multiple spaces in a row become a single space
        combination = combination.replace(/\s+/g, ' ');

        var sequence = combination.split(' '),
            info;

        // if this pattern is a sequence of keys then run through this method
        // to reprocess each pattern one key at a time
        if (sequence.length > 1) {
            _bindSequence(combination, sequence, callback, action);
            return;
        }

        info = _getKeyInfo(combination, action);

        // make sure to initialize array if this is the first time
        // a callback is added for this key
        _callbacks[info.key] = _callbacks[info.key] || [];

        // remove an existing match if there is one
        _getMatches(info.key, info.modifiers, {
            type: info.action
        }, sequenceName, combination, level);

        // add this call back to the array
        // if it is a sequence put it at the beginning
        // if not put it at the end
        //
        // this is important because the way these are processed expects
        // the sequence ones to come first
        _callbacks[info.key][sequenceName ? 'unshift' : 'push']({
            callback: callback,
            modifiers: info.modifiers,
            action: info.action,
            seq: sequenceName,
            level: level,
            combo: combination
        });
    }

    /**
     * binds multiple combinations to the same callback
     *
     * @param {Array} combinations
     * @param {Function} callback
     * @param {string|undefined} action
     * @returns void
     */
    function _bindMultiple(combinations, callback, action) {
        for (var i = 0; i < combinations.length; ++i) {
            _bindSingle(combinations[i], callback, action);
        }
    }

    // start!
    _addEvent(document, 'keypress', _handleKeyEvent);
    _addEvent(document, 'keydown', _handleKeyEvent);
    _addEvent(document, 'keyup', _handleKeyEvent);

    var Mousetrap = {

        /**
         * binds an event to mousetrap
         *
         * can be a single key, a combination of keys separated with +,
         * an array of keys, or a sequence of keys separated by spaces
         *
         * be sure to list the modifier keys first to make sure that the
         * correct key ends up getting bound (the last key in the pattern)
         *
         * @param {string|Array} keys
         * @param {Function} callback
         * @param {string=} action - 'keypress', 'keydown', or 'keyup'
         * @returns void
         */
        bind: function(keys, callback, action) {
            keys = keys instanceof Array ? keys : [keys];
            _bindMultiple(keys, callback, action);
            return this;
        },

        /**
         * unbinds an event to mousetrap
         *
         * the unbinding sets the callback function of the specified key combo
         * to an empty function and deletes the corresponding key in the
         * _directMap dict.
         *
         * TODO: actually remove this from the _callbacks dictionary instead
         * of binding an empty function
         *
         * the keycombo+action has to be exactly the same as
         * it was defined in the bind method
         *
         * @param {string|Array} keys
         * @param {string} action
         * @returns void
         */
        unbind: function(keys, action) {
            return Mousetrap.bind(keys, function() {}, action);
        },

        /**
         * triggers an event that has already been bound
         *
         * @param {string} keys
         * @param {string=} action
         * @returns void
         */
        trigger: function(keys, action) {
            if (_directMap[keys + ':' + action]) {
                _directMap[keys + ':' + action]({}, keys);
            }
            return this;
        },

        /**
         * resets the library back to its initial state.  this is useful
         * if you want to clear out the current keyboard shortcuts and bind
         * new ones - for example if you switch to another page
         *
         * @returns void
         */
        reset: function() {
            _callbacks = {};
            _directMap = {};
            return this;
        },

        /**
         * should we stop this event before firing off callbacks
         *
         * @param {Event} e
         * @param {Element} element
         * @return {boolean}
         */
        stopCallback: function(e, element) {

            // if the element has the class "mousetrap" then no need to stop
            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                return false;
            }

            // stop for input, select, and textarea
            return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
        },

        /**
         * exposes _handleKey publicly so it can be overwritten by extensions
         */
        handleKey: _handleKey
    };

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose mousetrap as an AMD module
    if (typeof define === 'function' && define.amd) {
        define(Mousetrap);
    }
})(window, document);

/*! jQuery plugin for Hammer.JS - v1.1.3 - 2014-05-20
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */
(function(window, undefined) {
    'use strict';

    function setupPlugin(Hammer, $) {
        // provide polyfill for Date.now()
        // browser support: http://kangax.github.io/es5-compat-table/#Date.now
        if (!Date.now) {
            Date.now = function now() {
                return new Date().getTime();
            };
        }

        /**
         * the methods on/off are called by the instance, but with the jquery plugin
         * we use the jquery event methods instead.
         * @this    {Hammer.Instance}
         * @return  {jQuery}
         */
        Hammer.utils.each(['on', 'off'], function(method) {
            Hammer.utils[method] = function(element, type, handler) {
                $(element)[method](type, function($ev) {
                    // append the jquery fixed properties/methods
                    var data = $.extend({}, $ev.originalEvent, $ev);
                    if (data.button === undefined) {
                        data.button = $ev.which - 1;
                    }
                    handler.call(this, data);
                });
            };
        });

        /**
         * trigger events
         * this is called by the gestures to trigger an event like 'tap'
         * @this    {Hammer.Instance}
         * @param   {String}    gesture
         * @param   {Object}    eventData
         * @return  {jQuery}
         */
        Hammer.Instance.prototype.trigger = function(gesture, eventData) {
            var el = $(this.element);
            if (el.has(eventData.target).length) {
                el = $(eventData.target);
            }

            return el.trigger({
                type: gesture,
                gesture: eventData
            });
        };

        /**
         * jQuery plugin
         * create instance of Hammer and watch for gestures,
         * and when called again you can change the options
         * @param   {Object}    [options={}]
         * @return  {jQuery}
         */
        $.fn.hammer = function(options) {
            return this.each(function() {
                var el = $(this);
                var inst = el.data('hammer');

                // start new hammer instance
                if (!inst) {
                    el.data('hammer', new Hammer(this, options || {}));
                    // change the options
                } else if (inst && options) {
                    Hammer.utils.extend(inst.options, options);
                }
            });
        };
    }


    // AMD
    if (typeof define == 'function' && define.amd) {
        define(['hammerjs', 'jquery'], setupPlugin);
    } else {
        setupPlugin(window.Hammer, window.jQuery || window.Zepto);
    }

})(window);
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype,
        ObjProto = Object.prototype,
        FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var
        push = ArrayProto.push,
        slice = ArrayProto.slice,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
        nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeBind = FuncProto.bind,
        nativeCreate = Object.create;

    // Naked function reference for surrogate-prototype-swapping.
    var Ctor = function() {};

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object.
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = _;
        }
        exports._ = _;
    } else {
        root._ = _;
    }

    // Current version.
    _.VERSION = '1.8.3';

    // Internal function that returns an efficient (for current engines) version
    // of the passed-in callback, to be repeatedly applied in other Underscore
    // functions.
    var optimizeCb = function(func, context, argCount) {
        if (context === void 0) return func;
        switch (argCount == null ? 3 : argCount) {
            case 1:
                return function(value) {
                    return func.call(context, value);
                };
            case 2:
                return function(value, other) {
                    return func.call(context, value, other);
                };
            case 3:
                return function(value, index, collection) {
                    return func.call(context, value, index, collection);
                };
            case 4:
                return function(accumulator, value, index, collection) {
                    return func.call(context, accumulator, value, index, collection);
                };
        }
        return function() {
            return func.apply(context, arguments);
        };
    };

    // A mostly-internal function to generate callbacks that can be applied
    // to each element in a collection, returning the desired result — either
    // identity, an arbitrary callback, a property matcher, or a property accessor.
    var cb = function(value, context, argCount) {
        if (value == null) return _.identity;
        if (_.isFunction(value)) return optimizeCb(value, context, argCount);
        if (_.isObject(value)) return _.matcher(value);
        return _.property(value);
    };
    _.iteratee = function(value, context) {
        return cb(value, context, Infinity);
    };

    // An internal function for creating assigner functions.
    var createAssigner = function(keysFunc, undefinedOnly) {
        return function(obj) {
            var length = arguments.length;
            if (length < 2 || obj == null) return obj;
            for (var index = 1; index < length; index++) {
                var source = arguments[index],
                    keys = keysFunc(source),
                    l = keys.length;
                for (var i = 0; i < l; i++) {
                    var key = keys[i];
                    if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
                }
            }
            return obj;
        };
    };

    // An internal function for creating a new object that inherits from another.
    var baseCreate = function(prototype) {
        if (!_.isObject(prototype)) return {};
        if (nativeCreate) return nativeCreate(prototype);
        Ctor.prototype = prototype;
        var result = new Ctor;
        Ctor.prototype = null;
        return result;
    };

    var property = function(key) {
        return function(obj) {
            return obj == null ? void 0 : obj[key];
        };
    };

    // Helper for collection methods to determine whether a collection
    // should be iterated as an array or as an object
    // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var getLength = property('length');
    var isArrayLike = function(collection) {
        var length = getLength(collection);
        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    };

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles raw objects in addition to array-likes. Treats all
    // sparse array-likes as if they were dense.
    _.each = _.forEach = function(obj, iteratee, context) {
        iteratee = optimizeCb(iteratee, context);
        var i, length;
        if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; i++) {
                iteratee(obj[i], i, obj);
            }
        } else {
            var keys = _.keys(obj);
            for (i = 0, length = keys.length; i < length; i++) {
                iteratee(obj[keys[i]], keys[i], obj);
            }
        }
        return obj;
    };

    // Return the results of applying the iteratee to each element.
    _.map = _.collect = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            results = Array(length);
        for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            results[index] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
    };

    // Create a reducing function iterating left or right.
    function createReduce(dir) {
        // Optimized iterator function as using arguments.length
        // in the main function will deoptimize the, see #1991.
        function iterator(obj, iteratee, memo, keys, index, length) {
            for (; index >= 0 && index < length; index += dir) {
                var currentKey = keys ? keys[index] : index;
                memo = iteratee(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
        }

        return function(obj, iteratee, memo, context) {
            iteratee = optimizeCb(iteratee, context, 4);
            var keys = !isArrayLike(obj) && _.keys(obj),
                length = (keys || obj).length,
                index = dir > 0 ? 0 : length - 1;
            // Determine the initial value if none is provided.
            if (arguments.length < 3) {
                memo = obj[keys ? keys[index] : index];
                index += dir;
            }
            return iterator(obj, iteratee, memo, keys, index, length);
        };
    }

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`.
    _.reduce = _.foldl = _.inject = createReduce(1);

    // The right-associative version of reduce, also known as `foldr`.
    _.reduceRight = _.foldr = createReduce(-1);

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, predicate, context) {
        var key;
        if (isArrayLike(obj)) {
            key = _.findIndex(obj, predicate, context);
        } else {
            key = _.findKey(obj, predicate, context);
        }
        if (key !== void 0 && key !== -1) return obj[key];
    };

    // Return all the elements that pass a truth test.
    // Aliased as `select`.
    _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        predicate = cb(predicate, context);
        _.each(obj, function(value, index, list) {
            if (predicate(value, index, list)) results.push(value);
        });
        return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(cb(predicate)), context);
    };

    // Determine whether all of the elements match a truth test.
    // Aliased as `all`.
    _.every = _.all = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj)) return false;
        }
        return true;
    };

    // Determine if at least one element in the object matches a truth test.
    // Aliased as `any`.
    _.some = _.any = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length;
        for (var index = 0; index < length; index++) {
            var currentKey = keys ? keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj)) return true;
        }
        return false;
    };

    // Determine if the array or object contains a given item (using `===`).
    // Aliased as `includes` and `include`.
    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        if (typeof fromIndex != 'number' || guard) fromIndex = 0;
        return _.indexOf(obj, item, fromIndex) >= 0;
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
            var func = isFunc ? method : value[method];
            return func == null ? func : func.apply(value, args);
        });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs) {
        return _.filter(obj, _.matcher(attrs));
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matcher(attrs));
    };

    // Return the maximum element (or element-based computation).
    _.max = function(obj, iteratee, context) {
        var result = -Infinity,
            lastComputed = -Infinity,
            value, computed;
        if (iteratee == null && obj != null) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
                value = obj[i];
                if (value > result) {
                    result = value;
                }
            }
        } else {
            iteratee = cb(iteratee, context);
            _.each(obj, function(value, index, list) {
                computed = iteratee(value, index, list);
                if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                    result = value;
                    lastComputed = computed;
                }
            });
        }
        return result;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iteratee, context) {
        var result = Infinity,
            lastComputed = Infinity,
            value, computed;
        if (iteratee == null && obj != null) {
            obj = isArrayLike(obj) ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
                value = obj[i];
                if (value < result) {
                    result = value;
                }
            }
        } else {
            iteratee = cb(iteratee, context);
            _.each(obj, function(value, index, list) {
                computed = iteratee(value, index, list);
                if (computed < lastComputed || computed === Infinity && result === Infinity) {
                    result = value;
                    lastComputed = computed;
                }
            });
        }
        return result;
    };

    // Shuffle a collection, using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    _.shuffle = function(obj) {
        var set = isArrayLike(obj) ? obj : _.values(obj);
        var length = set.length;
        var shuffled = Array(length);
        for (var index = 0, rand; index < length; index++) {
            rand = _.random(0, index);
            if (rand !== index) shuffled[index] = shuffled[rand];
            shuffled[rand] = set[index];
        }
        return shuffled;
    };

    // Sample **n** random values from a collection.
    // If **n** is not specified, returns a single random element.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
        if (n == null || guard) {
            if (!isArrayLike(obj)) obj = _.values(obj);
            return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
    };

    // Sort the object's values by a criterion produced by an iteratee.
    _.sortBy = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        return _.pluck(_.map(obj, function(value, index, list) {
            return {
                value: value,
                index: index,
                criteria: iteratee(value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
                if (a > b || a === void 0) return 1;
                if (a < b || b === void 0) return -1;
            }
            return left.index - right.index;
        }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior) {
        return function(obj, iteratee, context) {
            var result = {};
            iteratee = cb(iteratee, context);
            _.each(obj, function(value, index) {
                var key = iteratee(value, index, obj);
                behavior(result, value, key);
            });
            return result;
        };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key].push(value);
        else result[key] = [value];
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, value, key) {
        result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, value, key) {
        if (_.has(result, key)) result[key]++;
        else result[key] = 1;
    });

    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (isArrayLike(obj)) return _.map(obj, _.identity);
        return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
        if (obj == null) return 0;
        return isArrayLike(obj) ? obj.length : _.keys(obj).length;
    };

    // Split a collection into two arrays: one whose elements all satisfy the given
    // predicate, and one whose elements all do not satisfy the predicate.
    _.partition = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var pass = [],
            fail = [];
        _.each(obj, function(value, key, obj) {
            (predicate(value, key, obj) ? pass : fail).push(value);
        });
        return [pass, fail];
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[0];
        return _.initial(array, array.length - n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N.
    _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array.
    _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if (n == null || guard) return array[array.length - 1];
        return _.rest(array, Math.max(0, array.length - n));
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array.
    _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, n == null || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
        return _.filter(array, _.identity);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, strict, startIndex) {
        var output = [],
            idx = 0;
        for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
            var value = input[i];
            if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
                //flatten current level of array or arguments object
                if (!shallow) value = flatten(value, shallow, strict);
                var j = 0,
                    len = value.length;
                output.length += len;
                while (j < len) {
                    output[idx++] = value[j++];
                }
            } else if (!strict) {
                output[idx++] = value;
            }
        }
        return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
        return flatten(array, shallow, false);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (!_.isBoolean(isSorted)) {
            context = iteratee;
            iteratee = isSorted;
            isSorted = false;
        }
        if (iteratee != null) iteratee = cb(iteratee, context);
        var result = [];
        var seen = [];
        for (var i = 0, length = getLength(array); i < length; i++) {
            var value = array[i],
                computed = iteratee ? iteratee(value, i, array) : value;
            if (isSorted) {
                if (!i || seen !== computed) result.push(value);
                seen = computed;
            } else if (iteratee) {
                if (!_.contains(seen, computed)) {
                    seen.push(computed);
                    result.push(value);
                }
            } else if (!_.contains(result, value)) {
                result.push(value);
            }
        }
        return result;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
        return _.uniq(flatten(arguments, true, true));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
        var result = [];
        var argsLength = arguments.length;
        for (var i = 0, length = getLength(array); i < length; i++) {
            var item = array[i];
            if (_.contains(result, item)) continue;
            for (var j = 1; j < argsLength; j++) {
                if (!_.contains(arguments[j], item)) break;
            }
            if (j === argsLength) result.push(item);
        }
        return result;
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
        var rest = flatten(arguments, true, true, 1);
        return _.filter(array, function(value) {
            return !_.contains(rest, value);
        });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
        return _.unzip(arguments);
    };

    // Complement of _.zip. Unzip accepts an array of arrays and groups
    // each array's elements on shared indices
    _.unzip = function(array) {
        var length = array && _.max(array, getLength).length || 0;
        var result = Array(length);

        for (var index = 0; index < length; index++) {
            result[index] = _.pluck(array, index);
        }
        return result;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = function(list, values) {
        var result = {};
        for (var i = 0, length = getLength(list); i < length; i++) {
            if (values) {
                result[list[i]] = values[i];
            } else {
                result[list[i][0]] = list[i][1];
            }
        }
        return result;
    };

    // Generator function to create the findIndex and findLastIndex functions
    function createPredicateIndexFinder(dir) {
        return function(array, predicate, context) {
            predicate = cb(predicate, context);
            var length = getLength(array);
            var index = dir > 0 ? 0 : length - 1;
            for (; index >= 0 && index < length; index += dir) {
                if (predicate(array[index], index, array)) return index;
            }
            return -1;
        };
    }

    // Returns the first index on an array-like that passes a predicate test
    _.findIndex = createPredicateIndexFinder(1);
    _.findLastIndex = createPredicateIndexFinder(-1);

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = cb(iteratee, context, 1);
        var value = iteratee(obj);
        var low = 0,
            high = getLength(array);
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (iteratee(array[mid]) < value) low = mid + 1;
            else high = mid;
        }
        return low;
    };

    // Generator function to create the indexOf and lastIndexOf functions
    function createIndexFinder(dir, predicateFind, sortedIndex) {
        return function(array, item, idx) {
            var i = 0,
                length = getLength(array);
            if (typeof idx == 'number') {
                if (dir > 0) {
                    i = idx >= 0 ? idx : Math.max(idx + length, i);
                } else {
                    length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
                }
            } else if (sortedIndex && idx && length) {
                idx = sortedIndex(array, item);
                return array[idx] === item ? idx : -1;
            }
            if (item !== item) {
                idx = predicateFind(slice.call(array, i, length), _.isNaN);
                return idx >= 0 ? idx + i : -1;
            }
            for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
                if (array[idx] === item) return idx;
            }
            return -1;
        };
    }

    // Return the position of the first occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
        if (stop == null) {
            stop = start || 0;
            start = 0;
        }
        step = step || 1;

        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var range = Array(length);

        for (var idx = 0; idx < length; idx++, start += step) {
            range[idx] = start;
        }

        return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Determines whether to execute a function as a constructor
    // or a normal function with the provided arguments
    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
        if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
        var self = baseCreate(sourceFunc.prototype);
        var result = sourceFunc.apply(self, args);
        if (_.isObject(result)) return result;
        return self;
    };

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = function(func, context) {
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
        var args = slice.call(arguments, 2);
        var bound = function() {
            return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
        };
        return bound;
    };

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context. _ acts
    // as a placeholder, allowing any combination of arguments to be pre-filled.
    _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1);
        var bound = function() {
            var position = 0,
                length = boundArgs.length;
            var args = Array(length);
            for (var i = 0; i < length; i++) {
                args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
            }
            while (position < arguments.length) args.push(arguments[position++]);
            return executeBound(func, bound, this, this, args);
        };
        return bound;
    };

    // Bind a number of an object's methods to that object. Remaining arguments
    // are the method names to be bound. Useful for ensuring that all callbacks
    // defined on an object belong to it.
    _.bindAll = function(obj) {
        var i, length = arguments.length,
            key;
        if (length <= 1) throw new Error('bindAll must be passed function names');
        for (i = 1; i < length; i++) {
            key = arguments[i];
            obj[key] = _.bind(obj[key], obj);
        }
        return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
        var memoize = function(key) {
            var cache = memoize.cache;
            var address = '' + (hasher ? hasher.apply(this, arguments) : key);
            if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
            return cache[address];
        };
        memoize.cache = {};
        return memoize;
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = _.partial(_.delay, _, 1);

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) options = {};
        var later = function() {
            previous = options.leading === false ? 0 : _.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
        };
        return function() {
            var now = _.now();
            if (!previous && options.leading === false) previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                result = func.apply(context, args);
                if (!timeout) context = args = null;
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function() {
            var last = _.now() - timestamp;

            if (last < wait && last >= 0) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    if (!timeout) context = args = null;
                }
            }
        };

        return function() {
            context = this;
            args = arguments;
            timestamp = _.now();
            var callNow = immediate && !timeout;
            if (!timeout) timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
    };

    // Returns a negated version of the passed-in predicate.
    _.negate = function(predicate) {
        return function() {
            return !predicate.apply(this, arguments);
        };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
        var args = arguments;
        var start = args.length - 1;
        return function() {
            var i = start;
            var result = args[start].apply(this, arguments);
            while (i--) result = args[i].call(this, result);
            return result;
        };
    };

    // Returns a function that will only be executed on and after the Nth call.
    _.after = function(times, func) {
        return function() {
            if (--times < 1) {
                return func.apply(this, arguments);
            }
        };
    };

    // Returns a function that will only be executed up to (but not including) the Nth call.
    _.before = function(times, func) {
        var memo;
        return function() {
            if (--times > 0) {
                memo = func.apply(this, arguments);
            }
            if (times <= 1) func = null;
            return memo;
        };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = _.partial(_.before, 2);

    // Object Functions
    // ----------------

    // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
    var hasEnumBug = !{
        toString: null
    }.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
        'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'
    ];

    function collectNonEnumProps(obj, keys) {
        var nonEnumIdx = nonEnumerableProps.length;
        var constructor = obj.constructor;
        var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

        // Constructor is a special case.
        var prop = 'constructor';
        if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

        while (nonEnumIdx--) {
            prop = nonEnumerableProps[nonEnumIdx];
            if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
                keys.push(prop);
            }
        }
    }

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj)
            if (_.has(obj, key)) keys.push(key);
            // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
    };

    // Retrieve all the property names of an object.
    _.allKeys = function(obj) {
        if (!_.isObject(obj)) return [];
        var keys = [];
        for (var key in obj) keys.push(key);
        // Ahem, IE < 9.
        if (hasEnumBug) collectNonEnumProps(obj, keys);
        return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    };

    // Returns the results of applying the iteratee to each element of the object
    // In contrast to _.map it returns an object
    _.mapObject = function(obj, iteratee, context) {
        iteratee = cb(iteratee, context);
        var keys = _.keys(obj),
            length = keys.length,
            results = {},
            currentKey;
        for (var index = 0; index < length; index++) {
            currentKey = keys[index];
            results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
        }
        return results;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = Array(length);
        for (var i = 0; i < length; i++) {
            pairs[i] = [keys[i], obj[keys[i]]];
        }
        return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
            result[obj[keys[i]]] = keys[i];
        }
        return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
            if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = createAssigner(_.allKeys);

    // Assigns a given object with all the own properties in the passed-in object(s)
    // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
    _.extendOwn = _.assign = createAssigner(_.keys);

    // Returns the first key on an object that passes a predicate test
    _.findKey = function(obj, predicate, context) {
        predicate = cb(predicate, context);
        var keys = _.keys(obj),
            key;
        for (var i = 0, length = keys.length; i < length; i++) {
            key = keys[i];
            if (predicate(obj[key], key, obj)) return key;
        }
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(object, oiteratee, context) {
        var result = {},
            obj = object,
            iteratee, keys;
        if (obj == null) return result;
        if (_.isFunction(oiteratee)) {
            keys = _.allKeys(obj);
            iteratee = optimizeCb(oiteratee, context);
        } else {
            keys = flatten(arguments, false, false, 1);
            iteratee = function(value, key, obj) {
                return key in obj;
            };
            obj = Object(obj);
        }
        for (var i = 0, length = keys.length; i < length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (iteratee(value, key, obj)) result[key] = value;
        }
        return result;
    };

    // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj, iteratee, context) {
        if (_.isFunction(iteratee)) {
            iteratee = _.negate(iteratee);
        } else {
            var keys = _.map(flatten(arguments, false, false, 1), String);
            iteratee = function(value, key) {
                return !_.contains(keys, key);
            };
        }
        return _.pick(obj, iteratee, context);
    };

    // Fill in a given object with default properties.
    _.defaults = createAssigner(_.allKeys, true);

    // Creates an object that inherits from the given prototype object.
    // If additional properties are provided then they will be added to the
    // created object.
    _.create = function(prototype, props) {
        var result = baseCreate(prototype);
        if (props) _.extendOwn(result, props);
        return result;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
    };

    // Returns whether an object has a given set of `key:value` pairs.
    _.isMatch = function(object, attrs) {
        var keys = _.keys(attrs),
            length = keys.length;
        if (object == null) return !length;
        var obj = Object(object);
        for (var i = 0; i < length; i++) {
            var key = keys[i];
            if (attrs[key] !== obj[key] || !(key in obj)) return false;
        }
        return true;
    };


    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a === 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // Unwrap any wrapped objects.
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, regular expressions, dates, and booleans are compared by value.
            case '[object RegExp]':
                // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return '' + a === '' + b;
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive.
                // Object(NaN) is equivalent to NaN
                if (+a !== +a) return +b !== +b;
                // An `egal` comparison is performed for other numeric values.
                return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a === +b;
        }

        var areArrays = className === '[object Array]';
        if (!areArrays) {
            if (typeof a != 'object' || typeof b != 'object') return false;

            // Objects with different constructors are not equivalent, but `Object`s or `Array`s
            // from different frames are.
            var aCtor = a.constructor,
                bCtor = b.constructor;
            if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                    _.isFunction(bCtor) && bCtor instanceof bCtor) &&
                ('constructor' in a && 'constructor' in b)) {
                return false;
            }
        }
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

        // Initializing stack of traversed objects.
        // It's done here since we only need them for objects and arrays comparison.
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a) return bStack[length] === b;
        }

        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);

        // Recursively compare objects and arrays.
        if (areArrays) {
            // Compare array lengths to determine if a deep comparison is necessary.
            length = a.length;
            if (length !== b.length) return false;
            // Deep compare the contents, ignoring non-numeric properties.
            while (length--) {
                if (!eq(a[length], b[length], aStack, bStack)) return false;
            }
        } else {
            // Deep compare objects.
            var keys = _.keys(a),
                key;
            length = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            if (_.keys(b).length !== length) return false;
            while (length--) {
                // Deep compare each member
                key = keys[length];
                if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return true;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
        return eq(a, b);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
        return _.keys(obj).length === 0;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) === '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
        _['is' + name] = function(obj) {
            return toString.call(obj) === '[object ' + name + ']';
        };
    });

    // Define a fallback version of the method in browsers (ahem, IE < 9), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
            return _.has(obj, 'callee');
        };
    }

    // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
    // IE 11 (#1621), and in Safari 8 (#1929).
    if (typeof /./ != 'function' && typeof Int8Array != 'object') {
        _.isFunction = function(obj) {
            return typeof obj == 'function' || false;
        };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = function(obj) {
        return _.isNumber(obj) && obj !== +obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
        return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
        return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, key) {
        return obj != null && hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
    };

    // Keep the identity function around for default iteratees.
    _.identity = function(value) {
        return value;
    };

    // Predicate-generating functions. Often useful outside of Underscore.
    _.constant = function(value) {
        return function() {
            return value;
        };
    };

    _.noop = function() {};

    _.property = property;

    // Generates a function for a given object that returns a given property.
    _.propertyOf = function(obj) {
        return obj == null ? function() {} : function(key) {
            return obj[key];
        };
    };

    // Returns a predicate for checking whether an object has a given set of
    // `key:value` pairs.
    _.matcher = _.matches = function(attrs) {
        attrs = _.extendOwn({}, attrs);
        return function(obj) {
            return _.isMatch(obj, attrs);
        };
    };

    // Run a function **n** times.
    _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = optimizeCb(iteratee, context, 1);
        for (var i = 0; i < n; i++) accum[i] = iteratee(i);
        return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
        if (max == null) {
            max = min;
            min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
    };

    // A (possibly faster) way to get the current timestamp as an integer.
    _.now = Date.now || function() {
        return new Date().getTime();
    };

    // List of HTML entities for escaping.
    var escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '`': '&#x60;'
    };
    var unescapeMap = _.invert(escapeMap);

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    var createEscaper = function(map) {
        var escaper = function(match) {
            return map[match];
        };
        // Regexes for identifying a key that needs to be escaped
        var source = '(?:' + _.keys(map).join('|') + ')';
        var testRegexp = RegExp(source);
        var replaceRegexp = RegExp(source, 'g');
        return function(string) {
            string = string == null ? '' : '' + string;
            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
    };
    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap);

    // If the value of the named `property` is a function then invoke it with the
    // `object` as context; otherwise, return it.
    _.result = function(object, property, fallback) {
        var value = object == null ? void 0 : object[property];
        if (value === void 0) {
            value = fallback;
        }
        return _.isFunction(value) ? value.call(object) : value;
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
        "'": "'",
        '\\': '\\',
        '\r': 'r',
        '\n': 'n',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

    var escapeChar = function(match) {
        return '\\' + escapes[match];
    };

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    // NB: `oldSettings` only exists for backwards compatibility.
    _.template = function(text, settings, oldSettings) {
        if (!settings && oldSettings) settings = oldSettings;
        settings = _.defaults({}, settings, _.templateSettings);

        // Combine delimiters into one regular expression via alternation.
        var matcher = RegExp([
            (settings.escape || noMatch).source,
            (settings.interpolate || noMatch).source,
            (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');

        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset).replace(escaper, escapeChar);
            index = offset + match.length;

            if (escape) {
                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
            } else if (interpolate) {
                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
            } else if (evaluate) {
                source += "';\n" + evaluate + "\n__p+='";
            }

            // Adobe VMs need the match returned to produce the correct offest.
            return match;
        });
        source += "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __t,__p='',__j=Array.prototype.join," +
            "print=function(){__p+=__j.call(arguments,'');};\n" +
            source + 'return __p;\n';

        try {
            var render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
            e.source = source;
            throw e;
        }

        var template = function(data) {
            return render.call(this, data, _);
        };

        // Provide the compiled source as a convenience for precompilation.
        var argument = settings.variable || 'obj';
        template.source = 'function(' + argument + '){\n' + source + '}';

        return template;
    };

    // Add a "chain" function. Start chaining a wrapped Underscore object.
    _.chain = function(obj) {
        var instance = _(obj);
        instance._chain = true;
        return instance;
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(instance, obj) {
        return instance._chain ? _(obj).chain() : obj;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [this._wrapped];
                push.apply(args, arguments);
                return result(this, func.apply(_, args));
            };
        });
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            method.apply(obj, arguments);
            if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
            return result(this, obj);
        };
    });

    // Add all accessor Array functions to the wrapper.
    _.each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            return result(this, method.apply(this._wrapped, arguments));
        };
    });

    // Extracts the result from a wrapped and chained object.
    _.prototype.value = function() {
        return this._wrapped;
    };

    // Provide unwrapping proxy for some methods used in engine operations
    // such as arithmetic and JSON stringification.
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

    _.prototype.toString = function() {
        return '' + this._wrapped;
    };

    // AMD registration happens at the end for compatibility with AMD loaders
    // that may not enforce next-turn semantics on modules. Even though general
    // practice for AMD registration is to be anonymous, underscore registers
    // as a named module because, like jQuery, it is a base library that is
    // popular enough to be bundled in a third party lib, but not be part of
    // an AMD load request. Those cases could generate an error when an
    // anonymous define() is called outside of a loader request.
    if (typeof define === 'function' && define.amd) {
        define('underscore', [], function() {
            return _;
        });
    }
}.call(this));

//     Backbone.js 1.2.3

//     (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(factory) {

    // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
    // We use `self` instead of `window` for `WebWorker` support.
    var root = (typeof self == 'object' && self.self == self && self) ||
        (typeof global == 'object' && global.global == global && global);

    // Set up Backbone appropriately for the environment. Start with AMD.
    if (typeof define === 'function' && define.amd) {
        define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
            // Export global even in AMD case in case this script is loaded with
            // others that may still expect a global Backbone.
            root.Backbone = factory(root, exports, _, $);
        });

        // Next for Node.js or CommonJS. jQuery may not be needed as a module.
    } else if (typeof exports !== 'undefined') {
        var _ = require('underscore'),
            $;
        try {
            $ = require('jquery');
        } catch (e) {}
        factory(root, exports, _, $);

        // Finally, as a browser global.
    } else {
        root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
    }

}(function(root, Backbone, _, $) {

    // Initial Setup
    // -------------

    // Save the previous value of the `Backbone` variable, so that it can be
    // restored later on, if `noConflict` is used.
    var previousBackbone = root.Backbone;

    // Create a local reference to a common array method we'll want to use later.
    var slice = Array.prototype.slice;

    // Current version of the library. Keep in sync with `package.json`.
    Backbone.VERSION = '1.2.3';

    // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
    // the `$` variable.
    Backbone.$ = $;

    // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
    // to its previous owner. Returns a reference to this Backbone object.
    Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
    };

    // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
    // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
    // set a `X-Http-Method-Override` header.
    Backbone.emulateHTTP = false;

    // Turn on `emulateJSON` to support legacy servers that can't deal with direct
    // `application/json` requests ... this will encode the body as
    // `application/x-www-form-urlencoded` instead and will send the model in a
    // form param named `model`.
    Backbone.emulateJSON = false;

    // Proxy Backbone class methods to Underscore functions, wrapping the model's
    // `attributes` object or collection's `models` array behind the scenes.
    //
    // collection.filter(function(model) { return model.get('age') > 10 });
    // collection.each(this.addView);
    //
    // `Function#apply` can be slow so we use the method's arg count, if we know it.
    var addMethod = function(length, method, attribute) {
        switch (length) {
            case 1:
                return function() {
                    return _[method](this[attribute]);
                };
            case 2:
                return function(value) {
                    return _[method](this[attribute], value);
                };
            case 3:
                return function(iteratee, context) {
                    return _[method](this[attribute], cb(iteratee, this), context);
                };
            case 4:
                return function(iteratee, defaultVal, context) {
                    return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
                };
            default:
                return function() {
                    var args = slice.call(arguments);
                    args.unshift(this[attribute]);
                    return _[method].apply(_, args);
                };
        }
    };
    var addUnderscoreMethods = function(Class, methods, attribute) {
        _.each(methods, function(length, method) {
            if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
        });
    };

    // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
    var cb = function(iteratee, instance) {
        if (_.isFunction(iteratee)) return iteratee;
        if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
        if (_.isString(iteratee)) return function(model) {
            return model.get(iteratee);
        };
        return iteratee;
    };
    var modelMatcher = function(attrs) {
        var matcher = _.matches(attrs);
        return function(model) {
            return matcher(model.attributes);
        };
    };

    // Backbone.Events
    // ---------------

    // A module that can be mixed in to *any object* in order to provide it with
    // a custom event channel. You may bind a callback to an event with `on` or
    // remove with `off`; `trigger`-ing an event fires all callbacks in
    // succession.
    //
    //     var object = {};
    //     _.extend(object, Backbone.Events);
    //     object.on('expand', function(){ alert('expanded'); });
    //     object.trigger('expand');
    //
    var Events = Backbone.Events = {};

    // Regular expression used to split event strings.
    var eventSplitter = /\s+/;

    // Iterates over the standard `event, callback` (as well as the fancy multiple
    // space-separated events `"change blur", callback` and jQuery-style event
    // maps `{event: callback}`).
    var eventsApi = function(iteratee, events, name, callback, opts) {
        var i = 0,
            names;
        if (name && typeof name === 'object') {
            // Handle event maps.
            if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
            for (names = _.keys(name); i < names.length; i++) {
                events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
            }
        } else if (name && eventSplitter.test(name)) {
            // Handle space separated event names by delegating them individually.
            for (names = name.split(eventSplitter); i < names.length; i++) {
                events = iteratee(events, names[i], callback, opts);
            }
        } else {
            // Finally, standard events.
            events = iteratee(events, name, callback, opts);
        }
        return events;
    };

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    Events.on = function(name, callback, context) {
        return internalOn(this, name, callback, context);
    };

    // Guard the `listening` argument from the public API.
    var internalOn = function(obj, name, callback, context, listening) {
        obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
            context: context,
            ctx: obj,
            listening: listening
        });

        if (listening) {
            var listeners = obj._listeners || (obj._listeners = {});
            listeners[listening.id] = listening;
        }

        return obj;
    };

    // Inversion-of-control versions of `on`. Tell *this* object to listen to
    // an event in another object... keeping track of what it's listening to
    // for easier unbinding later.
    Events.listenTo = function(obj, name, callback) {
        if (!obj) return this;
        var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = listeningTo[id];

        // This object is not listening to any other events on `obj` yet.
        // Setup the necessary references to track the listening callbacks.
        if (!listening) {
            var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
            listening = listeningTo[id] = {
                obj: obj,
                objId: id,
                id: thisId,
                listeningTo: listeningTo,
                count: 0
            };
        }

        // Bind callbacks on obj, and keep track of them on listening.
        internalOn(obj, name, callback, this, listening);
        return this;
    };

    // The reducing API that adds a callback to the `events` object.
    var onApi = function(events, name, callback, options) {
        if (callback) {
            var handlers = events[name] || (events[name] = []);
            var context = options.context,
                ctx = options.ctx,
                listening = options.listening;
            if (listening) listening.count++;

            handlers.push({
                callback: callback,
                context: context,
                ctx: context || ctx,
                listening: listening
            });
        }
        return events;
    };

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    Events.off = function(name, callback, context) {
        if (!this._events) return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
            context: context,
            listeners: this._listeners
        });
        return this;
    };

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;

        var ids = obj ? [obj._listenId] : _.keys(listeningTo);

        for (var i = 0; i < ids.length; i++) {
            var listening = listeningTo[ids[i]];

            // If listening doesn't exist, this object is not currently
            // listening to obj. Break out early.
            if (!listening) break;

            listening.obj.off(name, callback, this);
        }
        if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

        return this;
    };

    // The reducing API that removes a callback from the `events` object.
    var offApi = function(events, name, callback, options) {
        if (!events) return;

        var i = 0,
            listening;
        var context = options.context,
            listeners = options.listeners;

        // Delete all events listeners and "drop" events.
        if (!name && !callback && !context) {
            var ids = _.keys(listeners);
            for (; i < ids.length; i++) {
                listening = listeners[ids[i]];
                delete listeners[listening.id];
                delete listening.listeningTo[listening.objId];
            }
            return;
        }

        var names = name ? [name] : _.keys(events);
        for (; i < names.length; i++) {
            name = names[i];
            var handlers = events[name];

            // Bail out if there are no events stored.
            if (!handlers) break;

            // Replace events if there are any remaining.  Otherwise, clean up.
            var remaining = [];
            for (var j = 0; j < handlers.length; j++) {
                var handler = handlers[j];
                if (
                    callback && callback !== handler.callback &&
                    callback !== handler.callback._callback ||
                    context && context !== handler.context
                ) {
                    remaining.push(handler);
                } else {
                    listening = handler.listening;
                    if (listening && --listening.count === 0) {
                        delete listeners[listening.id];
                        delete listening.listeningTo[listening.objId];
                    }
                }
            }

            // Update tail event if the list has any events.  Otherwise, clean up.
            if (remaining.length) {
                events[name] = remaining;
            } else {
                delete events[name];
            }
        }
        if (_.size(events)) return events;
    };

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, its listener will be removed. If multiple events
    // are passed in using the space-separated syntax, the handler will fire
    // once for each event, not once for a combination of all events.
    Events.once = function(name, callback, context) {
        // Map the event into a `{event: once}` object.
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
        return this.on(events, void 0, context);
    };

    // Inversion-of-control versions of `once`.
    Events.listenToOnce = function(obj, name, callback) {
        // Map the event into a `{event: once}` object.
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
        return this.listenTo(obj, events);
    };

    // Reduces the event callbacks into a map of `{event: onceWrapper}`.
    // `offer` unbinds the `onceWrapper` after it has been called.
    var onceMap = function(map, name, callback, offer) {
        if (callback) {
            var once = map[name] = _.once(function() {
                offer(name, once);
                callback.apply(this, arguments);
            });
            once._callback = callback;
        }
        return map;
    };

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    Events.trigger = function(name) {
        if (!this._events) return this;

        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
    };

    // Handles triggering the appropriate event callbacks.
    var triggerApi = function(objEvents, name, cb, args) {
        if (objEvents) {
            var events = objEvents[name];
            var allEvents = objEvents.all;
            if (events && allEvents) allEvents = allEvents.slice();
            if (events) triggerEvents(events, args);
            if (allEvents) triggerEvents(allEvents, [name].concat(args));
        }
        return objEvents;
    };

    // A difficult-to-believe, but optimized internal dispatch function for
    // triggering events. Tries to keep the usual cases speedy (most internal
    // Backbone events have 3 arguments).
    var triggerEvents = function(events, args) {
        var ev, i = -1,
            l = events.length,
            a1 = args[0],
            a2 = args[1],
            a3 = args[2];
        switch (args.length) {
            case 0:
                while (++i < l)(ev = events[i]).callback.call(ev.ctx);
                return;
            case 1:
                while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1);
                return;
            case 2:
                while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);
                return;
            case 3:
                while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
                return;
            default:
                while (++i < l)(ev = events[i]).callback.apply(ev.ctx, args);
                return;
        }
    };

    // Aliases for backwards compatibility.
    Events.bind = Events.on;
    Events.unbind = Events.off;

    // Allow the `Backbone` object to serve as a global event bus, for folks who
    // want global "pubsub" in a convenient place.
    _.extend(Backbone, Events);

    // Backbone.Model
    // --------------

    // Backbone **Models** are the basic data object in the framework --
    // frequently representing a row in a table in a database on your server.
    // A discrete chunk of data and a bunch of useful, related methods for
    // performing computations and transformations on that data.

    // Create a new model with the specified attributes. A client id (`cid`)
    // is automatically generated and assigned for you.
    var Model = Backbone.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection) this.collection = options.collection;
        if (options.parse) attrs = this.parse(attrs, options) || {};
        attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
    };

    // Attach all inheritable methods to the Model prototype.
    _.extend(Model.prototype, Events, {

        // A hash of attributes whose current and previous value differ.
        changed: null,

        // The value returned during the last failed validation.
        validationError: null,

        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: 'id',

        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: 'c',

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
            return _.clone(this.attributes);
        },

        // Proxy `Backbone.sync` by default -- but override this if you need
        // custom syncing semantics for *this* particular model.
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },

        // Get the value of an attribute.
        get: function(attr) {
            return this.attributes[attr];
        },

        // Get the HTML-escaped value of an attribute.
        escape: function(attr) {
            return _.escape(this.get(attr));
        },

        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr) {
            return this.get(attr) != null;
        },

        // Special-cased proxy to underscore's `_.matches` method.
        matches: function(attrs) {
            return !!_.iteratee(attrs, this)(this.attributes);
        },

        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
            if (key == null) return this;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            var attrs;
            if (typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            options || (options = {});

            // Run validation.
            if (!this._validate(attrs, options)) return false;

            // Extract attributes and options.
            var unset = options.unset;
            var silent = options.silent;
            var changes = [];
            var changing = this._changing;
            this._changing = true;

            if (!changing) {
                this._previousAttributes = _.clone(this.attributes);
                this.changed = {};
            }

            var current = this.attributes;
            var changed = this.changed;
            var prev = this._previousAttributes;

            // For each `set` attribute, update or delete the current value.
            for (var attr in attrs) {
                val = attrs[attr];
                if (!_.isEqual(current[attr], val)) changes.push(attr);
                if (!_.isEqual(prev[attr], val)) {
                    changed[attr] = val;
                } else {
                    delete changed[attr];
                }
                unset ? delete current[attr] : current[attr] = val;
            }

            // Update the `id`.
            this.id = this.get(this.idAttribute);

            // Trigger all relevant attribute changes.
            if (!silent) {
                if (changes.length) this._pending = options;
                for (var i = 0; i < changes.length; i++) {
                    this.trigger('change:' + changes[i], this, current[changes[i]], options);
                }
            }

            // You might be wondering why there's a `while` loop here. Changes can
            // be recursively nested within `"change"` events.
            if (changing) return this;
            if (!silent) {
                while (this._pending) {
                    options = this._pending;
                    this._pending = false;
                    this.trigger('change', this, options);
                }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },

        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr, options) {
            return this.set(attr, void 0, _.extend({}, options, {
                unset: true
            }));
        },

        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
            var attrs = {};
            for (var key in this.attributes) attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, {
                unset: true
            }));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            var changed = {};
            for (var attr in diff) {
                var val = diff[attr];
                if (_.isEqual(old[attr], val)) continue;
                changed[attr] = val;
            }
            return _.size(changed) ? changed : false;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
            if (attr == null || !this._previousAttributes) return null;
            return this._previousAttributes[attr];
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
            return _.clone(this._previousAttributes);
        },

        // Fetch the model from the server, merging the response with the model's
        // local attributes. Any changed attributes will trigger a "change" event.
        fetch: function(options) {
            options = _.extend({
                parse: true
            }, options);
            var model = this;
            var success = options.success;
            options.success = function(resp) {
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (!model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
        },

        // Set a hash of model attributes, and sync the model to the server.
        // If the server returns an attributes hash that differs, the model's
        // state will be `set` again.
        save: function(key, val, options) {
            // Handle both `"key", value` and `{key: value}` -style arguments.
            var attrs;
            if (key == null || typeof key === 'object') {
                attrs = key;
                options = val;
            } else {
                (attrs = {})[key] = val;
            }

            options = _.extend({
                validate: true,
                parse: true
            }, options);
            var wait = options.wait;

            // If we're not waiting and attributes exist, save acts as
            // `set(attr).save(null, opts)` with validation. Otherwise, check if
            // the model will be valid when the attributes, if any, are set.
            if (attrs && !wait) {
                if (!this.set(attrs, options)) return false;
            } else {
                if (!this._validate(attrs, options)) return false;
            }

            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            var model = this;
            var success = options.success;
            var attributes = this.attributes;
            options.success = function(resp) {
                // Ensure attributes are restored during synchronous saves.
                model.attributes = attributes;
                var serverAttrs = options.parse ? model.parse(resp, options) : resp;
                if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
                if (serverAttrs && !model.set(serverAttrs, options)) return false;
                if (success) success.call(options.context, model, resp, options);
                model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);

            // Set temporary attributes if `{wait: true}` to properly find new ids.
            if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

            var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
            if (method === 'patch' && !options.attrs) options.attrs = attrs;
            var xhr = this.sync(method, this, options);

            // Restore attributes.
            this.attributes = attributes;

            return xhr;
        },

        // Destroy this model on the server if it was already persisted.
        // Optimistically removes the model from its collection, if it has one.
        // If `wait: true` is passed, waits for the server to respond before removal.
        destroy: function(options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
            var wait = options.wait;

            var destroy = function() {
                model.stopListening();
                model.trigger('destroy', model, model.collection, options);
            };

            options.success = function(resp) {
                if (wait) destroy();
                if (success) success.call(options.context, model, resp, options);
                if (!model.isNew()) model.trigger('sync', model, resp, options);
            };

            var xhr = false;
            if (this.isNew()) {
                _.defer(options.success);
            } else {
                wrapError(this, options);
                xhr = this.sync('delete', this, options);
            }
            if (!wait) destroy();
            return xhr;
        },

        // Default URL for the model's representation on the server -- if you're
        // using Backbone's restful methods, override this to change the endpoint
        // that will be called.
        url: function() {
            var base =
                _.result(this, 'urlRoot') ||
                _.result(this.collection, 'url') ||
                urlError();
            if (this.isNew()) return base;
            var id = this.get(this.idAttribute);
            return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
        },

        // **parse** converts a response into the hash of attributes to be `set` on
        // the model. The default implementation is just to pass the response along.
        parse: function(resp, options) {
            return resp;
        },

        // Create a new model with identical attributes to this one.
        clone: function() {
            return new this.constructor(this.attributes);
        },

        // A model is new if it has never been saved to the server, and lacks an id.
        isNew: function() {
            return !this.has(this.idAttribute);
        },

        // Check if the model is currently in a valid state.
        isValid: function(options) {
            return this._validate({}, _.defaults({
                validate: true
            }, options));
        },

        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
            if (!options.validate || !this.validate) return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger('invalid', this, error, _.extend(options, {
                validationError: error
            }));
            return false;
        }

    });

    // Underscore methods that we want to implement on the Model, mapped to the
    // number of arguments they take.
    var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
    };

    // Mix in each Underscore method as a proxy to `Model#attributes`.
    addUnderscoreMethods(Model, modelMethods, 'attributes');

    // Backbone.Collection
    // -------------------

    // If models tend to represent a single row of data, a Backbone Collection is
    // more analogous to a table full of data ... or a small slice or page of that
    // table, or a collection of rows that belong together for a particular reason
    // -- all of the messages in this particular folder, all of the documents
    // belonging to this particular author, and so on. Collections maintain
    // indexes of their models, both in order, and for lookup by `id`.

    // Create a new **Collection**, perhaps to contain a specific type of `model`.
    // If a `comparator` is specified, the Collection will maintain
    // its models in sort order, as they're added and removed.
    var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, _.extend({
            silent: true
        }, options));
    };

    // Default options for `Collection#set`.
    var setOptions = {
        add: true,
        remove: true,
        merge: true
    };
    var addOptions = {
        add: true,
        remove: false
    };

    // Splices `insert` into `array` at index `at`.
    var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        for (var i = 0; i < tail.length; i++) tail[i] = array[i + at];
        for (i = 0; i < length; i++) array[i + at] = insert[i];
        for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
    };

    // Define the Collection's inheritable methods.
    _.extend(Collection.prototype, Events, {

        // The default model for a collection is just a **Backbone.Model**.
        // This should be overridden in most cases.
        model: Model,

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
            return this.map(function(model) {
                return model.toJSON(options);
            });
        },

        // Proxy `Backbone.sync` by default.
        sync: function() {
            return Backbone.sync.apply(this, arguments);
        },

        // Add a model, or list of models to the set. `models` may be Backbone
        // Models or raw JavaScript objects to be converted to Models, or any
        // combination of the two.
        add: function(models, options) {
            return this.set(models, _.extend({
                merge: false
            }, options, addOptions));
        },

        // Remove a model, or a list of models from the set.
        remove: function(models, options) {
            options = _.extend({}, options);
            var singular = !_.isArray(models);
            models = singular ? [models] : _.clone(models);
            var removed = this._removeModels(models, options);
            if (!options.silent && removed) this.trigger('update', this, options);
            return singular ? removed[0] : removed;
        },

        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function(models, options) {
            if (models == null) return;

            options = _.defaults({}, options, setOptions);
            if (options.parse && !this._isModel(models)) models = this.parse(models, options);

            var singular = !_.isArray(models);
            models = singular ? [models] : models.slice();

            var at = options.at;
            if (at != null) at = +at;
            if (at < 0) at += this.length + 1;

            var set = [];
            var toAdd = [];
            var toRemove = [];
            var modelMap = {};

            var add = options.add;
            var merge = options.merge;
            var remove = options.remove;

            var sort = false;
            var sortable = this.comparator && (at == null) && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;

            // Turn bare objects into model references, and prevent invalid models
            // from being added.
            var model;
            for (var i = 0; i < models.length; i++) {
                model = models[i];

                // If a duplicate is found, prevent it from being added and
                // optionally merge it into the existing model.
                var existing = this.get(model);
                if (existing) {
                    if (merge && model !== existing) {
                        var attrs = this._isModel(model) ? model.attributes : model;
                        if (options.parse) attrs = existing.parse(attrs, options);
                        existing.set(attrs, options);
                        if (sortable && !sort) sort = existing.hasChanged(sortAttr);
                    }
                    if (!modelMap[existing.cid]) {
                        modelMap[existing.cid] = true;
                        set.push(existing);
                    }
                    models[i] = existing;

                    // If this is a new, valid model, push it to the `toAdd` list.
                } else if (add) {
                    model = models[i] = this._prepareModel(model, options);
                    if (model) {
                        toAdd.push(model);
                        this._addReference(model, options);
                        modelMap[model.cid] = true;
                        set.push(model);
                    }
                }
            }

            // Remove stale models.
            if (remove) {
                for (i = 0; i < this.length; i++) {
                    model = this.models[i];
                    if (!modelMap[model.cid]) toRemove.push(model);
                }
                if (toRemove.length) this._removeModels(toRemove, options);
            }

            // See if sorting is needed, update `length` and splice in new models.
            var orderChanged = false;
            var replace = !sortable && add && remove;
            if (set.length && replace) {
                orderChanged = this.length != set.length || _.some(this.models, function(model, index) {
                    return model !== set[index];
                });
                this.models.length = 0;
                splice(this.models, set, 0);
                this.length = this.models.length;
            } else if (toAdd.length) {
                if (sortable) sort = true;
                splice(this.models, toAdd, at == null ? this.length : at);
                this.length = this.models.length;
            }

            // Silently sort the collection if appropriate.
            if (sort) this.sort({
                silent: true
            });

            // Unless silenced, it's time to fire all appropriate add/sort events.
            if (!options.silent) {
                for (i = 0; i < toAdd.length; i++) {
                    if (at != null) options.index = at + i;
                    model = toAdd[i];
                    model.trigger('add', model, this, options);
                }
                if (sort || orderChanged) this.trigger('sort', this, options);
                if (toAdd.length || toRemove.length) this.trigger('update', this, options);
            }

            // Return the added (or merged) model (or models).
            return singular ? models[0] : models;
        },

        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function(models, options) {
            options = options ? _.clone(options) : {};
            for (var i = 0; i < this.models.length; i++) {
                this._removeReference(this.models[i], options);
            }
            options.previousModels = this.models;
            this._reset();
            models = this.add(models, _.extend({
                silent: true
            }, options));
            if (!options.silent) this.trigger('reset', this, options);
            return models;
        },

        // Add a model to the end of the collection.
        push: function(model, options) {
            return this.add(model, _.extend({
                at: this.length
            }, options));
        },

        // Remove a model from the end of the collection.
        pop: function(options) {
            var model = this.at(this.length - 1);
            return this.remove(model, options);
        },

        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
            return this.add(model, _.extend({
                at: 0
            }, options));
        },

        // Remove a model from the beginning of the collection.
        shift: function(options) {
            var model = this.at(0);
            return this.remove(model, options);
        },

        // Slice out a sub-array of models from the collection.
        slice: function() {
            return slice.apply(this.models, arguments);
        },

        // Get a model from the set by id.
        get: function(obj) {
            if (obj == null) return void 0;
            var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
            return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
        },

        // Get the model at the given index.
        at: function(index) {
            if (index < 0) index += this.length;
            return this.models[index];
        },

        // Return models with matching attributes. Useful for simple cases of
        // `filter`.
        where: function(attrs, first) {
            return this[first ? 'find' : 'filter'](attrs);
        },

        // Return the first model with matching attributes. Useful for simple cases
        // of `find`.
        findWhere: function(attrs) {
            return this.where(attrs, true);
        },

        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
            var comparator = this.comparator;
            if (!comparator) throw new Error('Cannot sort a set without a comparator');
            options || (options = {});

            var length = comparator.length;
            if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

            // Run sort based on type of `comparator`.
            if (length === 1 || _.isString(comparator)) {
                this.models = this.sortBy(comparator);
            } else {
                this.models.sort(comparator);
            }
            if (!options.silent) this.trigger('sort', this, options);
            return this;
        },

        // Pluck an attribute from each model in the collection.
        pluck: function(attr) {
            return _.invoke(this.models, 'get', attr);
        },

        // Fetch the default set of models for this collection, resetting the
        // collection when they arrive. If `reset: true` is passed, the response
        // data will be passed through the `reset` method instead of `set`.
        fetch: function(options) {
            options = _.extend({
                parse: true
            }, options);
            var success = options.success;
            var collection = this;
            options.success = function(resp) {
                var method = options.reset ? 'reset' : 'set';
                collection[method](resp, options);
                if (success) success.call(options.context, collection, resp, options);
                collection.trigger('sync', collection, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
        },

        // Create a new instance of a model in this collection. Add the model to the
        // collection immediately, unless `wait: true` is passed, in which case we
        // wait for the server to agree.
        create: function(model, options) {
            options = options ? _.clone(options) : {};
            var wait = options.wait;
            model = this._prepareModel(model, options);
            if (!model) return false;
            if (!wait) this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function(model, resp, callbackOpts) {
                if (wait) collection.add(model, callbackOpts);
                if (success) success.call(callbackOpts.context, model, resp, callbackOpts);
            };
            model.save(null, options);
            return model;
        },

        // **parse** converts a response into a list of models to be added to the
        // collection. The default implementation is just to pass it through.
        parse: function(resp, options) {
            return resp;
        },

        // Create a new collection with an identical list of models as this one.
        clone: function() {
            return new this.constructor(this.models, {
                model: this.model,
                comparator: this.comparator
            });
        },

        // Define how to uniquely identify models in the collection.
        modelId: function(attrs) {
            return attrs[this.model.prototype.idAttribute || 'id'];
        },

        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function() {
            this.length = 0;
            this.models = [];
            this._byId = {};
        },

        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function(attrs, options) {
            if (this._isModel(attrs)) {
                if (!attrs.collection) attrs.collection = this;
                return attrs;
            }
            options = options ? _.clone(options) : {};
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model.validationError) return model;
            this.trigger('invalid', this, model.validationError, options);
            return false;
        },

        // Internal method called by both remove and set.
        _removeModels: function(models, options) {
            var removed = [];
            for (var i = 0; i < models.length; i++) {
                var model = this.get(models[i]);
                if (!model) continue;

                var index = this.indexOf(model);
                this.models.splice(index, 1);
                this.length--;

                if (!options.silent) {
                    options.index = index;
                    model.trigger('remove', model, this, options);
                }

                removed.push(model);
                this._removeReference(model, options);
            }
            return removed.length ? removed : false;
        },

        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function(model) {
            return model instanceof Model;
        },

        // Internal method to create a model's ties to a collection.
        _addReference: function(model, options) {
            this._byId[model.cid] = model;
            var id = this.modelId(model.attributes);
            if (id != null) this._byId[id] = model;
            model.on('all', this._onModelEvent, this);
        },

        // Internal method to sever a model's ties to a collection.
        _removeReference: function(model, options) {
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null) delete this._byId[id];
            if (this === model.collection) delete model.collection;
            model.off('all', this._onModelEvent, this);
        },

        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
            if ((event === 'add' || event === 'remove') && collection !== this) return;
            if (event === 'destroy') this.remove(model, options);
            if (event === 'change') {
                var prevId = this.modelId(model.previousAttributes());
                var id = this.modelId(model.attributes);
                if (prevId !== id) {
                    if (prevId != null) delete this._byId[prevId];
                    if (id != null) this._byId[id] = model;
                }
            }
            this.trigger.apply(this, arguments);
        }

    });

    // Underscore methods that we want to implement on the Collection.
    // 90% of the core usefulness of Backbone Collections is actually implemented
    // right here:
    var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 4,
        foldl: 4,
        inject: 4,
        reduceRight: 4,
        foldr: 4,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3
    };

    // Mix in each Underscore method as a proxy to `Collection#models`.
    addUnderscoreMethods(Collection, collectionMethods, 'models');

    // Backbone.View
    // -------------

    // Backbone Views are almost more convention than they are actual code. A View
    // is simply a JavaScript object that represents a logical chunk of UI in the
    // DOM. This might be a single item, an entire list, a sidebar or panel, or
    // even the surrounding frame which wraps your whole app. Defining a chunk of
    // UI as a **View** allows you to define your DOM events declaratively, without
    // having to worry about render order ... and makes it easy for the view to
    // react to specific changes in the state of your models.

    // Creating a Backbone.View creates its initial element outside of the DOM,
    // if an existing element is not provided...
    var View = Backbone.View = function(options) {
        this.cid = _.uniqueId('view');
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
    };

    // Cached regex to split keys for `delegate`.
    var delegateEventSplitter = /^(\S+)\s*(.*)$/;

    // List of view options to be set as properties.
    var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

    // Set up all inheritable **Backbone.View** properties and methods.
    _.extend(View.prototype, Events, {

        // The default `tagName` of a View's element is `"div"`.
        tagName: 'div',

        // jQuery delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function(selector) {
            return this.$el.find(selector);
        },

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function() {
            return this;
        },

        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Backbone.Events listeners.
        remove: function() {
            this._removeElement();
            this.stopListening();
            return this;
        },

        // Remove this view's element from the document and all event listeners
        // attached to it. Exposed for subclasses using an alternative DOM
        // manipulation API.
        _removeElement: function() {
            this.$el.remove();
        },

        // Change the view's element (`this.el` property) and re-delegate the
        // view's events on the new element.
        setElement: function(element) {
            this.undelegateEvents();
            this._setElement(element);
            this.delegateEvents();
            return this;
        },

        // Creates the `this.el` and `this.$el` references for this view using the
        // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
        // context or an element. Subclasses can override this to utilize an
        // alternative DOM manipulation API and are only required to set the
        // `this.el` property.
        _setElement: function(el) {
            this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
            this.el = this.$el[0];
        },

        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function(events) {
            events || (events = _.result(this, 'events'));
            if (!events) return this;
            this.undelegateEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) method = this[method];
                if (!method) continue;
                var match = key.match(delegateEventSplitter);
                this.delegate(match[1], match[2], _.bind(method, this));
            }
            return this;
        },

        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function(eventName, selector, listener) {
            this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
            return this;
        },

        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // Backbone views attached to the same DOM element.
        undelegateEvents: function() {
            if (this.$el) this.$el.off('.delegateEvents' + this.cid);
            return this;
        },

        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function(eventName, selector, listener) {
            this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
            return this;
        },

        // Produces a DOM element to be assigned to your view. Exposed for
        // subclasses using an alternative DOM manipulation API.
        _createElement: function(tagName) {
            return document.createElement(tagName);
        },

        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function() {
            if (!this.el) {
                var attrs = _.extend({}, _.result(this, 'attributes'));
                if (this.id) attrs.id = _.result(this, 'id');
                if (this.className) attrs['class'] = _.result(this, 'className');
                this.setElement(this._createElement(_.result(this, 'tagName')));
                this._setAttributes(attrs);
            } else {
                this.setElement(_.result(this, 'el'));
            }
        },

        // Set attributes from a hash on this view's element.  Exposed for
        // subclasses using an alternative DOM manipulation API.
        _setAttributes: function(attributes) {
            this.$el.attr(attributes);
        }

    });

    // Backbone.sync
    // -------------

    // Override this function to change the manner in which Backbone persists
    // models to the server. You will be passed the type of request, and the
    // model in question. By default, makes a RESTful Ajax request
    // to the model's `url()`. Some possible customizations could be:
    //
    // * Use `setTimeout` to batch rapid-fire updates into a single request.
    // * Send up the models as XML instead of JSON.
    // * Persist models via WebSockets instead of Ajax.
    //
    // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
    // as `POST`, with a `_method` parameter containing the true HTTP method,
    // as well as all requests with the body as `application/x-www-form-urlencoded`
    // instead of `application/json` with the model in a param named `model`.
    // Useful when interfacing with server-side languages like **PHP** that make
    // it difficult to read the body of `PUT` requests.
    Backbone.sync = function(method, model, options) {
        var type = methodMap[method];

        // Default options, unless specified.
        _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
        });

        // Default JSON-request options.
        var params = {
            type: type,
            dataType: 'json'
        };

        // Ensure that we have a URL.
        if (!options.url) {
            params.url = _.result(model, 'url') || urlError();
        }

        // Ensure that we have the appropriate request data.
        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
            params.contentType = 'application/json';
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }

        // For older servers, emulate JSON by encoding the request into an HTML-form.
        if (options.emulateJSON) {
            params.contentType = 'application/x-www-form-urlencoded';
            params.data = params.data ? {
                model: params.data
            } : {};
        }

        // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
        // And an `X-HTTP-Method-Override` header.
        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
            params.type = 'POST';
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
                xhr.setRequestHeader('X-HTTP-Method-Override', type);
                if (beforeSend) return beforeSend.apply(this, arguments);
            };
        }

        // Don't process data on a non-GET request.
        if (params.type !== 'GET' && !options.emulateJSON) {
            params.processData = false;
        }

        // Pass along `textStatus` and `errorThrown` from jQuery.
        var error = options.error;
        options.error = function(xhr, textStatus, errorThrown) {
            options.textStatus = textStatus;
            options.errorThrown = errorThrown;
            if (error) error.call(options.context, xhr, textStatus, errorThrown);
        };

        // Make the request, allowing the user to override any Ajax options.
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger('request', model, xhr, options);
        return xhr;
    };

    // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
    var methodMap = {
        'create': 'POST',
        'update': 'PUT',
        'patch': 'PATCH',
        'delete': 'DELETE',
        'read': 'GET'
    };

    // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
    // Override this if you'd like to use a different library.
    Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
    };

    // Backbone.Router
    // ---------------

    // Routers map faux-URLs to actions, and fire events when routes are
    // matched. Creating a new one sets its `routes` hash, if not set statically.
    var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes) this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };

    // Cached regular expressions for matching named param parts and splatted
    // parts of route strings.
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

    // Set up all inheritable **Backbone.Router** properties and methods.
    _.extend(Router.prototype, Events, {

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        // Manually bind a single named route to a callback. For example:
        //
        //     this.route('search/:query/p:num', 'search', function(query, num) {
        //       ...
        //     });
        //
        route: function(route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = '';
            }
            if (!callback) callback = this[name];
            var router = this;
            Backbone.history.route(route, function(fragment) {
                var args = router._extractParameters(route, fragment);
                if (router.execute(callback, args, name) !== false) {
                    router.trigger.apply(router, ['route:' + name].concat(args));
                    router.trigger('route', name, args);
                    Backbone.history.trigger('route', router, name, args);
                }
            });
            return this;
        },

        // Execute a route handler with the provided parameters.  This is an
        // excellent place to do pre-route setup or post-route cleanup.
        execute: function(callback, args, name) {
            if (callback) callback.apply(this, args);
        },

        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function(fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
        },

        // Bind all defined routes to `Backbone.history`. We have to reverse the
        // order of the routes here to support behavior where the most general
        // routes can be defined at the bottom of the route map.
        _bindRoutes: function() {
            if (!this.routes) return;
            this.routes = _.result(this, 'routes');
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },

        // Convert a route string into a regular expression, suitable for matching
        // against the current location hash.
        _routeToRegExp: function(route) {
            route = route.replace(escapeRegExp, '\\$&')
                .replace(optionalParam, '(?:$1)?')
                .replace(namedParam, function(match, optional) {
                    return optional ? match : '([^/?]+)';
                })
                .replace(splatParam, '([^?]*?)');
            return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },

        // Given a route, and a URL fragment that it matches, return the array of
        // extracted decoded parameters. Empty or unmatched parameters will be
        // treated as `null` to normalize cross-browser behavior.
        _extractParameters: function(route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function(param, i) {
                // Don't decode the search params.
                if (i === params.length - 1) return param || null;
                return param ? decodeURIComponent(param) : null;
            });
        }

    });

    // Backbone.History
    // ----------------

    // Handles cross-browser history management, based on either
    // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
    // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
    // and URL fragments. If the browser supports neither (old IE, natch),
    // falls back to polling.
    var History = Backbone.History = function() {
        this.handlers = [];
        this.checkUrl = _.bind(this.checkUrl, this);

        // Ensure that `History` can be used outside of the browser.
        if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
        }
    };

    // Cached regex for stripping a leading hash/slash and trailing space.
    var routeStripper = /^[#\/]|\s+$/g;

    // Cached regex for stripping leading and trailing slashes.
    var rootStripper = /^\/+|\/+$/g;

    // Cached regex for stripping urls of hash.
    var pathStripper = /#.*$/;

    // Has the history handling already been started?
    History.started = false;

    // Set up all inheritable **Backbone.History** properties and methods.
    _.extend(History.prototype, Events, {

        // The default interval to poll for hash changes, if necessary, is
        // twenty times a second.
        interval: 50,

        // Are we at the app root?
        atRoot: function() {
            var path = this.location.pathname.replace(/[^\/]$/, '$&/');
            return path === this.root && !this.getSearch();
        },

        // Does the pathname match the root?
        matchRoot: function() {
            var path = this.decodeFragment(this.location.pathname);
            var root = path.slice(0, this.root.length - 1) + '/';
            return root === this.root;
        },

        // Unicode characters in `location.pathname` are percent encoded so they're
        // decoded for comparison. `%25` should not be decoded since it may be part
        // of an encoded parameter.
        decodeFragment: function(fragment) {
            return decodeURI(fragment.replace(/%25/g, '%2525'));
        },

        // In IE6, the hash fragment and search params are incorrect if the
        // fragment contains `?`.
        getSearch: function() {
            var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
            return match ? match[0] : '';
        },

        // Gets the true hash value. Cannot use location.hash directly due to bug
        // in Firefox where location.hash will always be decoded.
        getHash: function(window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : '';
        },

        // Get the pathname and search params, without the root.
        getPath: function() {
            var path = this.decodeFragment(
                this.location.pathname + this.getSearch()
            ).slice(this.root.length - 1);
            return path.charAt(0) === '/' ? path.slice(1) : path;
        },

        // Get the cross-browser normalized URL fragment from the path or hash.
        getFragment: function(fragment) {
            if (fragment == null) {
                if (this._usePushState || !this._wantsHashChange) {
                    fragment = this.getPath();
                } else {
                    fragment = this.getHash();
                }
            }
            return fragment.replace(routeStripper, '');
        },

        // Start the hash change handling, returning `true` if the current URL matches
        // an existing route, and `false` otherwise.
        start: function(options) {
            if (History.started) throw new Error('Backbone.history has already been started');
            History.started = true;

            // Figure out the initial configuration. Do we need an iframe?
            // Is pushState desired ... is it available?
            this.options = _.extend({
                root: '/'
            }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._hasHashChange = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
            this._useHashChange = this._wantsHashChange && this._hasHashChange;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.history && this.history.pushState);
            this._usePushState = this._wantsPushState && this._hasPushState;
            this.fragment = this.getFragment();

            // Normalize root to always include a leading and trailing slash.
            this.root = ('/' + this.root + '/').replace(rootStripper, '/');

            // Transition from hashChange to pushState or vice versa if both are
            // requested.
            if (this._wantsHashChange && this._wantsPushState) {

                // If we've started off with a route from a `pushState`-enabled
                // browser, but we're currently in a browser that doesn't support it...
                if (!this._hasPushState && !this.atRoot()) {
                    var root = this.root.slice(0, -1) || '/';
                    this.location.replace(root + '#' + this.getPath());
                    // Return immediately as browser will do redirect to new url
                    return true;

                    // Or if we've started out with a hash-based route, but we're currently
                    // in a browser where it could be `pushState`-based instead...
                } else if (this._hasPushState && this.atRoot()) {
                    this.navigate(this.getHash(), {
                        replace: true
                    });
                }

            }

            // Proxy an iframe to handle location events if the browser doesn't
            // support the `hashchange` event, HTML5 history, or the user wants
            // `hashChange` but not `pushState`.
            if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
                this.iframe = document.createElement('iframe');
                this.iframe.src = 'javascript:0';
                this.iframe.style.display = 'none';
                this.iframe.tabIndex = -1;
                var body = document.body;
                // Using `appendChild` will throw on IE < 9 if the document is not ready.
                var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
                iWindow.document.open();
                iWindow.document.close();
                iWindow.location.hash = '#' + this.fragment;
            }

            // Add a cross-platform `addEventListener` shim for older browsers.
            var addEventListener = window.addEventListener || function(eventName, listener) {
                return attachEvent('on' + eventName, listener);
            };

            // Depending on whether we're using pushState or hashes, and whether
            // 'onhashchange' is supported, determine how we check the URL state.
            if (this._usePushState) {
                addEventListener('popstate', this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                addEventListener('hashchange', this.checkUrl, false);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }

            if (!this.options.silent) return this.loadUrl();
        },

        // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
        // but possibly useful for unit testing Routers.
        stop: function() {
            // Add a cross-platform `removeEventListener` shim for older browsers.
            var removeEventListener = window.removeEventListener || function(eventName, listener) {
                return detachEvent('on' + eventName, listener);
            };

            // Remove window listeners.
            if (this._usePushState) {
                removeEventListener('popstate', this.checkUrl, false);
            } else if (this._useHashChange && !this.iframe) {
                removeEventListener('hashchange', this.checkUrl, false);
            }

            // Clean up the iframe if necessary.
            if (this.iframe) {
                document.body.removeChild(this.iframe);
                this.iframe = null;
            }

            // Some environments will throw when clearing an undefined interval.
            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
            History.started = false;
        },

        // Add a route to be tested when the fragment changes. Routes added later
        // may override previous routes.
        route: function(route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },

        // Checks the current URL to see if it has changed, and if it has,
        // calls `loadUrl`, normalizing across the hidden iframe.
        checkUrl: function(e) {
            var current = this.getFragment();

            // If the user pressed the back button, the iframe's hash will have
            // changed and we should use that for comparison.
            if (current === this.fragment && this.iframe) {
                current = this.getHash(this.iframe.contentWindow);
            }

            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl();
        },

        // Attempt to load the current URL fragment. If a route succeeds with a
        // match, returns `true`. If no defined routes matches the fragment,
        // returns `false`.
        loadUrl: function(fragment) {
            // If the root doesn't match, no routes can match either.
            if (!this.matchRoot()) return false;
            fragment = this.fragment = this.getFragment(fragment);
            return _.some(this.handlers, function(handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
        },

        // Save a fragment into the hash history, or replace the URL state if the
        // 'replace' option is passed. You are responsible for properly URL-encoding
        // the fragment in advance.
        //
        // The options object can contain `trigger: true` if you wish to have the
        // route callback be fired (not usually desirable), or `replace: true`, if
        // you wish to modify the current URL without adding an entry to the history.
        navigate: function(fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = {
                trigger: !!options
            };

            // Normalize the fragment.
            fragment = this.getFragment(fragment || '');

            // Don't include a trailing slash on the root.
            var root = this.root;
            if (fragment === '' || fragment.charAt(0) === '?') {
                root = root.slice(0, -1) || '/';
            }
            var url = root + fragment;

            // Strip the hash and decode for matching.
            fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

            if (this.fragment === fragment) return;
            this.fragment = fragment;

            // If pushState is available, we use it to set the fragment as a real URL.
            if (this._usePushState) {
                this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

                // If hash changes haven't been explicitly disabled, update the hash
                // fragment to store history.
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && (fragment !== this.getHash(this.iframe.contentWindow))) {
                    var iWindow = this.iframe.contentWindow;

                    // Opening and closing the iframe tricks IE7 and earlier to push a
                    // history entry on hash-tag change.  When replace is true, we don't
                    // want this.
                    if (!options.replace) {
                        iWindow.document.open();
                        iWindow.document.close();
                    }

                    this._updateHash(iWindow.location, fragment, options.replace);
                }

                // If you've told us that you explicitly don't want fallback hashchange-
                // based history, then `navigate` becomes a page refresh.
            } else {
                return this.location.assign(url);
            }
            if (options.trigger) return this.loadUrl(fragment);
        },

        // Update the hash location, either replacing the current entry, or adding
        // a new one to the browser history.
        _updateHash: function(location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, '');
                location.replace(href + '#' + fragment);
            } else {
                // Some browsers require that `hash` contains a leading #.
                location.hash = '#' + fragment;
            }
        }

    });

    // Create the default Backbone.history.
    Backbone.history = new History;

    // Helpers
    // -------

    // Helper function to correctly set up the prototype chain for subclasses.
    // Similar to `goog.inherits`, but uses a hash of prototype properties and
    // class properties to be extended.
    var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;

        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent constructor.
        if (protoProps && _.has(protoProps, 'constructor')) {
            child = protoProps.constructor;
        } else {
            child = function() {
                return parent.apply(this, arguments);
            };
        }

        // Add static properties to the constructor function, if supplied.
        _.extend(child, parent, staticProps);

        // Set the prototype chain to inherit from `parent`, without calling
        // `parent` constructor function.
        var Surrogate = function() {
            this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate;

        // Add prototype properties (instance properties) to the subclass,
        // if supplied.
        if (protoProps) _.extend(child.prototype, protoProps);

        // Set a convenience property in case the parent's prototype is needed
        // later.
        child.__super__ = parent.prototype;

        return child;
    };

    // Set up inheritance for the model, collection, router, view and history.
    Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

    // Throw an error when a URL is needed, and none is supplied.
    var urlError = function() {
        throw new Error('A "url" property or function must be specified');
    };

    // Wrap an optional error callback with a fallback error event.
    var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
            if (error) error.call(options.context, model, resp, options);
            model.trigger('error', model, resp, options);
        };
    };

    return Backbone;

}));

(function(root, factory) {
    // Set up Backbone appropriately for the environment.
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['underscore', 'backbone', 'hammerjs'], function(_, Backbone) {
            factory(root, _, Backbone);
        });
    } else {
        // Browser globals
        factory(root, root._, root.Backbone);
    }
}(this, function(root, _, Backbone) {
    var $ = Backbone.$;

    if (!$.fn.hammer) {
        throw new Error('Hammer jQuery plugin not loaded.');
    }

    var delegateEventSplitter = /^(\S+)\s*(.*)$/;
    var viewOptions = ['hammerEvents', 'hammerOptions'];

    var View = Backbone.View;
    var delegateEvents = View.prototype.delegateEvents;
    var undelegateEvents = View.prototype.undelegateEvents;

    Backbone.View = View.extend({
        constructor: function(options) {
            options = options || {};
            _.extend(this, _.pick(options, viewOptions));
            return View.apply(this, arguments);
        },

        _hammered: false,

        undelegateEvents: function() {
            this.undelegateHammerEvents();
            return undelegateEvents.apply(this, arguments);
        },

        undelegateHammerEvents: function() {
            if (this._hammered) {
                this.hammer().off('.hammerEvents' + this.cid);
            }
            return this;
        },

        delegateEvents: function() {
            delegateEvents.apply(this, arguments);
            this.delegateHammerEvents();
            return this;
        },

        delegateHammerEvents: function(events) {
            var options = _.defaults(_.result(this, 'hammerOptions') || {}, Backbone.hammerOptions);
            if (!(events || (events = _.result(this, 'hammerEvents')))) return this;
            this.undelegateHammerEvents();
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) method = this[events[key]];
                if (!method) continue;

                var match = key.match(delegateEventSplitter);
                var eventName = match[1],
                    selector = match[2];
                eventName += '.hammerEvents' + this.cid;
                method = _.bind(method, this);
                if (selector === '') {
                    this.hammer(options).on(eventName, method);
                } else {
                    this.hammer(options).on(eventName, selector, method);
                }
            }
            return this;
        },

        hammer: function(options) {
            this._hammered = true;
            return this.$el.hammer(options);
        }
    });
}));

(function(_, Backbone, Mousetrap) {
    'use strict';

    var oldDelegateEvents = Backbone.View.prototype.delegateEvents;
    var oldUndelegateEvents = Backbone.View.prototype.undelegateEvents;
    var oldRemove = Backbone.View.prototype.remove;

    // Map from keyboard commands to the View instance that most recently bound each one.
    // so we can avoid accidentally unbinding keys when a view replaced a previous view's keybinding.
    var lastBound = {};

    _.extend(Backbone.View.prototype, {

        keyboardEvents: {},

        bindKeyboardEvents: function(events) {
            if (!(events || (events = _.result(this, 'keyboardEvents')))) return;
            for (var key in events) {
                var method = events[key];
                if (!_.isFunction(method)) method = this[events[key]];
                if (!method) throw new Error('Method "' + events[key] + '" does not exist');
                method = _.bind(method, this);

                // Use global-bind plugin when appropriate
                // https://github.com/ccampbell/mousetrap/tree/master/plugins/global-bind
                if ('bindGlobal' in Mousetrap && (key.indexOf('mod') !== -1 || key.indexOf('command') !== -1 || key.indexOf('ctrl') !== -1)) {
                    Mousetrap.bindGlobal(key, method);
                } else {
                    Mousetrap.bind(key, method);
                }
                lastBound[key] = this;
            }
            return this;
        },

        unbindKeyboardEvents: function() {
            for (var keys in this.keyboardEvents) {
                if (lastBound[keys] === this) {
                    Mousetrap.unbind(keys);
                    delete lastBound[keys];
                }
            }
            return this;
        },

        delegateEvents: function() {
            var ret = oldDelegateEvents.apply(this, arguments);
            this.bindKeyboardEvents();
            return ret;
        },

        undelegateEvents: function() {
            var ret = oldUndelegateEvents.apply(this, arguments);
            if (this.unbindKeyboardEvents) this.unbindKeyboardEvents();
            return ret;
        },

        remove: function() {
            var ret = oldRemove.apply(this, arguments);
            if (this.unbindKeyboardEvents) this.unbindKeyboardEvents();
            return ret;
        }

    });
})(_, Backbone, Mousetrap);

/*!
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */



var Hogan = {};

(function(Hogan, useArrayBuffer) {
    Hogan.Template = function(codeObj, text, compiler, options) {
        codeObj = codeObj || {};
        this.r = codeObj.code || this.r;
        this.c = compiler;
        this.options = options || {};
        this.text = text || '';
        this.partials = codeObj.partials || {};
        this.subs = codeObj.subs || {};
        this.ib();
    }

    Hogan.Template.prototype = {
        // render: replaced by generated code.
        r: function(context, partials, indent) {
            return '';
        },

        // variable escaping
        v: hoganEscape,

        // triple stache
        t: coerceToString,

        render: function render(context, partials, indent) {
            return this.ri([context], partials || {}, indent);
        },

        // render internal -- a hook for overrides that catches partials too
        ri: function(context, partials, indent) {
            return this.r(context, partials, indent);
        },

        // ensurePartial
        ep: function(symbol, partials) {
            var partial = this.partials[symbol];

            // check to see that if we've instantiated this partial before
            var template = partials[partial.name];
            if (partial.instance && partial.base == template) {
                return partial.instance;
            }

            if (typeof template == 'string') {
                if (!this.c) {
                    throw new Error("No compiler available.");
                }
                template = this.c.compile(template, this.options);
            }

            if (!template) {
                return null;
            }

            // We use this to check whether the partials dictionary has changed
            this.partials[symbol].base = template;

            if (partial.subs) {
                // Make sure we consider parent template now
                if (this.activeSub === undefined) {
                    // Store parent template text in partials.stackText to perform substitutions in child templates correctly
                    partials.stackText = this.text;
                }
                template = createSpecializedPartial(template, partial.subs, partial.partials,
                    this.stackSubs, this.stackPartials, partials.stackText || this.text);
            }
            this.partials[symbol].instance = template;

            return template;
        },

        // tries to find a partial in the current scope and render it
        rp: function(symbol, context, partials, indent) {
            var partial = this.ep(symbol, partials);
            if (!partial) {
                return '';
            }

            return partial.ri(context, partials, indent);
        },

        // render a section
        rs: function(context, partials, section) {
            var tail = context[context.length - 1];

            if (!isArray(tail)) {
                section(context, partials, this);
                return;
            }

            for (var i = 0; i < tail.length; i++) {
                context.push(tail[i]);
                section(context, partials, this);
                context.pop();
            }
        },

        // maybe start a section
        s: function(val, ctx, partials, inverted, start, end, tags) {
            var pass;

            if (isArray(val) && val.length === 0) {
                return false;
            }

            if (typeof val == 'function') {
                val = this.ms(val, ctx, partials, inverted, start, end, tags);
            }

            pass = !!val;

            if (!inverted && pass && ctx) {
                ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
            }

            return pass;
        },

        // find values with dotted names
        d: function(key, ctx, partials, returnFound) {
            var found,
                names = key.split('.'),
                val = this.f(names[0], ctx, partials, returnFound),
                doModelGet = this.options.modelGet,
                cx = null;

            if (key === '.' && isArray(ctx[ctx.length - 2])) {
                val = ctx[ctx.length - 1];
            } else {
                for (var i = 1; i < names.length; i++) {
                    found = findInScope(names[i], val, doModelGet);
                    if (found != null) {
                        cx = val;
                        val = found;
                    } else {
                        val = '';
                    }
                }
            }

            if (returnFound && !val) {
                return false;
            }

            if (!returnFound && typeof val == 'function') {
                ctx.push(cx);
                val = this.mv(val, ctx, partials);
                ctx.pop();
            }

            return val;
        },

        // find values with normal names
        f: function(key, ctx, partials, returnFound) {
            var val = false,
                v = null,
                found = false,
                doModelGet = this.options.modelGet;

            for (var i = ctx.length - 1; i >= 0; i--) {
                v = ctx[i];
                val = findInScope(key, v, doModelGet);
                if (val != null) {
                    found = true;
                    break;
                }
            }

            if (!found) {
                return (returnFound) ? false : "";
            }

            if (!returnFound && typeof val == 'function') {
                val = this.mv(val, ctx, partials);
            }

            return val;
        },

        // higher order templates
        ls: function(func, cx, partials, text, tags) {
            var oldTags = this.options.delimiters;

            this.options.delimiters = tags;
            this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
            this.options.delimiters = oldTags;

            return false;
        },

        // compile text
        ct: function(text, cx, partials) {
            if (this.options.disableLambda) {
                throw new Error('Lambda features disabled.');
            }
            return this.c.compile(text, this.options).render(cx, partials);
        },

        // template result buffering
        b: (useArrayBuffer) ? function(s) {
            this.buf.push(s);
        } : function(s) {
            this.buf += s;
        },

        fl: (useArrayBuffer) ? function() {
            var r = this.buf.join('');
            this.buf = [];
            return r;
        } : function() {
            var r = this.buf;
            this.buf = '';
            return r;
        },
        // init the buffer
        ib: function() {
            this.buf = (useArrayBuffer) ? [] : '';
        },

        // method replace section
        ms: function(func, ctx, partials, inverted, start, end, tags) {
            var textSource,
                cx = ctx[ctx.length - 1],
                result = func.call(cx);

            if (typeof result == 'function') {
                if (inverted) {
                    return true;
                } else {
                    textSource = (this.activeSub && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
                    return this.ls(result, cx, partials, textSource.substring(start, end), tags);
                }
            }

            return result;
        },

        // method replace variable
        mv: function(func, ctx, partials) {
            var cx = ctx[ctx.length - 1];
            var result = func.call(cx);

            if (typeof result == 'function') {
                return this.ct(coerceToString(result.call(cx)), cx, partials);
            }

            return result;
        },

        sub: function(name, context, partials, indent) {
            var f = this.subs[name];
            if (f) {
                this.activeSub = name;
                f(context, partials, this, indent);
                this.activeSub = false;
            }
        }

    };

    //Find a key in an object
    function findInScope(key, scope, doModelGet) {
        var val, checkVal;

        if (scope && typeof scope == 'object') {

            if (scope[key] != null) {
                val = scope[key];

                // try lookup with get for backbone or similar model data
            } else if (doModelGet && scope.get && typeof scope.get == 'function') {
                val = scope.get(key);
            }
        }

        return val;
    }

    function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, childText) {
        function PartialTemplate() {};
        PartialTemplate.prototype = instance;

        function Substitutions() {};
        Substitutions.prototype = instance.subs;
        var key;
        var partial = new PartialTemplate();
        partial.subs = new Substitutions();
        partial.subsText = {}; //hehe. substext.
        partial.ib();

        stackSubs = stackSubs || {};
        partial.stackSubs = stackSubs;
        for (key in subs) {
            if (!stackSubs[key]) stackSubs[key] = subs[key];
            partial.subsText[key] = childText;
        }
        for (key in stackSubs) {
            partial.subs[key] = stackSubs[key];
        }

        stackPartials = stackPartials || {};
        partial.stackPartials = stackPartials;
        for (key in partials) {
            if (!stackPartials[key]) stackPartials[key] = partials[key];
        }
        for (key in stackPartials) {
            partial.partials[key] = stackPartials[key];
        }

        return partial;
    }

    var rAmp = /&/g,
        rLt = /</g,
        rGt = />/g,
        rApos = /\'/g,
        rQuot = /\"/g,
        hChars = /[&<>\"\']/;

    function coerceToString(val) {
        return String((val === null || val === undefined) ? '' : val);
    }

    function hoganEscape(str) {
        str = coerceToString(str);
        return hChars.test(str) ?
            str
            .replace(rAmp, '&amp;')
            .replace(rLt, '&lt;')
            .replace(rGt, '&gt;')
            .replace(rApos, '&#39;')
            .replace(rQuot, '&quot;') :
            str;
    }

    var isArray = Array.isArray || function(a) {
        return Object.prototype.toString.call(a) === '[object Array]';
    };

})(typeof exports !== 'undefined' ? exports : Hogan);



(function(Hogan) {
    // Setup regex  assignments
    // remove whitespace according to Mustache spec
    var rIsWhitespace = /\S/,
        rQuot = /\"/g,
        rNewline = /\n/g,
        rCr = /\r/g,
        rSlash = /\\/g;

    Hogan.tags = {
        '#': 1,
        '^': 2,
        '<': 3,
        '$': 4,
        '/': 5,
        '!': 6,
        '>': 7,
        '=': 8,
        '_v': 9,
        '{': 10,
        '&': 11,
        '_t': 12
    };

    Hogan.scan = function scan(text, delimiters) {
        var len = text.length,
            IN_TEXT = 0,
            IN_TAG_TYPE = 1,
            IN_TAG = 2,
            state = IN_TEXT,
            tagType = null,
            tag = null,
            buf = '',
            tokens = [],
            seenTag = false,
            i = 0,
            lineStart = 0,
            otag = '{{',
            ctag = '}}';

        function addBuf() {
            if (buf.length > 0) {
                tokens.push({
                    tag: '_t',
                    text: new String(buf)
                });
                buf = '';
            }
        }

        function lineIsWhitespace() {
            var isAllWhitespace = true;
            for (var j = lineStart; j < tokens.length; j++) {
                isAllWhitespace =
                    (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||
                    (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);
                if (!isAllWhitespace) {
                    return false;
                }
            }

            return isAllWhitespace;
        }

        function filterLine(haveSeenTag, noNewLine) {
            addBuf();

            if (haveSeenTag && lineIsWhitespace()) {
                for (var j = lineStart, next; j < tokens.length; j++) {
                    if (tokens[j].text) {
                        if ((next = tokens[j + 1]) && next.tag == '>') {
                            // set indent to token value
                            next.indent = tokens[j].text.toString()
                        }
                        tokens.splice(j, 1);
                    }
                }
            } else if (!noNewLine) {
                tokens.push({
                    tag: '\n'
                });
            }

            seenTag = false;
            lineStart = tokens.length;
        }

        function changeDelimiters(text, index) {
            var close = '=' + ctag,
                closeIndex = text.indexOf(close, index),
                delimiters = trim(
                    text.substring(text.indexOf('=', index) + 1, closeIndex)
                ).split(' ');

            otag = delimiters[0];
            ctag = delimiters[delimiters.length - 1];

            return closeIndex + close.length - 1;
        }

        if (delimiters) {
            delimiters = delimiters.split(' ');
            otag = delimiters[0];
            ctag = delimiters[1];
        }

        for (i = 0; i < len; i++) {
            if (state == IN_TEXT) {
                if (tagChange(otag, text, i)) {
                    --i;
                    addBuf();
                    state = IN_TAG_TYPE;
                } else {
                    if (text.charAt(i) == '\n') {
                        filterLine(seenTag);
                    } else {
                        buf += text.charAt(i);
                    }
                }
            } else if (state == IN_TAG_TYPE) {
                i += otag.length - 1;
                tag = Hogan.tags[text.charAt(i + 1)];
                tagType = tag ? text.charAt(i + 1) : '_v';
                if (tagType == '=') {
                    i = changeDelimiters(text, i);
                    state = IN_TEXT;
                } else {
                    if (tag) {
                        i++;
                    }
                    state = IN_TAG;
                }
                seenTag = i;
            } else {
                if (tagChange(ctag, text, i)) {
                    tokens.push({
                        tag: tagType,
                        n: trim(buf),
                        otag: otag,
                        ctag: ctag,
                        i: (tagType == '/') ? seenTag - otag.length : i + ctag.length
                    });
                    buf = '';
                    i += ctag.length - 1;
                    state = IN_TEXT;
                    if (tagType == '{') {
                        if (ctag == '}}') {
                            i++;
                        } else {
                            cleanTripleStache(tokens[tokens.length - 1]);
                        }
                    }
                } else {
                    buf += text.charAt(i);
                }
            }
        }

        filterLine(seenTag, true);

        return tokens;
    }

    function cleanTripleStache(token) {
        if (token.n.substr(token.n.length - 1) === '}') {
            token.n = token.n.substring(0, token.n.length - 1);
        }
    }

    function trim(s) {
        if (s.trim) {
            return s.trim();
        }

        return s.replace(/^\s*|\s*$/g, '');
    }

    function tagChange(tag, text, index) {
        if (text.charAt(index) != tag.charAt(0)) {
            return false;
        }

        for (var i = 1, l = tag.length; i < l; i++) {
            if (text.charAt(index + i) != tag.charAt(i)) {
                return false;
            }
        }

        return true;
    }

    // the tags allowed inside super templates
    var allowedInSuper = {
        '_t': true,
        '\n': true,
        '$': true,
        '/': true
    };

    function buildTree(tokens, kind, stack, customTags) {
        var instructions = [],
            opener = null,
            tail = null,
            token = null;

        tail = stack[stack.length - 1];

        while (tokens.length > 0) {
            token = tokens.shift();

            if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {
                throw new Error('Illegal content in < super tag.');
            }

            if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {
                stack.push(token);
                token.nodes = buildTree(tokens, token.tag, stack, customTags);
            } else if (token.tag == '/') {
                if (stack.length === 0) {
                    throw new Error('Closing tag without opener: /' + token.n);
                }
                opener = stack.pop();
                if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
                    throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
                }
                opener.end = token.i;
                return instructions;
            } else if (token.tag == '\n') {
                token.last = (tokens.length == 0) || (tokens[0].tag == '\n');
            }

            instructions.push(token);
        }

        if (stack.length > 0) {
            throw new Error('missing closing tag: ' + stack.pop().n);
        }

        return instructions;
    }

    function isOpener(token, tags) {
        for (var i = 0, l = tags.length; i < l; i++) {
            if (tags[i].o == token.n) {
                token.tag = '#';
                return true;
            }
        }
    }

    function isCloser(close, open, tags) {
        for (var i = 0, l = tags.length; i < l; i++) {
            if (tags[i].c == close && tags[i].o == open) {
                return true;
            }
        }
    }

    function stringifySubstitutions(obj) {
        var items = [];
        for (var key in obj) {
            items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
        }
        return "{ " + items.join(",") + " }";
    }

    function stringifyPartials(codeObj) {
        var partials = [];
        for (var key in codeObj.partials) {
            partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
        }
        return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
    }

    Hogan.stringify = function(codeObj, text, options) {
        return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) + "}";
    }

    var serialNo = 0;
    Hogan.generate = function(tree, text, options) {
        serialNo = 0;
        var context = {
            code: '',
            subs: {},
            partials: {}
        };
        Hogan.walk(tree, context);

        if (options.asString) {
            return this.stringify(context, text, options);
        }

        return this.makeTemplate(context, text, options);
    }

    Hogan.wrapMain = function(code) {
        return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
    }

    Hogan.template = Hogan.Template;

    Hogan.makeTemplate = function(codeObj, text, options) {
        var template = this.makePartials(codeObj);
        template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));
        return new this.template(template, text, this, options);
    }

    Hogan.makePartials = function(codeObj) {
        var key, template = {
            subs: {},
            partials: codeObj.partials,
            name: codeObj.name
        };
        for (key in template.partials) {
            template.partials[key] = this.makePartials(template.partials[key]);
        }
        for (key in codeObj.subs) {
            template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);
        }
        return template;
    }

    function esc(s) {
        return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\"')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r');
    }

    function chooseMethod(s) {
        return (~s.indexOf('.')) ? 'd' : 'f';
    }

    function createPartial(node, context) {
        var prefix = "<" + (context.prefix || "");
        var sym = prefix + node.n + serialNo++;
        context.partials[sym] = {
            name: node.n,
            partials: {}
        };
        context.code += 't.b(t.rp("' + esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
        return sym;
    }

    Hogan.codegen = {
        '#': function(node, context) {
            context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + " " + node.ctag + '")){' +
                't.rs(c,p,' + 'function(c,p,t){';
            Hogan.walk(node.nodes, context);
            context.code += '});c.pop();}';
        },

        '^': function(node, context) {
            context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
            Hogan.walk(node.nodes, context);
            context.code += '};';
        },

        '>': createPartial,
        '<': function(node, context) {
            var ctx = {
                partials: {},
                code: '',
                subs: {},
                inPartial: true
            };
            Hogan.walk(node.nodes, ctx);
            var template = context.partials[createPartial(node, context)];
            template.subs = ctx.subs;
            template.partials = ctx.partials;
        },

        '$': function(node, context) {
            var ctx = {
                subs: {},
                code: '',
                partials: context.partials,
                prefix: node.n
            };
            Hogan.walk(node.nodes, ctx);
            context.subs[node.n] = ctx.code;
            if (!context.inPartial) {
                context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
            }
        },

        '\n': function(node, context) {
            context.code += write('"\\n"' + (node.last ? '' : ' + i'));
        },

        '_v': function(node, context) {
            context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
        },

        '_t': function(node, context) {
            context.code += write('"' + esc(node.text) + '"');
        },

        '{': tripleStache,

        '&': tripleStache
    }

    function tripleStache(node, context) {
        context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    }

    function write(s) {
        return 't.b(' + s + ');';
    }

    Hogan.walk = function(nodelist, context) {
        var func;
        for (var i = 0, l = nodelist.length; i < l; i++) {
            func = Hogan.codegen[nodelist[i].tag];
            func && func(nodelist[i], context);
        }
        return context;
    }

    Hogan.parse = function(tokens, text, options) {
        options = options || {};
        return buildTree(tokens, '', [], options.sectionTags || []);
    }

    Hogan.cache = {};

    Hogan.cacheKey = function(text, options) {
        return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
    }

    Hogan.compile = function(text, options) {
        options = options || {};
        var key = Hogan.cacheKey(text, options);
        var template = this.cache[key];

        if (template) {
            return template;
        }

        template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
        return this.cache[key] = template;
    }
})(typeof exports !== 'undefined' ? exports : Hogan);


/*! overthrow - An overflow:auto polyfill for responsive design. - v0.7.0 - 2013-11-04
 * Copyright (c) 2013 Scott Jehl, Filament Group, Inc.; Licensed MIT */
/*! Overthrow. An overflow:auto polyfill for responsive design. (c) 2012: Scott Jehl, Filament Group, Inc. http://filamentgroup.github.com/Overthrow/license.txt */
(function(w, undefined) {

    var doc = w.document,
        docElem = doc.documentElement,
        enabledClassName = "overthrow-enabled",

        // Touch events are used in the polyfill, and thus are a prerequisite
        canBeFilledWithPoly = "ontouchmove" in doc,

        // The following attempts to determine whether the browser has native overflow support
        // so we can enable it but not polyfill
        nativeOverflow =
        // Features-first. iOS5 overflow scrolling property check - no UA needed here. thanks Apple :)
        "WebkitOverflowScrolling" in docElem.style ||
        // Test the windows scrolling property as well
        "msOverflowStyle" in docElem.style ||
        // Touch events aren't supported and screen width is greater than X
        // ...basically, this is a loose "desktop browser" check. 
        // It may wrongly opt-in very large tablets with no touch support.
        (!canBeFilledWithPoly && w.screen.width > 800) ||
        // Hang on to your hats.
        // Whitelist some popular, overflow-supporting mobile browsers for now and the future
        // These browsers are known to get overlow support right, but give us no way of detecting it.
        (function() {
            var ua = w.navigator.userAgent,
                // Webkit crosses platforms, and the browsers on our list run at least version 534
                webkit = ua.match(/AppleWebKit\/([0-9]+)/),
                wkversion = webkit && webkit[1],
                wkLte534 = webkit && wkversion >= 534;

            return (
                /* Android 3+ with webkit gte 534
                ~: Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13 */
                ua.match(/Android ([0-9]+)/) && RegExp.$1 >= 3 && wkLte534 ||
                /* Blackberry 7+ with webkit gte 534
                ~: Mozilla/5.0 (BlackBerry; U; BlackBerry 9900; en-US) AppleWebKit/534.11+ (KHTML, like Gecko) Version/7.0.0 Mobile Safari/534.11+ */
                ua.match(/ Version\/([0-9]+)/) && RegExp.$1 >= 0 && w.blackberry && wkLte534 ||
                /* Blackberry Playbook with webkit gte 534
                ~: Mozilla/5.0 (PlayBook; U; RIM Tablet OS 1.0.0; en-US) AppleWebKit/534.8+ (KHTML, like Gecko) Version/0.0.1 Safari/534.8+ */
                ua.indexOf("PlayBook") > -1 && wkLte534 && !ua.indexOf("Android 2") === -1 ||
                /* Firefox Mobile (Fennec) 4 and up
                ~: Mozilla/5.0 (Mobile; rv:15.0) Gecko/15.0 Firefox/15.0 */
                ua.match(/Firefox\/([0-9]+)/) && RegExp.$1 >= 4 ||
                /* WebOS 3 and up (TouchPad too)
                ~: Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.48 Safari/534.6 TouchPad/1.0 */
                ua.match(/wOSBrowser\/([0-9]+)/) && RegExp.$1 >= 233 && wkLte534 ||
                /* Nokia Browser N8
                ~: Mozilla/5.0 (Symbian/3; Series60/5.2 NokiaN8-00/012.002; Profile/MIDP-2.1 Configuration/CLDC-1.1 ) AppleWebKit/533.4 (KHTML, like Gecko) NokiaBrowser/7.3.0 Mobile Safari/533.4 3gpp-gba 
                ~: Note: the N9 doesn't have native overflow with one-finger touch. wtf */
                ua.match(/NokiaBrowser\/([0-9\.]+)/) && parseFloat(RegExp.$1) === 7.3 && webkit && wkversion >= 533
            );
        })();

    // Expose overthrow API
    w.overthrow = {};

    w.overthrow.enabledClassName = enabledClassName;

    w.overthrow.addClass = function() {
        if (docElem.className.indexOf(w.overthrow.enabledClassName) === -1) {
            docElem.className += " " + w.overthrow.enabledClassName;
        }
    };

    w.overthrow.removeClass = function() {
        docElem.className = docElem.className.replace(w.overthrow.enabledClassName, "");
    };

    // Enable and potentially polyfill overflow
    w.overthrow.set = function() {

        // If nativeOverflow or at least the element canBeFilledWithPoly, add a class to cue CSS that assumes overflow scrolling will work (setting height on elements and such)
        if (nativeOverflow) {
            w.overthrow.addClass();
        }

    };

    // expose polyfillable 
    w.overthrow.canBeFilledWithPoly = canBeFilledWithPoly;

    // Destroy everything later. If you want to.
    w.overthrow.forget = function() {

        w.overthrow.removeClass();

    };

    // Expose overthrow API
    w.overthrow.support = nativeOverflow ? "native" : "none";

})(this);

/*! Overthrow. An overflow:auto polyfill for responsive design. (c) 2012: Scott Jehl, Filament Group, Inc. http://filamentgroup.github.com/Overthrow/license.txt */
(function(w, o, undefined) {

    // o is overthrow reference from overthrow-polyfill.js
    if (o === undefined) {
        return;
    }

    // Easing can use any of Robert Penner's equations (http://www.robertpenner.com/easing_terms_of_use.html). By default, overthrow includes ease-out-cubic
    // arguments: t = current iteration, b = initial value, c = end value, d = total iterations
    // use w.overthrow.easing to provide a custom function externally, or pass an easing function as a callback to the toss method
    o.easing = function(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
    };

    // tossing property is true during a programatic scroll
    o.tossing = false;

    // Keeper of intervals
    var timeKeeper;

    /* toss scrolls and element with easing

    // elem is the element to scroll
    // options hash:
    	* left is the desired horizontal scroll. Default is "+0". For relative distances, pass a string with "+" or "-" in front.
    	* top is the desired vertical scroll. Default is "+0". For relative distances, pass a string with "+" or "-" in front.
    	* duration is the number of milliseconds the throw will take. Default is 100.
    	* easing is an optional custom easing function. Default is w.overthrow.easing. Must follow the easing function signature

    */
    o.toss = function(elem, options) {
        o.intercept();
        var i = 0,
            sLeft = elem.scrollLeft,
            sTop = elem.scrollTop,
            // Toss defaults
            op = {
                top: "+0",
                left: "+0",
                duration: 50,
                easing: o.easing,
                finished: function() {}
            },
            endLeft, endTop, finished = false;

        // Mixin based on predefined defaults
        if (options) {
            for (var j in op) {
                if (options[j] !== undefined) {
                    op[j] = options[j];
                }
            }
        }

        // Convert relative values to ints
        // First the left val
        if (typeof op.left === "string") {
            op.left = parseFloat(op.left);
            endLeft = op.left + sLeft;
        } else {
            endLeft = op.left;
            op.left = op.left - sLeft;
        }
        // Then the top val
        if (typeof op.top === "string") {

            op.top = parseFloat(op.top);
            endTop = op.top + sTop;
        } else {
            endTop = op.top;
            op.top = op.top - sTop;
        }

        o.tossing = true;
        timeKeeper = setInterval(function() {
            if (i++ < op.duration) {
                elem.scrollLeft = op.easing(i, sLeft, op.left, op.duration);
                elem.scrollTop = op.easing(i, sTop, op.top, op.duration);
            } else {
                if (endLeft !== elem.scrollLeft) {
                    elem.scrollLeft = endLeft;
                } else {
                    // if the end of the vertical scrolling has taken place
                    // we know that we're done here call the callback
                    // otherwise signal that horizontal scrolling is complete
                    if (finished) {
                        op.finished();
                    }
                    finished = true;
                }

                if (endTop !== elem.scrollTop) {
                    elem.scrollTop = endTop;
                } else {
                    // if the end of the horizontal scrolling has taken place
                    // we know that we're done here call the callback
                    if (finished) {
                        op.finished();
                    }
                    finished = true;
                }

                o.intercept();
            }
        }, 1);

        // Return the values, post-mixin, with end values specified
        return {
            top: endTop,
            left: endLeft,
            duration: o.duration,
            easing: o.easing
        };
    };

    // Intercept any throw in progress
    o.intercept = function() {
        clearInterval(timeKeeper);
        o.tossing = false;
    };

})(this, this.overthrow);

/*! Overthrow. An overflow:auto polyfill for responsive design. (c) 2012: Scott Jehl, Filament Group, Inc. http://filamentgroup.github.com/Overthrow/license.txt */
(function(w, o, undefined) {

    // o is overthrow reference from overthrow-polyfill.js
    if (o === undefined) {
        return;
    }

    o.scrollIndicatorClassName = "overthrow";

    var doc = w.document,
        docElem = doc.documentElement,
        // o api
        nativeOverflow = o.support === "native",
        canBeFilledWithPoly = o.canBeFilledWithPoly,
        configure = o.configure,
        set = o.set,
        forget = o.forget,
        scrollIndicatorClassName = o.scrollIndicatorClassName;

    // find closest overthrow (elem or a parent)
    o.closest = function(target, ascend) {
        return !ascend && target.className && target.className.indexOf(scrollIndicatorClassName) > -1 && target || o.closest(target.parentNode);
    };

    // polyfill overflow
    var enabled = false;
    o.set = function() {

        set();

        // If nativeOverflow or it doesn't look like the browser canBeFilledWithPoly, our job is done here. Exit viewport left.
        if (enabled || nativeOverflow || !canBeFilledWithPoly) {
            return;
        }

        w.overthrow.addClass();

        enabled = true;

        o.support = "polyfilled";

        o.forget = function() {
            forget();
            enabled = false;
            // Remove touch binding (check for method support since this part isn't qualified by touch support like the rest)
            if (doc.removeEventListener) {
                doc.removeEventListener("touchstart", start, false);
            }
        };

        // Fill 'er up!
        // From here down, all logic is associated with touch scroll handling
        // elem references the overthrow element in use
        var elem,

            // The last several Y values are kept here
            lastTops = [],

            // The last several X values are kept here
            lastLefts = [],

            // lastDown will be true if the last scroll direction was down, false if it was up
            lastDown,

            // lastRight will be true if the last scroll direction was right, false if it was left
            lastRight,

            // For a new gesture, or change in direction, reset the values from last scroll
            resetVertTracking = function() {
                lastTops = [];
                lastDown = null;
            },

            resetHorTracking = function() {
                lastLefts = [];
                lastRight = null;
            },

            // On webkit, touch events hardly trickle through textareas and inputs
            // Disabling CSS pointer events makes sure they do, but it also makes the controls innaccessible
            // Toggling pointer events at the right moments seems to do the trick
            // Thanks Thomas Bachem http://stackoverflow.com/a/5798681 for the following
            inputs,
            setPointers = function(val) {
                inputs = elem.querySelectorAll("textarea, input");
                for (var i = 0, il = inputs.length; i < il; i++) {
                    inputs[i].style.pointerEvents = val;
                }
            },

            // For nested overthrows, changeScrollTarget restarts a touch event cycle on a parent or child overthrow
            changeScrollTarget = function(startEvent, ascend) {
                if (doc.createEvent) {
                    var newTarget = (!ascend || ascend === undefined) && elem.parentNode || elem.touchchild || elem,
                        tEnd;

                    if (newTarget !== elem) {
                        tEnd = doc.createEvent("HTMLEvents");
                        tEnd.initEvent("touchend", true, true);
                        elem.dispatchEvent(tEnd);
                        newTarget.touchchild = elem;
                        elem = newTarget;
                        newTarget.dispatchEvent(startEvent);
                    }
                }
            },

            // Touchstart handler
            // On touchstart, touchmove and touchend are freshly bound, and all three share a bunch of vars set by touchstart
            // Touchend unbinds them again, until next time
            start = function(e) {

                // Stop any throw in progress
                if (o.intercept) {
                    o.intercept();
                }

                // Reset the distance and direction tracking
                resetVertTracking();
                resetHorTracking();

                elem = o.closest(e.target);

                if (!elem || elem === docElem || e.touches.length > 1) {
                    return;
                }

                setPointers("none");
                var touchStartE = e,
                    scrollT = elem.scrollTop,
                    scrollL = elem.scrollLeft,
                    height = elem.offsetHeight,
                    width = elem.offsetWidth,
                    startY = e.touches[0].pageY,
                    startX = e.touches[0].pageX,
                    scrollHeight = elem.scrollHeight,
                    scrollWidth = elem.scrollWidth,

                    // Touchmove handler
                    move = function(e) {

                        var ty = scrollT + startY - e.touches[0].pageY,
                            tx = scrollL + startX - e.touches[0].pageX,
                            down = ty >= (lastTops.length ? lastTops[0] : 0),
                            right = tx >= (lastLefts.length ? lastLefts[0] : 0);

                        // If there's room to scroll the current container, prevent the default window scroll
                        if ((ty > 0 && ty < scrollHeight - height) || (tx > 0 && tx < scrollWidth - width)) {
                            e.preventDefault();
                        }
                        // This bubbling is dumb. Needs a rethink.
                        else {
                            changeScrollTarget(touchStartE);
                        }

                        // If down and lastDown are inequal, the y scroll has changed direction. Reset tracking.
                        if (lastDown && down !== lastDown) {
                            resetVertTracking();
                        }

                        // If right and lastRight are inequal, the x scroll has changed direction. Reset tracking.
                        if (lastRight && right !== lastRight) {
                            resetHorTracking();
                        }

                        // remember the last direction in which we were headed
                        lastDown = down;
                        lastRight = right;

                        // set the container's scroll
                        elem.scrollTop = ty;
                        elem.scrollLeft = tx;

                        lastTops.unshift(ty);
                        lastLefts.unshift(tx);

                        if (lastTops.length > 3) {
                            lastTops.pop();
                        }
                        if (lastLefts.length > 3) {
                            lastLefts.pop();
                        }
                    },

                    // Touchend handler
                    end = function(e) {

                        // Bring the pointers back
                        setPointers("auto");
                        setTimeout(function() {
                            setPointers("none");
                        }, 450);
                        elem.removeEventListener("touchmove", move, false);
                        elem.removeEventListener("touchend", end, false);
                    };

                elem.addEventListener("touchmove", move, false);
                elem.addEventListener("touchend", end, false);
            };

        // Bind to touch, handle move and end within
        doc.addEventListener("touchstart", start, false);
    };

})(this, this.overthrow);

/*! Overthrow. An overflow:auto polyfill for responsive design. (c) 2012: Scott Jehl, Filament Group, Inc. http://filamentgroup.github.com/Overthrow/license.txt */
(function(w, undefined) {

    // Auto-init
    w.overthrow.set();

}(this));
/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.2
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */


(function() {

    "use strict";

    //Declare root variable - window in the browser, global on the server
    var root = this,
        previous = root.Chart;

    //Occupy the global variable of Chart, and create a simple base class
    var Chart = function(context) {
        var chart = this;
        this.canvas = context.canvas;

        this.ctx = context;

        //Variables global to the chart
        var computeDimension = function(element, dimension) {
            if (element['offset' + dimension]) {
                return element['offset' + dimension];
            } else {
                return document.defaultView.getComputedStyle(element).getPropertyValue(dimension);
            }
        };

        var width = this.width = computeDimension(context.canvas, 'Width') || context.canvas.width;
        var height = this.height = computeDimension(context.canvas, 'Height') || context.canvas.height;

        // Firefox requires this to work correctly
        context.canvas.width = width;
        context.canvas.height = height;

        width = this.width = context.canvas.width;
        height = this.height = context.canvas.height;
        this.aspectRatio = this.width / this.height;
        //High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.
        helpers.retinaScale(this);

        return this;
    };
    //Globally expose the defaults to allow for user updating/changing
    Chart.defaults = {
        global: {
            // Boolean - Whether to animate the chart
            animation: true,

            // Number - Number of animation steps
            animationSteps: 60,

            // String - Animation easing effect
            animationEasing: "easeOutQuart",

            // Boolean - If we should show the scale at all
            showScale: true,

            // Boolean - If we want to override with a hard coded scale
            scaleOverride: false,

            // ** Required if scaleOverride is true **
            // Number - The number of steps in a hard coded scale
            scaleSteps: null,
            // Number - The value jump in the hard coded scale
            scaleStepWidth: null,
            // Number - The scale starting value
            scaleStartValue: null,

            // String - Colour of the scale line
            scaleLineColor: "rgba(0,0,0,.1)",

            // Number - Pixel width of the scale line
            scaleLineWidth: 1,

            // Boolean - Whether to show labels on the scale
            scaleShowLabels: true,

            // Interpolated JS string - can access value
            scaleLabel: "<%=value%>",

            // Boolean - Whether the scale should stick to integers, and not show any floats even if drawing space is there
            scaleIntegersOnly: true,

            // Boolean - Whether the scale should start at zero, or an order of magnitude down from the lowest value
            scaleBeginAtZero: false,

            // String - Scale label font declaration for the scale label
            scaleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

            // Number - Scale label font size in pixels
            scaleFontSize: 12,

            // String - Scale label font weight style
            scaleFontStyle: "normal",

            // String - Scale label font colour
            scaleFontColor: "#666",

            // Boolean - whether or not the chart should be responsive and resize when the browser does.
            responsive: false,

            // Boolean - whether to maintain the starting aspect ratio or not when responsive, if set to false, will take up entire container
            maintainAspectRatio: true,

            // Boolean - Determines whether to draw tooltips on the canvas or not - attaches events to touchmove & mousemove
            showTooltips: true,

            // Boolean - Determines whether to draw built-in tooltip or call custom tooltip function
            customTooltips: false,

            // Array - Array of string names to attach tooltip events
            tooltipEvents: ["mousemove", "touchstart", "touchmove", "mouseout"],

            // String - Tooltip background colour
            tooltipFillColor: "rgba(0,0,0,0.8)",

            // String - Tooltip label font declaration for the scale label
            tooltipFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

            // Number - Tooltip label font size in pixels
            tooltipFontSize: 14,

            // String - Tooltip font weight style
            tooltipFontStyle: "normal",

            // String - Tooltip label font colour
            tooltipFontColor: "#fff",

            // String - Tooltip title font declaration for the scale label
            tooltipTitleFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

            // Number - Tooltip title font size in pixels
            tooltipTitleFontSize: 14,

            // String - Tooltip title font weight style
            tooltipTitleFontStyle: "bold",

            // String - Tooltip title font colour
            tooltipTitleFontColor: "#fff",

            // Number - pixel width of padding around tooltip text
            tooltipYPadding: 6,

            // Number - pixel width of padding around tooltip text
            tooltipXPadding: 6,

            // Number - Size of the caret on the tooltip
            tooltipCaretSize: 8,

            // Number - Pixel radius of the tooltip border
            tooltipCornerRadius: 6,

            // Number - Pixel offset from point x to tooltip edge
            tooltipXOffset: 10,

            // String - Template string for single tooltips
            tooltipTemplate: "<%if (label){%><%=label%>: <%}%><%= value %>",

            // String - Template string for single tooltips
            multiTooltipTemplate: "<%= value %>",

            // String - Colour behind the legend colour block
            multiTooltipKeyBackground: '#fff',

            // Function - Will fire on animation progression.
            onAnimationProgress: function() {},

            // Function - Will fire on animation completion.
            onAnimationComplete: function() {}

        }
    };

    //Create a dictionary of chart types, to allow for extension of existing types
    Chart.types = {};

    //Global Chart helpers object for utility methods and classes
    var helpers = Chart.helpers = {};

    //-- Basic js utility methods
    var each = helpers.each = function(loopable, callback, self) {
            var additionalArgs = Array.prototype.slice.call(arguments, 3);
            // Check to see if null or undefined firstly.
            if (loopable) {
                if (loopable.length === +loopable.length) {
                    var i;
                    for (i = 0; i < loopable.length; i++) {
                        callback.apply(self, [loopable[i], i].concat(additionalArgs));
                    }
                } else {
                    for (var item in loopable) {
                        callback.apply(self, [loopable[item], item].concat(additionalArgs));
                    }
                }
            }
        },
        clone = helpers.clone = function(obj) {
            var objClone = {};
            each(obj, function(value, key) {
                if (obj.hasOwnProperty(key)) {
                    objClone[key] = value;
                }
            });
            return objClone;
        },
        extend = helpers.extend = function(base) {
            each(Array.prototype.slice.call(arguments, 1), function(extensionObject) {
                each(extensionObject, function(value, key) {
                    if (extensionObject.hasOwnProperty(key)) {
                        base[key] = value;
                    }
                });
            });
            return base;
        },
        merge = helpers.merge = function(base, master) {
            //Merge properties in left object over to a shallow clone of object right.
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift({});
            return extend.apply(null, args);
        },
        indexOf = helpers.indexOf = function(arrayToSearch, item) {
            if (Array.prototype.indexOf) {
                return arrayToSearch.indexOf(item);
            } else {
                for (var i = 0; i < arrayToSearch.length; i++) {
                    if (arrayToSearch[i] === item) return i;
                }
                return -1;
            }
        },
        where = helpers.where = function(collection, filterCallback) {
            var filtered = [];

            helpers.each(collection, function(item) {
                if (filterCallback(item)) {
                    filtered.push(item);
                }
            });

            return filtered;
        },
        findNextWhere = helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
            // Default to start of the array
            if (!startIndex) {
                startIndex = -1;
            }
            for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
                var currentItem = arrayToSearch[i];
                if (filterCallback(currentItem)) {
                    return currentItem;
                }
            }
        },
        findPreviousWhere = helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
            // Default to end of the array
            if (!startIndex) {
                startIndex = arrayToSearch.length;
            }
            for (var i = startIndex - 1; i >= 0; i--) {
                var currentItem = arrayToSearch[i];
                if (filterCallback(currentItem)) {
                    return currentItem;
                }
            }
        },
        inherits = helpers.inherits = function(extensions) {
            //Basic javascript inheritance based on the model created in Backbone.js
            var parent = this;
            var ChartElement = (extensions && extensions.hasOwnProperty("constructor")) ? extensions.constructor : function() {
                return parent.apply(this, arguments);
            };

            var Surrogate = function() {
                this.constructor = ChartElement;
            };
            Surrogate.prototype = parent.prototype;
            ChartElement.prototype = new Surrogate();

            ChartElement.extend = inherits;

            if (extensions) extend(ChartElement.prototype, extensions);

            ChartElement.__super__ = parent.prototype;

            return ChartElement;
        },
        noop = helpers.noop = function() {},
        uid = helpers.uid = (function() {
            var id = 0;
            return function() {
                return "chart-" + id++;
            };
        })(),
        warn = helpers.warn = function(str) {
            //Method for warning of errors
            if (window.console && typeof window.console.warn === "function") console.warn(str);
        },
        amd = helpers.amd = (typeof define === 'function' && define.amd),
        //-- Math methods
        isNumber = helpers.isNumber = function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        },
        max = helpers.max = function(array) {
            return Math.max.apply(Math, array);
        },
        min = helpers.min = function(array) {
            return Math.min.apply(Math, array);
        },
        cap = helpers.cap = function(valueToCap, maxValue, minValue) {
            if (isNumber(maxValue)) {
                if (valueToCap > maxValue) {
                    return maxValue;
                }
            } else if (isNumber(minValue)) {
                if (valueToCap < minValue) {
                    return minValue;
                }
            }
            return valueToCap;
        },
        getDecimalPlaces = helpers.getDecimalPlaces = function(num) {
            if (num % 1 !== 0 && isNumber(num)) {
                var s = num.toString();
                if (s.indexOf("e-") < 0) {
                    // no exponent, e.g. 0.01
                    return s.split(".")[1].length;
                } else if (s.indexOf(".") < 0) {
                    // no decimal point, e.g. 1e-9
                    return parseInt(s.split("e-")[1]);
                } else {
                    // exponent and decimal point, e.g. 1.23e-9
                    var parts = s.split(".")[1].split("e-");
                    return parts[0].length + parseInt(parts[1]);
                }
            } else {
                return 0;
            }
        },
        toRadians = helpers.radians = function(degrees) {
            return degrees * (Math.PI / 180);
        },
        // Gets the angle from vertical upright to the point about a centre.
        getAngleFromPoint = helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
            var distanceFromXCenter = anglePoint.x - centrePoint.x,
                distanceFromYCenter = anglePoint.y - centrePoint.y,
                radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);


            var angle = Math.PI * 2 + Math.atan2(distanceFromYCenter, distanceFromXCenter);

            //If the segment is in the top left quadrant, we need to add another rotation to the angle
            if (distanceFromXCenter < 0 && distanceFromYCenter < 0) {
                angle += Math.PI * 2;
            }

            return {
                angle: angle,
                distance: radialDistanceFromCenter
            };
        },
        aliasPixel = helpers.aliasPixel = function(pixelWidth) {
            return (pixelWidth % 2 === 0) ? 0 : 0.5;
        },
        splineCurve = helpers.splineCurve = function(FirstPoint, MiddlePoint, AfterPoint, t) {
            //Props to Rob Spencer at scaled innovation for his post on splining between points
            //http://scaledinnovation.com/analytics/splines/aboutSplines.html
            var d01 = Math.sqrt(Math.pow(MiddlePoint.x - FirstPoint.x, 2) + Math.pow(MiddlePoint.y - FirstPoint.y, 2)),
                d12 = Math.sqrt(Math.pow(AfterPoint.x - MiddlePoint.x, 2) + Math.pow(AfterPoint.y - MiddlePoint.y, 2)),
                fa = t * d01 / (d01 + d12), // scaling factor for triangle Ta
                fb = t * d12 / (d01 + d12);
            return {
                inner: {
                    x: MiddlePoint.x - fa * (AfterPoint.x - FirstPoint.x),
                    y: MiddlePoint.y - fa * (AfterPoint.y - FirstPoint.y)
                },
                outer: {
                    x: MiddlePoint.x + fb * (AfterPoint.x - FirstPoint.x),
                    y: MiddlePoint.y + fb * (AfterPoint.y - FirstPoint.y)
                }
            };
        },
        calculateOrderOfMagnitude = helpers.calculateOrderOfMagnitude = function(val) {
            return Math.floor(Math.log(val) / Math.LN10);
        },
        calculateScaleRange = helpers.calculateScaleRange = function(valuesArray, drawingSize, textSize, startFromZero, integersOnly) {

            //Set a minimum step of two - a point at the top of the graph, and a point at the base
            var minSteps = 2,
                maxSteps = Math.floor(drawingSize / (textSize * 1.5)),
                skipFitting = (minSteps >= maxSteps);

            var maxValue = max(valuesArray),
                minValue = min(valuesArray);

            // We need some degree of separation here to calculate the scales if all the values are the same
            // Adding/minusing 0.5 will give us a range of 1.
            if (maxValue === minValue) {
                maxValue += 0.5;
                // So we don't end up with a graph with a negative start value if we've said always start from zero
                if (minValue >= 0.5 && !startFromZero) {
                    minValue -= 0.5;
                } else {
                    // Make up a whole number above the values
                    maxValue += 0.5;
                }
            }

            var valueRange = Math.abs(maxValue - minValue),
                rangeOrderOfMagnitude = calculateOrderOfMagnitude(valueRange),
                graphMax = Math.ceil(maxValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude),
                graphMin = (startFromZero) ? 0 : Math.floor(minValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude),
                graphRange = graphMax - graphMin,
                stepValue = Math.pow(10, rangeOrderOfMagnitude),
                numberOfSteps = Math.round(graphRange / stepValue);

            //If we have more space on the graph we'll use it to give more definition to the data
            while ((numberOfSteps > maxSteps || (numberOfSteps * 2) < maxSteps) && !skipFitting) {
                if (numberOfSteps > maxSteps) {
                    stepValue *= 2;
                    numberOfSteps = Math.round(graphRange / stepValue);
                    // Don't ever deal with a decimal number of steps - cancel fitting and just use the minimum number of steps.
                    if (numberOfSteps % 1 !== 0) {
                        skipFitting = true;
                    }
                }
                //We can fit in double the amount of scale points on the scale
                else {
                    //If user has declared ints only, and the step value isn't a decimal
                    if (integersOnly && rangeOrderOfMagnitude >= 0) {
                        //If the user has said integers only, we need to check that making the scale more granular wouldn't make it a float
                        if (stepValue / 2 % 1 === 0) {
                            stepValue /= 2;
                            numberOfSteps = Math.round(graphRange / stepValue);
                        }
                        //If it would make it a float break out of the loop
                        else {
                            break;
                        }
                    }
                    //If the scale doesn't have to be an int, make the scale more granular anyway.
                    else {
                        stepValue /= 2;
                        numberOfSteps = Math.round(graphRange / stepValue);
                    }

                }
            }

            if (skipFitting) {
                numberOfSteps = minSteps;
                stepValue = graphRange / numberOfSteps;
            }

            return {
                steps: numberOfSteps,
                stepValue: stepValue,
                min: graphMin,
                max: graphMin + (numberOfSteps * stepValue)
            };

        },
        /* jshint ignore:start */
        // Blows up jshint errors based on the new Function constructor
        //Templating methods
        //Javascript micro templating by John Resig - source at http://ejohn.org/blog/javascript-micro-templating/
        template = helpers.template = function(templateString, valuesObject) {

            // If templateString is function rather than string-template - call the function for valuesObject

            if (templateString instanceof Function) {
                return templateString(valuesObject);
            }

            var cache = {};

            function tmpl(str, data) {
                // Figure out if we're getting a template, or if we need to
                // load the template - and be sure to cache the result.
                var fn = !/\W/.test(str) ?
                    cache[str] = cache[str] :

                    // Generate a reusable function that will serve as a template
                    // generator (and which will be cached).
                    new Function("obj",
                        "var p=[],print=function(){p.push.apply(p,arguments);};" +

                        // Introduce the data as local variables using with(){}
                        "with(obj){p.push('" +

                        // Convert the template into pure JavaScript
                        str
                        .replace(/[\r\t\n]/g, " ")
                        .split("<%").join("\t")
                        .replace(/((^|%>)[^\t]*)'/g, "$1\r")
                        .replace(/\t=(.*?)%>/g, "',$1,'")
                        .split("\t").join("');")
                        .split("%>").join("p.push('")
                        .split("\r").join("\\'") +
                        "');}return p.join('');"
                    );

                // Provide some basic currying to the user
                return data ? fn(data) : fn;
            }
            return tmpl(templateString, valuesObject);
        },
        /* jshint ignore:end */
        generateLabels = helpers.generateLabels = function(templateString, numberOfSteps, graphMin, stepValue) {
            var labelsArray = new Array(numberOfSteps);
            if (templateString) {
                each(labelsArray, function(val, index) {
                    labelsArray[index] = template(templateString, {
                        value: (graphMin + (stepValue * (index + 1)))
                    });
                });
            }
            return labelsArray;
        },
        //--Animation methods
        //Easing functions adapted from Robert Penner's easing equations
        //http://www.robertpenner.com/easing/
        easingEffects = helpers.easingEffects = {
            linear: function(t) {
                return t;
            },
            easeInQuad: function(t) {
                return t * t;
            },
            easeOutQuad: function(t) {
                return -1 * t * (t - 2);
            },
            easeInOutQuad: function(t) {
                if ((t /= 1 / 2) < 1) {
                    return 1 / 2 * t * t;
                }
                return -1 / 2 * ((--t) * (t - 2) - 1);
            },
            easeInCubic: function(t) {
                return t * t * t;
            },
            easeOutCubic: function(t) {
                return 1 * ((t = t / 1 - 1) * t * t + 1);
            },
            easeInOutCubic: function(t) {
                if ((t /= 1 / 2) < 1) {
                    return 1 / 2 * t * t * t;
                }
                return 1 / 2 * ((t -= 2) * t * t + 2);
            },
            easeInQuart: function(t) {
                return t * t * t * t;
            },
            easeOutQuart: function(t) {
                return -1 * ((t = t / 1 - 1) * t * t * t - 1);
            },
            easeInOutQuart: function(t) {
                if ((t /= 1 / 2) < 1) {
                    return 1 / 2 * t * t * t * t;
                }
                return -1 / 2 * ((t -= 2) * t * t * t - 2);
            },
            easeInQuint: function(t) {
                return 1 * (t /= 1) * t * t * t * t;
            },
            easeOutQuint: function(t) {
                return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
            },
            easeInOutQuint: function(t) {
                if ((t /= 1 / 2) < 1) {
                    return 1 / 2 * t * t * t * t * t;
                }
                return 1 / 2 * ((t -= 2) * t * t * t * t + 2);
            },
            easeInSine: function(t) {
                return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
            },
            easeOutSine: function(t) {
                return 1 * Math.sin(t / 1 * (Math.PI / 2));
            },
            easeInOutSine: function(t) {
                return -1 / 2 * (Math.cos(Math.PI * t / 1) - 1);
            },
            easeInExpo: function(t) {
                return (t === 0) ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
            },
            easeOutExpo: function(t) {
                return (t === 1) ? 1 : 1 * (-Math.pow(2, -10 * t / 1) + 1);
            },
            easeInOutExpo: function(t) {
                if (t === 0) {
                    return 0;
                }
                if (t === 1) {
                    return 1;
                }
                if ((t /= 1 / 2) < 1) {
                    return 1 / 2 * Math.pow(2, 10 * (t - 1));
                }
                return 1 / 2 * (-Math.pow(2, -10 * --t) + 2);
            },
            easeInCirc: function(t) {
                if (t >= 1) {
                    return t;
                }
                return -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
            },
            easeOutCirc: function(t) {
                return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
            },
            easeInOutCirc: function(t) {
                if ((t /= 1 / 2) < 1) {
                    return -1 / 2 * (Math.sqrt(1 - t * t) - 1);
                }
                return 1 / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1);
            },
            easeInElastic: function(t) {
                var s = 1.70158;
                var p = 0;
                var a = 1;
                if (t === 0) {
                    return 0;
                }
                if ((t /= 1) == 1) {
                    return 1;
                }
                if (!p) {
                    p = 1 * 0.3;
                }
                if (a < Math.abs(1)) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p / (2 * Math.PI) * Math.asin(1 / a);
                }
                return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
            },
            easeOutElastic: function(t) {
                var s = 1.70158;
                var p = 0;
                var a = 1;
                if (t === 0) {
                    return 0;
                }
                if ((t /= 1) == 1) {
                    return 1;
                }
                if (!p) {
                    p = 1 * 0.3;
                }
                if (a < Math.abs(1)) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p / (2 * Math.PI) * Math.asin(1 / a);
                }
                return a * Math.pow(2, -10 * t) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) + 1;
            },
            easeInOutElastic: function(t) {
                var s = 1.70158;
                var p = 0;
                var a = 1;
                if (t === 0) {
                    return 0;
                }
                if ((t /= 1 / 2) == 2) {
                    return 1;
                }
                if (!p) {
                    p = 1 * (0.3 * 1.5);
                }
                if (a < Math.abs(1)) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p / (2 * Math.PI) * Math.asin(1 / a);
                }
                if (t < 1) {
                    return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p));
                }
                return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * 1 - s) * (2 * Math.PI) / p) * 0.5 + 1;
            },
            easeInBack: function(t) {
                var s = 1.70158;
                return 1 * (t /= 1) * t * ((s + 1) * t - s);
            },
            easeOutBack: function(t) {
                var s = 1.70158;
                return 1 * ((t = t / 1 - 1) * t * ((s + 1) * t + s) + 1);
            },
            easeInOutBack: function(t) {
                var s = 1.70158;
                if ((t /= 1 / 2) < 1) {
                    return 1 / 2 * (t * t * (((s *= (1.525)) + 1) * t - s));
                }
                return 1 / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
            },
            easeInBounce: function(t) {
                return 1 - easingEffects.easeOutBounce(1 - t);
            },
            easeOutBounce: function(t) {
                if ((t /= 1) < (1 / 2.75)) {
                    return 1 * (7.5625 * t * t);
                } else if (t < (2 / 2.75)) {
                    return 1 * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75);
                } else if (t < (2.5 / 2.75)) {
                    return 1 * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375);
                } else {
                    return 1 * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375);
                }
            },
            easeInOutBounce: function(t) {
                if (t < 1 / 2) {
                    return easingEffects.easeInBounce(t * 2) * 0.5;
                }
                return easingEffects.easeOutBounce(t * 2 - 1) * 0.5 + 1 * 0.5;
            }
        },
        //Request animation polyfill - http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
        requestAnimFrame = helpers.requestAnimFrame = (function() {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(callback) {
                    return window.setTimeout(callback, 1000 / 60);
                };
        })(),
        cancelAnimFrame = helpers.cancelAnimFrame = (function() {
            return window.cancelAnimationFrame ||
                window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                window.oCancelAnimationFrame ||
                window.msCancelAnimationFrame ||
                function(callback) {
                    return window.clearTimeout(callback, 1000 / 60);
                };
        })(),
        animationLoop = helpers.animationLoop = function(callback, totalSteps, easingString, onProgress, onComplete, chartInstance) {

            var currentStep = 0,
                easingFunction = easingEffects[easingString] || easingEffects.linear;

            var animationFrame = function() {
                currentStep++;
                var stepDecimal = currentStep / totalSteps;
                var easeDecimal = easingFunction(stepDecimal);

                callback.call(chartInstance, easeDecimal, stepDecimal, currentStep);
                onProgress.call(chartInstance, easeDecimal, stepDecimal);
                if (currentStep < totalSteps) {
                    chartInstance.animationFrame = requestAnimFrame(animationFrame);
                } else {
                    onComplete.apply(chartInstance);
                }
            };
            requestAnimFrame(animationFrame);
        },
        //-- DOM methods
        getRelativePosition = helpers.getRelativePosition = function(evt) {
            var mouseX, mouseY;
            var e = evt.originalEvent || evt,
                canvas = evt.currentTarget || evt.srcElement,
                boundingRect = canvas.getBoundingClientRect();

            if (e.touches) {
                mouseX = e.touches[0].clientX - boundingRect.left;
                mouseY = e.touches[0].clientY - boundingRect.top;

            } else {
                mouseX = e.clientX - boundingRect.left;
                mouseY = e.clientY - boundingRect.top;
            }

            return {
                x: mouseX,
                y: mouseY
            };

        },
        addEvent = helpers.addEvent = function(node, eventType, method) {
            if (node.addEventListener) {
                node.addEventListener(eventType, method);
            } else if (node.attachEvent) {
                node.attachEvent("on" + eventType, method);
            } else {
                node["on" + eventType] = method;
            }
        },
        removeEvent = helpers.removeEvent = function(node, eventType, handler) {
            if (node.removeEventListener) {
                node.removeEventListener(eventType, handler, false);
            } else if (node.detachEvent) {
                node.detachEvent("on" + eventType, handler);
            } else {
                node["on" + eventType] = noop;
            }
        },
        bindEvents = helpers.bindEvents = function(chartInstance, arrayOfEvents, handler) {
            // Create the events object if it's not already present
            if (!chartInstance.events) chartInstance.events = {};

            each(arrayOfEvents, function(eventName) {
                chartInstance.events[eventName] = function() {
                    handler.apply(chartInstance, arguments);
                };
                addEvent(chartInstance.chart.canvas, eventName, chartInstance.events[eventName]);
            });
        },
        unbindEvents = helpers.unbindEvents = function(chartInstance, arrayOfEvents) {
            each(arrayOfEvents, function(handler, eventName) {
                removeEvent(chartInstance.chart.canvas, eventName, handler);
            });
        },
        getMaximumWidth = helpers.getMaximumWidth = function(domNode) {
            var container = domNode.parentNode,
                padding = parseInt(getStyle(container, 'padding-left')) + parseInt(getStyle(container, 'padding-right'));
            // TODO = check cross browser stuff with this.
            return container.clientWidth - padding;
        },
        getMaximumHeight = helpers.getMaximumHeight = function(domNode) {
            var container = domNode.parentNode,
                padding = parseInt(getStyle(container, 'padding-bottom')) + parseInt(getStyle(container, 'padding-top'));
            // TODO = check cross browser stuff with this.
            return container.clientHeight - padding;
        },
        getStyle = helpers.getStyle = function(el, property) {
            return el.currentStyle ?
                el.currentStyle[property] :
                document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
        },
        getMaximumSize = helpers.getMaximumSize = helpers.getMaximumWidth, // legacy support
        retinaScale = helpers.retinaScale = function(chart) {
            var ctx = chart.ctx,
                width = chart.canvas.width,
                height = chart.canvas.height;

            if (window.devicePixelRatio) {
                ctx.canvas.style.width = width + "px";
                ctx.canvas.style.height = height + "px";
                ctx.canvas.height = height * window.devicePixelRatio;
                ctx.canvas.width = width * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }
        },
        //-- Canvas methods
        clear = helpers.clear = function(chart) {
            chart.ctx.clearRect(0, 0, chart.width, chart.height);
        },
        fontString = helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
            return fontStyle + " " + pixelSize + "px " + fontFamily;
        },
        longestText = helpers.longestText = function(ctx, font, arrayOfStrings) {
            ctx.font = font;
            var longest = 0;
            each(arrayOfStrings, function(string) {
                var textWidth = ctx.measureText(string).width;
                longest = (textWidth > longest) ? textWidth : longest;
            });
            return longest;
        },
        drawRoundedRectangle = helpers.drawRoundedRectangle = function(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        };


    //Store a reference to each instance - allowing us to globally resize chart instances on window resize.
    //Destroy method on the chart will remove the instance of the chart from this reference.
    Chart.instances = {};

    Chart.Type = function(data, options, chart) {
        this.options = options;
        this.chart = chart;
        this.id = uid();
        //Add the chart instance to the global namespace
        Chart.instances[this.id] = this;

        // Initialize is always called when a chart type is created
        // By default it is a no op, but it should be extended
        if (options.responsive) {
            this.resize();
        }
        this.initialize.call(this, data);
    };

    //Core methods that'll be a part of every chart type
    extend(Chart.Type.prototype, {
        initialize: function() {
            return this;
        },
        clear: function() {
            clear(this.chart);
            return this;
        },
        stop: function() {
            // Stops any current animation loop occuring
            Chart.animationService.cancelAnimation(this);
            return this;
        },
        resize: function(callback) {
            this.stop();
            var canvas = this.chart.canvas,
                newWidth = getMaximumWidth(this.chart.canvas),
                newHeight = this.options.maintainAspectRatio ? newWidth / this.chart.aspectRatio : getMaximumHeight(this.chart.canvas);

            canvas.width = this.chart.width = newWidth;
            canvas.height = this.chart.height = newHeight;

            retinaScale(this.chart);

            if (typeof callback === "function") {
                callback.apply(this, Array.prototype.slice.call(arguments, 1));
            }
            return this;
        },
        reflow: noop,
        render: function(reflow) {
            if (reflow) {
                this.reflow();
            }

            if (this.options.animation && !reflow) {
                var animation = new Chart.Animation();
                animation.numSteps = this.options.animationSteps;
                animation.easing = this.options.animationEasing;

                // render function
                animation.render = function(chartInstance, animationObject) {
                    var easingFunction = helpers.easingEffects[animationObject.easing];
                    var stepDecimal = animationObject.currentStep / animationObject.numSteps;
                    var easeDecimal = easingFunction(stepDecimal);

                    chartInstance.draw(easeDecimal, stepDecimal, animationObject.currentStep);
                };

                // user events
                animation.onAnimationProgress = this.options.onAnimationProgress;
                animation.onAnimationComplete = this.options.onAnimationComplete;

                Chart.animationService.addAnimation(this, animation);
            } else {
                this.draw();
                this.options.onAnimationComplete.call(this);
            }
            return this;
        },
        generateLegend: function() {
            return template(this.options.legendTemplate, this);
        },
        destroy: function() {
            this.clear();
            unbindEvents(this, this.events);
            var canvas = this.chart.canvas;

            // Reset canvas height/width attributes starts a fresh with the canvas context
            canvas.width = this.chart.width;
            canvas.height = this.chart.height;

            // < IE9 doesn't support removeProperty
            if (canvas.style.removeProperty) {
                canvas.style.removeProperty('width');
                canvas.style.removeProperty('height');
            } else {
                canvas.style.removeAttribute('width');
                canvas.style.removeAttribute('height');
            }

            delete Chart.instances[this.id];
        },
        showTooltip: function(ChartElements, forceRedraw) {
            // Only redraw the chart if we've actually changed what we're hovering on.
            if (typeof this.activeElements === 'undefined') this.activeElements = [];

            var isChanged = (function(Elements) {
                var changed = false;

                if (Elements.length !== this.activeElements.length) {
                    changed = true;
                    return changed;
                }

                each(Elements, function(element, index) {
                    if (element !== this.activeElements[index]) {
                        changed = true;
                    }
                }, this);
                return changed;
            }).call(this, ChartElements);

            if (!isChanged && !forceRedraw) {
                return;
            } else {
                this.activeElements = ChartElements;
            }
            this.draw();
            if (this.options.customTooltips) {
                this.options.customTooltips(false);
            }
            if (ChartElements.length > 0) {
                // If we have multiple datasets, show a MultiTooltip for all of the data points at that index
                if (this.datasets && this.datasets.length > 1) {
                    var dataArray,
                        dataIndex;

                    for (var i = this.datasets.length - 1; i >= 0; i--) {
                        dataArray = this.datasets[i].points || this.datasets[i].bars || this.datasets[i].segments;
                        dataIndex = indexOf(dataArray, ChartElements[0]);
                        if (dataIndex !== -1) {
                            break;
                        }
                    }
                    var tooltipLabels = [],
                        tooltipColors = [],
                        medianPosition = (function(index) {

                            // Get all the points at that particular index
                            var Elements = [],
                                dataCollection,
                                xPositions = [],
                                yPositions = [],
                                xMax,
                                yMax,
                                xMin,
                                yMin;
                            helpers.each(this.datasets, function(dataset) {
                                dataCollection = dataset.points || dataset.bars || dataset.segments;
                                if (dataCollection[dataIndex] && dataCollection[dataIndex].hasValue()) {
                                    Elements.push(dataCollection[dataIndex]);
                                }
                            });

                            helpers.each(Elements, function(element) {
                                xPositions.push(element.x);
                                yPositions.push(element.y);


                                //Include any colour information about the element
                                tooltipLabels.push(helpers.template(this.options.multiTooltipTemplate, element));
                                tooltipColors.push({
                                    fill: element._saved.fillColor || element.fillColor,
                                    stroke: element._saved.strokeColor || element.strokeColor
                                });

                            }, this);

                            yMin = min(yPositions);
                            yMax = max(yPositions);

                            xMin = min(xPositions);
                            xMax = max(xPositions);

                            return {
                                x: (xMin > this.chart.width / 2) ? xMin : xMax,
                                y: (yMin + yMax) / 2
                            };
                        }).call(this, dataIndex);

                    new Chart.MultiTooltip({
                        x: medianPosition.x,
                        y: medianPosition.y,
                        xPadding: this.options.tooltipXPadding,
                        yPadding: this.options.tooltipYPadding,
                        xOffset: this.options.tooltipXOffset,
                        fillColor: this.options.tooltipFillColor,
                        textColor: this.options.tooltipFontColor,
                        fontFamily: this.options.tooltipFontFamily,
                        fontStyle: this.options.tooltipFontStyle,
                        fontSize: this.options.tooltipFontSize,
                        titleTextColor: this.options.tooltipTitleFontColor,
                        titleFontFamily: this.options.tooltipTitleFontFamily,
                        titleFontStyle: this.options.tooltipTitleFontStyle,
                        titleFontSize: this.options.tooltipTitleFontSize,
                        cornerRadius: this.options.tooltipCornerRadius,
                        labels: tooltipLabels,
                        legendColors: tooltipColors,
                        legendColorBackground: this.options.multiTooltipKeyBackground,
                        title: ChartElements[0].label,
                        chart: this.chart,
                        ctx: this.chart.ctx,
                        custom: this.options.customTooltips
                    }).draw();

                } else {
                    each(ChartElements, function(Element) {
                        var tooltipPosition = Element.tooltipPosition();
                        new Chart.Tooltip({
                            x: Math.round(tooltipPosition.x),
                            y: Math.round(tooltipPosition.y),
                            xPadding: this.options.tooltipXPadding,
                            yPadding: this.options.tooltipYPadding,
                            fillColor: this.options.tooltipFillColor,
                            textColor: this.options.tooltipFontColor,
                            fontFamily: this.options.tooltipFontFamily,
                            fontStyle: this.options.tooltipFontStyle,
                            fontSize: this.options.tooltipFontSize,
                            caretHeight: this.options.tooltipCaretSize,
                            cornerRadius: this.options.tooltipCornerRadius,
                            text: template(this.options.tooltipTemplate, Element),
                            chart: this.chart,
                            custom: this.options.customTooltips
                        }).draw();
                    }, this);
                }
            }
            return this;
        },
        toBase64Image: function() {
            return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
        }
    });

    Chart.Type.extend = function(extensions) {

        var parent = this;

        var ChartType = function() {
            return parent.apply(this, arguments);
        };

        //Copy the prototype object of the this class
        ChartType.prototype = clone(parent.prototype);
        //Now overwrite some of the properties in the base class with the new extensions
        extend(ChartType.prototype, extensions);

        ChartType.extend = Chart.Type.extend;

        if (extensions.name || parent.prototype.name) {

            var chartName = extensions.name || parent.prototype.name;
            //Assign any potential default values of the new chart type

            //If none are defined, we'll use a clone of the chart type this is being extended from.
            //I.e. if we extend a line chart, we'll use the defaults from the line chart if our new chart
            //doesn't define some defaults of their own.

            var baseDefaults = (Chart.defaults[parent.prototype.name]) ? clone(Chart.defaults[parent.prototype.name]) : {};

            Chart.defaults[chartName] = extend(baseDefaults, extensions.defaults);

            Chart.types[chartName] = ChartType;

            //Register this new chart type in the Chart prototype
            Chart.prototype[chartName] = function(data, options) {
                var config = merge(Chart.defaults.global, Chart.defaults[chartName], options || {});
                return new ChartType(data, config, this);
            };
        } else {
            warn("Name not provided for this chart, so it hasn't been registered");
        }
        return parent;
    };

    Chart.Element = function(configuration) {
        extend(this, configuration);
        this.initialize.apply(this, arguments);
        this.save();
    };
    extend(Chart.Element.prototype, {
        initialize: function() {},
        restore: function(props) {
            if (!props) {
                extend(this, this._saved);
            } else {
                each(props, function(key) {
                    this[key] = this._saved[key];
                }, this);
            }
            return this;
        },
        save: function() {
            this._saved = clone(this);
            delete this._saved._saved;
            return this;
        },
        update: function(newProps) {
            each(newProps, function(value, key) {
                this._saved[key] = this[key];
                this[key] = value;
            }, this);
            return this;
        },
        transition: function(props, ease) {
            each(props, function(value, key) {
                this[key] = ((value - this._saved[key]) * ease) + this._saved[key];
            }, this);
            return this;
        },
        tooltipPosition: function() {
            return {
                x: this.x,
                y: this.y
            };
        },
        hasValue: function() {
            return isNumber(this.value);
        }
    });

    Chart.Element.extend = inherits;


    Chart.Point = Chart.Element.extend({
        display: true,
        inRange: function(chartX, chartY) {
            var hitDetectionRange = this.hitDetectionRadius + this.radius;
            return ((Math.pow(chartX - this.x, 2) + Math.pow(chartY - this.y, 2)) < Math.pow(hitDetectionRange, 2));
        },
        draw: function() {
            if (this.display) {
                var ctx = this.ctx;
                ctx.beginPath();

                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.closePath();

                ctx.strokeStyle = this.strokeColor;
                ctx.lineWidth = this.strokeWidth;

                ctx.fillStyle = this.fillColor;

                ctx.fill();
                ctx.stroke();
            }


            //Quick debug for bezier curve splining
            //Highlights control points and the line between them.
            //Handy for dev - stripped in the min version.

            // ctx.save();
            // ctx.fillStyle = "black";
            // ctx.strokeStyle = "black"
            // ctx.beginPath();
            // ctx.arc(this.controlPoints.inner.x,this.controlPoints.inner.y, 2, 0, Math.PI*2);
            // ctx.fill();

            // ctx.beginPath();
            // ctx.arc(this.controlPoints.outer.x,this.controlPoints.outer.y, 2, 0, Math.PI*2);
            // ctx.fill();

            // ctx.moveTo(this.controlPoints.inner.x,this.controlPoints.inner.y);
            // ctx.lineTo(this.x, this.y);
            // ctx.lineTo(this.controlPoints.outer.x,this.controlPoints.outer.y);
            // ctx.stroke();

            // ctx.restore();



        }
    });

    Chart.Arc = Chart.Element.extend({
        inRange: function(chartX, chartY) {

            var pointRelativePosition = helpers.getAngleFromPoint(this, {
                x: chartX,
                y: chartY
            });

            //Check if within the range of the open/close angle
            var betweenAngles = (pointRelativePosition.angle >= this.startAngle && pointRelativePosition.angle <= this.endAngle),
                withinRadius = (pointRelativePosition.distance >= this.innerRadius && pointRelativePosition.distance <= this.outerRadius);

            return (betweenAngles && withinRadius);
            //Ensure within the outside of the arc centre, but inside arc outer
        },
        tooltipPosition: function() {
            var centreAngle = this.startAngle + ((this.endAngle - this.startAngle) / 2),
                rangeFromCentre = (this.outerRadius - this.innerRadius) / 2 + this.innerRadius;
            return {
                x: this.x + (Math.cos(centreAngle) * rangeFromCentre),
                y: this.y + (Math.sin(centreAngle) * rangeFromCentre)
            };
        },
        draw: function(animationPercent) {

            var easingDecimal = animationPercent || 1;

            var ctx = this.ctx;

            ctx.beginPath();

            ctx.arc(this.x, this.y, this.outerRadius, this.startAngle, this.endAngle);

            ctx.arc(this.x, this.y, this.innerRadius, this.endAngle, this.startAngle, true);

            ctx.closePath();
            ctx.strokeStyle = this.strokeColor;
            ctx.lineWidth = this.strokeWidth;

            ctx.fillStyle = this.fillColor;

            ctx.fill();
            ctx.lineJoin = 'bevel';

            if (this.showStroke) {
                ctx.stroke();
            }
        }
    });

    Chart.Rectangle = Chart.Element.extend({
        draw: function() {
            var ctx = this.ctx,
                halfWidth = this.width / 2,
                leftX = this.x - halfWidth,
                rightX = this.x + halfWidth,
                top = this.base - (this.base - this.y),
                halfStroke = this.strokeWidth / 2;

            // Canvas doesn't allow us to stroke inside the width so we can
            // adjust the sizes to fit if we're setting a stroke on the line
            if (this.showStroke) {
                leftX += halfStroke;
                rightX -= halfStroke;
                top += halfStroke;
            }

            ctx.beginPath();

            ctx.fillStyle = this.fillColor;
            ctx.strokeStyle = this.strokeColor;
            ctx.lineWidth = this.strokeWidth;

            // It'd be nice to keep this class totally generic to any rectangle
            // and simply specify which border to miss out.
            ctx.moveTo(leftX, this.base);
            ctx.lineTo(leftX, top);
            ctx.lineTo(rightX, top);
            ctx.lineTo(rightX, this.base);
            ctx.fill();
            if (this.showStroke) {
                ctx.stroke();
            }
        },
        height: function() {
            return this.base - this.y;
        },
        inRange: function(chartX, chartY) {
            return (chartX >= this.x - this.width / 2 && chartX <= this.x + this.width / 2) && (chartY >= this.y && chartY <= this.base);
        }
    });

    Chart.Animation = Chart.Element.extend({
        currentStep: null, // the current animation step
        numSteps: 60, // default number of steps
        easing: "", // the easing to use for this animation
        render: null, // render function used by the animation service

        onAnimationProgress: null, // user specified callback to fire on each step of the animation 
        onAnimationComplete: null, // user specified callback to fire when the animation finishes
    });

    Chart.Tooltip = Chart.Element.extend({
        draw: function() {

            var ctx = this.chart.ctx;

            ctx.font = fontString(this.fontSize, this.fontStyle, this.fontFamily);

            this.xAlign = "center";
            this.yAlign = "above";

            //Distance between the actual element.y position and the start of the tooltip caret
            var caretPadding = this.caretPadding = 2;

            var tooltipWidth = ctx.measureText(this.text).width + 2 * this.xPadding,
                tooltipRectHeight = this.fontSize + 2 * this.yPadding,
                tooltipHeight = tooltipRectHeight + this.caretHeight + caretPadding;

            if (this.x + tooltipWidth / 2 > this.chart.width) {
                this.xAlign = "left";
            } else if (this.x - tooltipWidth / 2 < 0) {
                this.xAlign = "right";
            }

            if (this.y - tooltipHeight < 0) {
                this.yAlign = "below";
            }


            var tooltipX = this.x - tooltipWidth / 2,
                tooltipY = this.y - tooltipHeight;

            ctx.fillStyle = this.fillColor;

            // Custom Tooltips
            if (this.custom) {
                this.custom(this);
            } else {
                switch (this.yAlign) {
                    case "above":
                        //Draw a caret above the x/y
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y - caretPadding);
                        ctx.lineTo(this.x + this.caretHeight, this.y - (caretPadding + this.caretHeight));
                        ctx.lineTo(this.x - this.caretHeight, this.y - (caretPadding + this.caretHeight));
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case "below":
                        tooltipY = this.y + caretPadding + this.caretHeight;
                        //Draw a caret below the x/y
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + caretPadding);
                        ctx.lineTo(this.x + this.caretHeight, this.y + caretPadding + this.caretHeight);
                        ctx.lineTo(this.x - this.caretHeight, this.y + caretPadding + this.caretHeight);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }

                switch (this.xAlign) {
                    case "left":
                        tooltipX = this.x - tooltipWidth + (this.cornerRadius + this.caretHeight);
                        break;
                    case "right":
                        tooltipX = this.x - (this.cornerRadius + this.caretHeight);
                        break;
                }

                drawRoundedRectangle(ctx, tooltipX, tooltipY, tooltipWidth, tooltipRectHeight, this.cornerRadius);

                ctx.fill();

                ctx.fillStyle = this.textColor;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.text, tooltipX + tooltipWidth / 2, tooltipY + tooltipRectHeight / 2);
            }
        }
    });

    Chart.MultiTooltip = Chart.Element.extend({
        initialize: function() {
            this.font = fontString(this.fontSize, this.fontStyle, this.fontFamily);

            this.titleFont = fontString(this.titleFontSize, this.titleFontStyle, this.titleFontFamily);

            this.height = (this.labels.length * this.fontSize) + ((this.labels.length - 1) * (this.fontSize / 2)) + (this.yPadding * 2) + this.titleFontSize * 1.5;

            this.ctx.font = this.titleFont;

            var titleWidth = this.ctx.measureText(this.title).width,
                //Label has a legend square as well so account for this.
                labelWidth = longestText(this.ctx, this.font, this.labels) + this.fontSize + 3,
                longestTextWidth = max([labelWidth, titleWidth]);

            this.width = longestTextWidth + (this.xPadding * 2);


            var halfHeight = this.height / 2;

            //Check to ensure the height will fit on the canvas
            if (this.y - halfHeight < 0) {
                this.y = halfHeight;
            } else if (this.y + halfHeight > this.chart.height) {
                this.y = this.chart.height - halfHeight;
            }

            //Decide whether to align left or right based on position on canvas
            if (this.x > this.chart.width / 2) {
                this.x -= this.xOffset + this.width;
            } else {
                this.x += this.xOffset;
            }


        },
        getLineHeight: function(index) {
            var baseLineHeight = this.y - (this.height / 2) + this.yPadding,
                afterTitleIndex = index - 1;

            //If the index is zero, we're getting the title
            if (index === 0) {
                return baseLineHeight + this.titleFontSize / 2;
            } else {
                return baseLineHeight + ((this.fontSize * 1.5 * afterTitleIndex) + this.fontSize / 2) + this.titleFontSize * 1.5;
            }

        },
        draw: function() {
            // Custom Tooltips
            if (this.custom) {
                this.custom(this);
            } else {
                drawRoundedRectangle(this.ctx, this.x, this.y - this.height / 2, this.width, this.height, this.cornerRadius);
                var ctx = this.ctx;
                ctx.fillStyle = this.fillColor;
                ctx.fill();
                ctx.closePath();

                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                ctx.fillStyle = this.titleTextColor;
                ctx.font = this.titleFont;

                ctx.fillText(this.title, this.x + this.xPadding, this.getLineHeight(0));

                ctx.font = this.font;
                helpers.each(this.labels, function(label, index) {
                    ctx.fillStyle = this.textColor;
                    ctx.fillText(label, this.x + this.xPadding + this.fontSize + 3, this.getLineHeight(index + 1));

                    //A bit gnarly, but clearing this rectangle breaks when using explorercanvas (clears whole canvas)
                    //ctx.clearRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize/2, this.fontSize, this.fontSize);
                    //Instead we'll make a white filled block to put the legendColour palette over.

                    ctx.fillStyle = this.legendColorBackground;
                    ctx.fillRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize / 2, this.fontSize, this.fontSize);

                    ctx.fillStyle = this.legendColors[index].fill;
                    ctx.fillRect(this.x + this.xPadding, this.getLineHeight(index + 1) - this.fontSize / 2, this.fontSize, this.fontSize);


                }, this);
            }
        }
    });

    Chart.Scale = Chart.Element.extend({
        initialize: function() {
            this.fit();
        },
        buildYLabels: function() {
            this.yLabels = [];

            var stepDecimalPlaces = getDecimalPlaces(this.stepValue);

            for (var i = 0; i <= this.steps; i++) {
                this.yLabels.push(template(this.templateString, {
                    value: (this.min + (i * this.stepValue)).toFixed(stepDecimalPlaces)
                }));
            }
            this.yLabelWidth = (this.display && this.showLabels) ? longestText(this.ctx, this.font, this.yLabels) + 10 : 0;
        },
        addXLabel: function(label) {
            this.xLabels.push(label);
            this.valuesCount++;
            this.fit();
        },
        removeXLabel: function() {
            this.xLabels.shift();
            this.valuesCount--;
            this.fit();
        },
        // Fitting loop to rotate x Labels and figure out what fits there, and also calculate how many Y steps to use
        fit: function() {
            // First we need the width of the yLabels, assuming the xLabels aren't rotated

            // To do that we need the base line at the top and base of the chart, assuming there is no x label rotation
            this.startPoint = (this.display) ? this.fontSize : 0;
            this.endPoint = (this.display) ? this.height - (this.fontSize * 1.5) - 5 : this.height; // -5 to pad labels

            // Apply padding settings to the start and end point.
            this.startPoint += this.padding;
            this.endPoint -= this.padding;

            // Cache the starting endpoint, excluding the space for x labels
            var cachedEndPoint = this.endPoint;

            // Cache the starting height, so can determine if we need to recalculate the scale yAxis
            var cachedHeight = this.endPoint - this.startPoint,
                cachedYLabelWidth;

            // Build the current yLabels so we have an idea of what size they'll be to start
            /*
             *	This sets what is returned from calculateScaleRange as static properties of this class:
             *
            	this.steps;
            	this.stepValue;
            	this.min;
            	this.max;
             *
             */
            this.calculateYRange(cachedHeight);

            // With these properties set we can now build the array of yLabels
            // and also the width of the largest yLabel
            this.buildYLabels();

            this.calculateXLabelRotation();

            while ((cachedHeight > this.endPoint - this.startPoint)) {
                cachedHeight = this.endPoint - this.startPoint;
                cachedYLabelWidth = this.yLabelWidth;

                this.calculateYRange(cachedHeight);
                this.buildYLabels();

                // Only go through the xLabel loop again if the yLabel width has changed
                if (cachedYLabelWidth < this.yLabelWidth) {
                    this.endPoint = cachedEndPoint;
                    this.calculateXLabelRotation();
                }
            }

        },
        calculateXLabelRotation: function() {
            //Get the width of each grid by calculating the difference
            //between x offsets between 0 and 1.

            this.ctx.font = this.font;

            var firstWidth = this.ctx.measureText(this.xLabels[0]).width,
                lastWidth = this.ctx.measureText(this.xLabels[this.xLabels.length - 1]).width,
                firstRotated,
                lastRotated;


            this.xScalePaddingRight = lastWidth / 2 + 3;
            this.xScalePaddingLeft = (firstWidth / 2 > this.yLabelWidth) ? firstWidth / 2 : this.yLabelWidth;

            this.xLabelRotation = 0;
            if (this.display) {
                var originalLabelWidth = longestText(this.ctx, this.font, this.xLabels),
                    cosRotation,
                    firstRotatedWidth;
                this.xLabelWidth = originalLabelWidth;
                //Allow 3 pixels x2 padding either side for label readability
                var xGridWidth = Math.floor(this.calculateX(1) - this.calculateX(0)) - 6;

                //Max label rotate should be 90 - also act as a loop counter
                while ((this.xLabelWidth > xGridWidth && this.xLabelRotation === 0) || (this.xLabelWidth > xGridWidth && this.xLabelRotation <= 90 && this.xLabelRotation > 0)) {
                    cosRotation = Math.cos(toRadians(this.xLabelRotation));

                    firstRotated = cosRotation * firstWidth;
                    lastRotated = cosRotation * lastWidth;

                    // We're right aligning the text now.
                    if (firstRotated + this.fontSize / 2 > this.yLabelWidth) {
                        this.xScalePaddingLeft = firstRotated + this.fontSize / 2;
                    }
                    this.xScalePaddingRight = this.fontSize / 2;


                    this.xLabelRotation++;
                    this.xLabelWidth = cosRotation * originalLabelWidth;

                }
                if (this.xLabelRotation > 0) {
                    this.endPoint -= Math.sin(toRadians(this.xLabelRotation)) * originalLabelWidth + 3;
                }
            } else {
                this.xLabelWidth = 0;
                this.xScalePaddingRight = this.padding;
                this.xScalePaddingLeft = this.padding;
            }

        },
        // Needs to be overidden in each Chart type
        // Otherwise we need to pass all the data into the scale class
        calculateYRange: noop,
        drawingArea: function() {
            return this.startPoint - this.endPoint;
        },
        calculateY: function(value) {
            var scalingFactor = this.drawingArea() / (this.min - this.max);
            return this.endPoint - (scalingFactor * (value - this.min));
        },
        calculateX: function(index) {
            var isRotated = (this.xLabelRotation > 0),
                // innerWidth = (this.offsetGridLines) ? this.width - offsetLeft - this.padding : this.width - (offsetLeft + halfLabelWidth * 2) - this.padding,
                innerWidth = this.width - (this.xScalePaddingLeft + this.xScalePaddingRight),
                valueWidth = innerWidth / Math.max((this.valuesCount - ((this.offsetGridLines) ? 0 : 1)), 1),
                valueOffset = (valueWidth * index) + this.xScalePaddingLeft;

            if (this.offsetGridLines) {
                valueOffset += (valueWidth / 2);
            }

            return Math.round(valueOffset);
        },
        update: function(newProps) {
            helpers.extend(this, newProps);
            this.fit();
        },
        draw: function() {
            var ctx = this.ctx,
                yLabelGap = (this.endPoint - this.startPoint) / this.steps,
                xStart = Math.round(this.xScalePaddingLeft);
            if (this.display) {
                ctx.fillStyle = this.textColor;
                ctx.font = this.font;
                each(this.yLabels, function(labelString, index) {
                    var yLabelCenter = this.endPoint - (yLabelGap * index),
                        linePositionY = Math.round(yLabelCenter),
                        drawHorizontalLine = this.showHorizontalLines;

                    ctx.textAlign = "right";
                    ctx.textBaseline = "middle";
                    if (this.showLabels) {
                        ctx.fillText(labelString, xStart - 10, yLabelCenter);
                    }

                    // This is X axis, so draw it
                    if (index === 0 && !drawHorizontalLine) {
                        drawHorizontalLine = true;
                    }

                    if (drawHorizontalLine) {
                        ctx.beginPath();
                    }

                    if (index > 0) {
                        // This is a grid line in the centre, so drop that
                        ctx.lineWidth = this.gridLineWidth;
                        ctx.strokeStyle = this.gridLineColor;
                    } else {
                        // This is the first line on the scale
                        ctx.lineWidth = this.lineWidth;
                        ctx.strokeStyle = this.lineColor;
                    }

                    linePositionY += helpers.aliasPixel(ctx.lineWidth);

                    if (drawHorizontalLine) {
                        ctx.moveTo(xStart, linePositionY);
                        ctx.lineTo(this.width, linePositionY);
                        ctx.stroke();
                        ctx.closePath();
                    }

                    ctx.lineWidth = this.lineWidth;
                    ctx.strokeStyle = this.lineColor;
                    ctx.beginPath();
                    ctx.moveTo(xStart - 5, linePositionY);
                    ctx.lineTo(xStart, linePositionY);
                    ctx.stroke();
                    ctx.closePath();

                }, this);

                each(this.xLabels, function(label, index) {
                    var xPos = this.calculateX(index) + aliasPixel(this.lineWidth),
                        // Check to see if line/bar here and decide where to place the line
                        linePos = this.calculateX(index - (this.offsetGridLines ? 0.5 : 0)) + aliasPixel(this.lineWidth),
                        isRotated = (this.xLabelRotation > 0),
                        drawVerticalLine = this.showVerticalLines;

                    // This is Y axis, so draw it
                    if (index === 0 && !drawVerticalLine) {
                        drawVerticalLine = true;
                    }

                    if (drawVerticalLine) {
                        ctx.beginPath();
                    }

                    if (index > 0) {
                        // This is a grid line in the centre, so drop that
                        ctx.lineWidth = this.gridLineWidth;
                        ctx.strokeStyle = this.gridLineColor;
                    } else {
                        // This is the first line on the scale
                        ctx.lineWidth = this.lineWidth;
                        ctx.strokeStyle = this.lineColor;
                    }

                    if (drawVerticalLine) {
                        ctx.moveTo(linePos, this.endPoint);
                        ctx.lineTo(linePos, this.startPoint - 3);
                        ctx.stroke();
                        ctx.closePath();
                    }


                    ctx.lineWidth = this.lineWidth;
                    ctx.strokeStyle = this.lineColor;


                    // Small lines at the bottom of the base grid line
                    ctx.beginPath();
                    ctx.moveTo(linePos, this.endPoint);
                    ctx.lineTo(linePos, this.endPoint + 5);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.save();
                    ctx.translate(xPos, (isRotated) ? this.endPoint + 12 : this.endPoint + 8);
                    ctx.rotate(toRadians(this.xLabelRotation) * -1);
                    ctx.font = this.font;
                    ctx.textAlign = (isRotated) ? "right" : "center";
                    ctx.textBaseline = (isRotated) ? "middle" : "top";
                    ctx.fillText(label, 0, 0);
                    ctx.restore();
                }, this);

            }
        }

    });

    Chart.RadialScale = Chart.Element.extend({
        initialize: function() {
            this.size = min([this.height, this.width]);
            this.drawingArea = (this.display) ? (this.size / 2) - (this.fontSize / 2 + this.backdropPaddingY) : (this.size / 2);
        },
        calculateCenterOffset: function(value) {
            // Take into account half font size + the yPadding of the top value
            var scalingFactor = this.drawingArea / (this.max - this.min);

            return (value - this.min) * scalingFactor;
        },
        update: function() {
            if (!this.lineArc) {
                this.setScaleSize();
            } else {
                this.drawingArea = (this.display) ? (this.size / 2) - (this.fontSize / 2 + this.backdropPaddingY) : (this.size / 2);
            }
            this.buildYLabels();
        },
        buildYLabels: function() {
            this.yLabels = [];

            var stepDecimalPlaces = getDecimalPlaces(this.stepValue);

            for (var i = 0; i <= this.steps; i++) {
                this.yLabels.push(template(this.templateString, {
                    value: (this.min + (i * this.stepValue)).toFixed(stepDecimalPlaces)
                }));
            }
        },
        getCircumference: function() {
            return ((Math.PI * 2) / this.valuesCount);
        },
        setScaleSize: function() {
            /*
             * Right, this is really confusing and there is a lot of maths going on here
             * The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
             *
             * Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
             *
             * Solution:
             *
             * We assume the radius of the polygon is half the size of the canvas at first
             * at each index we check if the text overlaps.
             *
             * Where it does, we store that angle and that index.
             *
             * After finding the largest index and angle we calculate how much we need to remove
             * from the shape radius to move the point inwards by that x.
             *
             * We average the left and right distances to get the maximum shape radius that can fit in the box
             * along with labels.
             *
             * Once we have that, we can find the centre point for the chart, by taking the x text protrusion
             * on each side, removing that from the size, halving it and adding the left x protrusion width.
             *
             * This will mean we have a shape fitted to the canvas, as large as it can be with the labels
             * and position it in the most space efficient manner
             *
             * https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
             */


            // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
            // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
            var largestPossibleRadius = min([(this.height / 2 - this.pointLabelFontSize - 5), this.width / 2]),
                pointPosition,
                i,
                textWidth,
                halfTextWidth,
                furthestRight = this.width,
                furthestRightIndex,
                furthestRightAngle,
                furthestLeft = 0,
                furthestLeftIndex,
                furthestLeftAngle,
                xProtrusionLeft,
                xProtrusionRight,
                radiusReductionRight,
                radiusReductionLeft,
                maxWidthRadius;
            this.ctx.font = fontString(this.pointLabelFontSize, this.pointLabelFontStyle, this.pointLabelFontFamily);
            for (i = 0; i < this.valuesCount; i++) {
                // 5px to space the text slightly out - similar to what we do in the draw function.
                pointPosition = this.getPointPosition(i, largestPossibleRadius);
                textWidth = this.ctx.measureText(template(this.templateString, {
                    value: this.labels[i]
                })).width + 5;
                if (i === 0 || i === this.valuesCount / 2) {
                    // If we're at index zero, or exactly the middle, we're at exactly the top/bottom
                    // of the radar chart, so text will be aligned centrally, so we'll half it and compare
                    // w/left and right text sizes
                    halfTextWidth = textWidth / 2;
                    if (pointPosition.x + halfTextWidth > furthestRight) {
                        furthestRight = pointPosition.x + halfTextWidth;
                        furthestRightIndex = i;
                    }
                    if (pointPosition.x - halfTextWidth < furthestLeft) {
                        furthestLeft = pointPosition.x - halfTextWidth;
                        furthestLeftIndex = i;
                    }
                } else if (i < this.valuesCount / 2) {
                    // Less than half the values means we'll left align the text
                    if (pointPosition.x + textWidth > furthestRight) {
                        furthestRight = pointPosition.x + textWidth;
                        furthestRightIndex = i;
                    }
                } else if (i > this.valuesCount / 2) {
                    // More than half the values means we'll right align the text
                    if (pointPosition.x - textWidth < furthestLeft) {
                        furthestLeft = pointPosition.x - textWidth;
                        furthestLeftIndex = i;
                    }
                }
            }

            xProtrusionLeft = furthestLeft;

            xProtrusionRight = Math.ceil(furthestRight - this.width);

            furthestRightAngle = this.getIndexAngle(furthestRightIndex);

            furthestLeftAngle = this.getIndexAngle(furthestLeftIndex);

            radiusReductionRight = xProtrusionRight / Math.sin(furthestRightAngle + Math.PI / 2);

            radiusReductionLeft = xProtrusionLeft / Math.sin(furthestLeftAngle + Math.PI / 2);

            // Ensure we actually need to reduce the size of the chart
            radiusReductionRight = (isNumber(radiusReductionRight)) ? radiusReductionRight : 0;
            radiusReductionLeft = (isNumber(radiusReductionLeft)) ? radiusReductionLeft : 0;

            this.drawingArea = largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2;

            //this.drawingArea = min([maxWidthRadius, (this.height - (2 * (this.pointLabelFontSize + 5)))/2])
            this.setCenterPoint(radiusReductionLeft, radiusReductionRight);

        },
        setCenterPoint: function(leftMovement, rightMovement) {

            var maxRight = this.width - rightMovement - this.drawingArea,
                maxLeft = leftMovement + this.drawingArea;

            this.xCenter = (maxLeft + maxRight) / 2;
            // Always vertically in the centre as the text height doesn't change
            this.yCenter = (this.height / 2);
        },

        getIndexAngle: function(index) {
            var angleMultiplier = (Math.PI * 2) / this.valuesCount;
            // Start from the top instead of right, so remove a quarter of the circle

            return index * angleMultiplier - (Math.PI / 2);
        },
        getPointPosition: function(index, distanceFromCenter) {
            var thisAngle = this.getIndexAngle(index);
            return {
                x: (Math.cos(thisAngle) * distanceFromCenter) + this.xCenter,
                y: (Math.sin(thisAngle) * distanceFromCenter) + this.yCenter
            };
        },
        draw: function() {
            if (this.display) {
                var ctx = this.ctx;
                each(this.yLabels, function(label, index) {
                    // Don't draw a centre value
                    if (index > 0) {
                        var yCenterOffset = index * (this.drawingArea / this.steps),
                            yHeight = this.yCenter - yCenterOffset,
                            pointPosition;

                        // Draw circular lines around the scale
                        if (this.lineWidth > 0) {
                            ctx.strokeStyle = this.lineColor;
                            ctx.lineWidth = this.lineWidth;

                            if (this.lineArc) {
                                ctx.beginPath();
                                ctx.arc(this.xCenter, this.yCenter, yCenterOffset, 0, Math.PI * 2);
                                ctx.closePath();
                                ctx.stroke();
                            } else {
                                ctx.beginPath();
                                for (var i = 0; i < this.valuesCount; i++) {
                                    pointPosition = this.getPointPosition(i, this.calculateCenterOffset(this.min + (index * this.stepValue)));
                                    if (i === 0) {
                                        ctx.moveTo(pointPosition.x, pointPosition.y);
                                    } else {
                                        ctx.lineTo(pointPosition.x, pointPosition.y);
                                    }
                                }
                                ctx.closePath();
                                ctx.stroke();
                            }
                        }
                        if (this.showLabels) {
                            ctx.font = fontString(this.fontSize, this.fontStyle, this.fontFamily);
                            if (this.showLabelBackdrop) {
                                var labelWidth = ctx.measureText(label).width;
                                ctx.fillStyle = this.backdropColor;
                                ctx.fillRect(
                                    this.xCenter - labelWidth / 2 - this.backdropPaddingX,
                                    yHeight - this.fontSize / 2 - this.backdropPaddingY,
                                    labelWidth + this.backdropPaddingX * 2,
                                    this.fontSize + this.backdropPaddingY * 2
                                );
                            }
                            ctx.textAlign = 'center';
                            ctx.textBaseline = "middle";
                            ctx.fillStyle = this.fontColor;
                            ctx.fillText(label, this.xCenter, yHeight);
                        }
                    }
                }, this);

                if (!this.lineArc) {
                    ctx.lineWidth = this.angleLineWidth;
                    ctx.strokeStyle = this.angleLineColor;
                    for (var i = this.valuesCount - 1; i >= 0; i--) {
                        if (this.angleLineWidth > 0) {
                            var outerPosition = this.getPointPosition(i, this.calculateCenterOffset(this.max));
                            ctx.beginPath();
                            ctx.moveTo(this.xCenter, this.yCenter);
                            ctx.lineTo(outerPosition.x, outerPosition.y);
                            ctx.stroke();
                            ctx.closePath();
                        }
                        // Extra 3px out for some label spacing
                        var pointLabelPosition = this.getPointPosition(i, this.calculateCenterOffset(this.max) + 5);
                        ctx.font = fontString(this.pointLabelFontSize, this.pointLabelFontStyle, this.pointLabelFontFamily);
                        ctx.fillStyle = this.pointLabelFontColor;

                        var labelsCount = this.labels.length,
                            halfLabelsCount = this.labels.length / 2,
                            quarterLabelsCount = halfLabelsCount / 2,
                            upperHalf = (i < quarterLabelsCount || i > labelsCount - quarterLabelsCount),
                            exactQuarter = (i === quarterLabelsCount || i === labelsCount - quarterLabelsCount);
                        if (i === 0) {
                            ctx.textAlign = 'center';
                        } else if (i === halfLabelsCount) {
                            ctx.textAlign = 'center';
                        } else if (i < halfLabelsCount) {
                            ctx.textAlign = 'left';
                        } else {
                            ctx.textAlign = 'right';
                        }

                        // Set the correct text baseline based on outer positioning
                        if (exactQuarter) {
                            ctx.textBaseline = 'middle';
                        } else if (upperHalf) {
                            ctx.textBaseline = 'bottom';
                        } else {
                            ctx.textBaseline = 'top';
                        }

                        ctx.fillText(this.labels[i], pointLabelPosition.x, pointLabelPosition.y);
                    }
                }
            }
        }
    });

    Chart.animationService = {
        frameDuration: 17,
        animations: [],
        dropFrames: 0,
        addAnimation: function(chartInstance, animationObject) {
            for (var index = 0; index < this.animations.length; ++index) {
                if (this.animations[index].chartInstance === chartInstance) {
                    // replacing an in progress animation
                    this.animations[index].animationObject = animationObject;
                    return;
                }
            }

            this.animations.push({
                chartInstance: chartInstance,
                animationObject: animationObject
            });

            // If there are no animations queued, manually kickstart a digest, for lack of a better word
            if (this.animations.length == 1) {
                helpers.requestAnimFrame.call(window, this.digestWrapper);
            }
        },
        // Cancel the animation for a given chart instance
        cancelAnimation: function(chartInstance) {
            var index = helpers.findNextWhere(this.animations, function(animationWrapper) {
                return animationWrapper.chartInstance === chartInstance;
            });

            if (index) {
                this.animations.splice(index, 1);
            }
        },
        // calls startDigest with the proper context
        digestWrapper: function() {
            Chart.animationService.startDigest.call(Chart.animationService);
        },
        startDigest: function() {

            var startTime = Date.now();
            var framesToDrop = 0;

            if (this.dropFrames > 1) {
                framesToDrop = Math.floor(this.dropFrames);
                this.dropFrames -= framesToDrop;
            }

            for (var i = 0; i < this.animations.length; i++) {

                if (this.animations[i].animationObject.currentStep === null) {
                    this.animations[i].animationObject.currentStep = 0;
                }

                this.animations[i].animationObject.currentStep += 1 + framesToDrop;
                if (this.animations[i].animationObject.currentStep > this.animations[i].animationObject.numSteps) {
                    this.animations[i].animationObject.currentStep = this.animations[i].animationObject.numSteps;
                }

                this.animations[i].animationObject.render(this.animations[i].chartInstance, this.animations[i].animationObject);

                if (this.animations[i].animationObject.currentStep == this.animations[i].animationObject.numSteps) {
                    // executed the last frame. Remove the animation.
                    this.animations.splice(i, 1);
                    // Keep the index in place to offset the splice
                    i--;
                }
            }

            var endTime = Date.now();
            var delay = endTime - startTime - this.frameDuration;
            var frameDelay = delay / this.frameDuration;

            if (frameDelay > 1) {
                this.dropFrames += frameDelay;
            }

            // Do we have more stuff to animate?
            if (this.animations.length > 0) {
                helpers.requestAnimFrame.call(window, this.digestWrapper);
            }
        }
    };

    // Attach global event to resize each chart instance when the browser resizes
    helpers.addEvent(window, "resize", (function() {
        // Basic debounce of resize function so it doesn't hurt performance when resizing browser.
        var timeout;
        return function() {
            clearTimeout(timeout);
            timeout = setTimeout(function() {
                each(Chart.instances, function(instance) {
                    // If the responsive flag is set in the chart instance config
                    // Cascade the resize event down to the chart.
                    if (instance.options.responsive) {
                        instance.resize(instance.render, true);
                    }
                });
            }, 50);
        };
    })());


    if (amd) {
        define(function() {
            return Chart;
        });
    } else if (typeof module === 'object' && module.exports) {
        module.exports = Chart;
    }

    root.Chart = Chart;

    Chart.noConflict = function() {
        root.Chart = previous;
        return Chart;
    };

}).call(this);

(function() {
    "use strict";

    var root = this,
        Chart = root.Chart,
        helpers = Chart.helpers;


    var defaultConfig = {
        //Boolean - Whether the scale should start at zero, or an order of magnitude down from the lowest value
        scaleBeginAtZero: true,

        //Boolean - Whether grid lines are shown across the chart
        scaleShowGridLines: true,

        //String - Colour of the grid lines
        scaleGridLineColor: "rgba(0,0,0,.05)",

        //Number - Width of the grid lines
        scaleGridLineWidth: 1,

        //Boolean - Whether to show horizontal lines (except X axis)
        scaleShowHorizontalLines: true,

        //Boolean - Whether to show vertical lines (except Y axis)
        scaleShowVerticalLines: true,

        //Boolean - If there is a stroke on each bar
        barShowStroke: true,

        //Number - Pixel width of the bar stroke
        barStrokeWidth: 2,

        //Number - Spacing between each of the X value sets
        barValueSpacing: 5,

        //Number - Spacing between data sets within X values
        barDatasetSpacing: 1,

        //String - A legend template
        legendTemplate: "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].fillColor%>\"><%if(datasets[i].label){%><%=datasets[i].label%><%}%></span></li><%}%></ul>"

    };


    Chart.Type.extend({
        name: "Bar",
        defaults: defaultConfig,
        initialize: function(data) {

            //Expose options as a scope variable here so we can access it in the ScaleClass
            var options = this.options;

            this.ScaleClass = Chart.Scale.extend({
                offsetGridLines: true,
                calculateBarX: function(datasetCount, datasetIndex, barIndex) {
                    //Reusable method for calculating the xPosition of a given bar based on datasetIndex & width of the bar
                    var xWidth = this.calculateBaseWidth(),
                        xAbsolute = this.calculateX(barIndex) - (xWidth / 2),
                        barWidth = this.calculateBarWidth(datasetCount);

                    return xAbsolute + (barWidth * datasetIndex) + (datasetIndex * options.barDatasetSpacing) + barWidth / 2;
                },
                calculateBaseWidth: function() {
                    return (this.calculateX(1) - this.calculateX(0)) - (2 * options.barValueSpacing);
                },
                calculateBarWidth: function(datasetCount) {
                    //The padding between datasets is to the right of each bar, providing that there are more than 1 dataset
                    var baseWidth = this.calculateBaseWidth() - ((datasetCount - 1) * options.barDatasetSpacing);

                    return (baseWidth / datasetCount);
                }
            });

            this.datasets = [];

            //Set up tooltip events on the chart
            if (this.options.showTooltips) {
                helpers.bindEvents(this, this.options.tooltipEvents, function(evt) {
                    var activeBars = (evt.type !== 'mouseout') ? this.getBarsAtEvent(evt) : [];

                    this.eachBars(function(bar) {
                        bar.restore(['fillColor', 'strokeColor']);
                    });
                    helpers.each(activeBars, function(activeBar) {
                        activeBar.fillColor = activeBar.highlightFill;
                        activeBar.strokeColor = activeBar.highlightStroke;
                    });
                    this.showTooltip(activeBars);
                });
            }

            //Declare the extension of the default point, to cater for the options passed in to the constructor
            this.BarClass = Chart.Rectangle.extend({
                strokeWidth: this.options.barStrokeWidth,
                showStroke: this.options.barShowStroke,
                ctx: this.chart.ctx
            });

            //Iterate through each of the datasets, and build this into a property of the chart
            helpers.each(data.datasets, function(dataset, datasetIndex) {

                var datasetObject = {
                    label: dataset.label || null,
                    fillColor: dataset.fillColor,
                    strokeColor: dataset.strokeColor,
                    bars: []
                };

                this.datasets.push(datasetObject);

                helpers.each(dataset.data, function(dataPoint, index) {
                    //Add a new point for each piece of data, passing any required data to draw.
                    datasetObject.bars.push(new this.BarClass({
                        index: index,
                        value: dataPoint,
                        label: data.labels[index],
                        datasetLabel: dataset.label,
                        strokeColor: dataset.strokeColor,
                        fillColor: dataset.fillColor,
                        highlightFill: dataset.highlightFill || dataset.fillColor,
                        highlightStroke: dataset.highlightStroke || dataset.strokeColor
                    }));
                }, this);

            }, this);

            this.buildScale(data.labels);

            this.BarClass.prototype.base = this.scale.endPoint;

            this.eachBars(function(bar, index, datasetIndex) {
                helpers.extend(bar, {
                    width: this.scale.calculateBarWidth(this.datasets.length),
                    x: this.scale.calculateBarX(this.datasets.length, datasetIndex, index),
                    y: this.scale.endPoint
                });
                bar.save();
            }, this);

            this.render();
        },
        update: function() {
            this.scale.update();
            // Reset any highlight colours before updating.
            helpers.each(this.activeElements, function(activeElement) {
                activeElement.restore(['fillColor', 'strokeColor']);
            });

            this.eachBars(function(bar) {
                bar.save();
            });
            this.render();
        },
        eachBars: function(callback) {
            helpers.each(this.datasets, function(dataset, datasetIndex) {
                helpers.each(dataset.bars, callback, this, datasetIndex);
            }, this);
        },
        getBarsAtEvent: function(e) {
            var barsArray = [],
                eventPosition = helpers.getRelativePosition(e),
                datasetIterator = function(dataset) {
                    barsArray.push(dataset.bars[barIndex]);
                },
                barIndex;

            for (var datasetIndex = 0; datasetIndex < this.datasets.length; datasetIndex++) {
                for (barIndex = 0; barIndex < this.datasets[datasetIndex].bars.length; barIndex++) {
                    if (this.datasets[datasetIndex].bars[barIndex].inRange(eventPosition.x, eventPosition.y)) {
                        helpers.each(this.datasets, datasetIterator);
                        return barsArray;
                    }
                }
            }

            return barsArray;
        },
        buildScale: function(labels) {
            var self = this;

            var dataTotal = function() {
                var values = [];
                self.eachBars(function(bar) {
                    values.push(bar.value);
                });
                return values;
            };

            var scaleOptions = {
                templateString: this.options.scaleLabel,
                height: this.chart.height,
                width: this.chart.width,
                ctx: this.chart.ctx,
                textColor: this.options.scaleFontColor,
                fontSize: this.options.scaleFontSize,
                fontStyle: this.options.scaleFontStyle,
                fontFamily: this.options.scaleFontFamily,
                valuesCount: labels.length,
                beginAtZero: this.options.scaleBeginAtZero,
                integersOnly: this.options.scaleIntegersOnly,
                calculateYRange: function(currentHeight) {
                    var updatedRanges = helpers.calculateScaleRange(
                        dataTotal(),
                        currentHeight,
                        this.fontSize,
                        this.beginAtZero,
                        this.integersOnly
                    );
                    helpers.extend(this, updatedRanges);
                },
                xLabels: labels,
                font: helpers.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
                lineWidth: this.options.scaleLineWidth,
                lineColor: this.options.scaleLineColor,
                showHorizontalLines: this.options.scaleShowHorizontalLines,
                showVerticalLines: this.options.scaleShowVerticalLines,
                gridLineWidth: (this.options.scaleShowGridLines) ? this.options.scaleGridLineWidth : 0,
                gridLineColor: (this.options.scaleShowGridLines) ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
                padding: (this.options.showScale) ? 0 : (this.options.barShowStroke) ? this.options.barStrokeWidth : 0,
                showLabels: this.options.scaleShowLabels,
                display: this.options.showScale
            };

            if (this.options.scaleOverride) {
                helpers.extend(scaleOptions, {
                    calculateYRange: helpers.noop,
                    steps: this.options.scaleSteps,
                    stepValue: this.options.scaleStepWidth,
                    min: this.options.scaleStartValue,
                    max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
                });
            }

            this.scale = new this.ScaleClass(scaleOptions);
        },
        addData: function(valuesArray, label) {
            //Map the values array for each of the datasets
            helpers.each(valuesArray, function(value, datasetIndex) {
                //Add a new point for each piece of data, passing any required data to draw.
                this.datasets[datasetIndex].bars.push(new this.BarClass({
                    value: value,
                    label: label,
                    datasetLabel: this.datasets[datasetIndex].label,
                    x: this.scale.calculateBarX(this.datasets.length, datasetIndex, this.scale.valuesCount + 1),
                    y: this.scale.endPoint,
                    width: this.scale.calculateBarWidth(this.datasets.length),
                    base: this.scale.endPoint,
                    strokeColor: this.datasets[datasetIndex].strokeColor,
                    fillColor: this.datasets[datasetIndex].fillColor
                }));
            }, this);

            this.scale.addXLabel(label);
            //Then re-render the chart.
            this.update();
        },
        removeData: function() {
            this.scale.removeXLabel();
            //Then re-render the chart.
            helpers.each(this.datasets, function(dataset) {
                dataset.bars.shift();
            }, this);
            this.update();
        },
        reflow: function() {
            helpers.extend(this.BarClass.prototype, {
                y: this.scale.endPoint,
                base: this.scale.endPoint
            });
            var newScaleProps = helpers.extend({
                height: this.chart.height,
                width: this.chart.width
            });
            this.scale.update(newScaleProps);
        },
        draw: function(ease) {
            var easingDecimal = ease || 1;
            this.clear();

            var ctx = this.chart.ctx;

            this.scale.draw(easingDecimal);

            //Draw all the bars for each dataset
            helpers.each(this.datasets, function(dataset, datasetIndex) {
                helpers.each(dataset.bars, function(bar, index) {
                    if (bar.hasValue()) {
                        bar.base = this.scale.endPoint;
                        //Transition then draw
                        bar.transition({
                            x: this.scale.calculateBarX(this.datasets.length, datasetIndex, index),
                            y: this.scale.calculateY(bar.value),
                            width: this.scale.calculateBarWidth(this.datasets.length)
                        }, easingDecimal).draw();
                    }
                }, this);

            }, this);
        }
    });


}).call(this);

(function() {
    "use strict";

    var root = this,
        Chart = root.Chart,
        //Cache a local reference to Chart.helpers
        helpers = Chart.helpers;

    var defaultConfig = {
        //Boolean - Whether we should show a stroke on each segment
        segmentShowStroke: true,

        //String - The colour of each segment stroke
        segmentStrokeColor: "#fff",

        //Number - The width of each segment stroke
        segmentStrokeWidth: 2,

        //The percentage of the chart that we cut out of the middle.
        percentageInnerCutout: 50,

        //Number - Amount of animation steps
        animationSteps: 100,

        //String - Animation easing effect
        animationEasing: "easeOutBounce",

        //Boolean - Whether we animate the rotation of the Doughnut
        animateRotate: true,

        //Boolean - Whether we animate scaling the Doughnut from the centre
        animateScale: false,

        //String - A legend template
        legendTemplate: "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<segments.length; i++){%><li><span style=\"background-color:<%=segments[i].fillColor%>\"><%if(segments[i].label){%><%=segments[i].label%><%}%></span></li><%}%></ul>"

    };

    Chart.Type.extend({
        //Passing in a name registers this chart in the Chart namespace
        name: "Doughnut",
        //Providing a defaults will also register the deafults in the chart namespace
        defaults: defaultConfig,
        //Initialize is fired when the chart is initialized - Data is passed in as a parameter
        //Config is automatically merged by the core of Chart.js, and is available at this.options
        initialize: function(data) {

            //Declare segments as a static property to prevent inheriting across the Chart type prototype
            this.segments = [];
            this.outerRadius = (helpers.min([this.chart.width, this.chart.height]) - this.options.segmentStrokeWidth / 2) / 2;

            this.SegmentArc = Chart.Arc.extend({
                ctx: this.chart.ctx,
                x: this.chart.width / 2,
                y: this.chart.height / 2
            });

            //Set up tooltip events on the chart
            if (this.options.showTooltips) {
                helpers.bindEvents(this, this.options.tooltipEvents, function(evt) {
                    var activeSegments = (evt.type !== 'mouseout') ? this.getSegmentsAtEvent(evt) : [];

                    helpers.each(this.segments, function(segment) {
                        segment.restore(["fillColor"]);
                    });
                    helpers.each(activeSegments, function(activeSegment) {
                        activeSegment.fillColor = activeSegment.highlightColor;
                    });
                    this.showTooltip(activeSegments);
                });
            }
            this.calculateTotal(data);

            helpers.each(data, function(datapoint, index) {
                if (!datapoint.color) {
                    datapoint.color = 'hsl(' + (360 * index / data.length) + ', 100%, 50%)';
                }
                this.addData(datapoint, index, true);
            }, this);

            this.render();
        },
        getSegmentsAtEvent: function(e) {
            var segmentsArray = [];

            var location = helpers.getRelativePosition(e);

            helpers.each(this.segments, function(segment) {
                if (segment.inRange(location.x, location.y)) segmentsArray.push(segment);
            }, this);
            return segmentsArray;
        },
        addData: function(segment, atIndex, silent) {
            var index = atIndex || this.segments.length;
            this.segments.splice(index, 0, new this.SegmentArc({
                value: segment.value,
                outerRadius: (this.options.animateScale) ? 0 : this.outerRadius,
                innerRadius: (this.options.animateScale) ? 0 : (this.outerRadius / 100) * this.options.percentageInnerCutout,
                fillColor: segment.color,
                highlightColor: segment.highlight || segment.color,
                showStroke: this.options.segmentShowStroke,
                strokeWidth: this.options.segmentStrokeWidth,
                strokeColor: this.options.segmentStrokeColor,
                startAngle: Math.PI * 1.5,
                circumference: (this.options.animateRotate) ? 0 : this.calculateCircumference(segment.value),
                label: segment.label
            }));
            if (!silent) {
                this.reflow();
                this.update();
            }
        },
        calculateCircumference: function(value) {
            if (this.total > 0) {
                return (Math.PI * 2) * (value / this.total);
            } else {
                return 0;
            }
        },
        calculateTotal: function(data) {
            this.total = 0;
            helpers.each(data, function(segment) {
                this.total += Math.abs(segment.value);
            }, this);
        },
        update: function() {
            this.calculateTotal(this.segments);

            // Reset any highlight colours before updating.
            helpers.each(this.activeElements, function(activeElement) {
                activeElement.restore(['fillColor']);
            });

            helpers.each(this.segments, function(segment) {
                segment.save();
            });
            this.render();
        },

        removeData: function(atIndex) {
            var indexToDelete = (helpers.isNumber(atIndex)) ? atIndex : this.segments.length - 1;
            this.segments.splice(indexToDelete, 1);
            this.reflow();
            this.update();
        },

        reflow: function() {
            helpers.extend(this.SegmentArc.prototype, {
                x: this.chart.width / 2,
                y: this.chart.height / 2
            });
            this.outerRadius = (helpers.min([this.chart.width, this.chart.height]) - this.options.segmentStrokeWidth / 2) / 2;
            helpers.each(this.segments, function(segment) {
                segment.update({
                    outerRadius: this.outerRadius,
                    innerRadius: (this.outerRadius / 100) * this.options.percentageInnerCutout
                });
            }, this);
        },
        draw: function(easeDecimal) {
            var animDecimal = (easeDecimal) ? easeDecimal : 1;
            this.clear();
            helpers.each(this.segments, function(segment, index) {
                segment.transition({
                    circumference: this.calculateCircumference(segment.value),
                    outerRadius: this.outerRadius,
                    innerRadius: (this.outerRadius / 100) * this.options.percentageInnerCutout
                }, animDecimal);

                segment.endAngle = segment.startAngle + segment.circumference;

                segment.draw();
                if (index === 0) {
                    segment.startAngle = Math.PI * 1.5;
                }
                //Check to see if it's the last segment, if not get the next and update the start angle
                if (index < this.segments.length - 1) {
                    this.segments[index + 1].startAngle = segment.endAngle;
                }
            }, this);

        }
    });

    Chart.types.Doughnut.extend({
        name: "Pie",
        defaults: helpers.merge(defaultConfig, {
            percentageInnerCutout: 0
        })
    });

}).call(this);

(function() {
    "use strict";

    var root = this,
        Chart = root.Chart,
        helpers = Chart.helpers;

    var defaultConfig = {

        ///Boolean - Whether grid lines are shown across the chart
        scaleShowGridLines: true,

        //String - Colour of the grid lines
        scaleGridLineColor: "rgba(0,0,0,.05)",

        //Number - Width of the grid lines
        scaleGridLineWidth: 1,

        //Boolean - Whether to show horizontal lines (except X axis)
        scaleShowHorizontalLines: true,

        //Boolean - Whether to show vertical lines (except Y axis)
        scaleShowVerticalLines: true,

        //Boolean - Whether the line is curved between points
        bezierCurve: true,

        //Number - Tension of the bezier curve between points
        bezierCurveTension: 0.4,

        //Boolean - Whether to show a dot for each point
        pointDot: true,

        //Number - Radius of each point dot in pixels
        pointDotRadius: 4,

        //Number - Pixel width of point dot stroke
        pointDotStrokeWidth: 1,

        //Number - amount extra to add to the radius to cater for hit detection outside the drawn point
        pointHitDetectionRadius: 20,

        //Boolean - Whether to show a stroke for datasets
        datasetStroke: true,

        //Number - Pixel width of dataset stroke
        datasetStrokeWidth: 2,

        //Boolean - Whether to fill the dataset with a colour
        datasetFill: true,

        //String - A legend template
        legendTemplate: "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].strokeColor%>\"><%if(datasets[i].label){%><%=datasets[i].label%><%}%></span></li><%}%></ul>",

        //Boolean - Whether to horizontally center the label and point dot inside the grid
        offsetGridLines: false

    };


    Chart.Type.extend({
        name: "Line",
        defaults: defaultConfig,
        initialize: function(data) {
            //Declare the extension of the default point, to cater for the options passed in to the constructor
            this.PointClass = Chart.Point.extend({
                offsetGridLines: this.options.offsetGridLines,
                strokeWidth: this.options.pointDotStrokeWidth,
                radius: this.options.pointDotRadius,
                display: this.options.pointDot,
                hitDetectionRadius: this.options.pointHitDetectionRadius,
                ctx: this.chart.ctx,
                inRange: function(mouseX) {
                    return (Math.pow(mouseX - this.x, 2) < Math.pow(this.radius + this.hitDetectionRadius, 2));
                }
            });

            this.datasets = [];

            //Set up tooltip events on the chart
            if (this.options.showTooltips) {
                helpers.bindEvents(this, this.options.tooltipEvents, function(evt) {
                    var activePoints = (evt.type !== 'mouseout') ? this.getPointsAtEvent(evt) : [];
                    this.eachPoints(function(point) {
                        point.restore(['fillColor', 'strokeColor']);
                    });
                    helpers.each(activePoints, function(activePoint) {
                        activePoint.fillColor = activePoint.highlightFill;
                        activePoint.strokeColor = activePoint.highlightStroke;
                    });
                    this.showTooltip(activePoints);
                });
            }

            //Iterate through each of the datasets, and build this into a property of the chart
            helpers.each(data.datasets, function(dataset) {

                var datasetObject = {
                    label: dataset.label || null,
                    fillColor: dataset.fillColor,
                    strokeColor: dataset.strokeColor,
                    pointColor: dataset.pointColor,
                    pointStrokeColor: dataset.pointStrokeColor,
                    points: []
                };

                this.datasets.push(datasetObject);


                helpers.each(dataset.data, function(dataPoint, index) {
                    //Add a new point for each piece of data, passing any required data to draw.
                    datasetObject.points.push(new this.PointClass({
                        value: dataPoint,
                        label: data.labels[index],
                        datasetLabel: dataset.label,
                        strokeColor: dataset.pointStrokeColor,
                        fillColor: dataset.pointColor,
                        highlightFill: dataset.pointHighlightFill || dataset.pointColor,
                        highlightStroke: dataset.pointHighlightStroke || dataset.pointStrokeColor
                    }));
                }, this);

                this.buildScale(data.labels);


                this.eachPoints(function(point, index) {
                    helpers.extend(point, {
                        x: this.scale.calculateX(index),
                        y: this.scale.endPoint
                    });
                    point.save();
                }, this);

            }, this);


            this.render();
        },
        update: function() {
            this.scale.update();
            // Reset any highlight colours before updating.
            helpers.each(this.activeElements, function(activeElement) {
                activeElement.restore(['fillColor', 'strokeColor']);
            });
            this.eachPoints(function(point) {
                point.save();
            });
            this.render();
        },
        eachPoints: function(callback) {
            helpers.each(this.datasets, function(dataset) {
                helpers.each(dataset.points, callback, this);
            }, this);
        },
        getPointsAtEvent: function(e) {
            var pointsArray = [],
                eventPosition = helpers.getRelativePosition(e);
            helpers.each(this.datasets, function(dataset) {
                helpers.each(dataset.points, function(point) {
                    if (point.inRange(eventPosition.x, eventPosition.y)) pointsArray.push(point);
                });
            }, this);
            return pointsArray;
        },
        buildScale: function(labels) {
            var self = this;

            var dataTotal = function() {
                var values = [];
                self.eachPoints(function(point) {
                    values.push(point.value);
                });

                return values;
            };

            var scaleOptions = {
                templateString: this.options.scaleLabel,
                height: this.chart.height,
                width: this.chart.width,
                ctx: this.chart.ctx,
                textColor: this.options.scaleFontColor,
                offsetGridLines: this.options.offsetGridLines,
                fontSize: this.options.scaleFontSize,
                fontStyle: this.options.scaleFontStyle,
                fontFamily: this.options.scaleFontFamily,
                valuesCount: labels.length,
                beginAtZero: this.options.scaleBeginAtZero,
                integersOnly: this.options.scaleIntegersOnly,
                calculateYRange: function(currentHeight) {
                    var updatedRanges = helpers.calculateScaleRange(
                        dataTotal(),
                        currentHeight,
                        this.fontSize,
                        this.beginAtZero,
                        this.integersOnly
                    );
                    helpers.extend(this, updatedRanges);
                },
                xLabels: labels,
                font: helpers.fontString(this.options.scaleFontSize, this.options.scaleFontStyle, this.options.scaleFontFamily),
                lineWidth: this.options.scaleLineWidth,
                lineColor: this.options.scaleLineColor,
                showHorizontalLines: this.options.scaleShowHorizontalLines,
                showVerticalLines: this.options.scaleShowVerticalLines,
                gridLineWidth: (this.options.scaleShowGridLines) ? this.options.scaleGridLineWidth : 0,
                gridLineColor: (this.options.scaleShowGridLines) ? this.options.scaleGridLineColor : "rgba(0,0,0,0)",
                padding: (this.options.showScale) ? 0 : this.options.pointDotRadius + this.options.pointDotStrokeWidth,
                showLabels: this.options.scaleShowLabels,
                display: this.options.showScale
            };

            if (this.options.scaleOverride) {
                helpers.extend(scaleOptions, {
                    calculateYRange: helpers.noop,
                    steps: this.options.scaleSteps,
                    stepValue: this.options.scaleStepWidth,
                    min: this.options.scaleStartValue,
                    max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
                });
            }


            this.scale = new Chart.Scale(scaleOptions);
        },
        addData: function(valuesArray, label) {
            //Map the values array for each of the datasets

            helpers.each(valuesArray, function(value, datasetIndex) {
                //Add a new point for each piece of data, passing any required data to draw.
                this.datasets[datasetIndex].points.push(new this.PointClass({
                    value: value,
                    label: label,
                    datasetLabel: this.datasets[datasetIndex].label,
                    x: this.scale.calculateX(this.scale.valuesCount + 1),
                    y: this.scale.endPoint,
                    strokeColor: this.datasets[datasetIndex].pointStrokeColor,
                    fillColor: this.datasets[datasetIndex].pointColor
                }));
            }, this);

            this.scale.addXLabel(label);
            //Then re-render the chart.
            this.update();
        },
        removeData: function() {
            this.scale.removeXLabel();
            //Then re-render the chart.
            helpers.each(this.datasets, function(dataset) {
                dataset.points.shift();
            }, this);
            this.update();
        },
        reflow: function() {
            var newScaleProps = helpers.extend({
                height: this.chart.height,
                width: this.chart.width
            });
            this.scale.update(newScaleProps);
        },
        draw: function(ease) {
            var easingDecimal = ease || 1;
            this.clear();

            var ctx = this.chart.ctx;

            // Some helper methods for getting the next/prev points
            var hasValue = function(item) {
                    return item.value !== null;
                },
                nextPoint = function(point, collection, index) {
                    return helpers.findNextWhere(collection, hasValue, index) || point;
                },
                previousPoint = function(point, collection, index) {
                    return helpers.findPreviousWhere(collection, hasValue, index) || point;
                };

            this.scale.draw(easingDecimal);


            helpers.each(this.datasets, function(dataset) {
                var pointsWithValues = helpers.where(dataset.points, hasValue);

                //Transition each point first so that the line and point drawing isn't out of sync
                //We can use this extra loop to calculate the control points of this dataset also in this loop

                helpers.each(dataset.points, function(point, index) {
                    if (point.hasValue()) {
                        point.transition({
                            y: this.scale.calculateY(point.value),
                            x: this.scale.calculateX(index)
                        }, easingDecimal);
                    }
                }, this);


                // Control points need to be calculated in a separate loop, because we need to know the current x/y of the point
                // This would cause issues when there is no animation, because the y of the next point would be 0, so beziers would be skewed
                if (this.options.bezierCurve) {
                    helpers.each(pointsWithValues, function(point, index) {
                        var tension = (index > 0 && index < pointsWithValues.length - 1) ? this.options.bezierCurveTension : 0;
                        point.controlPoints = helpers.splineCurve(
                            previousPoint(point, pointsWithValues, index),
                            point,
                            nextPoint(point, pointsWithValues, index),
                            tension
                        );

                        // Prevent the bezier going outside of the bounds of the graph

                        // Cap puter bezier handles to the upper/lower scale bounds
                        if (point.controlPoints.outer.y > this.scale.endPoint) {
                            point.controlPoints.outer.y = this.scale.endPoint;
                        } else if (point.controlPoints.outer.y < this.scale.startPoint) {
                            point.controlPoints.outer.y = this.scale.startPoint;
                        }

                        // Cap inner bezier handles to the upper/lower scale bounds
                        if (point.controlPoints.inner.y > this.scale.endPoint) {
                            point.controlPoints.inner.y = this.scale.endPoint;
                        } else if (point.controlPoints.inner.y < this.scale.startPoint) {
                            point.controlPoints.inner.y = this.scale.startPoint;
                        }
                    }, this);
                }


                //Draw the line between all the points
                ctx.lineWidth = this.options.datasetStrokeWidth;
                ctx.strokeStyle = dataset.strokeColor;
                ctx.beginPath();

                helpers.each(pointsWithValues, function(point, index) {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        if (this.options.bezierCurve) {
                            var previous = previousPoint(point, pointsWithValues, index);

                            ctx.bezierCurveTo(
                                previous.controlPoints.outer.x,
                                previous.controlPoints.outer.y,
                                point.controlPoints.inner.x,
                                point.controlPoints.inner.y,
                                point.x,
                                point.y
                            );
                        } else {
                            ctx.lineTo(point.x, point.y);
                        }
                    }
                }, this);

                ctx.stroke();

                if (this.options.datasetFill && pointsWithValues.length > 0) {
                    //Round off the line by going to the base of the chart, back to the start, then fill.
                    ctx.lineTo(pointsWithValues[pointsWithValues.length - 1].x, this.scale.endPoint);
                    ctx.lineTo(pointsWithValues[0].x, this.scale.endPoint);
                    ctx.fillStyle = dataset.fillColor;
                    ctx.closePath();
                    ctx.fill();
                }

                //Now draw the points over the line
                //A little inefficient double looping, but better than the line
                //lagging behind the point positions
                helpers.each(pointsWithValues, function(point) {
                    point.draw();
                });
            }, this);
        }
    });


}).call(this);

(function() {
    "use strict";

    var root = this,
        Chart = root.Chart,
        //Cache a local reference to Chart.helpers
        helpers = Chart.helpers;

    var defaultConfig = {
        //Boolean - Show a backdrop to the scale label
        scaleShowLabelBackdrop: true,

        //String - The colour of the label backdrop
        scaleBackdropColor: "rgba(255,255,255,0.75)",

        // Boolean - Whether the scale should begin at zero
        scaleBeginAtZero: true,

        //Number - The backdrop padding above & below the label in pixels
        scaleBackdropPaddingY: 2,

        //Number - The backdrop padding to the side of the label in pixels
        scaleBackdropPaddingX: 2,

        //Boolean - Show line for each value in the scale
        scaleShowLine: true,

        //Boolean - Stroke a line around each segment in the chart
        segmentShowStroke: true,

        //String - The colour of the stroke on each segment.
        segmentStrokeColor: "#fff",

        //Number - The width of the stroke value in pixels
        segmentStrokeWidth: 2,

        //Number - Amount of animation steps
        animationSteps: 100,

        //String - Animation easing effect.
        animationEasing: "easeOutBounce",

        //Boolean - Whether to animate the rotation of the chart
        animateRotate: true,

        //Boolean - Whether to animate scaling the chart from the centre
        animateScale: false,

        //String - A legend template
        legendTemplate: "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<segments.length; i++){%><li><span style=\"background-color:<%=segments[i].fillColor%>\"><%if(segments[i].label){%><%=segments[i].label%><%}%></span></li><%}%></ul>"
    };


    Chart.Type.extend({
        //Passing in a name registers this chart in the Chart namespace
        name: "PolarArea",
        //Providing a defaults will also register the deafults in the chart namespace
        defaults: defaultConfig,
        //Initialize is fired when the chart is initialized - Data is passed in as a parameter
        //Config is automatically merged by the core of Chart.js, and is available at this.options
        initialize: function(data) {
            this.segments = [];
            //Declare segment class as a chart instance specific class, so it can share props for this instance
            this.SegmentArc = Chart.Arc.extend({
                showStroke: this.options.segmentShowStroke,
                strokeWidth: this.options.segmentStrokeWidth,
                strokeColor: this.options.segmentStrokeColor,
                ctx: this.chart.ctx,
                innerRadius: 0,
                x: this.chart.width / 2,
                y: this.chart.height / 2
            });
            this.scale = new Chart.RadialScale({
                display: this.options.showScale,
                fontStyle: this.options.scaleFontStyle,
                fontSize: this.options.scaleFontSize,
                fontFamily: this.options.scaleFontFamily,
                fontColor: this.options.scaleFontColor,
                showLabels: this.options.scaleShowLabels,
                showLabelBackdrop: this.options.scaleShowLabelBackdrop,
                backdropColor: this.options.scaleBackdropColor,
                backdropPaddingY: this.options.scaleBackdropPaddingY,
                backdropPaddingX: this.options.scaleBackdropPaddingX,
                lineWidth: (this.options.scaleShowLine) ? this.options.scaleLineWidth : 0,
                lineColor: this.options.scaleLineColor,
                lineArc: true,
                width: this.chart.width,
                height: this.chart.height,
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2,
                ctx: this.chart.ctx,
                templateString: this.options.scaleLabel,
                valuesCount: data.length
            });

            this.updateScaleRange(data);

            this.scale.update();

            helpers.each(data, function(segment, index) {
                this.addData(segment, index, true);
            }, this);

            //Set up tooltip events on the chart
            if (this.options.showTooltips) {
                helpers.bindEvents(this, this.options.tooltipEvents, function(evt) {
                    var activeSegments = (evt.type !== 'mouseout') ? this.getSegmentsAtEvent(evt) : [];
                    helpers.each(this.segments, function(segment) {
                        segment.restore(["fillColor"]);
                    });
                    helpers.each(activeSegments, function(activeSegment) {
                        activeSegment.fillColor = activeSegment.highlightColor;
                    });
                    this.showTooltip(activeSegments);
                });
            }

            this.render();
        },
        getSegmentsAtEvent: function(e) {
            var segmentsArray = [];

            var location = helpers.getRelativePosition(e);

            helpers.each(this.segments, function(segment) {
                if (segment.inRange(location.x, location.y)) segmentsArray.push(segment);
            }, this);
            return segmentsArray;
        },
        addData: function(segment, atIndex, silent) {
            var index = atIndex || this.segments.length;

            this.segments.splice(index, 0, new this.SegmentArc({
                fillColor: segment.color,
                highlightColor: segment.highlight || segment.color,
                label: segment.label,
                value: segment.value,
                outerRadius: (this.options.animateScale) ? 0 : this.scale.calculateCenterOffset(segment.value),
                circumference: (this.options.animateRotate) ? 0 : this.scale.getCircumference(),
                startAngle: Math.PI * 1.5
            }));
            if (!silent) {
                this.reflow();
                this.update();
            }
        },
        removeData: function(atIndex) {
            var indexToDelete = (helpers.isNumber(atIndex)) ? atIndex : this.segments.length - 1;
            this.segments.splice(indexToDelete, 1);
            this.reflow();
            this.update();
        },
        calculateTotal: function(data) {
            this.total = 0;
            helpers.each(data, function(segment) {
                this.total += segment.value;
            }, this);
            this.scale.valuesCount = this.segments.length;
        },
        updateScaleRange: function(datapoints) {
            var valuesArray = [];
            helpers.each(datapoints, function(segment) {
                valuesArray.push(segment.value);
            });

            var scaleSizes = (this.options.scaleOverride) ? {
                    steps: this.options.scaleSteps,
                    stepValue: this.options.scaleStepWidth,
                    min: this.options.scaleStartValue,
                    max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
                } :
                helpers.calculateScaleRange(
                    valuesArray,
                    helpers.min([this.chart.width, this.chart.height]) / 2,
                    this.options.scaleFontSize,
                    this.options.scaleBeginAtZero,
                    this.options.scaleIntegersOnly
                );

            helpers.extend(
                this.scale,
                scaleSizes, {
                    size: helpers.min([this.chart.width, this.chart.height]),
                    xCenter: this.chart.width / 2,
                    yCenter: this.chart.height / 2
                }
            );

        },
        update: function() {
            this.calculateTotal(this.segments);

            helpers.each(this.segments, function(segment) {
                segment.save();
            });

            this.reflow();
            this.render();
        },
        reflow: function() {
            helpers.extend(this.SegmentArc.prototype, {
                x: this.chart.width / 2,
                y: this.chart.height / 2
            });
            this.updateScaleRange(this.segments);
            this.scale.update();

            helpers.extend(this.scale, {
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2
            });

            helpers.each(this.segments, function(segment) {
                segment.update({
                    outerRadius: this.scale.calculateCenterOffset(segment.value)
                });
            }, this);

        },
        draw: function(ease) {
            var easingDecimal = ease || 1;
            //Clear & draw the canvas
            this.clear();
            helpers.each(this.segments, function(segment, index) {
                segment.transition({
                    circumference: this.scale.getCircumference(),
                    outerRadius: this.scale.calculateCenterOffset(segment.value)
                }, easingDecimal);

                segment.endAngle = segment.startAngle + segment.circumference;

                // If we've removed the first segment we need to set the first one to
                // start at the top.
                if (index === 0) {
                    segment.startAngle = Math.PI * 1.5;
                }

                //Check to see if it's the last segment, if not get the next and update the start angle
                if (index < this.segments.length - 1) {
                    this.segments[index + 1].startAngle = segment.endAngle;
                }
                segment.draw();
            }, this);
            this.scale.draw();
        }
    });

}).call(this);

(function() {
    "use strict";

    var root = this,
        Chart = root.Chart,
        helpers = Chart.helpers;



    Chart.Type.extend({
        name: "Radar",
        defaults: {
            //Boolean - Whether to show lines for each scale point
            scaleShowLine: true,

            //Boolean - Whether we show the angle lines out of the radar
            angleShowLineOut: true,

            //Boolean - Whether to show labels on the scale
            scaleShowLabels: false,

            // Boolean - Whether the scale should begin at zero
            scaleBeginAtZero: true,

            //String - Colour of the angle line
            angleLineColor: "rgba(0,0,0,.1)",

            //Number - Pixel width of the angle line
            angleLineWidth: 1,

            //String - Point label font declaration
            pointLabelFontFamily: "'Arial'",

            //String - Point label font weight
            pointLabelFontStyle: "normal",

            //Number - Point label font size in pixels
            pointLabelFontSize: 10,

            //String - Point label font colour
            pointLabelFontColor: "#666",

            //Boolean - Whether to show a dot for each point
            pointDot: true,

            //Number - Radius of each point dot in pixels
            pointDotRadius: 3,

            //Number - Pixel width of point dot stroke
            pointDotStrokeWidth: 1,

            //Number - amount extra to add to the radius to cater for hit detection outside the drawn point
            pointHitDetectionRadius: 20,

            //Boolean - Whether to show a stroke for datasets
            datasetStroke: true,

            //Number - Pixel width of dataset stroke
            datasetStrokeWidth: 2,

            //Boolean - Whether to fill the dataset with a colour
            datasetFill: true,

            //String - A legend template
            legendTemplate: "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].strokeColor%>\"><%if(datasets[i].label){%><%=datasets[i].label%><%}%></span></li><%}%></ul>"

        },

        initialize: function(data) {
            this.PointClass = Chart.Point.extend({
                strokeWidth: this.options.pointDotStrokeWidth,
                radius: this.options.pointDotRadius,
                display: this.options.pointDot,
                hitDetectionRadius: this.options.pointHitDetectionRadius,
                ctx: this.chart.ctx
            });

            this.datasets = [];

            this.buildScale(data);

            //Set up tooltip events on the chart
            if (this.options.showTooltips) {
                helpers.bindEvents(this, this.options.tooltipEvents, function(evt) {
                    var activePointsCollection = (evt.type !== 'mouseout') ? this.getPointsAtEvent(evt) : [];

                    this.eachPoints(function(point) {
                        point.restore(['fillColor', 'strokeColor']);
                    });
                    helpers.each(activePointsCollection, function(activePoint) {
                        activePoint.fillColor = activePoint.highlightFill;
                        activePoint.strokeColor = activePoint.highlightStroke;
                    });

                    this.showTooltip(activePointsCollection);
                });
            }

            //Iterate through each of the datasets, and build this into a property of the chart
            helpers.each(data.datasets, function(dataset) {

                var datasetObject = {
                    label: dataset.label || null,
                    fillColor: dataset.fillColor,
                    strokeColor: dataset.strokeColor,
                    pointColor: dataset.pointColor,
                    pointStrokeColor: dataset.pointStrokeColor,
                    points: []
                };

                this.datasets.push(datasetObject);

                helpers.each(dataset.data, function(dataPoint, index) {
                    //Add a new point for each piece of data, passing any required data to draw.
                    var pointPosition;
                    if (!this.scale.animation) {
                        pointPosition = this.scale.getPointPosition(index, this.scale.calculateCenterOffset(dataPoint));
                    }
                    datasetObject.points.push(new this.PointClass({
                        value: dataPoint,
                        label: data.labels[index],
                        datasetLabel: dataset.label,
                        x: (this.options.animation) ? this.scale.xCenter : pointPosition.x,
                        y: (this.options.animation) ? this.scale.yCenter : pointPosition.y,
                        strokeColor: dataset.pointStrokeColor,
                        fillColor: dataset.pointColor,
                        highlightFill: dataset.pointHighlightFill || dataset.pointColor,
                        highlightStroke: dataset.pointHighlightStroke || dataset.pointStrokeColor
                    }));
                }, this);

            }, this);

            this.render();
        },
        eachPoints: function(callback) {
            helpers.each(this.datasets, function(dataset) {
                helpers.each(dataset.points, callback, this);
            }, this);
        },

        getPointsAtEvent: function(evt) {
            var mousePosition = helpers.getRelativePosition(evt),
                fromCenter = helpers.getAngleFromPoint({
                    x: this.scale.xCenter,
                    y: this.scale.yCenter
                }, mousePosition);

            var anglePerIndex = (Math.PI * 2) / this.scale.valuesCount,
                pointIndex = Math.round((fromCenter.angle - Math.PI * 1.5) / anglePerIndex),
                activePointsCollection = [];

            // If we're at the top, make the pointIndex 0 to get the first of the array.
            if (pointIndex >= this.scale.valuesCount || pointIndex < 0) {
                pointIndex = 0;
            }

            if (fromCenter.distance <= this.scale.drawingArea) {
                helpers.each(this.datasets, function(dataset) {
                    activePointsCollection.push(dataset.points[pointIndex]);
                });
            }

            return activePointsCollection;
        },

        buildScale: function(data) {
            this.scale = new Chart.RadialScale({
                display: this.options.showScale,
                fontStyle: this.options.scaleFontStyle,
                fontSize: this.options.scaleFontSize,
                fontFamily: this.options.scaleFontFamily,
                fontColor: this.options.scaleFontColor,
                showLabels: this.options.scaleShowLabels,
                showLabelBackdrop: this.options.scaleShowLabelBackdrop,
                backdropColor: this.options.scaleBackdropColor,
                backdropPaddingY: this.options.scaleBackdropPaddingY,
                backdropPaddingX: this.options.scaleBackdropPaddingX,
                lineWidth: (this.options.scaleShowLine) ? this.options.scaleLineWidth : 0,
                lineColor: this.options.scaleLineColor,
                angleLineColor: this.options.angleLineColor,
                angleLineWidth: (this.options.angleShowLineOut) ? this.options.angleLineWidth : 0,
                // Point labels at the edge of each line
                pointLabelFontColor: this.options.pointLabelFontColor,
                pointLabelFontSize: this.options.pointLabelFontSize,
                pointLabelFontFamily: this.options.pointLabelFontFamily,
                pointLabelFontStyle: this.options.pointLabelFontStyle,
                height: this.chart.height,
                width: this.chart.width,
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2,
                ctx: this.chart.ctx,
                templateString: this.options.scaleLabel,
                labels: data.labels,
                valuesCount: data.datasets[0].data.length
            });

            this.scale.setScaleSize();
            this.updateScaleRange(data.datasets);
            this.scale.buildYLabels();
        },
        updateScaleRange: function(datasets) {
            var valuesArray = (function() {
                var totalDataArray = [];
                helpers.each(datasets, function(dataset) {
                    if (dataset.data) {
                        totalDataArray = totalDataArray.concat(dataset.data);
                    } else {
                        helpers.each(dataset.points, function(point) {
                            totalDataArray.push(point.value);
                        });
                    }
                });
                return totalDataArray;
            })();


            var scaleSizes = (this.options.scaleOverride) ? {
                    steps: this.options.scaleSteps,
                    stepValue: this.options.scaleStepWidth,
                    min: this.options.scaleStartValue,
                    max: this.options.scaleStartValue + (this.options.scaleSteps * this.options.scaleStepWidth)
                } :
                helpers.calculateScaleRange(
                    valuesArray,
                    helpers.min([this.chart.width, this.chart.height]) / 2,
                    this.options.scaleFontSize,
                    this.options.scaleBeginAtZero,
                    this.options.scaleIntegersOnly
                );

            helpers.extend(
                this.scale,
                scaleSizes
            );

        },
        addData: function(valuesArray, label) {
            //Map the values array for each of the datasets
            this.scale.valuesCount++;
            helpers.each(valuesArray, function(value, datasetIndex) {
                var pointPosition = this.scale.getPointPosition(this.scale.valuesCount, this.scale.calculateCenterOffset(value));
                this.datasets[datasetIndex].points.push(new this.PointClass({
                    value: value,
                    label: label,
                    datasetLabel: this.datasets[datasetIndex].label,
                    x: pointPosition.x,
                    y: pointPosition.y,
                    strokeColor: this.datasets[datasetIndex].pointStrokeColor,
                    fillColor: this.datasets[datasetIndex].pointColor
                }));
            }, this);

            this.scale.labels.push(label);

            this.reflow();

            this.update();
        },
        removeData: function() {
            this.scale.valuesCount--;
            this.scale.labels.shift();
            helpers.each(this.datasets, function(dataset) {
                dataset.points.shift();
            }, this);
            this.reflow();
            this.update();
        },
        update: function() {
            this.eachPoints(function(point) {
                point.save();
            });
            this.reflow();
            this.render();
        },
        reflow: function() {
            helpers.extend(this.scale, {
                width: this.chart.width,
                height: this.chart.height,
                size: helpers.min([this.chart.width, this.chart.height]),
                xCenter: this.chart.width / 2,
                yCenter: this.chart.height / 2
            });
            this.updateScaleRange(this.datasets);
            this.scale.setScaleSize();
            this.scale.buildYLabels();
        },
        draw: function(ease) {
            var easeDecimal = ease || 1,
                ctx = this.chart.ctx;
            this.clear();
            this.scale.draw();

            helpers.each(this.datasets, function(dataset) {

                //Transition each point first so that the line and point drawing isn't out of sync
                helpers.each(dataset.points, function(point, index) {
                    if (point.hasValue()) {
                        point.transition(this.scale.getPointPosition(index, this.scale.calculateCenterOffset(point.value)), easeDecimal);
                    }
                }, this);



                //Draw the line between all the points
                ctx.lineWidth = this.options.datasetStrokeWidth;
                ctx.strokeStyle = dataset.strokeColor;
                ctx.beginPath();
                helpers.each(dataset.points, function(point, index) {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }, this);
                ctx.closePath();
                ctx.stroke();

                ctx.fillStyle = dataset.fillColor;
                if (this.options.datasetFill) {
                    ctx.fill();
                }
                //Now draw the points over the line
                //A little inefficient double looping, but better than the line
                //lagging behind the point positions
                helpers.each(dataset.points, function(point) {
                    if (point.hasValue()) {
                        point.draw();
                    }
                });

            }, this);

        }

    });




}).call(this);

/**
 * @name MarkerClustererPlus for Google Maps V3
 * @version 2.1.1 [November 4, 2013]
 * @author Gary Little
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of markers.
 * <p>
 * This is an enhanced V3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the
 * <a href="http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/"
 * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.
 * <p>
 * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It
 *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>batchSizeIE</code>,
 *  and <code>calculator</code> properties as well as support for four more events. It also allows
 *  greater control over the styling of the text that appears on the cluster marker. The
 *  documentation has been significantly improved and the overall code has been simplified and
 *  polished. Very large numbers of markers can now be managed without causing Javascript timeout
 *  errors on Internet Explorer. Note that the name of the <code>clusterclick</code> event has been
 *  deprecated. The new name is <code>click</code>, so please change your application code now.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @name ClusterIconStyle
 * @class This class represents the object for values in the <code>styles</code> array passed
 *  to the {@link MarkerClusterer} constructor. The element in this array that is used to
 *  style the cluster icon is determined by calling the <code>calculator</code> function.
 *
 * @property {string} url The URL of the cluster icon image file. Required.
 * @property {number} height The display height (in pixels) of the cluster icon. Required.
 * @property {number} width The display width (in pixels) of the cluster icon. Required.
 * @property {Array} [anchorText] The position (in pixels) from the center of the cluster icon to
 *  where the text label is to be centered and drawn. The format is <code>[yoffset, xoffset]</code>
 *  where <code>yoffset</code> increases as you go down from center and <code>xoffset</code>
 *  increases to the right of center. The default is <code>[0, 0]</code>.
 * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the
 *  spot on the cluster icon that is to be aligned with the cluster position. The format is
 *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and
 *  <code>xoffset</code> increases to the right of the top-left corner of the icon. The default
 *  anchor position is the center of the cluster icon.
 * @property {string} [textColor="black"] The color of the label text shown on the
 *  cluster icon.
 * @property {number} [textSize=11] The size (in pixels) of the label text shown on the
 *  cluster icon.
 * @property {string} [textDecoration="none"] The value of the CSS <code>text-decoration</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontWeight="bold"] The value of the CSS <code>font-weight</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontStyle="normal"] The value of the CSS <code>font-style</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontFamily="Arial,sans-serif"] The value of the CSS <code>font-family</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [backgroundPosition="0 0"] The position of the cluster icon image
 *  within the image defined by <code>url</code>. The format is <code>"xpos ypos"</code>
 *  (the same format as for the CSS <code>background-position</code> property). You must set
 *  this property appropriately when the image defined by <code>url</code> represents a sprite
 *  containing multiple images. Note that the position <i>must</i> be specified in px units.
 */
/**
 * @name ClusterIconInfo
 * @class This class is an object containing general information about a cluster icon. This is
 *  the object that a <code>calculator</code> function returns.
 *
 * @property {string} text The text of the label to be shown on the cluster icon.
 * @property {number} index The index plus 1 of the element in the <code>styles</code>
 *  array to be used to style the cluster icon.
 * @property {string} title The tooltip to display when the mouse moves over the cluster icon.
 *  If this value is <code>undefined</code> or <code>""</code>, <code>title</code> is set to the
 *  value of the <code>title</code> property passed to the MarkerClusterer.
 */
/**
 * A cluster icon.
 *
 * @constructor
 * @extends google.maps.OverlayView
 * @param {Cluster} cluster The cluster with which the icon is to be associated.
 * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons
 *  to use for various cluster sizes.
 * @private
 */
function ClusterIcon(cluster, styles) {
    cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

    this.cluster_ = cluster;
    this.className_ = cluster.getMarkerClusterer().getClusterClass();
    this.styles_ = styles;
    this.center_ = null;
    this.div_ = null;
    this.sums_ = null;
    this.visible_ = false;

    this.setMap(cluster.getMap()); // Note: this causes onAdd to be called
}


/**
 * Adds the icon to the DOM.
 */
ClusterIcon.prototype.onAdd = function() {
    var cClusterIcon = this;
    var cMouseDownInCluster;
    var cDraggingMapByCluster;

    this.div_ = document.createElement("div");
    this.div_.className = this.className_;
    if (this.visible_) {
        this.show();
    }

    this.getPanes().overlayMouseTarget.appendChild(this.div_);

    // Fix for Issue 157
    this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function() {
        cDraggingMapByCluster = cMouseDownInCluster;
    });

    google.maps.event.addDomListener(this.div_, "mousedown", function() {
        cMouseDownInCluster = true;
        cDraggingMapByCluster = false;
    });

    google.maps.event.addDomListener(this.div_, "click", function(e) {
        cMouseDownInCluster = false;
        if (!cDraggingMapByCluster) {
            var theBounds;
            var mz;
            var mc = cClusterIcon.cluster_.getMarkerClusterer();
            /**
             * This event is fired when a cluster marker is clicked.
             * @name MarkerClusterer#click
             * @param {Cluster} c The cluster that was clicked.
             * @event
             */
            google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
            google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_); // deprecated name

            // The default click handler follows. Disable it by setting
            // the zoomOnClick property to false.
            if (mc.getZoomOnClick()) {
                // Zoom into the cluster.
                mz = mc.getMaxZoom();
                theBounds = cClusterIcon.cluster_.getBounds();
                mc.getMap().fitBounds(theBounds);
                // There is a fix for Issue 170 here:
                setTimeout(function() {
                    mc.getMap().fitBounds(theBounds);
                    // Don't zoom beyond the max zoom level
                    if (mz !== null && (mc.getMap().getZoom() > mz)) {
                        mc.getMap().setZoom(mz + 1);
                    }
                }, 100);
            }

            // Prevent event propagation to the map:
            e.cancelBubble = true;
            if (e.stopPropagation) {
                e.stopPropagation();
            }
        }
    });

    google.maps.event.addDomListener(this.div_, "mouseover", function() {
        var mc = cClusterIcon.cluster_.getMarkerClusterer();
        /**
         * This event is fired when the mouse moves over a cluster marker.
         * @name MarkerClusterer#mouseover
         * @param {Cluster} c The cluster that the mouse moved over.
         * @event
         */
        google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
    });

    google.maps.event.addDomListener(this.div_, "mouseout", function() {
        var mc = cClusterIcon.cluster_.getMarkerClusterer();
        /**
         * This event is fired when the mouse moves out of a cluster marker.
         * @name MarkerClusterer#mouseout
         * @param {Cluster} c The cluster that the mouse moved out of.
         * @event
         */
        google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
    });
};


/**
 * Removes the icon from the DOM.
 */
ClusterIcon.prototype.onRemove = function() {
    if (this.div_ && this.div_.parentNode) {
        this.hide();
        google.maps.event.removeListener(this.boundsChangedListener_);
        google.maps.event.clearInstanceListeners(this.div_);
        this.div_.parentNode.removeChild(this.div_);
        this.div_ = null;
    }
};


/**
 * Draws the icon.
 */
ClusterIcon.prototype.draw = function() {
    if (this.visible_) {
        var pos = this.getPosFromLatLng_(this.center_);
        this.div_.style.top = pos.y + "px";
        this.div_.style.left = pos.x + "px";
    }
};


/**
 * Hides the icon.
 */
ClusterIcon.prototype.hide = function() {
    if (this.div_) {
        this.div_.style.display = "none";
    }
    this.visible_ = false;
};


/**
 * Positions and shows the icon.
 */
ClusterIcon.prototype.show = function() {
    if (this.div_) {
        var img = "";
        // NOTE: values must be specified in px units
        var bp = this.backgroundPosition_.split(" ");
        var spriteH = parseInt(bp[0].trim(), 10);
        var spriteV = parseInt(bp[1].trim(), 10);
        var pos = this.getPosFromLatLng_(this.center_);
        this.div_.style.cssText = this.createCss(pos);
        img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
        if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
            img += "clip: rect(" + (-1 * spriteV) + "px, " + ((-1 * spriteH) + this.width_) + "px, " +
                ((-1 * spriteV) + this.height_) + "px, " + (-1 * spriteH) + "px);";
        } else {
            img += "width: " + this.width_ + "px;" + "height: " + this.height_ + "px;";
        }
        img += "'>";
        this.div_.innerHTML = img + "<div style='" +
            "position: absolute;" +
            "top: " + this.anchorText_[0] + "px;" +
            "left: " + this.anchorText_[1] + "px;" +
            "color: " + this.textColor_ + ";" +
            "font-size: " + this.textSize_ + "px;" +
            "font-family: " + this.fontFamily_ + ";" +
            "font-weight: " + this.fontWeight_ + ";" +
            "font-style: " + this.fontStyle_ + ";" +
            "text-decoration: " + this.textDecoration_ + ";" +
            "text-align: center;" +
            "width: " + this.width_ + "px;" +
            "line-height:" + this.height_ + "px;" +
            "'>" + (this.cluster_.hideLabel_ ? ' ' : this.sums_.text) + "</div>";
        if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
            this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
        } else {
            this.div_.title = this.sums_.title;
        }
        this.div_.style.display = "";
    }
    this.visible_ = true;
};


/**
 * Sets the icon styles to the appropriate element in the styles array.
 *
 * @param {ClusterIconInfo} sums The icon label text and styles index.
 */
ClusterIcon.prototype.useStyle = function(sums) {
    this.sums_ = sums;
    var index = Math.max(0, sums.index - 1);
    index = Math.min(this.styles_.length - 1, index);
    var style = this.styles_[index];
    this.url_ = style.url;
    this.height_ = style.height;
    this.width_ = style.width;
    this.anchorText_ = style.anchorText || [0, 0];
    this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];
    this.textColor_ = style.textColor || "black";
    this.textSize_ = style.textSize || 11;
    this.textDecoration_ = style.textDecoration || "none";
    this.fontWeight_ = style.fontWeight || "bold";
    this.fontStyle_ = style.fontStyle || "normal";
    this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
    this.backgroundPosition_ = style.backgroundPosition || "0 0";
};


/**
 * Sets the position at which to center the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function(center) {
    this.center_ = center;
};


/**
 * Creates the cssText style parameter based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position of the icon.
 * @return {string} The CSS style text.
 */
ClusterIcon.prototype.createCss = function(pos) {
    var style = [];
    style.push("cursor: pointer;");
    style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;");
    style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;");
    return style.join("");
};


/**
 * Returns the position at which to place the DIV depending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 */
ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
    var pos = this.getProjection().fromLatLngToDivPixel(latlng);
    pos.x -= this.anchorIcon_[1];
    pos.y -= this.anchorIcon_[0];
    pos.x = parseInt(pos.x, 10);
    pos.y = parseInt(pos.y, 10);
    return pos;
};


/**
 * Creates a single cluster that manages a group of proximate markers.
 *  Used internally, do not call this constructor directly.
 * @constructor
 * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this
 *  cluster is associated.
 */
function Cluster(mc) {
    this.markerClusterer_ = mc;
    this.map_ = mc.getMap();
    this.gridSize_ = mc.getGridSize();
    this.minClusterSize_ = mc.getMinimumClusterSize();
    this.averageCenter_ = mc.getAverageCenter();
    this.hideLabel_ = mc.getHideLabel();
    this.markers_ = [];
    this.center_ = null;
    this.bounds_ = null;
    this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
}


/**
 * Returns the number of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {number} The number of markers in the cluster.
 */
Cluster.prototype.getSize = function() {
    return this.markers_.length;
};


/**
 * Returns the array of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {Array} The array of markers in the cluster.
 */
Cluster.prototype.getMarkers = function() {
    return this.markers_;
};


/**
 * Returns the center of the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {google.maps.LatLng} The center of the cluster.
 */
Cluster.prototype.getCenter = function() {
    return this.center_;
};


/**
 * Returns the map with which the cluster is associated.
 *
 * @return {google.maps.Map} The map.
 * @ignore
 */
Cluster.prototype.getMap = function() {
    return this.map_;
};


/**
 * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 * @ignore
 */
Cluster.prototype.getMarkerClusterer = function() {
    return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 * @ignore
 */
Cluster.prototype.getBounds = function() {
    var i;
    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
    var markers = this.getMarkers();
    for (i = 0; i < markers.length; i++) {
        bounds.extend(markers[i].getPosition());
    }
    return bounds;
};


/**
 * Removes the cluster from the map.
 *
 * @ignore
 */
Cluster.prototype.remove = function() {
    this.clusterIcon_.setMap(null);
    this.markers_ = [];
    delete this.markers_;
};


/**
 * Adds a marker to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to be added.
 * @return {boolean} True if the marker was added.
 * @ignore
 */
Cluster.prototype.addMarker = function(marker) {
    var i;
    var mCount;
    var mz;

    if (this.isMarkerAlreadyAdded_(marker)) {
        return false;
    }

    if (!this.center_) {
        this.center_ = marker.getPosition();
        this.calculateBounds_();
    } else {
        if (this.averageCenter_) {
            var l = this.markers_.length + 1;
            var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
            var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
            this.center_ = new google.maps.LatLng(lat, lng);
            this.calculateBounds_();
        }
    }

    marker.isAdded = true;
    this.markers_.push(marker);

    mCount = this.markers_.length;
    mz = this.markerClusterer_.getMaxZoom();
    if (mz !== null && this.map_.getZoom() > mz) {
        // Zoomed in past max zoom, so show the marker.
        if (marker.getMap() !== this.map_) {
            marker.setMap(this.map_);
        }
    } else if (mCount < this.minClusterSize_) {
        // Min cluster size not reached so show the marker.
        if (marker.getMap() !== this.map_) {
            marker.setMap(this.map_);
        }
    } else if (mCount === this.minClusterSize_) {
        // Hide the markers that were showing.
        for (i = 0; i < mCount; i++) {
            this.markers_[i].setMap(null);
        }
    } else {
        marker.setMap(null);
    }

    return true;
};


/**
 * Determines if a marker lies within the cluster's bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 * @ignore
 */
Cluster.prototype.isMarkerInClusterBounds = function(marker) {
    return this.bounds_.contains(marker.getPosition());
};


/**
 * Calculates the extended bounds of the cluster with the grid.
 */
Cluster.prototype.calculateBounds_ = function() {
    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Updates the cluster icon.
 */
Cluster.prototype.updateIcon_ = function() {
    var mCount = this.markers_.length;
    var mz = this.markerClusterer_.getMaxZoom();

    if (mz !== null && this.map_.getZoom() > mz) {
        this.clusterIcon_.hide();
        return;
    }

    if (mCount < this.minClusterSize_) {
        // Min cluster size not yet reached.
        this.clusterIcon_.hide();
        return;
    }

    var numStyles = this.markerClusterer_.getStyles().length;
    var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
    this.clusterIcon_.setCenter(this.center_);
    this.clusterIcon_.useStyle(sums);
    this.clusterIcon_.show();
};


/**
 * Determines if a marker has already been added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker has already been added.
 */
Cluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
    for (var i = 0, n = this.markers_.length; i < n; i++) {
        if (marker === this.markers_[i]) {
            return true;
        }
    }
    return false;
};


/**
 * @name MarkerClustererOptions
 * @class This class represents the optional parameter passed to
 *  the {@link MarkerClusterer} constructor.
 * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.
 * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or
 *  <code>null</code> if clustering is to be enabled at all zoom levels.
 * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is
 *  clicked. You may want to set this to <code>false</code> if you have installed a handler
 *  for the <code>click</code> event and it deals with zooming on its own.
 * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be
 *  the average position of all markers in the cluster. If set to <code>false</code>, the
 *  cluster marker is positioned at the location of the first marker added to the cluster.
 * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster
 *  before the markers are hidden and a cluster marker appears.
 * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You
 *  may want to set this to <code>true</code> to ensure that hidden markers are not included
 *  in the marker count that appears on a cluster marker (this count is the value of the
 *  <code>text</code> property of the result returned by the default <code>calculator</code>).
 *  If set to <code>true</code> and you change the visibility of a marker being clustered, be
 *  sure to also call <code>MarkerClusterer.repaint()</code>.
 * @property {string} [title=""] The tooltip to display when the mouse moves over a cluster
 *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a
 *  different tooltip for each cluster marker.)
 * @property {function} [calculator=MarkerClusterer.CALCULATOR] The function used to determine
 *  the text to be displayed on a cluster marker and the index indicating which style to use
 *  for the cluster marker. The input parameters for the function are (1) the array of markers
 *  represented by a cluster marker and (2) the number of cluster icon styles. It returns a
 *  {@link ClusterIconInfo} object. The default <code>calculator</code> returns a
 *  <code>text</code> property which is the number of markers in the cluster and an
 *  <code>index</code> property which is one higher than the lowest integer such that
 *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles
 *  array, whichever is less. The <code>styles</code> array element used has an index of
 *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a
 *  <code>text</code> value of <code>"125"</code> and an <code>index</code> of <code>3</code>
 *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>
 *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>
 *  property that contains the text of the tooltip to be used for the cluster marker. If
 *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>
 *   property for the MarkerClusterer.
 * @property {string} [clusterClass="cluster"] The name of the CSS class defining general styles
 *  for the cluster markers. Use this class to define CSS styles that are not set up by the code
 *  that processes the <code>styles</code> array.
 * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles
 *  of the cluster markers to be used. The element to be used to style a given cluster marker
 *  is determined by the function defined by the <code>calculator</code> property.
 *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived
 *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and
 *  <code>imageSizes</code>.
 * @property {boolean} [enableRetinaIcons=false] Whether to allow the use of cluster icons that
 * have sizes that are some multiple (typically double) of their actual display size. Icons such
 * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.
 * Note: if this property is <code>true</code>, sprites cannot be used as cluster icons.
 * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the
 *  number of markers to be processed in a single batch when using a browser other than
 *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).
 * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is
 *  being used, markers are processed in several batches with a small delay inserted between
 *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the
 *  number of markers to be processed in a single batch; select as high a number as you can
 *  without causing a timeout error in the browser. This number might need to be as low as 100
 *  if 15,000 markers are being managed, for example.
 * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]
 *  The full URL of the root name of the group of image files to use for cluster icons.
 *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>
 *  where n is the image file number (1, 2, etc.).
 * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]
 *  The extension name for the cluster icon image files (e.g., <code>"png"</code> or
 *  <code>"jpg"</code>).
 * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]
 *  An array of numbers containing the widths of the group of
 *  <code>imagePath</code>n.<code>imageExtension</code> image files.
 *  (The images are assumed to be square.)
 */
/**
 * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.
 * @param {MarkerClustererOptions} [opt_options] The optional parameters.
 */
function MarkerClusterer(map, opt_markers, opt_options) {
    // MarkerClusterer implements google.maps.OverlayView interface. We use the
    // extend function to extend MarkerClusterer with google.maps.OverlayView
    // because it might not always be available when the code is defined so we
    // look for it at the last possible moment. If it doesn't exist now then
    // there is no point going ahead :)
    this.extend(MarkerClusterer, google.maps.OverlayView);

    opt_markers = opt_markers || [];
    opt_options = opt_options || {};

    this.markers_ = [];
    this.clusters_ = [];
    this.listeners_ = [];
    this.activeMap_ = null;
    this.ready_ = false;

    this.gridSize_ = opt_options.gridSize || 60;
    this.minClusterSize_ = opt_options.minimumClusterSize || 2;
    this.maxZoom_ = opt_options.maxZoom || null;
    this.styles_ = opt_options.styles || [];
    this.title_ = opt_options.title || "";
    this.zoomOnClick_ = true;
    if (opt_options.zoomOnClick !== undefined) {
        this.zoomOnClick_ = opt_options.zoomOnClick;
    }
    this.averageCenter_ = false;
    if (opt_options.averageCenter !== undefined) {
        this.averageCenter_ = opt_options.averageCenter;
    }
    this.ignoreHidden_ = false;
    if (opt_options.ignoreHidden !== undefined) {
        this.ignoreHidden_ = opt_options.ignoreHidden;
    }
    this.enableRetinaIcons_ = false;
    if (opt_options.enableRetinaIcons !== undefined) {
        this.enableRetinaIcons_ = opt_options.enableRetinaIcons;
    }
    this.hideLabel_ = false;
    if (opt_options.hideLabel !== undefined) {
        this.hideLabel_ = opt_options.hideLabel;
    }
    this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
    this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
    this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
    this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
    this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
    this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
    this.clusterClass_ = opt_options.clusterClass || "cluster";

    if (navigator.userAgent.toLowerCase().indexOf("msie") !== -1) {
        // Try to avoid IE timeout when processing a huge number of markers:
        this.batchSize_ = this.batchSizeIE_;
    }

    this.setupStyles_();

    this.addMarkers(opt_markers, true);
    this.setMap(map); // Note: this causes onAdd to be called
}


/**
 * Implementation of the onAdd interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function() {
    var cMarkerClusterer = this;

    this.activeMap_ = this.getMap();
    this.ready_ = true;

    this.repaint();

    // Add the map event listeners
    this.listeners_ = [
        google.maps.event.addListener(this.getMap(), "zoom_changed", function() {
            cMarkerClusterer.resetViewport_(false);
            // Workaround for this Google bug: when map is at level 0 and "-" of
            // zoom slider is clicked, a "zoom_changed" event is fired even though
            // the map doesn't zoom out any further. In this situation, no "idle"
            // event is triggered so the cluster markers that have been removed
            // do not get redrawn. Same goes for a zoom in at maxZoom.
            if (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) {
                google.maps.event.trigger(this, "idle");
            }
        }),
        google.maps.event.addListener(this.getMap(), "idle", function() {
            cMarkerClusterer.redraw_();
        })
    ];
};


/**
 * Implementation of the onRemove interface method.
 * Removes map event listeners and all cluster icons from the DOM.
 * All managed markers are also put back on the map.
 * @ignore
 */
MarkerClusterer.prototype.onRemove = function() {
    var i;

    // Put all the managed markers back on the map:
    for (i = 0; i < this.markers_.length; i++) {
        if (this.markers_[i].getMap() !== this.activeMap_) {
            this.markers_[i].setMap(this.activeMap_);
        }
    }

    // Remove all clusters:
    for (i = 0; i < this.clusters_.length; i++) {
        this.clusters_[i].remove();
    }
    this.clusters_ = [];

    // Remove map event listeners:
    for (i = 0; i < this.listeners_.length; i++) {
        google.maps.event.removeListener(this.listeners_[i]);
    }
    this.listeners_ = [];

    this.activeMap_ = null;
    this.ready_ = false;
};


/**
 * Implementation of the draw interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function() {};


/**
 * Sets up the styles object.
 */
MarkerClusterer.prototype.setupStyles_ = function() {
    var i, size;
    if (this.styles_.length > 0) {
        return;
    }

    for (i = 0; i < this.imageSizes_.length; i++) {
        size = this.imageSizes_[i];
        this.styles_.push({
            url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
            height: size,
            width: size
        });
    }
};


/**
 *  Fits the map to the bounds of the markers managed by the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function() {
    var i;
    var markers = this.getMarkers();
    var bounds = new google.maps.LatLngBounds();
    for (i = 0; i < markers.length; i++) {
        bounds.extend(markers[i].getPosition());
    }

    this.getMap().fitBounds(bounds);
};


/**
 * Returns the value of the <code>gridSize</code> property.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function() {
    return this.gridSize_;
};


/**
 * Sets the value of the <code>gridSize</code> property.
 *
 * @param {number} gridSize The grid size.
 */
MarkerClusterer.prototype.setGridSize = function(gridSize) {
    this.gridSize_ = gridSize;
};


/**
 * Returns the value of the <code>minimumClusterSize</code> property.
 *
 * @return {number} The minimum cluster size.
 */
MarkerClusterer.prototype.getMinimumClusterSize = function() {
    return this.minClusterSize_;
};

/**
 * Sets the value of the <code>minimumClusterSize</code> property.
 *
 * @param {number} minimumClusterSize The minimum cluster size.
 */
MarkerClusterer.prototype.setMinimumClusterSize = function(minimumClusterSize) {
    this.minClusterSize_ = minimumClusterSize;
};


/**
 *  Returns the value of the <code>maxZoom</code> property.
 *
 *  @return {number} The maximum zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function() {
    return this.maxZoom_;
};


/**
 *  Sets the value of the <code>maxZoom</code> property.
 *
 *  @param {number} maxZoom The maximum zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
    this.maxZoom_ = maxZoom;
};


/**
 *  Returns the value of the <code>styles</code> property.
 *
 *  @return {Array} The array of styles defining the cluster markers to be used.
 */
MarkerClusterer.prototype.getStyles = function() {
    return this.styles_;
};


/**
 *  Sets the value of the <code>styles</code> property.
 *
 *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.
 */
MarkerClusterer.prototype.setStyles = function(styles) {
    this.styles_ = styles;
};


/**
 * Returns the value of the <code>title</code> property.
 *
 * @return {string} The content of the title text.
 */
MarkerClusterer.prototype.getTitle = function() {
    return this.title_;
};


/**
 *  Sets the value of the <code>title</code> property.
 *
 *  @param {string} title The value of the title property.
 */
MarkerClusterer.prototype.setTitle = function(title) {
    this.title_ = title;
};


/**
 * Returns the value of the <code>zoomOnClick</code> property.
 *
 * @return {boolean} True if zoomOnClick property is set.
 */
MarkerClusterer.prototype.getZoomOnClick = function() {
    return this.zoomOnClick_;
};


/**
 *  Sets the value of the <code>zoomOnClick</code> property.
 *
 *  @param {boolean} zoomOnClick The value of the zoomOnClick property.
 */
MarkerClusterer.prototype.setZoomOnClick = function(zoomOnClick) {
    this.zoomOnClick_ = zoomOnClick;
};


/**
 * Returns the value of the <code>averageCenter</code> property.
 *
 * @return {boolean} True if averageCenter property is set.
 */
MarkerClusterer.prototype.getAverageCenter = function() {
    return this.averageCenter_;
};


/**
 *  Sets the value of the <code>averageCenter</code> property.
 *
 *  @param {boolean} averageCenter The value of the averageCenter property.
 */
MarkerClusterer.prototype.setAverageCenter = function(averageCenter) {
    this.averageCenter_ = averageCenter;
};


/**
 * Returns the value of the <code>ignoreHidden</code> property.
 *
 * @return {boolean} True if ignoreHidden property is set.
 */
MarkerClusterer.prototype.getIgnoreHidden = function() {
    return this.ignoreHidden_;
};


/**
 *  Sets the value of the <code>ignoreHidden</code> property.
 *
 *  @param {boolean} ignoreHidden The value of the ignoreHidden property.
 */
MarkerClusterer.prototype.setIgnoreHidden = function(ignoreHidden) {
    this.ignoreHidden_ = ignoreHidden;
};


/**
 * Returns the value of the <code>enableRetinaIcons</code> property.
 *
 * @return {boolean} True if enableRetinaIcons property is set.
 */
MarkerClusterer.prototype.getEnableRetinaIcons = function() {
    return this.enableRetinaIcons_;
};


/**
 *  Sets the value of the <code>enableRetinaIcons</code> property.
 *
 *  @param {boolean} enableRetinaIcons The value of the enableRetinaIcons property.
 */
MarkerClusterer.prototype.setEnableRetinaIcons = function(enableRetinaIcons) {
    this.enableRetinaIcons_ = enableRetinaIcons;
};


/**
 * Returns the value of the <code>imageExtension</code> property.
 *
 * @return {string} The value of the imageExtension property.
 */
MarkerClusterer.prototype.getImageExtension = function() {
    return this.imageExtension_;
};


/**
 *  Sets the value of the <code>imageExtension</code> property.
 *
 *  @param {string} imageExtension The value of the imageExtension property.
 */
MarkerClusterer.prototype.setImageExtension = function(imageExtension) {
    this.imageExtension_ = imageExtension;
};


/**
 * Returns the value of the <code>imagePath</code> property.
 *
 * @return {string} The value of the imagePath property.
 */
MarkerClusterer.prototype.getImagePath = function() {
    return this.imagePath_;
};


/**
 *  Sets the value of the <code>imagePath</code> property.
 *
 *  @param {string} imagePath The value of the imagePath property.
 */
MarkerClusterer.prototype.setImagePath = function(imagePath) {
    this.imagePath_ = imagePath;
};


/**
 * Returns the value of the <code>imageSizes</code> property.
 *
 * @return {Array} The value of the imageSizes property.
 */
MarkerClusterer.prototype.getImageSizes = function() {
    return this.imageSizes_;
};


/**
 *  Sets the value of the <code>imageSizes</code> property.
 *
 *  @param {Array} imageSizes The value of the imageSizes property.
 */
MarkerClusterer.prototype.setImageSizes = function(imageSizes) {
    this.imageSizes_ = imageSizes;
};


/**
 * Returns the value of the <code>calculator</code> property.
 *
 * @return {function} the value of the calculator property.
 */
MarkerClusterer.prototype.getCalculator = function() {
    return this.calculator_;
};


/**
 * Sets the value of the <code>calculator</code> property.
 *
 * @param {function(Array.<google.maps.Marker>, number)} calculator The value
 *  of the calculator property.
 */
MarkerClusterer.prototype.setCalculator = function(calculator) {
    this.calculator_ = calculator;
};

/**
 * Sets the value of the <code>hideLabel</code> property.
 *
 *  @param {boolean} printable The value of the hideLabel property.
 */
MarkerClusterer.prototype.setHideLabel = function(hideLabel) {
    this.hideLabel_ = hideLabel;
};

/**
 * Returns the value of the <code>hideLabel</code> property.
 *
 * @return {boolean} the value of the hideLabel property.
 */
MarkerClusterer.prototype.getHideLabel = function() {
    return this.hideLabel_;
};

/**
 * Returns the value of the <code>batchSizeIE</code> property.
 *
 * @return {number} the value of the batchSizeIE property.
 */
MarkerClusterer.prototype.getBatchSizeIE = function() {
    return this.batchSizeIE_;
};


/**
 * Sets the value of the <code>batchSizeIE</code> property.
 *
 *  @param {number} batchSizeIE The value of the batchSizeIE property.
 */
MarkerClusterer.prototype.setBatchSizeIE = function(batchSizeIE) {
    this.batchSizeIE_ = batchSizeIE;
};


/**
 * Returns the value of the <code>clusterClass</code> property.
 *
 * @return {string} the value of the clusterClass property.
 */
MarkerClusterer.prototype.getClusterClass = function() {
    return this.clusterClass_;
};


/**
 * Sets the value of the <code>clusterClass</code> property.
 *
 *  @param {string} clusterClass The value of the clusterClass property.
 */
MarkerClusterer.prototype.setClusterClass = function(clusterClass) {
    this.clusterClass_ = clusterClass;
};


/**
 *  Returns the array of markers managed by the clusterer.
 *
 *  @return {Array} The array of markers managed by the clusterer.
 */
MarkerClusterer.prototype.getMarkers = function() {
    return this.markers_;
};


/**
 *  Returns the number of markers managed by the clusterer.
 *
 *  @return {number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function() {
    return this.markers_.length;
};


/**
 * Returns the current array of clusters formed by the clusterer.
 *
 * @return {Array} The array of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getClusters = function() {
    return this.clusters_;
};


/**
 * Returns the number of clusters formed by the clusterer.
 *
 * @return {number} The number of clusters formed by the clusterer.
 */
MarkerClusterer.prototype.getTotalClusters = function() {
    return this.clusters_.length;
};


/**
 * Adds a marker to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
    this.pushMarkerTo_(marker);
    if (!opt_nodraw) {
        this.redraw_();
    }
};


/**
 * Adds an array of markers to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
    var key;
    for (key in markers) {
        if (markers.hasOwnProperty(key)) {
            this.pushMarkerTo_(markers[key]);
        }
    }
    if (!opt_nodraw) {
        this.redraw_();
    }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
    // If the marker is draggable add a listener so we can update the clusters on the dragend:
    if (marker.getDraggable()) {
        var cMarkerClusterer = this;
        google.maps.event.addListener(marker, "dragend", function() {
            if (cMarkerClusterer.ready_) {
                this.isAdded = false;
                cMarkerClusterer.repaint();
            }
        });
    }
    marker.isAdded = false;
    this.markers_.push(marker);
};


/**
 * Removes a marker from the cluster and map.  The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the
 *  marker was removed from the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @param {boolean} [opt_noMapRemove] Set to <code>true</code> to prevent removal from map but still removing from cluster management
 * @return {boolean} True if the marker was removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw, opt_noMapRemove) {
    var removeFromMap = true && !opt_noMapRemove;
    var removed = this.removeMarker_(marker, removeFromMap);

    if (!opt_nodraw && removed) {
        this.repaint();
    }

    return removed;
};


/**
 * Removes an array of markers from the cluster and map. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers
 *  were removed from the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @param {boolean} [opt_noMapRemove] Set to <code>true</code> to prevent removal from map but still removing from cluster management
 * @return {boolean} True if markers were removed from the clusterer.
 */
MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw, opt_noMapRemove) {
    var i, r;
    var removed = false;
    var removeFromMap = true && !opt_noMapRemove;

    for (i = 0; i < markers.length; i++) {
        r = this.removeMarker_(markers[i], removeFromMap);
        removed = removed || r;
    }

    if (!opt_nodraw && removed) {
        this.repaint();
    }

    return removed;
};


/**
 * Removes a marker and returns true if removed, false if not.
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @param {boolean} removeFromMap set to <code>true</code> to explicitly remove from map as well as cluster manangement
 * @return {boolean} Whether the marker was removed or not
 */
MarkerClusterer.prototype.removeMarker_ = function(marker, removeFromMap) {
    var i;
    var index = -1;
    if (this.markers_.indexOf) {
        index = this.markers_.indexOf(marker);
    } else {
        for (i = 0; i < this.markers_.length; i++) {
            if (marker === this.markers_[i]) {
                index = i;
                break;
            }
        }
    }

    if (index === -1) {
        // Marker is not in our list of markers, so do nothing:
        return false;
    }

    if (removeFromMap) {
        marker.setMap(null);
    }

    this.markers_.splice(index, 1); // Remove the marker from the list of managed markers
    return true;
};


/**
 * Removes all clusters and markers from the map and also removes all markers
 *  managed by the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function() {
    this.resetViewport_(true);
    this.markers_ = [];
};


/**
 * Recalculates and redraws all the marker clusters from scratch.
 *  Call this after changing any properties.
 */
MarkerClusterer.prototype.repaint = function() {
    var oldClusters = this.clusters_.slice();
    this.clusters_ = [];
    this.resetViewport_(false);
    this.redraw_();

    // Remove the old clusters.
    // Do it in a timeout to prevent blinking effect.
    setTimeout(function() {
        var i;
        for (i = 0; i < oldClusters.length; i++) {
            oldClusters[i].remove();
        }
    }, 0);
};


/**
 * Returns the current bounds extended by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 * @ignore
 */
MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
    var projection = this.getProjection();

    // Turn the bounds into latlng.
    var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
        bounds.getNorthEast().lng());
    var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
        bounds.getSouthWest().lng());

    // Convert the points to pixels and the extend out by the grid size.
    var trPix = projection.fromLatLngToDivPixel(tr);
    trPix.x += this.gridSize_;
    trPix.y -= this.gridSize_;

    var blPix = projection.fromLatLngToDivPixel(bl);
    blPix.x -= this.gridSize_;
    blPix.y += this.gridSize_;

    // Convert the pixel points back to LatLng
    var ne = projection.fromDivPixelToLatLng(trPix);
    var sw = projection.fromDivPixelToLatLng(blPix);

    // Extend the bounds to contain the new bounds.
    bounds.extend(ne);
    bounds.extend(sw);

    return bounds;
};


/**
 * Redraws all the clusters.
 */
MarkerClusterer.prototype.redraw_ = function() {
    this.createClusters_(0);
};


/**
 * Removes all clusters from the map. The markers are also removed from the map
 *  if <code>opt_hide</code> is set to <code>true</code>.
 *
 * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
 *  from the map.
 */
MarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
    var i, marker;
    // Remove all the clusters
    for (i = 0; i < this.clusters_.length; i++) {
        this.clusters_[i].remove();
    }
    this.clusters_ = [];

    // Reset the markers to not be added and to be removed from the map.
    for (i = 0; i < this.markers_.length; i++) {
        marker = this.markers_[i];
        marker.isAdded = false;
        if (opt_hide) {
            marker.setMap(null);
        }
    }
};


/**
 * Calculates the distance between two latlng locations in km.
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
 */
MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
    var R = 6371; // Radius of the Earth in km
    var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
    var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = R * c;
    return d;
};


/**
 * Determines if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
    return bounds.contains(marker.getPosition());
};


/**
 * Adds a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
    var i, d, cluster, center;
    var distance = 40000; // Some large number
    var clusterToAddTo = null;
    for (i = 0; i < this.clusters_.length; i++) {
        cluster = this.clusters_[i];
        center = cluster.getCenter();
        if (center) {
            d = this.distanceBetweenPoints_(center, marker.getPosition());
            if (d < distance) {
                distance = d;
                clusterToAddTo = cluster;
            }
        }
    }

    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
        clusterToAddTo.addMarker(marker);
    } else {
        cluster = new Cluster(this);
        cluster.addMarker(marker);
        this.clusters_.push(cluster);
    }
};


/**
 * Creates the clusters. This is done in batches to avoid timeout errors
 *  in some browsers when there is a huge number of markers.
 *
 * @param {number} iFirst The index of the first marker in the batch of
 *  markers to be added to clusters.
 */
MarkerClusterer.prototype.createClusters_ = function(iFirst) {
    var i, marker;
    var mapBounds;
    var cMarkerClusterer = this;
    if (!this.ready_) {
        return;
    }

    // Cancel previous batch processing if we're working on the first batch:
    if (iFirst === 0) {
        /**
         * This event is fired when the <code>MarkerClusterer</code> begins
         *  clustering markers.
         * @name MarkerClusterer#clusteringbegin
         * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
         * @event
         */
        google.maps.event.trigger(this, "clusteringbegin", this);

        if (typeof this.timerRefStatic !== "undefined") {
            clearTimeout(this.timerRefStatic);
            delete this.timerRefStatic;
        }
    }

    // Get our current map view bounds.
    // Create a new bounds object so we don't affect the map.
    //
    // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
    if (this.getMap().getZoom() > 3) {
        mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(),
            this.getMap().getBounds().getNorthEast());
    } else {
        mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
    }
    var bounds = this.getExtendedBounds(mapBounds);

    var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);

    for (i = iFirst; i < iLast; i++) {
        marker = this.markers_[i];
        if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
            if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
                this.addToClosestCluster_(marker);
            }
        }
    }

    if (iLast < this.markers_.length) {
        this.timerRefStatic = setTimeout(function() {
            cMarkerClusterer.createClusters_(iLast);
        }, 0);
    } else {
        delete this.timerRefStatic;

        /**
         * This event is fired when the <code>MarkerClusterer</code> stops
         *  clustering markers.
         * @name MarkerClusterer#clusteringend
         * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
         * @event
         */
        google.maps.event.trigger(this, "clusteringend", this);

        for (i = 0; i < this.clusters_.length; i++) {
            this.clusters_[i].updateIcon_();
        }
    }
};


/**
 * Extends an object's prototype by another's.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function(obj1, obj2) {
    return (function(object) {
        var property;
        for (property in object.prototype) {
            this.prototype[property] = object.prototype[property];
        }
        return this;
    }).apply(obj1, [obj2]);
};


/**
 * The default function for determining the label text and style
 * for a cluster icon.
 *
 * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.
 * @param {number} numStyles The number of marker styles available.
 * @return {ClusterIconInfo} The information resource for the cluster.
 * @constant
 * @ignore
 */
MarkerClusterer.CALCULATOR = function(markers, numStyles) {
    var index = 0;
    var title = "";
    var count = markers.length.toString();

    var dv = count;
    while (dv !== 0) {
        dv = parseInt(dv / 10, 10);
        index++;
    }

    index = Math.min(index, numStyles);
    return {
        text: count,
        index: index,
        title: title
    };
};


/**
 * The number of markers to process in one batch.
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE = 2000;


/**
 * The number of markers to process in one batch (IE only).
 *
 * @type {number}
 * @constant
 */
MarkerClusterer.BATCH_SIZE_IE = 500;


/**
 * The default root name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
MarkerClusterer.IMAGE_PATH = "//cdn.rawgit.com/mahnunchik/markerclustererplus/master/images/m";


/**
 * The default extension name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
MarkerClusterer.IMAGE_EXTENSION = "png";


/**
 * The default array of sizes for the marker cluster images.
 *
 * @type {Array.<number>}
 * @constant
 */
MarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];

if (typeof String.prototype.trim !== 'function') {
    /**
     * IE hack since trim() doesn't exist in all browsers
     * @return {string} The string with removed whitespace
     */
    String.prototype.trim = function() {
        return this.replace(/^\s+|\s+$/g, '');
    };
}


/**
 *  Ajax Autocomplete for jQuery, version 1.2.24
 *  (c) 2015 Tomas Kirda
 *
 *  Ajax Autocomplete for jQuery is freely distributable under the terms of an MIT-style license.
 *  For details, see the web site: https://github.com/devbridge/jQuery-Autocomplete
 */

/*jslint  browser: true, white: true, plusplus: true, vars: true */
/*global define, window, document, jQuery, exports, require */

// Expose plugin as an AMD module if AMD loader is present:
(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object' && typeof require === 'function') {
        // Browserify
        factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {
    'use strict';

    var
        utils = (function() {
            return {
                escapeRegExChars: function(value) {
                    return value.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                },
                createNode: function(containerClass) {
                    var div = document.createElement('div');
                    div.className = containerClass;
                    div.style.position = 'absolute';
                    div.style.display = 'none';
                    return div;
                }
            };
        }()),

        keys = {
            ESC: 27,
            TAB: 9,
            RETURN: 13,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40
        };

    function Autocomplete(el, options) {
        var noop = function() {},
            that = this,
            defaults = {
                ajaxSettings: {},
                autoSelectFirst: false,
                appendTo: document.body,
                serviceUrl: null,
                lookup: null,
                onSelect: null,
                width: 'auto',
                minChars: 1,
                maxHeight: 300,
                deferRequestBy: 0,
                params: {},
                formatResult: Autocomplete.formatResult,
                delimiter: null,
                zIndex: 9999,
                type: 'GET',
                noCache: false,
                onSearchStart: noop,
                onSearchComplete: noop,
                onSearchError: noop,
                preserveInput: false,
                containerClass: 'autocomplete-suggestions',
                tabDisabled: false,
                dataType: 'text',
                currentRequest: null,
                triggerSelectOnValidInput: true,
                preventBadQueries: true,
                lookupFilter: function(suggestion, originalQuery, queryLowerCase) {
                    return suggestion.value.toLowerCase().indexOf(queryLowerCase) !== -1;
                },
                paramName: 'query',
                transformResult: function(response) {
                    return typeof response === 'string' ? $.parseJSON(response) : response;
                },
                showNoSuggestionNotice: false,
                noSuggestionNotice: 'No results',
                orientation: 'bottom',
                forceFixPosition: false
            };

        // Shared variables:
        that.element = el;
        that.el = $(el);
        that.suggestions = [];
        that.badQueries = [];
        that.selectedIndex = -1;
        that.currentValue = that.element.value;
        that.intervalId = 0;
        that.cachedResponse = {};
        that.onChangeInterval = null;
        that.onChange = null;
        that.isLocal = false;
        that.suggestionsContainer = null;
        that.noSuggestionsContainer = null;
        that.options = $.extend({}, defaults, options);
        that.classes = {
            selected: 'autocomplete-selected',
            suggestion: 'autocomplete-suggestion'
        };
        that.hint = null;
        that.hintValue = '';
        that.selection = null;

        // Initialize and set options:
        that.initialize();
        that.setOptions(options);
    }

    Autocomplete.utils = utils;

    $.Autocomplete = Autocomplete;

    Autocomplete.formatResult = function(suggestion, currentValue) {
        var pattern = '(' + utils.escapeRegExChars(currentValue) + ')';

        return suggestion.value
            .replace(new RegExp(pattern, 'gi'), '<strong>$1<\/strong>')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/&lt;(\/?strong)&gt;/g, '<$1>');
    };

    Autocomplete.prototype = {

        killerFn: null,

        initialize: function() {
            var that = this,
                suggestionSelector = '.' + that.classes.suggestion,
                selected = that.classes.selected,
                options = that.options,
                container;

            // Remove autocomplete attribute to prevent native suggestions:
            that.element.setAttribute('autocomplete', 'off');

            that.killerFn = function(e) {
                if ($(e.target).closest('.' + that.options.containerClass).length === 0) {
                    that.killSuggestions();
                    that.disableKillerFn();
                }
            };

            // html() deals with many types: htmlString or Element or Array or jQuery
            that.noSuggestionsContainer = $('<div class="autocomplete-no-suggestion"></div>')
                .html(this.options.noSuggestionNotice).get(0);

            that.suggestionsContainer = Autocomplete.utils.createNode(options.containerClass);

            container = $(that.suggestionsContainer);

            container.appendTo(options.appendTo);

            // Only set width if it was provided:
            if (options.width !== 'auto') {
                container.width(options.width);
            }

            // Listen for mouse over event on suggestions list:
            container.on('mouseover.autocomplete', suggestionSelector, function() {
                that.activate($(this).data('index'));
            });

            // Deselect active element when mouse leaves suggestions container:
            container.on('mouseout.autocomplete', function() {
                that.selectedIndex = -1;
                container.children('.' + selected).removeClass(selected);
            });

            // Listen for click event on suggestions list:
            container.on('click.autocomplete', suggestionSelector, function() {
                that.select($(this).data('index'));
            });

            that.fixPositionCapture = function() {
                if (that.visible) {
                    that.fixPosition();
                }
            };

            $(window).on('resize.autocomplete', that.fixPositionCapture);

            that.el.on('keydown.autocomplete', function(e) {
                that.onKeyPress(e);
            });
            that.el.on('keyup.autocomplete', function(e) {
                that.onKeyUp(e);
            });
            that.el.on('blur.autocomplete', function() {
                that.onBlur();
            });
            that.el.on('focus.autocomplete', function() {
                that.onFocus();
            });
            that.el.on('change.autocomplete', function(e) {
                that.onKeyUp(e);
            });
            that.el.on('input.autocomplete', function(e) {
                that.onKeyUp(e);
            });
        },

        onFocus: function() {
            var that = this;
            that.fixPosition();
            if (that.options.minChars === 0 && that.el.val().length === 0) {
                that.onValueChange();
            }
        },

        onBlur: function() {
            this.enableKillerFn();
        },

        abortAjax: function() {
            var that = this;
            if (that.currentRequest) {
                that.currentRequest.abort();
                that.currentRequest = null;
            }
        },

        setOptions: function(suppliedOptions) {
            var that = this,
                options = that.options;

            $.extend(options, suppliedOptions);

            that.isLocal = $.isArray(options.lookup);

            if (that.isLocal) {
                options.lookup = that.verifySuggestionsFormat(options.lookup);
            }

            options.orientation = that.validateOrientation(options.orientation, 'bottom');

            // Adjust height, width and z-index:
            $(that.suggestionsContainer).css({
                'max-height': options.maxHeight + 'px',
                'width': options.width + 'px',
                'z-index': options.zIndex
            });
        },


        clearCache: function() {
            this.cachedResponse = {};
            this.badQueries = [];
        },

        clear: function() {
            this.clearCache();
            this.currentValue = '';
            this.suggestions = [];
        },

        disable: function() {
            var that = this;
            that.disabled = true;
            clearInterval(that.onChangeInterval);
            that.abortAjax();
        },

        enable: function() {
            this.disabled = false;
        },

        fixPosition: function() {
            // Use only when container has already its content

            var that = this,
                $container = $(that.suggestionsContainer),
                containerParent = $container.parent().get(0);
            // Fix position automatically when appended to body.
            // In other cases force parameter must be given.
            if (containerParent !== document.body && !that.options.forceFixPosition) {
                return;
            }

            // Choose orientation
            var orientation = that.options.orientation,
                containerHeight = $container.outerHeight(),
                height = that.el.outerHeight(),
                offset = that.el.offset(),
                styles = {
                    'top': offset.top,
                    'left': offset.left
                };

            if (orientation === 'auto') {
                var viewPortHeight = $(window).height(),
                    scrollTop = $(window).scrollTop(),
                    topOverflow = -scrollTop + offset.top - containerHeight,
                    bottomOverflow = scrollTop + viewPortHeight - (offset.top + height + containerHeight);

                orientation = (Math.max(topOverflow, bottomOverflow) === topOverflow) ? 'top' : 'bottom';
            }

            if (orientation === 'top') {
                styles.top += -containerHeight;
            } else {
                styles.top += height;
            }

            // If container is not positioned to body,
            // correct its position using offset parent offset
            if (containerParent !== document.body) {
                var opacity = $container.css('opacity'),
                    parentOffsetDiff;

                if (!that.visible) {
                    $container.css('opacity', 0).show();
                }

                parentOffsetDiff = $container.offsetParent().offset();
                styles.top -= parentOffsetDiff.top;
                styles.left -= parentOffsetDiff.left;

                if (!that.visible) {
                    $container.css('opacity', opacity).hide();
                }
            }

            // -2px to account for suggestions border.
            if (that.options.width === 'auto') {
                styles.width = (that.el.outerWidth() - 2) + 'px';
            }

            $container.css(styles);
        },

        enableKillerFn: function() {
            var that = this;
            $(document).on('click.autocomplete', that.killerFn);
        },

        disableKillerFn: function() {
            var that = this;
            $(document).off('click.autocomplete', that.killerFn);
        },

        killSuggestions: function() {
            var that = this;
            that.stopKillSuggestions();
            that.intervalId = window.setInterval(function() {
                if (that.visible) {
                    that.el.val(that.currentValue);
                    that.hide();
                }

                that.stopKillSuggestions();
            }, 50);
        },

        stopKillSuggestions: function() {
            window.clearInterval(this.intervalId);
        },

        isCursorAtEnd: function() {
            var that = this,
                valLength = that.el.val().length,
                selectionStart = that.element.selectionStart,
                range;

            if (typeof selectionStart === 'number') {
                return selectionStart === valLength;
            }
            if (document.selection) {
                range = document.selection.createRange();
                range.moveStart('character', -valLength);
                return valLength === range.text.length;
            }
            return true;
        },

        onKeyPress: function(e) {
            var that = this;

            // If suggestions are hidden and user presses arrow down, display suggestions:
            if (!that.disabled && !that.visible && e.which === keys.DOWN && that.currentValue) {
                that.suggest();
                return;
            }

            if (that.disabled || !that.visible) {
                return;
            }

            switch (e.which) {
                case keys.ESC:
                    that.el.val(that.currentValue);
                    that.hide();
                    break;
                case keys.RIGHT:
                    if (that.hint && that.options.onHint && that.isCursorAtEnd()) {
                        that.selectHint();
                        break;
                    }
                    return;
                case keys.TAB:
                    if (that.hint && that.options.onHint) {
                        that.selectHint();
                        return;
                    }
                    if (that.selectedIndex === -1) {
                        that.hide();
                        return;
                    }
                    that.select(that.selectedIndex);
                    if (that.options.tabDisabled === false) {
                        return;
                    }
                    break;
                case keys.RETURN:
                    if (that.selectedIndex === -1) {
                        that.hide();
                        return;
                    }
                    that.select(that.selectedIndex);
                    break;
                case keys.UP:
                    that.moveUp();
                    break;
                case keys.DOWN:
                    that.moveDown();
                    break;
                default:
                    return;
            }

            // Cancel event if function did not return:
            e.stopImmediatePropagation();
            e.preventDefault();
        },

        onKeyUp: function(e) {
            var that = this;

            if (that.disabled) {
                return;
            }

            switch (e.which) {
                case keys.UP:
                case keys.DOWN:
                    return;
            }

            clearInterval(that.onChangeInterval);

            if (that.currentValue !== that.el.val()) {
                that.findBestHint();
                if (that.options.deferRequestBy > 0) {
                    // Defer lookup in case when value changes very quickly:
                    that.onChangeInterval = setInterval(function() {
                        that.onValueChange();
                    }, that.options.deferRequestBy);
                } else {
                    that.onValueChange();
                }
            }
        },

        onValueChange: function() {
            var that = this,
                options = that.options,
                value = that.el.val(),
                query = that.getQuery(value);

            if (that.selection && that.currentValue !== query) {
                that.selection = null;
                (options.onInvalidateSelection || $.noop).call(that.element);
            }

            clearInterval(that.onChangeInterval);
            that.currentValue = value;
            that.selectedIndex = -1;

            // Check existing suggestion for the match before proceeding:
            if (options.triggerSelectOnValidInput && that.isExactMatch(query)) {
                that.select(0);
                return;
            }

            if (query.length < options.minChars) {
                that.hide();
            } else {
                that.getSuggestions(query);
            }
        },

        isExactMatch: function(query) {
            var suggestions = this.suggestions;

            return (suggestions.length === 1 && suggestions[0].value.toLowerCase() === query.toLowerCase());
        },

        getQuery: function(value) {
            var delimiter = this.options.delimiter,
                parts;

            if (!delimiter) {
                return value;
            }
            parts = value.split(delimiter);
            return $.trim(parts[parts.length - 1]);
        },

        getSuggestionsLocal: function(query) {
            var that = this,
                options = that.options,
                queryLowerCase = query.toLowerCase(),
                filter = options.lookupFilter,
                limit = parseInt(options.lookupLimit, 10),
                data;

            data = {
                suggestions: $.grep(options.lookup, function(suggestion) {
                    return filter(suggestion, query, queryLowerCase);
                })
            };

            if (limit && data.suggestions.length > limit) {
                data.suggestions = data.suggestions.slice(0, limit);
            }

            return data;
        },

        getSuggestions: function(q) {
            var response,
                that = this,
                options = that.options,
                serviceUrl = options.serviceUrl,
                params,
                cacheKey,
                ajaxSettings;

            options.params[options.paramName] = q;
            params = options.ignoreParams ? null : options.params;

            if (options.onSearchStart.call(that.element, options.params) === false) {
                return;
            }

            if ($.isFunction(options.lookup)) {
                options.lookup(q, function(data) {
                    that.suggestions = data.suggestions;
                    that.suggest();
                    options.onSearchComplete.call(that.element, q, data.suggestions);
                });
                return;
            }

            if (that.isLocal) {
                response = that.getSuggestionsLocal(q);
            } else {
                if ($.isFunction(serviceUrl)) {
                    serviceUrl = serviceUrl.call(that.element, q);
                }
                cacheKey = serviceUrl + '?' + $.param(params || {});
                response = that.cachedResponse[cacheKey];
            }

            if (response && $.isArray(response.suggestions)) {
                that.suggestions = response.suggestions;
                that.suggest();
                options.onSearchComplete.call(that.element, q, response.suggestions);
            } else if (!that.isBadQuery(q)) {
                that.abortAjax();

                ajaxSettings = {
                    url: serviceUrl,
                    data: params,
                    type: options.type,
                    dataType: options.dataType
                };

                $.extend(ajaxSettings, options.ajaxSettings);

                that.currentRequest = $.ajax(ajaxSettings).done(function(data) {
                    var result;
                    that.currentRequest = null;
                    result = options.transformResult(data, q);
                    that.processResponse(result, q, cacheKey);
                    options.onSearchComplete.call(that.element, q, result.suggestions);
                }).fail(function(jqXHR, textStatus, errorThrown) {
                    options.onSearchError.call(that.element, q, jqXHR, textStatus, errorThrown);
                });
            } else {
                options.onSearchComplete.call(that.element, q, []);
            }
        },

        isBadQuery: function(q) {
            if (!this.options.preventBadQueries) {
                return false;
            }

            var badQueries = this.badQueries,
                i = badQueries.length;

            while (i--) {
                if (q.indexOf(badQueries[i]) === 0) {
                    return true;
                }
            }

            return false;
        },

        hide: function() {
            var that = this,
                container = $(that.suggestionsContainer);

            if ($.isFunction(that.options.onHide) && that.visible) {
                that.options.onHide.call(that.element, container);
            }

            that.visible = false;
            that.selectedIndex = -1;
            clearInterval(that.onChangeInterval);
            $(that.suggestionsContainer).hide();
            that.signalHint(null);
        },

        suggest: function() {
            if (this.suggestions.length === 0) {
                if (this.options.showNoSuggestionNotice) {
                    this.noSuggestions();
                } else {
                    this.hide();
                }
                return;
            }

            var that = this,
                options = that.options,
                groupBy = options.groupBy,
                formatResult = options.formatResult,
                value = that.getQuery(that.currentValue),
                className = that.classes.suggestion,
                classSelected = that.classes.selected,
                container = $(that.suggestionsContainer),
                noSuggestionsContainer = $(that.noSuggestionsContainer),
                beforeRender = options.beforeRender,
                html = '',
                category,
                formatGroup = function(suggestion, index) {
                    var currentCategory = suggestion.data[groupBy];

                    if (category === currentCategory) {
                        return '';
                    }

                    category = currentCategory;

                    return '<div class="autocomplete-group"><strong>' + category + '</strong></div>';
                };

            if (options.triggerSelectOnValidInput && that.isExactMatch(value)) {
                that.select(0);
                return;
            }

            // Build suggestions inner HTML:
            $.each(that.suggestions, function(i, suggestion) {
                if (groupBy) {
                    html += formatGroup(suggestion, value, i);
                }

                html += '<div class="' + className + '" data-index="' + i + '">' + formatResult(suggestion, value) + '</div>';
            });

            this.adjustContainerWidth();

            noSuggestionsContainer.detach();
            container.html(html);

            if ($.isFunction(beforeRender)) {
                beforeRender.call(that.element, container);
            }

            that.fixPosition();
            container.show();

            // Select first value by default:
            if (options.autoSelectFirst) {
                that.selectedIndex = 0;
                container.scrollTop(0);
                container.children('.' + className).first().addClass(classSelected);
            }

            that.visible = true;
            that.findBestHint();
        },

        noSuggestions: function() {
            var that = this,
                container = $(that.suggestionsContainer),
                noSuggestionsContainer = $(that.noSuggestionsContainer);

            this.adjustContainerWidth();

            // Some explicit steps. Be careful here as it easy to get
            // noSuggestionsContainer removed from DOM if not detached properly.
            noSuggestionsContainer.detach();
            container.empty(); // clean suggestions if any
            container.append(noSuggestionsContainer);

            that.fixPosition();

            container.show();
            that.visible = true;
        },

        adjustContainerWidth: function() {
            var that = this,
                options = that.options,
                width,
                container = $(that.suggestionsContainer);

            // If width is auto, adjust width before displaying suggestions,
            // because if instance was created before input had width, it will be zero.
            // Also it adjusts if input width has changed.
            // -2px to account for suggestions border.
            if (options.width === 'auto') {
                width = that.el.outerWidth() - 2;
                container.width(width > 0 ? width : 300);
            }
        },

        findBestHint: function() {
            var that = this,
                value = that.el.val().toLowerCase(),
                bestMatch = null;

            if (!value) {
                return;
            }

            $.each(that.suggestions, function(i, suggestion) {
                var foundMatch = suggestion.value.toLowerCase().indexOf(value) === 0;
                if (foundMatch) {
                    bestMatch = suggestion;
                }
                return !foundMatch;
            });

            that.signalHint(bestMatch);
        },

        signalHint: function(suggestion) {
            var hintValue = '',
                that = this;
            if (suggestion) {
                hintValue = that.currentValue + suggestion.value.substr(that.currentValue.length);
            }
            if (that.hintValue !== hintValue) {
                that.hintValue = hintValue;
                that.hint = suggestion;
                (this.options.onHint || $.noop)(hintValue);
            }
        },

        verifySuggestionsFormat: function(suggestions) {
            // If suggestions is string array, convert them to supported format:
            if (suggestions.length && typeof suggestions[0] === 'string') {
                return $.map(suggestions, function(value) {
                    return {
                        value: value,
                        data: null
                    };
                });
            }

            return suggestions;
        },

        validateOrientation: function(orientation, fallback) {
            orientation = $.trim(orientation || '').toLowerCase();

            if ($.inArray(orientation, ['auto', 'bottom', 'top']) === -1) {
                orientation = fallback;
            }

            return orientation;
        },

        processResponse: function(result, originalQuery, cacheKey) {
            var that = this,
                options = that.options;

            result.suggestions = that.verifySuggestionsFormat(result.suggestions);

            // Cache results if cache is not disabled:
            if (!options.noCache) {
                that.cachedResponse[cacheKey] = result;
                if (options.preventBadQueries && result.suggestions.length === 0) {
                    that.badQueries.push(originalQuery);
                }
            }

            // Return if originalQuery is not matching current query:
            if (originalQuery !== that.getQuery(that.currentValue)) {
                return;
            }

            that.suggestions = result.suggestions;
            that.suggest();
        },

        activate: function(index) {
            var that = this,
                activeItem,
                selected = that.classes.selected,
                container = $(that.suggestionsContainer),
                children = container.find('.' + that.classes.suggestion);

            container.find('.' + selected).removeClass(selected);

            that.selectedIndex = index;

            if (that.selectedIndex !== -1 && children.length > that.selectedIndex) {
                activeItem = children.get(that.selectedIndex);
                $(activeItem).addClass(selected);
                return activeItem;
            }

            return null;
        },

        selectHint: function() {
            var that = this,
                i = $.inArray(that.hint, that.suggestions);

            that.select(i);
        },

        select: function(i) {
            var that = this;
            that.hide();
            that.onSelect(i);
        },

        moveUp: function() {
            var that = this;

            if (that.selectedIndex === -1) {
                return;
            }

            if (that.selectedIndex === 0) {
                $(that.suggestionsContainer).children().first().removeClass(that.classes.selected);
                that.selectedIndex = -1;
                that.el.val(that.currentValue);
                that.findBestHint();
                return;
            }

            that.adjustScroll(that.selectedIndex - 1);
        },

        moveDown: function() {
            var that = this;

            if (that.selectedIndex === (that.suggestions.length - 1)) {
                return;
            }

            that.adjustScroll(that.selectedIndex + 1);
        },

        adjustScroll: function(index) {
            var that = this,
                activeItem = that.activate(index);

            if (!activeItem) {
                return;
            }

            var offsetTop,
                upperBound,
                lowerBound,
                heightDelta = $(activeItem).outerHeight();

            offsetTop = activeItem.offsetTop;
            upperBound = $(that.suggestionsContainer).scrollTop();
            lowerBound = upperBound + that.options.maxHeight - heightDelta;

            if (offsetTop < upperBound) {
                $(that.suggestionsContainer).scrollTop(offsetTop);
            } else if (offsetTop > lowerBound) {
                $(that.suggestionsContainer).scrollTop(offsetTop - that.options.maxHeight + heightDelta);
            }

            if (!that.options.preserveInput) {
                that.el.val(that.getValue(that.suggestions[index].value));
            }
            that.signalHint(null);
        },

        onSelect: function(index) {
            var that = this,
                onSelectCallback = that.options.onSelect,
                suggestion = that.suggestions[index];

            that.currentValue = that.getValue(suggestion.value);

            if (that.currentValue !== that.el.val() && !that.options.preserveInput) {
                that.el.val(that.currentValue);
            }

            that.signalHint(null);
            that.suggestions = [];
            that.selection = suggestion;

            if ($.isFunction(onSelectCallback)) {
                onSelectCallback.call(that.element, suggestion);
            }
        },

        getValue: function(value) {
            var that = this,
                delimiter = that.options.delimiter,
                currentValue,
                parts;

            if (!delimiter) {
                return value;
            }

            currentValue = that.currentValue;
            parts = currentValue.split(delimiter);

            if (parts.length === 1) {
                return value;
            }

            return currentValue.substr(0, currentValue.length - parts[parts.length - 1].length) + value;
        },

        dispose: function() {
            var that = this;
            that.el.off('.autocomplete').removeData('autocomplete');
            that.disableKillerFn();
            $(window).off('resize.autocomplete', that.fixPositionCapture);
            $(that.suggestionsContainer).remove();
        }
    };

    // Create chainable jQuery plugin:
    $.fn.autocomplete = $.fn.devbridgeAutocomplete = function(options, args) {
        var dataKey = 'autocomplete';
        // If function invoked without argument return
        // instance of the first matched element:
        if (arguments.length === 0) {
            return this.first().data(dataKey);
        }

        return this.each(function() {
            var inputElement = $(this),
                instance = inputElement.data(dataKey);

            if (typeof options === 'string') {
                if (instance && typeof instance[options] === 'function') {
                    instance[options](args);
                }
            } else {
                // If instance already exists, destroy it:
                if (instance && instance.dispose) {
                    instance.dispose();
                }
                instance = new Autocomplete(this, options);
                inputElement.data(dataKey, instance);
            }
        });
    };
}));

/*!
 * ZeroClipboard
 * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface.
 * Copyright (c) 2014 Jon Rohan, James M. Greene
 * Licensed MIT
 * http://zeroclipboard.org/
 * v2.1.6
 */
(function(window, undefined) {
    "use strict";
    /**
     * Store references to critically important global functions that may be
     * overridden on certain web pages.
     */
    var _window = window,
        _document = _window.document,
        _navigator = _window.navigator,
        _setTimeout = _window.setTimeout,
        _encodeURIComponent = _window.encodeURIComponent,
        _ActiveXObject = _window.ActiveXObject,
        _Error = _window.Error,
        _parseInt = _window.Number.parseInt || _window.parseInt,
        _parseFloat = _window.Number.parseFloat || _window.parseFloat,
        _isNaN = _window.Number.isNaN || _window.isNaN,
        _round = _window.Math.round,
        _now = _window.Date.now,
        _keys = _window.Object.keys,
        _defineProperty = _window.Object.defineProperty,
        _hasOwn = _window.Object.prototype.hasOwnProperty,
        _slice = _window.Array.prototype.slice,
        _unwrap = function() {
            var unwrapper = function(el) {
                return el;
            };
            if (typeof _window.wrap === "function" && typeof _window.unwrap === "function") {
                try {
                    var div = _document.createElement("div");
                    var unwrappedDiv = _window.unwrap(div);
                    if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) {
                        unwrapper = _window.unwrap;
                    }
                } catch (e) {}
            }
            return unwrapper;
        }();
    /**
     * Convert an `arguments` object into an Array.
     *
     * @returns The arguments as an Array
     * @private
     */
    var _args = function(argumentsObj) {
        return _slice.call(argumentsObj, 0);
    };
    /**
     * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`.
     *
     * @returns The target object, augmented
     * @private
     */
    var _extend = function() {
        var i, len, arg, prop, src, copy, args = _args(arguments),
            target = args[0] || {};
        for (i = 1, len = args.length; i < len; i++) {
            if ((arg = args[i]) != null) {
                for (prop in arg) {
                    if (_hasOwn.call(arg, prop)) {
                        src = target[prop];
                        copy = arg[prop];
                        if (target !== copy && copy !== undefined) {
                            target[prop] = copy;
                        }
                    }
                }
            }
        }
        return target;
    };
    /**
     * Return a deep copy of the source object or array.
     *
     * @returns Object or Array
     * @private
     */
    var _deepCopy = function(source) {
        var copy, i, len, prop;
        if (typeof source !== "object" || source == null) {
            copy = source;
        } else if (typeof source.length === "number") {
            copy = [];
            for (i = 0, len = source.length; i < len; i++) {
                if (_hasOwn.call(source, i)) {
                    copy[i] = _deepCopy(source[i]);
                }
            }
        } else {
            copy = {};
            for (prop in source) {
                if (_hasOwn.call(source, prop)) {
                    copy[prop] = _deepCopy(source[prop]);
                }
            }
        }
        return copy;
    };
    /**
     * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep.
     * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to
     * be kept.
     *
     * @returns A new filtered object.
     * @private
     */
    var _pick = function(obj, keys) {
        var newObj = {};
        for (var i = 0, len = keys.length; i < len; i++) {
            if (keys[i] in obj) {
                newObj[keys[i]] = obj[keys[i]];
            }
        }
        return newObj;
    };
    /**
     * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit.
     * The inverse of `_pick`.
     *
     * @returns A new filtered object.
     * @private
     */
    var _omit = function(obj, keys) {
        var newObj = {};
        for (var prop in obj) {
            if (keys.indexOf(prop) === -1) {
                newObj[prop] = obj[prop];
            }
        }
        return newObj;
    };
    /**
     * Remove all owned, enumerable properties from an object.
     *
     * @returns The original object without its owned, enumerable properties.
     * @private
     */
    var _deleteOwnProperties = function(obj) {
        if (obj) {
            for (var prop in obj) {
                if (_hasOwn.call(obj, prop)) {
                    delete obj[prop];
                }
            }
        }
        return obj;
    };
    /**
     * Determine if an element is contained within another element.
     *
     * @returns Boolean
     * @private
     */
    var _containedBy = function(el, ancestorEl) {
        if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) {
            do {
                if (el === ancestorEl) {
                    return true;
                }
                el = el.parentNode;
            } while (el);
        }
        return false;
    };
    /**
     * Get the URL path's parent directory.
     *
     * @returns String or `undefined`
     * @private
     */
    var _getDirPathOfUrl = function(url) {
        var dir;
        if (typeof url === "string" && url) {
            dir = url.split("#")[0].split("?")[0];
            dir = url.slice(0, url.lastIndexOf("/") + 1);
        }
        return dir;
    };
    /**
     * Get the current script's URL by throwing an `Error` and analyzing it.
     *
     * @returns String or `undefined`
     * @private
     */
    var _getCurrentScriptUrlFromErrorStack = function(stack) {
        var url, matches;
        if (typeof stack === "string" && stack) {
            matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
            if (matches && matches[1]) {
                url = matches[1];
            } else {
                matches = stack.match(/\)@((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
                if (matches && matches[1]) {
                    url = matches[1];
                }
            }
        }
        return url;
    };
    /**
     * Get the current script's URL by throwing an `Error` and analyzing it.
     *
     * @returns String or `undefined`
     * @private
     */
    var _getCurrentScriptUrlFromError = function() {
        var url, err;
        try {
            throw new _Error();
        } catch (e) {
            err = e;
        }
        if (err) {
            url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack);
        }
        return url;
    };
    /**
     * Get the current script's URL.
     *
     * @returns String or `undefined`
     * @private
     */
    var _getCurrentScriptUrl = function() {
        var jsPath, scripts, i;
        if (_document.currentScript && (jsPath = _document.currentScript.src)) {
            return jsPath;
        }
        scripts = _document.getElementsByTagName("script");
        if (scripts.length === 1) {
            return scripts[0].src || undefined;
        }
        if ("readyState" in scripts[0]) {
            for (i = scripts.length; i--;) {
                if (scripts[i].readyState === "interactive" && (jsPath = scripts[i].src)) {
                    return jsPath;
                }
            }
        }
        if (_document.readyState === "loading" && (jsPath = scripts[scripts.length - 1].src)) {
            return jsPath;
        }
        if (jsPath = _getCurrentScriptUrlFromError()) {
            return jsPath;
        }
        return undefined;
    };
    /**
     * Get the unanimous parent directory of ALL script tags.
     * If any script tags are either (a) inline or (b) from differing parent
     * directories, this method must return `undefined`.
     *
     * @returns String or `undefined`
     * @private
     */
    var _getUnanimousScriptParentDir = function() {
        var i, jsDir, jsPath, scripts = _document.getElementsByTagName("script");
        for (i = scripts.length; i--;) {
            if (!(jsPath = scripts[i].src)) {
                jsDir = null;
                break;
            }
            jsPath = _getDirPathOfUrl(jsPath);
            if (jsDir == null) {
                jsDir = jsPath;
            } else if (jsDir !== jsPath) {
                jsDir = null;
                break;
            }
        }
        return jsDir || undefined;
    };
    /**
     * Get the presumed location of the "ZeroClipboard.swf" file, based on the location
     * of the executing JavaScript file (e.g. "ZeroClipboard.js", etc.).
     *
     * @returns String
     * @private
     */
    var _getDefaultSwfPath = function() {
        var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || "";
        return jsDir + "ZeroClipboard.swf";
    };
    /**
     * Keep track of the state of the Flash object.
     * @private
     */
    var _flashState = {
        bridge: null,
        version: "0.0.0",
        pluginType: "unknown",
        disabled: null,
        outdated: null,
        unavailable: null,
        deactivated: null,
        overdue: null,
        ready: null
    };
    /**
     * The minimum Flash Player version required to use ZeroClipboard completely.
     * @readonly
     * @private
     */
    var _minimumFlashVersion = "11.0.0";
    /**
     * Keep track of all event listener registrations.
     * @private
     */
    var _handlers = {};
    /**
     * Keep track of the currently activated element.
     * @private
     */
    var _currentElement;
    /**
     * Keep track of the element that was activated when a `copy` process started.
     * @private
     */
    var _copyTarget;
    /**
     * Keep track of data for the pending clipboard transaction.
     * @private
     */
    var _clipData = {};
    /**
     * Keep track of data formats for the pending clipboard transaction.
     * @private
     */
    var _clipDataFormatMap = null;
    /**
     * The `message` store for events
     * @private
     */
    var _eventMessages = {
        ready: "Flash communication is established",
        error: {
            "flash-disabled": "Flash is disabled or not installed",
            "flash-outdated": "Flash is too outdated to support ZeroClipboard",
            "flash-unavailable": "Flash is unable to communicate bidirectionally with JavaScript",
            "flash-deactivated": "Flash is too outdated for your browser and/or is configured as click-to-activate",
            "flash-overdue": "Flash communication was established but NOT within the acceptable time limit"
        }
    };
    /**
     * ZeroClipboard configuration defaults for the Core module.
     * @private
     */
    var _globalConfig = {
        swfPath: _getDefaultSwfPath(),
        trustedDomains: window.location.host ? [window.location.host] : [],
        cacheBust: true,
        forceEnhancedClipboard: false,
        flashLoadTimeout: 3e4,
        autoActivate: true,
        bubbleEvents: true,
        containerId: "global-zeroclipboard-html-bridge",
        containerClass: "global-zeroclipboard-container",
        swfObjectId: "global-zeroclipboard-flash-bridge",
        hoverClass: "zeroclipboard-is-hover",
        activeClass: "zeroclipboard-is-active",
        forceHandCursor: false,
        title: null,
        zIndex: 999999999
    };
    /**
     * The underlying implementation of `ZeroClipboard.config`.
     * @private
     */
    var _config = function(options) {
        if (typeof options === "object" && options !== null) {
            for (var prop in options) {
                if (_hasOwn.call(options, prop)) {
                    if (/^(?:forceHandCursor|title|zIndex|bubbleEvents)$/.test(prop)) {
                        _globalConfig[prop] = options[prop];
                    } else if (_flashState.bridge == null) {
                        if (prop === "containerId" || prop === "swfObjectId") {
                            if (_isValidHtml4Id(options[prop])) {
                                _globalConfig[prop] = options[prop];
                            } else {
                                throw new Error("The specified `" + prop + "` value is not valid as an HTML4 Element ID");
                            }
                        } else {
                            _globalConfig[prop] = options[prop];
                        }
                    }
                }
            }
        }
        if (typeof options === "string" && options) {
            if (_hasOwn.call(_globalConfig, options)) {
                return _globalConfig[options];
            }
            return;
        }
        return _deepCopy(_globalConfig);
    };
    /**
     * The underlying implementation of `ZeroClipboard.state`.
     * @private
     */
    var _state = function() {
        return {
            browser: _pick(_navigator, ["userAgent", "platform", "appName"]),
            flash: _omit(_flashState, ["bridge"]),
            zeroclipboard: {
                version: ZeroClipboard.version,
                config: ZeroClipboard.config()
            }
        };
    };
    /**
     * The underlying implementation of `ZeroClipboard.isFlashUnusable`.
     * @private
     */
    var _isFlashUnusable = function() {
        return !!(_flashState.disabled || _flashState.outdated || _flashState.unavailable || _flashState.deactivated);
    };
    /**
     * The underlying implementation of `ZeroClipboard.on`.
     * @private
     */
    var _on = function(eventType, listener) {
        var i, len, events, added = {};
        if (typeof eventType === "string" && eventType) {
            events = eventType.toLowerCase().split(/\s+/);
        } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
            for (i in eventType) {
                if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
                    ZeroClipboard.on(i, eventType[i]);
                }
            }
        }
        if (events && events.length) {
            for (i = 0, len = events.length; i < len; i++) {
                eventType = events[i].replace(/^on/, "");
                added[eventType] = true;
                if (!_handlers[eventType]) {
                    _handlers[eventType] = [];
                }
                _handlers[eventType].push(listener);
            }
            if (added.ready && _flashState.ready) {
                ZeroClipboard.emit({
                    type: "ready"
                });
            }
            if (added.error) {
                var errorTypes = ["disabled", "outdated", "unavailable", "deactivated", "overdue"];
                for (i = 0, len = errorTypes.length; i < len; i++) {
                    if (_flashState[errorTypes[i]] === true) {
                        ZeroClipboard.emit({
                            type: "error",
                            name: "flash-" + errorTypes[i]
                        });
                        break;
                    }
                }
            }
        }
        return ZeroClipboard;
    };
    /**
     * The underlying implementation of `ZeroClipboard.off`.
     * @private
     */
    var _off = function(eventType, listener) {
        var i, len, foundIndex, events, perEventHandlers;
        if (arguments.length === 0) {
            events = _keys(_handlers);
        } else if (typeof eventType === "string" && eventType) {
            events = eventType.split(/\s+/);
        } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
            for (i in eventType) {
                if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
                    ZeroClipboard.off(i, eventType[i]);
                }
            }
        }
        if (events && events.length) {
            for (i = 0, len = events.length; i < len; i++) {
                eventType = events[i].toLowerCase().replace(/^on/, "");
                perEventHandlers = _handlers[eventType];
                if (perEventHandlers && perEventHandlers.length) {
                    if (listener) {
                        foundIndex = perEventHandlers.indexOf(listener);
                        while (foundIndex !== -1) {
                            perEventHandlers.splice(foundIndex, 1);
                            foundIndex = perEventHandlers.indexOf(listener, foundIndex);
                        }
                    } else {
                        perEventHandlers.length = 0;
                    }
                }
            }
        }
        return ZeroClipboard;
    };
    /**
     * The underlying implementation of `ZeroClipboard.handlers`.
     * @private
     */
    var _listeners = function(eventType) {
        var copy;
        if (typeof eventType === "string" && eventType) {
            copy = _deepCopy(_handlers[eventType]) || null;
        } else {
            copy = _deepCopy(_handlers);
        }
        return copy;
    };
    /**
     * The underlying implementation of `ZeroClipboard.emit`.
     * @private
     */
    var _emit = function(event) {
        var eventCopy, returnVal, tmp;
        event = _createEvent(event);
        if (!event) {
            return;
        }
        if (_preprocessEvent(event)) {
            return;
        }
        if (event.type === "ready" && _flashState.overdue === true) {
            return ZeroClipboard.emit({
                type: "error",
                name: "flash-overdue"
            });
        }
        eventCopy = _extend({}, event);
        _dispatchCallbacks.call(this, eventCopy);
        if (event.type === "copy") {
            tmp = _mapClipDataToFlash(_clipData);
            returnVal = tmp.data;
            _clipDataFormatMap = tmp.formatMap;
        }
        return returnVal;
    };
    /**
     * The underlying implementation of `ZeroClipboard.create`.
     * @private
     */
    var _create = function() {
        if (typeof _flashState.ready !== "boolean") {
            _flashState.ready = false;
        }
        if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) {
            var maxWait = _globalConfig.flashLoadTimeout;
            if (typeof maxWait === "number" && maxWait >= 0) {
                _setTimeout(function() {
                    if (typeof _flashState.deactivated !== "boolean") {
                        _flashState.deactivated = true;
                    }
                    if (_flashState.deactivated === true) {
                        ZeroClipboard.emit({
                            type: "error",
                            name: "flash-deactivated"
                        });
                    }
                }, maxWait);
            }
            _flashState.overdue = false;
            _embedSwf();
        }
    };
    /**
     * The underlying implementation of `ZeroClipboard.destroy`.
     * @private
     */
    var _destroy = function() {
        ZeroClipboard.clearData();
        ZeroClipboard.blur();
        ZeroClipboard.emit("destroy");
        _unembedSwf();
        ZeroClipboard.off();
    };
    /**
     * The underlying implementation of `ZeroClipboard.setData`.
     * @private
     */
    var _setData = function(format, data) {
        var dataObj;
        if (typeof format === "object" && format && typeof data === "undefined") {
            dataObj = format;
            ZeroClipboard.clearData();
        } else if (typeof format === "string" && format) {
            dataObj = {};
            dataObj[format] = data;
        } else {
            return;
        }
        for (var dataFormat in dataObj) {
            if (typeof dataFormat === "string" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === "string" && dataObj[dataFormat]) {
                _clipData[dataFormat] = dataObj[dataFormat];
            }
        }
    };
    /**
     * The underlying implementation of `ZeroClipboard.clearData`.
     * @private
     */
    var _clearData = function(format) {
        if (typeof format === "undefined") {
            _deleteOwnProperties(_clipData);
            _clipDataFormatMap = null;
        } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
            delete _clipData[format];
        }
    };
    /**
     * The underlying implementation of `ZeroClipboard.getData`.
     * @private
     */
    var _getData = function(format) {
        if (typeof format === "undefined") {
            return _deepCopy(_clipData);
        } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
            return _clipData[format];
        }
    };
    /**
     * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`.
     * @private
     */
    var _focus = function(element) {
        if (!(element && element.nodeType === 1)) {
            return;
        }
        if (_currentElement) {
            _removeClass(_currentElement, _globalConfig.activeClass);
            if (_currentElement !== element) {
                _removeClass(_currentElement, _globalConfig.hoverClass);
            }
        }
        _currentElement = element;
        _addClass(element, _globalConfig.hoverClass);
        var newTitle = element.getAttribute("title") || _globalConfig.title;
        if (typeof newTitle === "string" && newTitle) {
            var htmlBridge = _getHtmlBridge(_flashState.bridge);
            if (htmlBridge) {
                htmlBridge.setAttribute("title", newTitle);
            }
        }
        var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, "cursor") === "pointer";
        _setHandCursor(useHandCursor);
        _reposition();
    };
    /**
     * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`.
     * @private
     */
    var _blur = function() {
        var htmlBridge = _getHtmlBridge(_flashState.bridge);
        if (htmlBridge) {
            htmlBridge.removeAttribute("title");
            htmlBridge.style.left = "0px";
            htmlBridge.style.top = "-9999px";
            htmlBridge.style.width = "1px";
            htmlBridge.style.top = "1px";
        }
        if (_currentElement) {
            _removeClass(_currentElement, _globalConfig.hoverClass);
            _removeClass(_currentElement, _globalConfig.activeClass);
            _currentElement = null;
        }
    };
    /**
     * The underlying implementation of `ZeroClipboard.activeElement`.
     * @private
     */
    var _activeElement = function() {
        return _currentElement || null;
    };
    /**
     * Check if a value is a valid HTML4 `ID` or `Name` token.
     * @private
     */
    var _isValidHtml4Id = function(id) {
        return typeof id === "string" && id && /^[A-Za-z][A-Za-z0-9_:\-\.]*$/.test(id);
    };
    /**
     * Create or update an `event` object, based on the `eventType`.
     * @private
     */
    var _createEvent = function(event) {
        var eventType;
        if (typeof event === "string" && event) {
            eventType = event;
            event = {};
        } else if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
            eventType = event.type;
        }
        if (!eventType) {
            return;
        }
        if (!event.target && /^(copy|aftercopy|_click)$/.test(eventType.toLowerCase())) {
            event.target = _copyTarget;
        }
        _extend(event, {
            type: eventType.toLowerCase(),
            target: event.target || _currentElement || null,
            relatedTarget: event.relatedTarget || null,
            currentTarget: _flashState && _flashState.bridge || null,
            timeStamp: event.timeStamp || _now() || null
        });
        var msg = _eventMessages[event.type];
        if (event.type === "error" && event.name && msg) {
            msg = msg[event.name];
        }
        if (msg) {
            event.message = msg;
        }
        if (event.type === "ready") {
            _extend(event, {
                target: null,
                version: _flashState.version
            });
        }
        if (event.type === "error") {
            if (/^flash-(disabled|outdated|unavailable|deactivated|overdue)$/.test(event.name)) {
                _extend(event, {
                    target: null,
                    minimumVersion: _minimumFlashVersion
                });
            }
            if (/^flash-(outdated|unavailable|deactivated|overdue)$/.test(event.name)) {
                _extend(event, {
                    version: _flashState.version
                });
            }
        }
        if (event.type === "copy") {
            event.clipboardData = {
                setData: ZeroClipboard.setData,
                clearData: ZeroClipboard.clearData
            };
        }
        if (event.type === "aftercopy") {
            event = _mapClipResultsFromFlash(event, _clipDataFormatMap);
        }
        if (event.target && !event.relatedTarget) {
            event.relatedTarget = _getRelatedTarget(event.target);
        }
        event = _addMouseData(event);
        return event;
    };
    /**
     * Get a relatedTarget from the target's `data-clipboard-target` attribute
     * @private
     */
    var _getRelatedTarget = function(targetEl) {
        var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute("data-clipboard-target");
        return relatedTargetId ? _document.getElementById(relatedTargetId) : null;
    };
    /**
     * Add element and position data to `MouseEvent` instances
     * @private
     */
    var _addMouseData = function(event) {
        if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
            var srcElement = event.target;
            var fromElement = event.type === "_mouseover" && event.relatedTarget ? event.relatedTarget : undefined;
            var toElement = event.type === "_mouseout" && event.relatedTarget ? event.relatedTarget : undefined;
            var pos = _getDOMObjectPosition(srcElement);
            var screenLeft = _window.screenLeft || _window.screenX || 0;
            var screenTop = _window.screenTop || _window.screenY || 0;
            var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft;
            var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop;
            var pageX = pos.left + (typeof event._stageX === "number" ? event._stageX : 0);
            var pageY = pos.top + (typeof event._stageY === "number" ? event._stageY : 0);
            var clientX = pageX - scrollLeft;
            var clientY = pageY - scrollTop;
            var screenX = screenLeft + clientX;
            var screenY = screenTop + clientY;
            var moveX = typeof event.movementX === "number" ? event.movementX : 0;
            var moveY = typeof event.movementY === "number" ? event.movementY : 0;
            delete event._stageX;
            delete event._stageY;
            _extend(event, {
                srcElement: srcElement,
                fromElement: fromElement,
                toElement: toElement,
                screenX: screenX,
                screenY: screenY,
                pageX: pageX,
                pageY: pageY,
                clientX: clientX,
                clientY: clientY,
                x: clientX,
                y: clientY,
                movementX: moveX,
                movementY: moveY,
                offsetX: 0,
                offsetY: 0,
                layerX: 0,
                layerY: 0
            });
        }
        return event;
    };
    /**
     * Determine if an event's registered handlers should be execute synchronously or asynchronously.
     *
     * @returns {boolean}
     * @private
     */
    var _shouldPerformAsync = function(event) {
        var eventType = event && typeof event.type === "string" && event.type || "";
        return !/^(?:(?:before)?copy|destroy)$/.test(eventType);
    };
    /**
     * Control if a callback should be executed asynchronously or not.
     *
     * @returns `undefined`
     * @private
     */
    var _dispatchCallback = function(func, context, args, async) {
        if (async) {
            _setTimeout(function() {
                func.apply(context, args);
            }, 0);
        } else {
            func.apply(context, args);
        }
    };
    /**
     * Handle the actual dispatching of events to client instances.
     *
     * @returns `undefined`
     * @private
     */
    var _dispatchCallbacks = function(event) {
        if (!(typeof event === "object" && event && event.type)) {
            return;
        }
        var async = _shouldPerformAsync(event);
        var wildcardTypeHandlers = _handlers["*"] || [];
        var specificTypeHandlers = _handlers[event.type] || [];
        var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
        if (handlers && handlers.length) {
            var i, len, func, context, eventCopy, originalContext = this;
            for (i = 0, len = handlers.length; i < len; i++) {
                func = handlers[i];
                context = originalContext;
                if (typeof func === "string" && typeof _window[func] === "function") {
                    func = _window[func];
                }
                if (typeof func === "object" && func && typeof func.handleEvent === "function") {
                    context = func;
                    func = func.handleEvent;
                }
                if (typeof func === "function") {
                    eventCopy = _extend({}, event);
                    _dispatchCallback(func, context, [eventCopy], async);
                }
            }
        }
        return this;
    };
    /**
     * Preprocess any special behaviors, reactions, or state changes after receiving this event.
     * Executes only once per event emitted, NOT once per client.
     * @private
     */
    var _preprocessEvent = function(event) {
        var element = event.target || _currentElement || null;
        var sourceIsSwf = event._source === "swf";
        delete event._source;
        var flashErrorNames = ["flash-disabled", "flash-outdated", "flash-unavailable", "flash-deactivated", "flash-overdue"];
        switch (event.type) {
            case "error":
                if (flashErrorNames.indexOf(event.name) !== -1) {
                    _extend(_flashState, {
                        disabled: event.name === "flash-disabled",
                        outdated: event.name === "flash-outdated",
                        unavailable: event.name === "flash-unavailable",
                        deactivated: event.name === "flash-deactivated",
                        overdue: event.name === "flash-overdue",
                        ready: false
                    });
                }
                break;

            case "ready":
                var wasDeactivated = _flashState.deactivated === true;
                _extend(_flashState, {
                    disabled: false,
                    outdated: false,
                    unavailable: false,
                    deactivated: false,
                    overdue: wasDeactivated,
                    ready: !wasDeactivated
                });
                break;

            case "beforecopy":
                _copyTarget = element;
                break;

            case "copy":
                var textContent, htmlContent, targetEl = event.relatedTarget;
                if (!(_clipData["text/html"] || _clipData["text/plain"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) {
                    event.clipboardData.clearData();
                    event.clipboardData.setData("text/plain", textContent);
                    if (htmlContent !== textContent) {
                        event.clipboardData.setData("text/html", htmlContent);
                    }
                } else if (!_clipData["text/plain"] && event.target && (textContent = event.target.getAttribute("data-clipboard-text"))) {
                    event.clipboardData.clearData();
                    event.clipboardData.setData("text/plain", textContent);
                }
                break;

            case "aftercopy":
                ZeroClipboard.clearData();
                if (element && element !== _safeActiveElement() && element.focus) {
                    element.focus();
                }
                break;

            case "_mouseover":
                ZeroClipboard.focus(element);
                if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                    if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
                        _fireMouseEvent(_extend({}, event, {
                            type: "mouseenter",
                            bubbles: false,
                            cancelable: false
                        }));
                    }
                    _fireMouseEvent(_extend({}, event, {
                        type: "mouseover"
                    }));
                }
                break;

            case "_mouseout":
                ZeroClipboard.blur();
                if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                    if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
                        _fireMouseEvent(_extend({}, event, {
                            type: "mouseleave",
                            bubbles: false,
                            cancelable: false
                        }));
                    }
                    _fireMouseEvent(_extend({}, event, {
                        type: "mouseout"
                    }));
                }
                break;

            case "_mousedown":
                _addClass(element, _globalConfig.activeClass);
                if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                    _fireMouseEvent(_extend({}, event, {
                        type: event.type.slice(1)
                    }));
                }
                break;

            case "_mouseup":
                _removeClass(element, _globalConfig.activeClass);
                if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                    _fireMouseEvent(_extend({}, event, {
                        type: event.type.slice(1)
                    }));
                }
                break;

            case "_click":
                _copyTarget = null;
                if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                    _fireMouseEvent(_extend({}, event, {
                        type: event.type.slice(1)
                    }));
                }
                break;

            case "_mousemove":
                if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                    _fireMouseEvent(_extend({}, event, {
                        type: event.type.slice(1)
                    }));
                }
                break;
        }
        if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
            return true;
        }
    };
    /**
     * Dispatch a synthetic MouseEvent.
     *
     * @returns `undefined`
     * @private
     */
    var _fireMouseEvent = function(event) {
        if (!(event && typeof event.type === "string" && event)) {
            return;
        }
        var e, target = event.target || null,
            doc = target && target.ownerDocument || _document,
            defaults = {
                view: doc.defaultView || _window,
                canBubble: true,
                cancelable: true,
                detail: event.type === "click" ? 1 : 0,
                button: typeof event.which === "number" ? event.which - 1 : typeof event.button === "number" ? event.button : doc.createEvent ? 0 : 1
            },
            args = _extend(defaults, event);
        if (!target) {
            return;
        }
        if (doc.createEvent && target.dispatchEvent) {
            args = [args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget];
            e = doc.createEvent("MouseEvents");
            if (e.initMouseEvent) {
                e.initMouseEvent.apply(e, args);
                e._source = "js";
                target.dispatchEvent(e);
            }
        }
    };
    /**
     * Create the HTML bridge element to embed the Flash object into.
     * @private
     */
    var _createHtmlBridge = function() {
        var container = _document.createElement("div");
        container.id = _globalConfig.containerId;
        container.className = _globalConfig.containerClass;
        container.style.position = "absolute";
        container.style.left = "0px";
        container.style.top = "-9999px";
        container.style.width = "1px";
        container.style.height = "1px";
        container.style.zIndex = "" + _getSafeZIndex(_globalConfig.zIndex);
        return container;
    };
    /**
     * Get the HTML element container that wraps the Flash bridge object/element.
     * @private
     */
    var _getHtmlBridge = function(flashBridge) {
        var htmlBridge = flashBridge && flashBridge.parentNode;
        while (htmlBridge && htmlBridge.nodeName === "OBJECT" && htmlBridge.parentNode) {
            htmlBridge = htmlBridge.parentNode;
        }
        return htmlBridge || null;
    };
    /**
     * Create the SWF object.
     *
     * @returns The SWF object reference.
     * @private
     */
    var _embedSwf = function() {
        var len, flashBridge = _flashState.bridge,
            container = _getHtmlBridge(flashBridge);
        if (!flashBridge) {
            var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig);
            var allowNetworking = allowScriptAccess === "never" ? "none" : "all";
            var flashvars = _vars(_globalConfig);
            var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig);
            container = _createHtmlBridge();
            var divToBeReplaced = _document.createElement("div");
            container.appendChild(divToBeReplaced);
            _document.body.appendChild(container);
            var tmpDiv = _document.createElement("div");
            var oldIE = _flashState.pluginType === "activex";
            tmpDiv.innerHTML = '<object id="' + _globalConfig.swfObjectId + '" name="' + _globalConfig.swfObjectId + '" ' + 'width="100%" height="100%" ' + (oldIE ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' : 'type="application/x-shockwave-flash" data="' + swfUrl + '"') + ">" + (oldIE ? '<param name="movie" value="' + swfUrl + '"/>' : "") + '<param name="allowScriptAccess" value="' + allowScriptAccess + '"/>' + '<param name="allowNetworking" value="' + allowNetworking + '"/>' + '<param name="menu" value="false"/>' + '<param name="wmode" value="transparent"/>' + '<param name="flashvars" value="' + flashvars + '"/>' + "</object>";
            flashBridge = tmpDiv.firstChild;
            tmpDiv = null;
            _unwrap(flashBridge).ZeroClipboard = ZeroClipboard;
            container.replaceChild(flashBridge, divToBeReplaced);
        }
        if (!flashBridge) {
            flashBridge = _document[_globalConfig.swfObjectId];
            if (flashBridge && (len = flashBridge.length)) {
                flashBridge = flashBridge[len - 1];
            }
            if (!flashBridge && container) {
                flashBridge = container.firstChild;
            }
        }
        _flashState.bridge = flashBridge || null;
        return flashBridge;
    };
    /**
     * Destroy the SWF object.
     * @private
     */
    var _unembedSwf = function() {
        var flashBridge = _flashState.bridge;
        if (flashBridge) {
            var htmlBridge = _getHtmlBridge(flashBridge);
            if (htmlBridge) {
                if (_flashState.pluginType === "activex" && "readyState" in flashBridge) {
                    flashBridge.style.display = "none";
                    (function removeSwfFromIE() {
                        if (flashBridge.readyState === 4) {
                            for (var prop in flashBridge) {
                                if (typeof flashBridge[prop] === "function") {
                                    flashBridge[prop] = null;
                                }
                            }
                            if (flashBridge.parentNode) {
                                flashBridge.parentNode.removeChild(flashBridge);
                            }
                            if (htmlBridge.parentNode) {
                                htmlBridge.parentNode.removeChild(htmlBridge);
                            }
                        } else {
                            _setTimeout(removeSwfFromIE, 10);
                        }
                    })();
                } else {
                    if (flashBridge.parentNode) {
                        flashBridge.parentNode.removeChild(flashBridge);
                    }
                    if (htmlBridge.parentNode) {
                        htmlBridge.parentNode.removeChild(htmlBridge);
                    }
                }
            }
            _flashState.ready = null;
            _flashState.bridge = null;
            _flashState.deactivated = null;
        }
    };
    /**
     * Map the data format names of the "clipData" to Flash-friendly names.
     *
     * @returns A new transformed object.
     * @private
     */
    var _mapClipDataToFlash = function(clipData) {
        var newClipData = {},
            formatMap = {};
        if (!(typeof clipData === "object" && clipData)) {
            return;
        }
        for (var dataFormat in clipData) {
            if (dataFormat && _hasOwn.call(clipData, dataFormat) && typeof clipData[dataFormat] === "string" && clipData[dataFormat]) {
                switch (dataFormat.toLowerCase()) {
                    case "text/plain":
                    case "text":
                    case "air:text":
                    case "flash:text":
                        newClipData.text = clipData[dataFormat];
                        formatMap.text = dataFormat;
                        break;

                    case "text/html":
                    case "html":
                    case "air:html":
                    case "flash:html":
                        newClipData.html = clipData[dataFormat];
                        formatMap.html = dataFormat;
                        break;

                    case "application/rtf":
                    case "text/rtf":
                    case "rtf":
                    case "richtext":
                    case "air:rtf":
                    case "flash:rtf":
                        newClipData.rtf = clipData[dataFormat];
                        formatMap.rtf = dataFormat;
                        break;

                    default:
                        break;
                }
            }
        }
        return {
            data: newClipData,
            formatMap: formatMap
        };
    };
    /**
     * Map the data format names from Flash-friendly names back to their original "clipData" names (via a format mapping).
     *
     * @returns A new transformed object.
     * @private
     */
    var _mapClipResultsFromFlash = function(clipResults, formatMap) {
        if (!(typeof clipResults === "object" && clipResults && typeof formatMap === "object" && formatMap)) {
            return clipResults;
        }
        var newResults = {};
        for (var prop in clipResults) {
            if (_hasOwn.call(clipResults, prop)) {
                if (prop !== "success" && prop !== "data") {
                    newResults[prop] = clipResults[prop];
                    continue;
                }
                newResults[prop] = {};
                var tmpHash = clipResults[prop];
                for (var dataFormat in tmpHash) {
                    if (dataFormat && _hasOwn.call(tmpHash, dataFormat) && _hasOwn.call(formatMap, dataFormat)) {
                        newResults[prop][formatMap[dataFormat]] = tmpHash[dataFormat];
                    }
                }
            }
        }
        return newResults;
    };
    /**
     * Will look at a path, and will create a "?noCache={time}" or "&noCache={time}"
     * query param string to return. Does NOT append that string to the original path.
     * This is useful because ExternalInterface often breaks when a Flash SWF is cached.
     *
     * @returns The `noCache` query param with necessary "?"/"&" prefix.
     * @private
     */
    var _cacheBust = function(path, options) {
        var cacheBust = options == null || options && options.cacheBust === true;
        if (cacheBust) {
            return (path.indexOf("?") === -1 ? "?" : "&") + "noCache=" + _now();
        } else {
            return "";
        }
    };
    /**
     * Creates a query string for the FlashVars param.
     * Does NOT include the cache-busting query param.
     *
     * @returns FlashVars query string
     * @private
     */
    var _vars = function(options) {
        var i, len, domain, domains, str = "",
            trustedOriginsExpanded = [];
        if (options.trustedDomains) {
            if (typeof options.trustedDomains === "string") {
                domains = [options.trustedDomains];
            } else if (typeof options.trustedDomains === "object" && "length" in options.trustedDomains) {
                domains = options.trustedDomains;
            }
        }
        if (domains && domains.length) {
            for (i = 0, len = domains.length; i < len; i++) {
                if (_hasOwn.call(domains, i) && domains[i] && typeof domains[i] === "string") {
                    domain = _extractDomain(domains[i]);
                    if (!domain) {
                        continue;
                    }
                    if (domain === "*") {
                        trustedOriginsExpanded.length = 0;
                        trustedOriginsExpanded.push(domain);
                        break;
                    }
                    trustedOriginsExpanded.push.apply(trustedOriginsExpanded, [domain, "//" + domain, _window.location.protocol + "//" + domain]);
                }
            }
        }
        if (trustedOriginsExpanded.length) {
            str += "trustedOrigins=" + _encodeURIComponent(trustedOriginsExpanded.join(","));
        }
        if (options.forceEnhancedClipboard === true) {
            str += (str ? "&" : "") + "forceEnhancedClipboard=true";
        }
        if (typeof options.swfObjectId === "string" && options.swfObjectId) {
            str += (str ? "&" : "") + "swfObjectId=" + _encodeURIComponent(options.swfObjectId);
        }
        return str;
    };
    /**
     * Extract the domain (e.g. "github.com") from an origin (e.g. "https://github.com") or
     * URL (e.g. "https://github.com/zeroclipboard/zeroclipboard/").
     *
     * @returns the domain
     * @private
     */
    var _extractDomain = function(originOrUrl) {
        if (originOrUrl == null || originOrUrl === "") {
            return null;
        }
        originOrUrl = originOrUrl.replace(/^\s+|\s+$/g, "");
        if (originOrUrl === "") {
            return null;
        }
        var protocolIndex = originOrUrl.indexOf("//");
        originOrUrl = protocolIndex === -1 ? originOrUrl : originOrUrl.slice(protocolIndex + 2);
        var pathIndex = originOrUrl.indexOf("/");
        originOrUrl = pathIndex === -1 ? originOrUrl : protocolIndex === -1 || pathIndex === 0 ? null : originOrUrl.slice(0, pathIndex);
        if (originOrUrl && originOrUrl.slice(-4).toLowerCase() === ".swf") {
            return null;
        }
        return originOrUrl || null;
    };
    /**
     * Set `allowScriptAccess` based on `trustedDomains` and `window.location.host` vs. `swfPath`.
     *
     * @returns The appropriate script access level.
     * @private
     */
    var _determineScriptAccess = function() {
        var _extractAllDomains = function(origins) {
            var i, len, tmp, resultsArray = [];
            if (typeof origins === "string") {
                origins = [origins];
            }
            if (!(typeof origins === "object" && origins && typeof origins.length === "number")) {
                return resultsArray;
            }
            for (i = 0, len = origins.length; i < len; i++) {
                if (_hasOwn.call(origins, i) && (tmp = _extractDomain(origins[i]))) {
                    if (tmp === "*") {
                        resultsArray.length = 0;
                        resultsArray.push("*");
                        break;
                    }
                    if (resultsArray.indexOf(tmp) === -1) {
                        resultsArray.push(tmp);
                    }
                }
            }
            return resultsArray;
        };
        return function(currentDomain, configOptions) {
            var swfDomain = _extractDomain(configOptions.swfPath);
            if (swfDomain === null) {
                swfDomain = currentDomain;
            }
            var trustedDomains = _extractAllDomains(configOptions.trustedDomains);
            var len = trustedDomains.length;
            if (len > 0) {
                if (len === 1 && trustedDomains[0] === "*") {
                    return "always";
                }
                if (trustedDomains.indexOf(currentDomain) !== -1) {
                    if (len === 1 && currentDomain === swfDomain) {
                        return "sameDomain";
                    }
                    return "always";
                }
            }
            return "never";
        };
    }();
    /**
     * Get the currently active/focused DOM element.
     *
     * @returns the currently active/focused element, or `null`
     * @private
     */
    var _safeActiveElement = function() {
        try {
            return _document.activeElement;
        } catch (err) {
            return null;
        }
    };
    /**
     * Add a class to an element, if it doesn't already have it.
     *
     * @returns The element, with its new class added.
     * @private
     */
    var _addClass = function(element, value) {
        if (!element || element.nodeType !== 1) {
            return element;
        }
        if (element.classList) {
            if (!element.classList.contains(value)) {
                element.classList.add(value);
            }
            return element;
        }
        if (value && typeof value === "string") {
            var classNames = (value || "").split(/\s+/);
            if (element.nodeType === 1) {
                if (!element.className) {
                    element.className = value;
                } else {
                    var className = " " + element.className + " ",
                        setClass = element.className;
                    for (var c = 0, cl = classNames.length; c < cl; c++) {
                        if (className.indexOf(" " + classNames[c] + " ") < 0) {
                            setClass += " " + classNames[c];
                        }
                    }
                    element.className = setClass.replace(/^\s+|\s+$/g, "");
                }
            }
        }
        return element;
    };
    /**
     * Remove a class from an element, if it has it.
     *
     * @returns The element, with its class removed.
     * @private
     */
    var _removeClass = function(element, value) {
        if (!element || element.nodeType !== 1) {
            return element;
        }
        if (element.classList) {
            if (element.classList.contains(value)) {
                element.classList.remove(value);
            }
            return element;
        }
        if (typeof value === "string" && value) {
            var classNames = value.split(/\s+/);
            if (element.nodeType === 1 && element.className) {
                var className = (" " + element.className + " ").replace(/[\n\t]/g, " ");
                for (var c = 0, cl = classNames.length; c < cl; c++) {
                    className = className.replace(" " + classNames[c] + " ", " ");
                }
                element.className = className.replace(/^\s+|\s+$/g, "");
            }
        }
        return element;
    };
    /**
     * Attempt to interpret the element's CSS styling. If `prop` is `"cursor"`,
     * then we assume that it should be a hand ("pointer") cursor if the element
     * is an anchor element ("a" tag).
     *
     * @returns The computed style property.
     * @private
     */
    var _getStyle = function(el, prop) {
        var value = _window.getComputedStyle(el, null).getPropertyValue(prop);
        if (prop === "cursor") {
            if (!value || value === "auto") {
                if (el.nodeName === "A") {
                    return "pointer";
                }
            }
        }
        return value;
    };
    /**
     * Get the zoom factor of the browser. Always returns `1.0`, except at
     * non-default zoom levels in IE<8 and some older versions of WebKit.
     *
     * @returns Floating unit percentage of the zoom factor (e.g. 150% = `1.5`).
     * @private
     */
    var _getZoomFactor = function() {
        var rect, physicalWidth, logicalWidth, zoomFactor = 1;
        if (typeof _document.body.getBoundingClientRect === "function") {
            rect = _document.body.getBoundingClientRect();
            physicalWidth = rect.right - rect.left;
            logicalWidth = _document.body.offsetWidth;
            zoomFactor = _round(physicalWidth / logicalWidth * 100) / 100;
        }
        return zoomFactor;
    };
    /**
     * Get the DOM positioning info of an element.
     *
     * @returns Object containing the element's position, width, and height.
     * @private
     */
    var _getDOMObjectPosition = function(obj) {
        var info = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        };
        if (obj.getBoundingClientRect) {
            var rect = obj.getBoundingClientRect();
            var pageXOffset, pageYOffset, zoomFactor;
            if ("pageXOffset" in _window && "pageYOffset" in _window) {
                pageXOffset = _window.pageXOffset;
                pageYOffset = _window.pageYOffset;
            } else {
                zoomFactor = _getZoomFactor();
                pageXOffset = _round(_document.documentElement.scrollLeft / zoomFactor);
                pageYOffset = _round(_document.documentElement.scrollTop / zoomFactor);
            }
            var leftBorderWidth = _document.documentElement.clientLeft || 0;
            var topBorderWidth = _document.documentElement.clientTop || 0;
            info.left = rect.left + pageXOffset - leftBorderWidth;
            info.top = rect.top + pageYOffset - topBorderWidth;
            info.width = "width" in rect ? rect.width : rect.right - rect.left;
            info.height = "height" in rect ? rect.height : rect.bottom - rect.top;
        }
        return info;
    };
    /**
     * Reposition the Flash object to cover the currently activated element.
     *
     * @returns `undefined`
     * @private
     */
    var _reposition = function() {
        var htmlBridge;
        if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) {
            var pos = _getDOMObjectPosition(_currentElement);
            _extend(htmlBridge.style, {
                width: pos.width + "px",
                height: pos.height + "px",
                top: pos.top + "px",
                left: pos.left + "px",
                zIndex: "" + _getSafeZIndex(_globalConfig.zIndex)
            });
        }
    };
    /**
     * Sends a signal to the Flash object to display the hand cursor if `true`.
     *
     * @returns `undefined`
     * @private
     */
    var _setHandCursor = function(enabled) {
        if (_flashState.ready === true) {
            if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === "function") {
                _flashState.bridge.setHandCursor(enabled);
            } else {
                _flashState.ready = false;
            }
        }
    };
    /**
     * Get a safe value for `zIndex`
     *
     * @returns an integer, or "auto"
     * @private
     */
    var _getSafeZIndex = function(val) {
        if (/^(?:auto|inherit)$/.test(val)) {
            return val;
        }
        var zIndex;
        if (typeof val === "number" && !_isNaN(val)) {
            zIndex = val;
        } else if (typeof val === "string") {
            zIndex = _getSafeZIndex(_parseInt(val, 10));
        }
        return typeof zIndex === "number" ? zIndex : "auto";
    };
    /**
     * Detect the Flash Player status, version, and plugin type.
     *
     * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code}
     * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript}
     *
     * @returns `undefined`
     * @private
     */
    var _detectFlashSupport = function(ActiveXObject) {
        var plugin, ax, mimeType, hasFlash = false,
            isActiveX = false,
            isPPAPI = false,
            flashVersion = "";
        /**
         * Derived from Apple's suggested sniffer.
         * @param {String} desc e.g. "Shockwave Flash 7.0 r61"
         * @returns {String} "7.0.61"
         * @private
         */
        function parseFlashVersion(desc) {
            var matches = desc.match(/[\d]+/g);
            matches.length = 3;
            return matches.join(".");
        }

        function isPepperFlash(flashPlayerFileName) {
            return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\.dll|libpepflashplayer\.so|pepperflashplayer\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === "chrome.plugin");
        }

        function inspectPlugin(plugin) {
            if (plugin) {
                hasFlash = true;
                if (plugin.version) {
                    flashVersion = parseFlashVersion(plugin.version);
                }
                if (!flashVersion && plugin.description) {
                    flashVersion = parseFlashVersion(plugin.description);
                }
                if (plugin.filename) {
                    isPPAPI = isPepperFlash(plugin.filename);
                }
            }
        }
        if (_navigator.plugins && _navigator.plugins.length) {
            plugin = _navigator.plugins["Shockwave Flash"];
            inspectPlugin(plugin);
            if (_navigator.plugins["Shockwave Flash 2.0"]) {
                hasFlash = true;
                flashVersion = "2.0.0.11";
            }
        } else if (_navigator.mimeTypes && _navigator.mimeTypes.length) {
            mimeType = _navigator.mimeTypes["application/x-shockwave-flash"];
            plugin = mimeType && mimeType.enabledPlugin;
            inspectPlugin(plugin);
        } else if (typeof ActiveXObject !== "undefined") {
            isActiveX = true;
            try {
                ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
                hasFlash = true;
                flashVersion = parseFlashVersion(ax.GetVariable("$version"));
            } catch (e1) {
                try {
                    ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
                    hasFlash = true;
                    flashVersion = "6.0.21";
                } catch (e2) {
                    try {
                        ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
                        hasFlash = true;
                        flashVersion = parseFlashVersion(ax.GetVariable("$version"));
                    } catch (e3) {
                        isActiveX = false;
                    }
                }
            }
        }
        _flashState.disabled = hasFlash !== true;
        _flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion);
        _flashState.version = flashVersion || "0.0.0";
        _flashState.pluginType = isPPAPI ? "pepper" : isActiveX ? "activex" : hasFlash ? "netscape" : "unknown";
    };
    /**
     * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later.
     */
    _detectFlashSupport(_ActiveXObject);
    /**
     * A shell constructor for `ZeroClipboard` client instances.
     *
     * @constructor
     */
    var ZeroClipboard = function() {
        if (!(this instanceof ZeroClipboard)) {
            return new ZeroClipboard();
        }
        if (typeof ZeroClipboard._createClient === "function") {
            ZeroClipboard._createClient.apply(this, _args(arguments));
        }
    };
    /**
     * The ZeroClipboard library's version number.
     *
     * @static
     * @readonly
     * @property {string}
     */
    _defineProperty(ZeroClipboard, "version", {
        value: "2.1.6",
        writable: false,
        configurable: true,
        enumerable: true
    });
    /**
     * Update or get a copy of the ZeroClipboard global configuration.
     * Returns a copy of the current/updated configuration.
     *
     * @returns Object
     * @static
     */
    ZeroClipboard.config = function() {
        return _config.apply(this, _args(arguments));
    };
    /**
     * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard.
     *
     * @returns Object
     * @static
     */
    ZeroClipboard.state = function() {
        return _state.apply(this, _args(arguments));
    };
    /**
     * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc.
     *
     * @returns Boolean
     * @static
     */
    ZeroClipboard.isFlashUnusable = function() {
        return _isFlashUnusable.apply(this, _args(arguments));
    };
    /**
     * Register an event listener.
     *
     * @returns `ZeroClipboard`
     * @static
     */
    ZeroClipboard.on = function() {
        return _on.apply(this, _args(arguments));
    };
    /**
     * Unregister an event listener.
     * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`.
     * If no `eventType` is provided, it will unregister all listeners for every event type.
     *
     * @returns `ZeroClipboard`
     * @static
     */
    ZeroClipboard.off = function() {
        return _off.apply(this, _args(arguments));
    };
    /**
     * Retrieve event listeners for an `eventType`.
     * If no `eventType` is provided, it will retrieve all listeners for every event type.
     *
     * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
     */
    ZeroClipboard.handlers = function() {
        return _listeners.apply(this, _args(arguments));
    };
    /**
     * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners.
     *
     * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
     * @static
     */
    ZeroClipboard.emit = function() {
        return _emit.apply(this, _args(arguments));
    };
    /**
     * Create and embed the Flash object.
     *
     * @returns The Flash object
     * @static
     */
    ZeroClipboard.create = function() {
        return _create.apply(this, _args(arguments));
    };
    /**
     * Self-destruct and clean up everything, including the embedded Flash object.
     *
     * @returns `undefined`
     * @static
     */
    ZeroClipboard.destroy = function() {
        return _destroy.apply(this, _args(arguments));
    };
    /**
     * Set the pending data for clipboard injection.
     *
     * @returns `undefined`
     * @static
     */
    ZeroClipboard.setData = function() {
        return _setData.apply(this, _args(arguments));
    };
    /**
     * Clear the pending data for clipboard injection.
     * If no `format` is provided, all pending data formats will be cleared.
     *
     * @returns `undefined`
     * @static
     */
    ZeroClipboard.clearData = function() {
        return _clearData.apply(this, _args(arguments));
    };
    /**
     * Get a copy of the pending data for clipboard injection.
     * If no `format` is provided, a copy of ALL pending data formats will be returned.
     *
     * @returns `String` or `Object`
     * @static
     */
    ZeroClipboard.getData = function() {
        return _getData.apply(this, _args(arguments));
    };
    /**
     * Sets the current HTML object that the Flash object should overlay. This will put the global
     * Flash object on top of the current element; depending on the setup, this may also set the
     * pending clipboard text data as well as the Flash object's wrapping element's title attribute
     * based on the underlying HTML element and ZeroClipboard configuration.
     *
     * @returns `undefined`
     * @static
     */
    ZeroClipboard.focus = ZeroClipboard.activate = function() {
        return _focus.apply(this, _args(arguments));
    };
    /**
     * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on
     * the setup, this may also unset the Flash object's wrapping element's title attribute based on
     * the underlying HTML element and ZeroClipboard configuration.
     *
     * @returns `undefined`
     * @static
     */
    ZeroClipboard.blur = ZeroClipboard.deactivate = function() {
        return _blur.apply(this, _args(arguments));
    };
    /**
     * Returns the currently focused/"activated" HTML element that the Flash object is wrapping.
     *
     * @returns `HTMLElement` or `null`
     * @static
     */
    ZeroClipboard.activeElement = function() {
        return _activeElement.apply(this, _args(arguments));
    };
    /**
     * Keep track of the ZeroClipboard client instance counter.
     */
    var _clientIdCounter = 0;
    /**
     * Keep track of the state of the client instances.
     *
     * Entry structure:
     *   _clientMeta[client.id] = {
     *     instance: client,
     *     elements: [],
     *     handlers: {}
     *   };
     */
    var _clientMeta = {};
    /**
     * Keep track of the ZeroClipboard clipped elements counter.
     */
    var _elementIdCounter = 0;
    /**
     * Keep track of the state of the clipped element relationships to clients.
     *
     * Entry structure:
     *   _elementMeta[element.zcClippingId] = [client1.id, client2.id];
     */
    var _elementMeta = {};
    /**
     * Keep track of the state of the mouse event handlers for clipped elements.
     *
     * Entry structure:
     *   _mouseHandlers[element.zcClippingId] = {
     *     mouseover:  function(event) {},
     *     mouseout:   function(event) {},
     *     mouseenter: function(event) {},
     *     mouseleave: function(event) {},
     *     mousemove:  function(event) {}
     *   };
     */
    var _mouseHandlers = {};
    /**
     * Extending the ZeroClipboard configuration defaults for the Client module.
     */
    _extend(_globalConfig, {
        autoActivate: true
    });
    /**
     * The real constructor for `ZeroClipboard` client instances.
     * @private
     */
    var _clientConstructor = function(elements) {
        var client = this;
        client.id = "" + _clientIdCounter++;
        _clientMeta[client.id] = {
            instance: client,
            elements: [],
            handlers: {}
        };
        if (elements) {
            client.clip(elements);
        }
        ZeroClipboard.on("*", function(event) {
            return client.emit(event);
        });
        ZeroClipboard.on("destroy", function() {
            client.destroy();
        });
        ZeroClipboard.create();
    };
    /**
     * The underlying implementation of `ZeroClipboard.Client.prototype.on`.
     * @private
     */
    var _clientOn = function(eventType, listener) {
        var i, len, events, added = {},
            handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
        if (typeof eventType === "string" && eventType) {
            events = eventType.toLowerCase().split(/\s+/);
        } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
            for (i in eventType) {
                if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
                    this.on(i, eventType[i]);
                }
            }
        }
        if (events && events.length) {
            for (i = 0, len = events.length; i < len; i++) {
                eventType = events[i].replace(/^on/, "");
                added[eventType] = true;
                if (!handlers[eventType]) {
                    handlers[eventType] = [];
                }
                handlers[eventType].push(listener);
            }
            if (added.ready && _flashState.ready) {
                this.emit({
                    type: "ready",
                    client: this
                });
            }
            if (added.error) {
                var errorTypes = ["disabled", "outdated", "unavailable", "deactivated", "overdue"];
                for (i = 0, len = errorTypes.length; i < len; i++) {
                    if (_flashState[errorTypes[i]]) {
                        this.emit({
                            type: "error",
                            name: "flash-" + errorTypes[i],
                            client: this
                        });
                        break;
                    }
                }
            }
        }
        return this;
    };
    /**
     * The underlying implementation of `ZeroClipboard.Client.prototype.off`.
     * @private
     */
    var _clientOff = function(eventType, listener) {
        var i, len, foundIndex, events, perEventHandlers, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
        if (arguments.length === 0) {
            events = _keys(handlers);
        } else if (typeof eventType === "string" && eventType) {
            events = eventType.split(/\s+/);
        } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
            for (i in eventType) {
                if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
                    this.off(i, eventType[i]);
                }
            }
        }
        if (events && events.length) {
            for (i = 0, len = events.length; i < len; i++) {
                eventType = events[i].toLowerCase().replace(/^on/, "");
                perEventHandlers = handlers[eventType];
                if (perEventHandlers && perEventHandlers.length) {
                    if (listener) {
                        foundIndex = perEventHandlers.indexOf(listener);
                        while (foundIndex !== -1) {
                            perEventHandlers.splice(foundIndex, 1);
                            foundIndex = perEventHandlers.indexOf(listener, foundIndex);
                        }
                    } else {
                        perEventHandlers.length = 0;
                    }
                }
            }
        }
        return this;
    };
    /**
     * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`.
     * @private
     */
    var _clientListeners = function(eventType) {
        var copy = null,
            handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
        if (handlers) {
            if (typeof eventType === "string" && eventType) {
                copy = handlers[eventType] ? handlers[eventType].slice(0) : [];
            } else {
                copy = _deepCopy(handlers);
            }
        }
        return copy;
    };
    /**
     * The underlying implementation of `ZeroClipboard.Client.prototype.emit`.
     * @private
     */
    var _clientEmit = function(event) {
        if (_clientShouldEmit.call(this, event)) {
            if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
                event = _extend({}, event);
            }
            var eventCopy = _extend({}, _createEvent(event), {
                client: this
            });
            _clientDispatchCallbacks.call(this, eventCopy);
        }
        return this;
    };
    /**
     * The underlying implementation of `ZeroClipboard.Client.prototype.clip`.
     * @private
     */
    var _clientClip = function(elements) {
        elements = _prepClip(elements);
        for (var i = 0; i < elements.length; i++) {
            if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
                if (!elements[i].zcClippingId) {
                    elements[i].zcClippingId = "zcClippingId_" + _elementIdCounter++;
                    _elementMeta[elements[i].zcClippingId] = [this.id];
                    if (_globalConfig.autoActivate === true) {
                        _addMouseHandlers(elements[i]);
                    }
                } else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) {
                    _elementMeta[elements[i].zcClippingId].push(this.id);
                }
                var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements;
                if (clippedElements.indexOf(elements[i]) === -1) {
                    clippedElements.push(elements[i]);
                }
            }
        }
        return this;
    };
    /**
     * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`.
     * @private
     */
    var _clientUnclip = function(elements) {
        var meta = _clientMeta[this.id];
        if (!meta) {
            return this;
        }
        var clippedElements = meta.elements;
        var arrayIndex;
        if (typeof elements === "undefined") {
            elements = clippedElements.slice(0);
        } else {
            elements = _prepClip(elements);
        }
        for (var i = elements.length; i--;) {
            if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
                arrayIndex = 0;
                while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) {
                    clippedElements.splice(arrayIndex, 1);
                }
                var clientIds = _elementMeta[elements[i].zcClippingId];
                if (clientIds) {
                    arrayIndex = 0;
                    while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) {
                        clientIds.splice(arrayIndex, 1);
                    }
                    if (clientIds.length === 0) {
                        if (_globalConfig.autoActivate === true) {
                            _removeMouseHandlers(elements[i]);
                        }
                        delete elements[i].zcClippingId;
                    }
                }
            }
        }
        return this;
    };
    /**
     * The underlying implementation of `ZeroClipboard.Client.prototype.elements`.
     * @private
     */
    var _clientElements = function() {
        var meta = _clientMeta[this.id];
        return meta && meta.elements ? meta.elements.slice(0) : [];
    };
    /**
     * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`.
     * @private
     */
    var _clientDestroy = function() {
        this.unclip();
        this.off();
        delete _clientMeta[this.id];
    };
    /**
     * Inspect an Event to see if the Client (`this`) should honor it for emission.
     * @private
     */
    var _clientShouldEmit = function(event) {
        if (!(event && event.type)) {
            return false;
        }
        if (event.client && event.client !== this) {
            return false;
        }
        var clippedEls = _clientMeta[this.id] && _clientMeta[this.id].elements;
        var hasClippedEls = !!clippedEls && clippedEls.length > 0;
        var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1;
        var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1;
        var goodClient = event.client && event.client === this;
        if (!(goodTarget || goodRelTarget || goodClient)) {
            return false;
        }
        return true;
    };
    /**
     * Handle the actual dispatching of events to a client instance.
     *
     * @returns `this`
     * @private
     */
    var _clientDispatchCallbacks = function(event) {
        if (!(typeof event === "object" && event && event.type)) {
            return;
        }
        var async = _shouldPerformAsync(event);
        var wildcardTypeHandlers = _clientMeta[this.id] && _clientMeta[this.id].handlers["*"] || [];
        var specificTypeHandlers = _clientMeta[this.id] && _clientMeta[this.id].handlers[event.type] || [];
        var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
        if (handlers && handlers.length) {
            var i, len, func, context, eventCopy, originalContext = this;
            for (i = 0, len = handlers.length; i < len; i++) {
                func = handlers[i];
                context = originalContext;
                if (typeof func === "string" && typeof _window[func] === "function") {
                    func = _window[func];
                }
                if (typeof func === "object" && func && typeof func.handleEvent === "function") {
                    context = func;
                    func = func.handleEvent;
                }
                if (typeof func === "function") {
                    eventCopy = _extend({}, event);
                    _dispatchCallback(func, context, [eventCopy], async);
                }
            }
        }
        return this;
    };
    /**
     * Prepares the elements for clipping/unclipping.
     *
     * @returns An Array of elements.
     * @private
     */
    var _prepClip = function(elements) {
        if (typeof elements === "string") {
            elements = [];
        }
        return typeof elements.length !== "number" ? [elements] : elements;
    };
    /**
     * Add a `mouseover` handler function for a clipped element.
     *
     * @returns `undefined`
     * @private
     */
    var _addMouseHandlers = function(element) {
        if (!(element && element.nodeType === 1)) {
            return;
        }
        var _suppressMouseEvents = function(event) {
            if (!(event || (event = _window.event))) {
                return;
            }
            if (event._source !== "js") {
                event.stopImmediatePropagation();
                event.preventDefault();
            }
            delete event._source;
        };
        var _elementMouseOver = function(event) {
            if (!(event || (event = _window.event))) {
                return;
            }
            _suppressMouseEvents(event);
            ZeroClipboard.focus(element);
        };
        element.addEventListener("mouseover", _elementMouseOver, false);
        element.addEventListener("mouseout", _suppressMouseEvents, false);
        element.addEventListener("mouseenter", _suppressMouseEvents, false);
        element.addEventListener("mouseleave", _suppressMouseEvents, false);
        element.addEventListener("mousemove", _suppressMouseEvents, false);
        _mouseHandlers[element.zcClippingId] = {
            mouseover: _elementMouseOver,
            mouseout: _suppressMouseEvents,
            mouseenter: _suppressMouseEvents,
            mouseleave: _suppressMouseEvents,
            mousemove: _suppressMouseEvents
        };
    };
    /**
     * Remove a `mouseover` handler function for a clipped element.
     *
     * @returns `undefined`
     * @private
     */
    var _removeMouseHandlers = function(element) {
        if (!(element && element.nodeType === 1)) {
            return;
        }
        var mouseHandlers = _mouseHandlers[element.zcClippingId];
        if (!(typeof mouseHandlers === "object" && mouseHandlers)) {
            return;
        }
        var key, val, mouseEvents = ["move", "leave", "enter", "out", "over"];
        for (var i = 0, len = mouseEvents.length; i < len; i++) {
            key = "mouse" + mouseEvents[i];
            val = mouseHandlers[key];
            if (typeof val === "function") {
                element.removeEventListener(key, val, false);
            }
        }
        delete _mouseHandlers[element.zcClippingId];
    };
    /**
     * Creates a new ZeroClipboard client instance.
     * Optionally, auto-`clip` an element or collection of elements.
     *
     * @constructor
     */
    ZeroClipboard._createClient = function() {
        _clientConstructor.apply(this, _args(arguments));
    };
    /**
     * Register an event listener to the client.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.on = function() {
        return _clientOn.apply(this, _args(arguments));
    };
    /**
     * Unregister an event handler from the client.
     * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`.
     * If no `eventType` is provided, it will unregister all handlers for every event type.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.off = function() {
        return _clientOff.apply(this, _args(arguments));
    };
    /**
     * Retrieve event listeners for an `eventType` from the client.
     * If no `eventType` is provided, it will retrieve all listeners for every event type.
     *
     * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
     */
    ZeroClipboard.prototype.handlers = function() {
        return _clientListeners.apply(this, _args(arguments));
    };
    /**
     * Event emission receiver from the Flash object for this client's registered JavaScript event listeners.
     *
     * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
     */
    ZeroClipboard.prototype.emit = function() {
        return _clientEmit.apply(this, _args(arguments));
    };
    /**
     * Register clipboard actions for new element(s) to the client.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.clip = function() {
        return _clientClip.apply(this, _args(arguments));
    };
    /**
     * Unregister the clipboard actions of previously registered element(s) on the page.
     * If no elements are provided, ALL registered elements will be unregistered.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.unclip = function() {
        return _clientUnclip.apply(this, _args(arguments));
    };
    /**
     * Get all of the elements to which this client is clipped.
     *
     * @returns array of clipped elements
     */
    ZeroClipboard.prototype.elements = function() {
        return _clientElements.apply(this, _args(arguments));
    };
    /**
     * Self-destruct and clean up everything for a single client.
     * This will NOT destroy the embedded Flash object.
     *
     * @returns `undefined`
     */
    ZeroClipboard.prototype.destroy = function() {
        return _clientDestroy.apply(this, _args(arguments));
    };
    /**
     * Stores the pending plain text to inject into the clipboard.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.setText = function(text) {
        ZeroClipboard.setData("text/plain", text);
        return this;
    };
    /**
     * Stores the pending HTML text to inject into the clipboard.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.setHtml = function(html) {
        ZeroClipboard.setData("text/html", html);
        return this;
    };
    /**
     * Stores the pending rich text (RTF) to inject into the clipboard.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.setRichText = function(richText) {
        ZeroClipboard.setData("application/rtf", richText);
        return this;
    };
    /**
     * Stores the pending data to inject into the clipboard.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.setData = function() {
        ZeroClipboard.setData.apply(this, _args(arguments));
        return this;
    };
    /**
     * Clears the pending data to inject into the clipboard.
     * If no `format` is provided, all pending data formats will be cleared.
     *
     * @returns `this`
     */
    ZeroClipboard.prototype.clearData = function() {
        ZeroClipboard.clearData.apply(this, _args(arguments));
        return this;
    };
    /**
     * Gets a copy of the pending data to inject into the clipboard.
     * If no `format` is provided, a copy of ALL pending data formats will be returned.
     *
     * @returns `String` or `Object`
     */
    ZeroClipboard.prototype.getData = function() {
        return ZeroClipboard.getData.apply(this, _args(arguments));
    };
    if (typeof define === "function" && define.amd) {
        define(function() {
            return ZeroClipboard;
        });
    } else if (typeof module === "object" && module && typeof module.exports === "object" && module.exports) {
        module.exports = ZeroClipboard;
    } else {
        window.ZeroClipboard = ZeroClipboard;
    }
})(function() {
    return this || window;
}());
/*!
 * MediaElement.js
 * HTML5 <video> and <audio> shim and player
 * http://mediaelementjs.com/
 *
 * Creates a JavaScript object that mimics HTML5 MediaElement API
 * for browsers that don't understand HTML5 or can't play the provided codec
 * Can play MP4 (H.264), Ogg, WebM, FLV, WMV, WMA, ACC, and MP3
 *
 * Copyright 2010-2014, John Dyer (http://j.hn)
 * License: MIT
 *
 */
// Namespace
var mejs = mejs || {};

// version number
mejs.version = '2.15.1';


// player number (for missing, same id attr)
mejs.meIndex = 0;

// media types accepted by plugins
mejs.plugins = {
    silverlight: [{
        version: [3, 0],
        types: ['video/mp4', 'video/m4v', 'video/mov', 'video/wmv', 'audio/wma', 'audio/m4a', 'audio/mp3', 'audio/wav', 'audio/mpeg']
    }],
    flash: [{
            version: [9, 0, 124],
            types: ['video/mp4', 'video/m4v', 'video/mov', 'video/flv', 'video/rtmp', 'video/x-flv', 'audio/flv', 'audio/x-flv', 'audio/mp3', 'audio/m4a', 'audio/mpeg', 'video/youtube', 'video/x-youtube', 'application/x-mpegURL']
        }
        //,{version: [12,0], types: ['video/webm']} // for future reference (hopefully!)
    ],
    youtube: [{
        version: null,
        types: ['video/youtube', 'video/x-youtube', 'audio/youtube', 'audio/x-youtube']
    }],
    vimeo: [{
        version: null,
        types: ['video/vimeo', 'video/x-vimeo']
    }]
};

/*
Utility methods
*/
mejs.Utility = {
    encodeUrl: function(url) {
        return encodeURIComponent(url); //.replace(/\?/gi,'%3F').replace(/=/gi,'%3D').replace(/&/gi,'%26');
    },
    escapeHTML: function(s) {
        return s.toString().split('&').join('&amp;').split('<').join('&lt;').split('"').join('&quot;');
    },
    absolutizeUrl: function(url) {
        var el = document.createElement('div');
        el.innerHTML = '<a href="' + this.escapeHTML(url) + '">x</a>';
        return el.firstChild.href;
    },
    getScriptPath: function(scriptNames) {
        var
            i = 0,
            j,
            codePath = '',
            testname = '',
            slashPos,
            filenamePos,
            scriptUrl,
            scriptPath,
            scriptFilename,
            scripts = document.getElementsByTagName('script'),
            il = scripts.length,
            jl = scriptNames.length;

        // go through all <script> tags
        for (; i < il; i++) {
            scriptUrl = scripts[i].src;
            slashPos = scriptUrl.lastIndexOf('/');
            if (slashPos > -1) {
                scriptFilename = scriptUrl.substring(slashPos + 1);
                scriptPath = scriptUrl.substring(0, slashPos + 1);
            } else {
                scriptFilename = scriptUrl;
                scriptPath = '';
            }

            // see if any <script> tags have a file name that matches the
            for (j = 0; j < jl; j++) {
                testname = scriptNames[j];
                filenamePos = scriptFilename.indexOf(testname);
                if (filenamePos > -1) {
                    codePath = scriptPath;
                    break;
                }
            }

            // if we found a path, then break and return it
            if (codePath !== '') {
                break;
            }
        }

        // send the best path back
        return codePath;
    },
    secondsToTimeCode: function(time, forceHours, showFrameCount, fps) {
        //add framecount
        if (typeof showFrameCount == 'undefined') {
            showFrameCount = false;
        } else if (typeof fps == 'undefined') {
            fps = 25;
        }

        var hours = Math.floor(time / 3600) % 24,
            minutes = Math.floor(time / 60) % 60,
            seconds = Math.floor(time % 60),
            frames = Math.floor(((time % 1) * fps).toFixed(3)),
            result =
            ((forceHours || hours > 0) ? (hours < 10 ? '0' + hours : hours) + ':' : '') +
            (minutes < 10 ? '0' + minutes : minutes) + ':' +
            (seconds < 10 ? '0' + seconds : seconds) +
            ((showFrameCount) ? ':' + (frames < 10 ? '0' + frames : frames) : '');

        return result;
    },

    timeCodeToSeconds: function(hh_mm_ss_ff, forceHours, showFrameCount, fps) {
        if (typeof showFrameCount == 'undefined') {
            showFrameCount = false;
        } else if (typeof fps == 'undefined') {
            fps = 25;
        }

        var tc_array = hh_mm_ss_ff.split(":"),
            tc_hh = parseInt(tc_array[0], 10),
            tc_mm = parseInt(tc_array[1], 10),
            tc_ss = parseInt(tc_array[2], 10),
            tc_ff = 0,
            tc_in_seconds = 0;

        if (showFrameCount) {
            tc_ff = parseInt(tc_array[3]) / fps;
        }

        tc_in_seconds = (tc_hh * 3600) + (tc_mm * 60) + tc_ss + tc_ff;

        return tc_in_seconds;
    },


    convertSMPTEtoSeconds: function(SMPTE) {
        if (typeof SMPTE != 'string')
            return false;

        SMPTE = SMPTE.replace(',', '.');

        var secs = 0,
            decimalLen = (SMPTE.indexOf('.') != -1) ? SMPTE.split('.')[1].length : 0,
            multiplier = 1;

        SMPTE = SMPTE.split(':').reverse();

        for (var i = 0; i < SMPTE.length; i++) {
            multiplier = 1;
            if (i > 0) {
                multiplier = Math.pow(60, i);
            }
            secs += Number(SMPTE[i]) * multiplier;
        }
        return Number(secs.toFixed(decimalLen));
    },

    /* borrowed from SWFObject: http://code.google.com/p/swfobject/source/browse/trunk/swfobject/src/swfobject.js#474 */
    removeSwf: function(id) {
        var obj = document.getElementById(id);
        if (obj && /object|embed/i.test(obj.nodeName)) {
            if (mejs.MediaFeatures.isIE) {
                obj.style.display = "none";
                (function() {
                    if (obj.readyState == 4) {
                        mejs.Utility.removeObjectInIE(id);
                    } else {
                        setTimeout(arguments.callee, 10);
                    }
                })();
            } else {
                obj.parentNode.removeChild(obj);
            }
        }
    },
    removeObjectInIE: function(id) {
        var obj = document.getElementById(id);
        if (obj) {
            for (var i in obj) {
                if (typeof obj[i] == "function") {
                    obj[i] = null;
                }
            }
            obj.parentNode.removeChild(obj);
        }
    }
};


// Core detector, plugins are added below
mejs.PluginDetector = {

    // main public function to test a plug version number PluginDetector.hasPluginVersion('flash',[9,0,125]);
    hasPluginVersion: function(plugin, v) {
        var pv = this.plugins[plugin];
        v[1] = v[1] || 0;
        v[2] = v[2] || 0;
        return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
    },

    // cached values
    nav: window.navigator,
    ua: window.navigator.userAgent.toLowerCase(),

    // stored version numbers
    plugins: [],

    // runs detectPlugin() and stores the version number
    addPlugin: function(p, pluginName, mimeType, activeX, axDetect) {
        this.plugins[p] = this.detectPlugin(pluginName, mimeType, activeX, axDetect);
    },

    // get the version number from the mimetype (all but IE) or ActiveX (IE)
    detectPlugin: function(pluginName, mimeType, activeX, axDetect) {

        var version = [0, 0, 0],
            description,
            i,
            ax;

        // Firefox, Webkit, Opera
        if (typeof(this.nav.plugins) != 'undefined' && typeof this.nav.plugins[pluginName] == 'object') {
            description = this.nav.plugins[pluginName].description;
            if (description && !(typeof this.nav.mimeTypes != 'undefined' && this.nav.mimeTypes[mimeType] && !this.nav.mimeTypes[mimeType].enabledPlugin)) {
                version = description.replace(pluginName, '').replace(/^\s+/, '').replace(/\sr/gi, '.').split('.');
                for (i = 0; i < version.length; i++) {
                    version[i] = parseInt(version[i].match(/\d+/), 10);
                }
            }
            // Internet Explorer / ActiveX
        } else if (typeof(window.ActiveXObject) != 'undefined') {
            try {
                ax = new ActiveXObject(activeX);
                if (ax) {
                    version = axDetect(ax);
                }
            } catch (e) {}
        }
        return version;
    }
};

// Add Flash detection
mejs.PluginDetector.addPlugin('flash', 'Shockwave Flash', 'application/x-shockwave-flash', 'ShockwaveFlash.ShockwaveFlash', function(ax) {
    // adapted from SWFObject
    var version = [],
        d = ax.GetVariable("$version");
    if (d) {
        d = d.split(" ")[1].split(",");
        version = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
    }
    return version;
});

// Add Silverlight detection
mejs.PluginDetector.addPlugin('silverlight', 'Silverlight Plug-In', 'application/x-silverlight-2', 'AgControl.AgControl', function(ax) {
    // Silverlight cannot report its version number to IE
    // but it does have a isVersionSupported function, so we have to loop through it to get a version number.
    // adapted from http://www.silverlightversion.com/
    var v = [0, 0, 0, 0],
        loopMatch = function(ax, v, i, n) {
            while (ax.isVersionSupported(v[0] + "." + v[1] + "." + v[2] + "." + v[3])) {
                v[i] += n;
            }
            v[i] -= n;
        };
    loopMatch(ax, v, 0, 1);
    loopMatch(ax, v, 1, 1);
    loopMatch(ax, v, 2, 10000); // the third place in the version number is usually 5 digits (4.0.xxxxx)
    loopMatch(ax, v, 2, 1000);
    loopMatch(ax, v, 2, 100);
    loopMatch(ax, v, 2, 10);
    loopMatch(ax, v, 2, 1);
    loopMatch(ax, v, 3, 1);

    return v;
});
// add adobe acrobat
/*
PluginDetector.addPlugin('acrobat','Adobe Acrobat','application/pdf','AcroPDF.PDF', function (ax) {
  var version = [],
    d = ax.GetVersions().split(',')[0].split('=')[1].split('.');

  if (d) {
    version = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
  }
  return version;
});
*/
// necessary detection (fixes for <IE9)
mejs.MediaFeatures = {
    init: function() {
        var
            t = this,
            d = document,
            nav = mejs.PluginDetector.nav,
            ua = mejs.PluginDetector.ua.toLowerCase(),
            i,
            v,
            html5Elements = ['source', 'track', 'audio', 'video'];

        // detect browsers (only the ones that have some kind of quirk we need to work around)
        t.isiPad = (ua.match(/ipad/i) !== null);
        t.isiPhone = (ua.match(/iphone/i) !== null);
        t.isiOS = t.isiPhone || t.isiPad;
        t.isAndroid = (ua.match(/android/i) !== null);
        t.isBustedAndroid = (ua.match(/android 2\.[12]/) !== null);
        t.isBustedNativeHTTPS = (location.protocol === 'https:' && (ua.match(/android [12]\./) !== null || ua.match(/macintosh.* version.* safari/) !== null));
        t.isIE = (nav.appName.toLowerCase().indexOf("microsoft") != -1 || nav.appName.toLowerCase().match(/trident/gi) !== null);
        t.isChrome = (ua.match(/chrome/gi) !== null);
        t.isChromium = (ua.match(/chromium/gi) !== null);
        t.isFirefox = (ua.match(/firefox/gi) !== null);
        t.isWebkit = (ua.match(/webkit/gi) !== null);
        t.isGecko = (ua.match(/gecko/gi) !== null) && !t.isWebkit && !t.isIE;
        t.isOpera = (ua.match(/opera/gi) !== null);
        t.hasTouch = ('ontouchstart' in window); //  && window.ontouchstart != null); // this breaks iOS 7

        // borrowed from Modernizr
        t.svg = !!document.createElementNS &&
            !!document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect;

        // create HTML5 media elements for IE before 9, get a <video> element for fullscreen detection
        for (i = 0; i < html5Elements.length; i++) {
            v = document.createElement(html5Elements[i]);
        }

        t.supportsMediaTag = (typeof v.canPlayType !== 'undefined' || t.isBustedAndroid);

        // Fix for IE9 on Windows 7N / Windows 7KN (Media Player not installer)
        try {
            v.canPlayType("video/mp4");
        } catch (e) {
            t.supportsMediaTag = false;
        }

        // detect native JavaScript fullscreen (Safari/Firefox only, Chrome still fails)

        // iOS
        t.hasSemiNativeFullScreen = (typeof v.webkitEnterFullscreen !== 'undefined');

        // W3C
        t.hasNativeFullscreen = (typeof v.requestFullscreen !== 'undefined');

        // webkit/firefox/IE11+
        t.hasWebkitNativeFullScreen = (typeof v.webkitRequestFullScreen !== 'undefined');
        t.hasMozNativeFullScreen = (typeof v.mozRequestFullScreen !== 'undefined');
        t.hasMsNativeFullScreen = (typeof v.msRequestFullscreen !== 'undefined');

        t.hasTrueNativeFullScreen = (t.hasWebkitNativeFullScreen || t.hasMozNativeFullScreen || t.hasMsNativeFullScreen);
        t.nativeFullScreenEnabled = t.hasTrueNativeFullScreen;

        // Enabled?
        if (t.hasMozNativeFullScreen) {
            t.nativeFullScreenEnabled = document.mozFullScreenEnabled;
        } else if (t.hasMsNativeFullScreen) {
            t.nativeFullScreenEnabled = document.msFullscreenEnabled;
        }

        if (t.isChrome) {
            t.hasSemiNativeFullScreen = false;
        }

        if (t.hasTrueNativeFullScreen) {

            t.fullScreenEventName = '';
            if (t.hasWebkitNativeFullScreen) {
                t.fullScreenEventName = 'webkitfullscreenchange';

            } else if (t.hasMozNativeFullScreen) {
                t.fullScreenEventName = 'mozfullscreenchange';

            } else if (t.hasMsNativeFullScreen) {
                t.fullScreenEventName = 'MSFullscreenChange';
            }

            t.isFullScreen = function() {
                if (t.hasMozNativeFullScreen) {
                    return d.mozFullScreen;

                } else if (t.hasWebkitNativeFullScreen) {
                    return d.webkitIsFullScreen;

                } else if (t.hasMsNativeFullScreen) {
                    return d.msFullscreenElement !== null;
                }
            }

            t.requestFullScreen = function(el) {

                if (t.hasWebkitNativeFullScreen) {
                    el.webkitRequestFullScreen();

                } else if (t.hasMozNativeFullScreen) {
                    el.mozRequestFullScreen();

                } else if (t.hasMsNativeFullScreen) {
                    el.msRequestFullscreen();

                }
            }

            t.cancelFullScreen = function() {
                if (t.hasWebkitNativeFullScreen) {
                    document.webkitCancelFullScreen();

                } else if (t.hasMozNativeFullScreen) {
                    document.mozCancelFullScreen();

                } else if (t.hasMsNativeFullScreen) {
                    document.msExitFullscreen();

                }
            }

        }


        // OS X 10.5 can't do this even if it says it can :(
        if (t.hasSemiNativeFullScreen && ua.match(/mac os x 10_5/i)) {
            t.hasNativeFullScreen = false;
            t.hasSemiNativeFullScreen = false;
        }

    }
};
mejs.MediaFeatures.init();

/*
extension methods to <video> or <audio> object to bring it into parity with PluginMediaElement (see below)
*/
mejs.HtmlMediaElement = {
    pluginType: 'native',
    isFullScreen: false,

    setCurrentTime: function(time) {
        this.currentTime = time;
    },

    setMuted: function(muted) {
        this.muted = muted;
    },

    setVolume: function(volume) {
        this.volume = volume;
    },

    // for parity with the plugin versions
    stop: function() {
        this.pause();
    },

    // This can be a url string
    // or an array [{src:'file.mp4',type:'video/mp4'},{src:'file.webm',type:'video/webm'}]
    setSrc: function(url) {

        // Fix for IE9 which can't set .src when there are <source> elements. Awesome, right?
        var
            existingSources = this.getElementsByTagName('source');
        while (existingSources.length > 0) {
            this.removeChild(existingSources[0]);
        }

        if (typeof url == 'string') {
            this.src = url;
        } else {
            var i, media;

            for (i = 0; i < url.length; i++) {
                media = url[i];
                if (this.canPlayType(media.type)) {
                    this.src = media.src;
                    break;
                }
            }
        }
    },

    setVideoSize: function(width, height) {
        this.width = width;
        this.height = height;
    }
};

/*
Mimics the <video/audio> element by calling Flash's External Interface or Silverlights [ScriptableMember]
*/
mejs.PluginMediaElement = function(pluginid, pluginType, mediaUrl) {
    this.id = pluginid;
    this.pluginType = pluginType;
    this.src = mediaUrl;
    this.events = {};
    this.attributes = {};
};

// JavaScript values and ExternalInterface methods that match HTML5 video properties methods
// http://www.adobe.com/livedocs/flash/9.0/ActionScriptLangRefV3/fl/video/FLVPlayback.html
// http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html
mejs.PluginMediaElement.prototype = {

    // special
    pluginElement: null,
    pluginType: '',
    isFullScreen: false,

    // not implemented :(
    playbackRate: -1,
    defaultPlaybackRate: -1,
    seekable: [],
    played: [],

    // HTML5 read-only properties
    paused: true,
    ended: false,
    seeking: false,
    duration: 0,
    error: null,
    tagName: '',

    // HTML5 get/set properties, but only set (updated by event handlers)
    muted: false,
    volume: 1,
    currentTime: 0,

    // HTML5 methods
    play: function() {
        if (this.pluginApi != null) {
            if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
                this.pluginApi.playVideo();
            } else {
                this.pluginApi.playMedia();
            }
            this.paused = false;
        }
    },
    load: function() {
        if (this.pluginApi != null) {
            if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {} else {
                this.pluginApi.loadMedia();
            }

            this.paused = false;
        }
    },
    pause: function() {
        if (this.pluginApi != null) {
            if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
                this.pluginApi.pauseVideo();
            } else {
                this.pluginApi.pauseMedia();
            }


            this.paused = true;
        }
    },
    stop: function() {
        if (this.pluginApi != null) {
            if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
                this.pluginApi.stopVideo();
            } else {
                this.pluginApi.stopMedia();
            }
            this.paused = true;
        }
    },
    canPlayType: function(type) {
        var i,
            j,
            pluginInfo,
            pluginVersions = mejs.plugins[this.pluginType];

        for (i = 0; i < pluginVersions.length; i++) {
            pluginInfo = pluginVersions[i];

            // test if user has the correct plugin version
            if (mejs.PluginDetector.hasPluginVersion(this.pluginType, pluginInfo.version)) {

                // test for plugin playback types
                for (j = 0; j < pluginInfo.types.length; j++) {
                    // find plugin that can play the type
                    if (type == pluginInfo.types[j]) {
                        return 'probably';
                    }
                }
            }
        }

        return '';
    },

    positionFullscreenButton: function(x, y, visibleAndAbove) {
        if (this.pluginApi != null && this.pluginApi.positionFullscreenButton) {
            this.pluginApi.positionFullscreenButton(Math.floor(x), Math.floor(y), visibleAndAbove);
        }
    },

    hideFullscreenButton: function() {
        if (this.pluginApi != null && this.pluginApi.hideFullscreenButton) {
            this.pluginApi.hideFullscreenButton();
        }
    },


    // custom methods since not all JavaScript implementations support get/set

    // This can be a url string
    // or an array [{src:'file.mp4',type:'video/mp4'},{src:'file.webm',type:'video/webm'}]
    setSrc: function(url) {
        if (typeof url == 'string') {
            this.pluginApi.setSrc(mejs.Utility.absolutizeUrl(url));
            this.src = mejs.Utility.absolutizeUrl(url);
        } else {
            var i, media;

            for (i = 0; i < url.length; i++) {
                media = url[i];
                if (this.canPlayType(media.type)) {
                    this.pluginApi.setSrc(mejs.Utility.absolutizeUrl(media.src));
                    this.src = mejs.Utility.absolutizeUrl(url);
                    break;
                }
            }
        }

    },
    setCurrentTime: function(time) {
        if (this.pluginApi != null) {
            if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
                this.pluginApi.seekTo(time);
            } else {
                this.pluginApi.setCurrentTime(time);
            }



            this.currentTime = time;
        }
    },
    setVolume: function(volume) {
        if (this.pluginApi != null) {
            // same on YouTube and MEjs
            if (this.pluginType == 'youtube') {
                this.pluginApi.setVolume(volume * 100);
            } else {
                this.pluginApi.setVolume(volume);
            }
            this.volume = volume;
        }
    },
    setMuted: function(muted) {
        if (this.pluginApi != null) {
            if (this.pluginType == 'youtube') {
                if (muted) {
                    this.pluginApi.mute();
                } else {
                    this.pluginApi.unMute();
                }
                this.muted = muted;
                this.dispatchEvent('volumechange');
            } else {
                this.pluginApi.setMuted(muted);
            }
            this.muted = muted;
        }
    },

    // additional non-HTML5 methods
    setVideoSize: function(width, height) {

        //if (this.pluginType == 'flash' || this.pluginType == 'silverlight') {
        if (this.pluginElement && this.pluginElement.style) {
            this.pluginElement.style.width = width + 'px';
            this.pluginElement.style.height = height + 'px';
        }
        if (this.pluginApi != null && this.pluginApi.setVideoSize) {
            this.pluginApi.setVideoSize(width, height);
        }
        //}
    },

    setFullscreen: function(fullscreen) {
        if (this.pluginApi != null && this.pluginApi.setFullscreen) {
            this.pluginApi.setFullscreen(fullscreen);
        }
    },

    enterFullScreen: function() {
        if (this.pluginApi != null && this.pluginApi.setFullscreen) {
            this.setFullscreen(true);
        }

    },

    exitFullScreen: function() {
        if (this.pluginApi != null && this.pluginApi.setFullscreen) {
            this.setFullscreen(false);
        }
    },

    // start: fake events
    addEventListener: function(eventName, callback, bubble) {
        this.events[eventName] = this.events[eventName] || [];
        this.events[eventName].push(callback);
    },
    removeEventListener: function(eventName, callback) {
        if (!eventName) {
            this.events = {};
            return true;
        }
        var callbacks = this.events[eventName];
        if (!callbacks) return true;
        if (!callback) {
            this.events[eventName] = [];
            return true;
        }
        for (var i = 0; i < callbacks.length; i++) {
            if (callbacks[i] === callback) {
                this.events[eventName].splice(i, 1);
                return true;
            }
        }
        return false;
    },
    dispatchEvent: function(eventName) {
        var i,
            args,
            callbacks = this.events[eventName];

        if (callbacks) {
            args = Array.prototype.slice.call(arguments, 1);
            for (i = 0; i < callbacks.length; i++) {
                callbacks[i].apply(null, args);
            }
        }
    },
    // end: fake events

    // fake DOM attribute methods
    hasAttribute: function(name) {
        return (name in this.attributes);
    },
    removeAttribute: function(name) {
        delete this.attributes[name];
    },
    getAttribute: function(name) {
        if (this.hasAttribute(name)) {
            return this.attributes[name];
        }
        return '';
    },
    setAttribute: function(name, value) {
        this.attributes[name] = value;
    },

    remove: function() {
        mejs.Utility.removeSwf(this.pluginElement.id);
        mejs.MediaPluginBridge.unregisterPluginElement(this.pluginElement.id);
    }
};

// Handles calls from Flash/Silverlight and reports them as native <video/audio> events and properties
mejs.MediaPluginBridge = {

    pluginMediaElements: {},
    htmlMediaElements: {},

    registerPluginElement: function(id, pluginMediaElement, htmlMediaElement) {
        this.pluginMediaElements[id] = pluginMediaElement;
        this.htmlMediaElements[id] = htmlMediaElement;
    },

    unregisterPluginElement: function(id) {
        delete this.pluginMediaElements[id];
        delete this.htmlMediaElements[id];
    },

    // when Flash/Silverlight is ready, it calls out to this method
    initPlugin: function(id) {

        var pluginMediaElement = this.pluginMediaElements[id],
            htmlMediaElement = this.htmlMediaElements[id];

        if (pluginMediaElement) {
            // find the javascript bridge
            switch (pluginMediaElement.pluginType) {
                case "flash":
                    pluginMediaElement.pluginElement = pluginMediaElement.pluginApi = document.getElementById(id);
                    break;
                case "silverlight":
                    pluginMediaElement.pluginElement = document.getElementById(pluginMediaElement.id);
                    pluginMediaElement.pluginApi = pluginMediaElement.pluginElement.Content.MediaElementJS;
                    break;
            }

            if (pluginMediaElement.pluginApi != null && pluginMediaElement.success) {
                pluginMediaElement.success(pluginMediaElement, htmlMediaElement);
            }
        }
    },

    // receives events from Flash/Silverlight and sends them out as HTML5 media events
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html
    fireEvent: function(id, eventName, values) {

        var
            e,
            i,
            bufferedTime,
            pluginMediaElement = this.pluginMediaElements[id];

        if (!pluginMediaElement) {
            return;
        }

        // fake event object to mimic real HTML media event.
        e = {
            type: eventName,
            target: pluginMediaElement
        };

        // attach all values to element and event object
        for (i in values) {
            pluginMediaElement[i] = values[i];
            e[i] = values[i];
        }

        // fake the newer W3C buffered TimeRange (loaded and total have been removed)
        bufferedTime = values.bufferedTime || 0;

        e.target.buffered = e.buffered = {
            start: function(index) {
                return 0;
            },
            end: function(index) {
                return bufferedTime;
            },
            length: 1
        };

        pluginMediaElement.dispatchEvent(e.type, e);
    }
};

/*
Default options
*/
mejs.MediaElementDefaults = {
    // allows testing on HTML5, flash, silverlight
    // auto: attempts to detect what the browser can do
    // auto_plugin: prefer plugins and then attempt native HTML5
    // native: forces HTML5 playback
    // shim: disallows HTML5, will attempt either Flash or Silverlight
    // none: forces fallback view
    mode: 'auto',
    // remove or reorder to change plugin priority and availability
    plugins: ['flash', 'silverlight', 'youtube', 'vimeo'],
    // shows debug errors on screen
    enablePluginDebug: false,
    // use plugin for browsers that have trouble with Basic Authentication on HTTPS sites
    httpsBasicAuthSite: false,
    // overrides the type specified, useful for dynamic instantiation
    type: '',
    // path to Flash and Silverlight plugins
    pluginPath: mejs.Utility.getScriptPath(['mediaelement.js', 'mediaelement.min.js', 'mediaelement-and-player.js', 'mediaelement-and-player.min.js']),
    // name of flash file
    flashName: 'flashmediaelement.swf',
    // streamer for RTMP streaming
    flashStreamer: '',
    // turns on the smoothing filter in Flash
    enablePluginSmoothing: false,
    // enabled pseudo-streaming (seek) on .mp4 files
    enablePseudoStreaming: false,
    // start query parameter sent to server for pseudo-streaming
    pseudoStreamingStartQueryParam: 'start',
    // name of silverlight file
    silverlightName: 'silverlightmediaelement.xap',
    // default if the <video width> is not specified
    defaultVideoWidth: 480,
    // default if the <video height> is not specified
    defaultVideoHeight: 270,
    // overrides <video width>
    pluginWidth: -1,
    // overrides <video height>
    pluginHeight: -1,
    pluginPath: '/Static/mediaelement/',
    // additional plugin variables in 'key=value' form
    pluginVars: [],
    // rate in milliseconds for Flash and Silverlight to fire the timeupdate event
    // larger number is less accurate, but less strain on plugin->JavaScript bridge
    timerRate: 250,
    // initial volume for player
    startVolume: 0.8,
    success: function() {},
    error: function() {}
};

/*
Determines if a browser supports the <video> or <audio> element
and returns either the native element or a Flash/Silverlight version that
mimics HTML5 MediaElement
*/
mejs.MediaElement = function(el, o) {
    return mejs.HtmlMediaElementShim.create(el, o);
};

mejs.HtmlMediaElementShim = {

    create: function(el, o) {
        var
            options = mejs.MediaElementDefaults,
            htmlMediaElement = (typeof(el) == 'string') ? document.getElementById(el) : el,
            tagName = htmlMediaElement.tagName.toLowerCase(),
            isMediaTag = (tagName === 'audio' || tagName === 'video'),
            src = (isMediaTag) ? htmlMediaElement.getAttribute('src') : htmlMediaElement.getAttribute('href'),
            poster = htmlMediaElement.getAttribute('poster'),
            autoplay = htmlMediaElement.getAttribute('autoplay'),
            preload = htmlMediaElement.getAttribute('preload'),
            controls = htmlMediaElement.getAttribute('controls'),
            playback,
            prop;

        // extend options
        for (prop in o) {
            options[prop] = o[prop];
        }

        // clean up attributes
        src = (typeof src == 'undefined' || src === null || src == '') ? null : src;
        poster = (typeof poster == 'undefined' || poster === null) ? '' : poster;
        preload = (typeof preload == 'undefined' || preload === null || preload === 'false') ? 'none' : preload;
        autoplay = !(typeof autoplay == 'undefined' || autoplay === null || autoplay === 'false');
        controls = !(typeof controls == 'undefined' || controls === null || controls === 'false');

        // test for HTML5 and plugin capabilities
        playback = this.determinePlayback(htmlMediaElement, options, mejs.MediaFeatures.supportsMediaTag, isMediaTag, src);
        playback.url = (playback.url !== null) ? mejs.Utility.absolutizeUrl(playback.url) : '';

        if (playback.method == 'native') {
            // second fix for android
            if (mejs.MediaFeatures.isBustedAndroid) {
                htmlMediaElement.src = playback.url;
                htmlMediaElement.addEventListener('click', function() {
                    htmlMediaElement.play();
                }, false);
            }

            // add methods to native HTMLMediaElement
            return this.updateNative(playback, options, autoplay, preload);
        } else if (playback.method !== '') {
            // create plugin to mimic HTMLMediaElement

            return this.createPlugin(playback, options, poster, autoplay, preload, controls);
        } else {
            // boo, no HTML5, no Flash, no Silverlight.
            this.createErrorMessage(playback, options, poster);

            return this;
        }
    },

    determinePlayback: function(htmlMediaElement, options, supportsMediaTag, isMediaTag, src) {
        var
            mediaFiles = [],
            i,
            j,
            k,
            l,
            n,
            type,
            result = {
                method: '',
                url: '',
                htmlMediaElement: htmlMediaElement,
                isVideo: (htmlMediaElement.tagName.toLowerCase() != 'audio')
            },
            pluginName,
            pluginVersions,
            pluginInfo,
            dummy,
            media;

        // STEP 1: Get URL and type from <video src> or <source src>

        // supplied type overrides <video type> and <source type>
        if (typeof options.type != 'undefined' && options.type !== '') {

            // accept either string or array of types
            if (typeof options.type == 'string') {
                mediaFiles.push({
                    type: options.type,
                    url: src
                });
            } else {

                for (i = 0; i < options.type.length; i++) {
                    mediaFiles.push({
                        type: options.type[i],
                        url: src
                    });
                }
            }

            // test for src attribute first
        } else if (src !== null) {
            type = this.formatType(src, htmlMediaElement.getAttribute('type'));
            mediaFiles.push({
                type: type,
                url: src
            });

            // then test for <source> elements
        } else {
            // test <source> types to see if they are usable
            for (i = 0; i < htmlMediaElement.childNodes.length; i++) {
                n = htmlMediaElement.childNodes[i];
                if (n.nodeType == 1 && n.tagName.toLowerCase() == 'source') {
                    src = n.getAttribute('src');
                    type = this.formatType(src, n.getAttribute('type'));
                    media = n.getAttribute('media');

                    if (!media || !window.matchMedia || (window.matchMedia && window.matchMedia(media).matches)) {
                        mediaFiles.push({
                            type: type,
                            url: src
                        });
                    }
                }
            }
        }

        // in the case of dynamicly created players
        // check for audio types
        if (!isMediaTag && mediaFiles.length > 0 && mediaFiles[0].url !== null && this.getTypeFromFile(mediaFiles[0].url).indexOf('audio') > -1) {
            result.isVideo = false;
        }


        // STEP 2: Test for playback method

        // special case for Android which sadly doesn't implement the canPlayType function (always returns '')
        if (mejs.MediaFeatures.isBustedAndroid) {
            htmlMediaElement.canPlayType = function(type) {
                return (type.match(/video\/(mp4|m4v)/gi) !== null) ? 'maybe' : '';
            };
        }

        // special case for Chromium to specify natively supported video codecs (i.e. WebM and Theora)
        if (mejs.MediaFeatures.isChromium) {
            htmlMediaElement.canPlayType = function(type) {
                return (type.match(/video\/(webm|ogv|ogg)/gi) !== null) ? 'maybe' : '';
            };
        }

        // test for native playback first
        if (supportsMediaTag && (options.mode === 'auto' || options.mode === 'auto_plugin' || options.mode === 'native') && !(mejs.MediaFeatures.isBustedNativeHTTPS && options.httpsBasicAuthSite === true)) {

            if (!isMediaTag) {

                // create a real HTML5 Media Element
                dummy = document.createElement(result.isVideo ? 'video' : 'audio');
                htmlMediaElement.parentNode.insertBefore(dummy, htmlMediaElement);
                htmlMediaElement.style.display = 'none';

                // use this one from now on
                result.htmlMediaElement = htmlMediaElement = dummy;
            }

            for (i = 0; i < mediaFiles.length; i++) {
                // normal check
                if (mediaFiles[i].type == "video/m3u8" || htmlMediaElement.canPlayType(mediaFiles[i].type).replace(/no/, '') !== ''
                    // special case for Mac/Safari 5.0.3 which answers '' to canPlayType('audio/mp3') but 'maybe' to canPlayType('audio/mpeg')
                    ||
                    htmlMediaElement.canPlayType(mediaFiles[i].type.replace(/mp3/, 'mpeg')).replace(/no/, '') !== ''
                    // special case for m4a supported by detecting mp4 support
                    ||
                    htmlMediaElement.canPlayType(mediaFiles[i].type.replace(/m4a/, 'mp4')).replace(/no/, '') !== '') {
                    result.method = 'native';
                    result.url = mediaFiles[i].url;
                    break;
                }
            }

            if (result.method === 'native') {
                if (result.url !== null) {
                    htmlMediaElement.src = result.url;
                }

                // if `auto_plugin` mode, then cache the native result but try plugins.
                if (options.mode !== 'auto_plugin') {
                    return result;
                }
            }
        }

        // if native playback didn't work, then test plugins
        if (options.mode === 'auto' || options.mode === 'auto_plugin' || options.mode === 'shim') {
            for (i = 0; i < mediaFiles.length; i++) {
                type = mediaFiles[i].type;

                // test all plugins in order of preference [silverlight, flash]
                for (j = 0; j < options.plugins.length; j++) {

                    pluginName = options.plugins[j];

                    // test version of plugin (for future features)
                    pluginVersions = mejs.plugins[pluginName];

                    for (k = 0; k < pluginVersions.length; k++) {
                        pluginInfo = pluginVersions[k];

                        // test if user has the correct plugin version

                        // for youtube/vimeo
                        if (pluginInfo.version == null ||

                            mejs.PluginDetector.hasPluginVersion(pluginName, pluginInfo.version)) {

                            // test for plugin playback types
                            for (l = 0; l < pluginInfo.types.length; l++) {
                                // find plugin that can play the type
                                if (type == pluginInfo.types[l]) {
                                    result.method = pluginName;
                                    result.url = mediaFiles[i].url;
                                    return result;
                                }
                            }
                        }
                    }
                }
            }
        }

        // at this point, being in 'auto_plugin' mode implies that we tried plugins but failed.
        // if we have native support then return that.
        if (options.mode === 'auto_plugin' && result.method === 'native') {
            return result;
        }

        // what if there's nothing to play? just grab the first available
        if (result.method === '' && mediaFiles.length > 0) {
            result.url = mediaFiles[0].url;
        }

        return result;
    },

    formatType: function(url, type) {
        var ext;

        // if no type is supplied, fake it with the extension
        if (url && !type) {
            return this.getTypeFromFile(url);
        } else {
            // only return the mime part of the type in case the attribute contains the codec
            // see http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#the-source-element
            // `video/mp4; codecs="avc1.42E01E, mp4a.40.2"` becomes `video/mp4`

            if (type && ~type.indexOf(';')) {
                return type.substr(0, type.indexOf(';'));
            } else {
                return type;
            }
        }
    },

    getTypeFromFile: function(url) {
        url = url.split('?')[0];
        var ext = url.substring(url.lastIndexOf('.') + 1).toLowerCase();
        return (/(mp4|m4v|ogg|ogv|m3u8|webm|webmv|flv|wmv|mpeg|mov)/gi.test(ext) ? 'video' : 'audio') + '/' + this.getTypeFromExtension(ext);
    },

    getTypeFromExtension: function(ext) {

        switch (ext) {
            case 'mp4':
            case 'm4v':
            case 'm4a':
                return 'mp4';
            case 'webm':
            case 'webma':
            case 'webmv':
                return 'webm';
            case 'ogg':
            case 'oga':
            case 'ogv':
                return 'ogg';
            default:
                return ext;
        }
    },

    createErrorMessage: function(playback, options, poster) {
        var
            htmlMediaElement = playback.htmlMediaElement,
            errorContainer = document.createElement('div');

        errorContainer.className = 'me-cannotplay';

        try {
            errorContainer.style.width = htmlMediaElement.width + 'px';
            errorContainer.style.height = htmlMediaElement.height + 'px';
        } catch (e) {}

        if (options.customError) {
            errorContainer.innerHTML = options.customError;
        } else {
            errorContainer.innerHTML = (poster !== '') ?
                '<a href="' + playback.url + '"><img src="' + poster + '" width="100%" height="100%" /></a>' :
                '<a href="' + playback.url + '"><span>' + mejs.i18n.t('Download File') + '</span></a>';
        }

        htmlMediaElement.parentNode.insertBefore(errorContainer, htmlMediaElement);
        htmlMediaElement.style.display = 'none';

        options.error(htmlMediaElement);
    },

    createPlugin: function(playback, options, poster, autoplay, preload, controls) {
        var
            htmlMediaElement = playback.htmlMediaElement,
            width = 1,
            height = 1,
            pluginid = 'me_' + playback.method + '_' + (mejs.meIndex++),
            pluginMediaElement = new mejs.PluginMediaElement(pluginid, playback.method, playback.url),
            container = document.createElement('div'),
            specialIEContainer,
            node,
            initVars;

        // copy tagName from html media element
        pluginMediaElement.tagName = htmlMediaElement.tagName

        // copy attributes from html media element to plugin media element
        for (var i = 0; i < htmlMediaElement.attributes.length; i++) {
            var attribute = htmlMediaElement.attributes[i];
            if (attribute.specified == true) {
                pluginMediaElement.setAttribute(attribute.name, attribute.value);
            }
        }

        // check for placement inside a <p> tag (sometimes WYSIWYG editors do this)
        node = htmlMediaElement.parentNode;
        while (node !== null && node.tagName.toLowerCase() !== 'body' && node.parentNode != null) {
            if (node.parentNode.tagName.toLowerCase() === 'p') {
                node.parentNode.parentNode.insertBefore(node, node.parentNode);
                break;
            }
            node = node.parentNode;
        }

        if (playback.isVideo) {
            width = (options.pluginWidth > 0) ? options.pluginWidth : (options.videoWidth > 0) ? options.videoWidth : (htmlMediaElement.getAttribute('width') !== null) ? htmlMediaElement.getAttribute('width') : options.defaultVideoWidth;
            height = (options.pluginHeight > 0) ? options.pluginHeight : (options.videoHeight > 0) ? options.videoHeight : (htmlMediaElement.getAttribute('height') !== null) ? htmlMediaElement.getAttribute('height') : options.defaultVideoHeight;


            // in case of '%' make sure it's encoded
            widthEncoded = mejs.Utility.encodeUrl(width);
            heightEncoded = mejs.Utility.encodeUrl(height);

        } else {
            if (options.enablePluginDebug) {
                width = 320;
                height = 240;
            }
        }

        // register plugin
        pluginMediaElement.success = options.success;
        mejs.MediaPluginBridge.registerPluginElement(pluginid, pluginMediaElement, htmlMediaElement);

        // add container (must be added to DOM before inserting HTML for IE)
        container.className = 'me-plugin';
        container.id = pluginid + '_container';

        if (playback.isVideo) {
            htmlMediaElement.parentNode.insertBefore(container, htmlMediaElement);
        } else {
            document.body.insertBefore(container, document.body.childNodes[0]);
        }

        // flash/silverlight vars
        initVars = [
            'id=' + pluginid,
            'isvideo=' + ((playback.isVideo) ? "true" : "false"),
            'autoplay=' + ((autoplay) ? "true" : "false"),
            'preload=' + preload,
            'width=' + widthEncoded,
            'startvolume=' + options.startVolume,
            'timerrate=' + options.timerRate,
            'flashstreamer=' + options.flashStreamer,
            'height=' + heightEncoded,
            'pseudostreamstart=' + options.pseudoStreamingStartQueryParam
        ];

        if (playback.url !== null) {
            if (playback.method == 'flash') {
                initVars.push('file=' + mejs.Utility.encodeUrl(playback.url));
            } else {
                initVars.push('file=' + playback.url);
            }
        }
        if (options.enablePluginDebug) {
            initVars.push('debug=true');
        }
        if (options.enablePluginSmoothing) {
            initVars.push('smoothing=true');
        }
        if (options.enablePseudoStreaming) {
            initVars.push('pseudostreaming=true');
        }
        if (controls) {
            initVars.push('controls=true'); // shows controls in the plugin if desired
        }
        if (options.pluginVars) {
            initVars = initVars.concat(options.pluginVars);
        }

        switch (playback.method) {
            case 'silverlight':
                container.innerHTML =
                    '<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" id="' + pluginid + '" name="' + pluginid + '" width="' + width + '" height="' + height + '" class="mejs-shim">' +
                    '<param name="initParams" value="' + initVars.join(',') + '" />' +
                    '<param name="windowless" value="true" />' +
                    '<param name="background" value="black" />' +
                    '<param name="minRuntimeVersion" value="3.0.0.0" />' +
                    '<param name="autoUpgrade" value="true" />' +
                    '<param name="source" value="' + options.pluginPath + options.silverlightName + '" />' +
                    '</object>';
                break;

            case 'flash':

                if (mejs.MediaFeatures.isIE) {
                    specialIEContainer = document.createElement('div');
                    container.appendChild(specialIEContainer);
                    specialIEContainer.outerHTML =
                        '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" ' +
                        'id="' + pluginid + '" width="' + width + '" height="' + height + '" class="mejs-shim">' +
                        '<param name="movie" value="' + options.pluginPath + options.flashName + '?x=' + (new Date()) + '" />' +
                        '<param name="flashvars" value="' + initVars.join('&amp;') + '" />' +
                        '<param name="quality" value="high" />' +
                        '<param name="bgcolor" value="#000000" />' +
                        '<param name="wmode" value="transparent" />' +
                        '<param name="allowScriptAccess" value="always" />' +
                        '<param name="allowFullScreen" value="true" />' +
                        '<param name="scale" value="default" />' +
                        '</object>';

                } else {

                    container.innerHTML =
                        '<embed id="' + pluginid + '" name="' + pluginid + '" ' +
                        'play="true" ' +
                        'loop="false" ' +
                        'quality="high" ' +
                        'bgcolor="#000000" ' +
                        'wmode="transparent" ' +
                        'allowScriptAccess="always" ' +
                        'allowFullScreen="true" ' +
                        'type="application/x-shockwave-flash" pluginspage="//www.macromedia.com/go/getflashplayer" ' +
                        'src="' + options.pluginPath + options.flashName + '" ' +
                        'flashvars="' + initVars.join('&') + '" ' +
                        'width="' + width + '" ' +
                        'height="' + height + '" ' +
                        'scale="default"' +
                        'class="mejs-shim"></embed>';
                }
                break;

            case 'youtube':


                var videoId;
                // youtu.be url from share button
                if (playback.url.lastIndexOf("youtu.be") != -1) {
                    videoId = playback.url.substr(playback.url.lastIndexOf('/') + 1);
                    if (videoId.indexOf('?') != -1) {
                        videoId = videoId.substr(0, videoId.indexOf('?'));
                    }
                } else {
                    videoId = playback.url.substr(playback.url.lastIndexOf('=') + 1);
                }
                youtubeSettings = {
                    container: container,
                    containerId: container.id,
                    pluginMediaElement: pluginMediaElement,
                    pluginId: pluginid,
                    videoId: videoId,
                    height: height,
                    width: width
                };

                if (mejs.PluginDetector.hasPluginVersion('flash', [10, 0, 0])) {
                    mejs.YouTubeApi.createFlash(youtubeSettings);
                } else {
                    mejs.YouTubeApi.enqueueIframe(youtubeSettings);
                }

                break;

                // DEMO Code. Does NOT work.
            case 'vimeo':
                var player_id = pluginid + "_player";
                pluginMediaElement.vimeoid = playback.url.substr(playback.url.lastIndexOf('/') + 1);

                container.innerHTML = '<iframe src="//player.vimeo.com/video/' + pluginMediaElement.vimeoid + '?api=1&portrait=0&byline=0&title=0&player_id=' + player_id + '" width="' + width + '" height="' + height + '" frameborder="0" class="mejs-shim" id="' + player_id + '" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
                if (typeof($f) == 'function') { // froogaloop available
                    var player = $f(container.childNodes[0]);
                    player.addEvent('ready', function() {
                        $.extend(player, {
                            playVideo: function() {
                                player.api('play');
                            },
                            stopVideo: function() {
                                player.api('unload');
                            },
                            pauseVideo: function() {
                                player.api('pause');
                            },
                            seekTo: function(seconds) {
                                player.api('seekTo', seconds);
                            },
                            setVolume: function(volume) {
                                player.api('setVolume', volume);
                            },
                            setMuted: function(muted) {
                                if (muted) {
                                    player.lastVolume = player.api('getVolume');
                                    player.api('setVolume', 0);
                                } else {
                                    player.api('setVolume', player.lastVolume);
                                    delete player.lastVolume;
                                }
                            }
                        });

                        function createEvent(player, pluginMediaElement, eventName, e) {
                            var obj = {
                                type: eventName,
                                target: pluginMediaElement
                            };
                            if (eventName == 'timeupdate') {
                                pluginMediaElement.currentTime = obj.currentTime = e.seconds;
                                pluginMediaElement.duration = obj.duration = e.duration;
                            }
                            pluginMediaElement.dispatchEvent(obj.type, obj);
                        }

                        player.addEvent('play', function() {
                            createEvent(player, pluginMediaElement, 'play');
                            createEvent(player, pluginMediaElement, 'playing');
                        });

                        player.addEvent('pause', function() {
                            createEvent(player, pluginMediaElement, 'pause');
                        });

                        player.addEvent('finish', function() {
                            createEvent(player, pluginMediaElement, 'ended');
                        });

                        player.addEvent('playProgress', function(e) {
                            createEvent(player, pluginMediaElement, 'timeupdate', e);
                        });

                        pluginMediaElement.pluginElement = container;
                        pluginMediaElement.pluginApi = player;

                        // init mejs
                        mejs.MediaPluginBridge.initPlugin(pluginid);
                    });
                } else {
                    console.warn("You need to include froogaloop for vimeo to work");
                }
                break;
        }
        // hide original element
        htmlMediaElement.style.display = 'none';
        // prevent browser from autoplaying when using a plugin
        htmlMediaElement.removeAttribute('autoplay');

        // FYI: options.success will be fired by the MediaPluginBridge

        return pluginMediaElement;
    },

    updateNative: function(playback, options, autoplay, preload) {

        var htmlMediaElement = playback.htmlMediaElement,
            m;


        // add methods to video object to bring it into parity with Flash Object
        for (m in mejs.HtmlMediaElement) {
            htmlMediaElement[m] = mejs.HtmlMediaElement[m];
        }

        /*
        Chrome now supports preload="none"
        if (mejs.MediaFeatures.isChrome) {

          // special case to enforce preload attribute (Chrome doesn't respect this)
          if (preload === 'none' && !autoplay) {

            // forces the browser to stop loading (note: fails in IE9)
            htmlMediaElement.src = '';
            htmlMediaElement.load();
            htmlMediaElement.canceledPreload = true;

            htmlMediaElement.addEventListener('play',function() {
              if (htmlMediaElement.canceledPreload) {
                htmlMediaElement.src = playback.url;
                htmlMediaElement.load();
                htmlMediaElement.play();
                htmlMediaElement.canceledPreload = false;
              }
            }, false);
          // for some reason Chrome forgets how to autoplay sometimes.
          } else if (autoplay) {
            htmlMediaElement.load();
            htmlMediaElement.play();
          }
        }
        */

        // fire success code
        options.success(htmlMediaElement, htmlMediaElement);

        return htmlMediaElement;
    }
};

/*
 - test on IE (object vs. embed)
 - determine when to use iframe (Firefox, Safari, Mobile) vs. Flash (Chrome, IE)
 - fullscreen?
*/

// YouTube Flash and Iframe API
mejs.YouTubeApi = {
        isIframeStarted: false,
        isIframeLoaded: false,
        loadIframeApi: function() {
            if (!this.isIframeStarted) {
                var tag = document.createElement('script');
                tag.src = "//www.youtube.com/player_api";
                var firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
                this.isIframeStarted = true;
            }
        },
        iframeQueue: [],
        enqueueIframe: function(yt) {

            if (this.isLoaded) {
                this.createIframe(yt);
            } else {
                this.loadIframeApi();
                this.iframeQueue.push(yt);
            }
        },
        createIframe: function(settings) {

            var
                pluginMediaElement = settings.pluginMediaElement,
                player = new YT.Player(settings.containerId, {
                    height: settings.height,
                    width: settings.width,
                    videoId: settings.videoId,
                    playerVars: {
                        controls: 0
                    },
                    events: {
                        'onReady': function() {

                            // hook up iframe object to MEjs
                            settings.pluginMediaElement.pluginApi = player;

                            // init mejs
                            mejs.MediaPluginBridge.initPlugin(settings.pluginId);

                            // create timer
                            setInterval(function() {
                                mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'timeupdate');
                            }, 250);
                        },
                        'onStateChange': function(e) {

                            mejs.YouTubeApi.handleStateChange(e.data, player, pluginMediaElement);

                        }
                    }
                });
        },

        createEvent: function(player, pluginMediaElement, eventName) {
            var obj = {
                type: eventName,
                target: pluginMediaElement
            };

            if (player && player.getDuration) {

                // time
                pluginMediaElement.currentTime = obj.currentTime = player.getCurrentTime();
                pluginMediaElement.duration = obj.duration = player.getDuration();

                // state
                obj.paused = pluginMediaElement.paused;
                obj.ended = pluginMediaElement.ended;

                // sound
                obj.muted = player.isMuted();
                obj.volume = player.getVolume() / 100;

                // progress
                obj.bytesTotal = player.getVideoBytesTotal();
                obj.bufferedBytes = player.getVideoBytesLoaded();

                // fake the W3C buffered TimeRange
                var bufferedTime = obj.bufferedBytes / obj.bytesTotal * obj.duration;

                obj.target.buffered = obj.buffered = {
                    start: function(index) {
                        return 0;
                    },
                    end: function(index) {
                        return bufferedTime;
                    },
                    length: 1
                };

            }

            // send event up the chain
            pluginMediaElement.dispatchEvent(obj.type, obj);
        },

        iFrameReady: function() {

            this.isLoaded = true;
            this.isIframeLoaded = true;

            while (this.iframeQueue.length > 0) {
                var settings = this.iframeQueue.pop();
                this.createIframe(settings);
            }
        },

        // FLASH!
        flashPlayers: {},
        createFlash: function(settings) {

            this.flashPlayers[settings.pluginId] = settings;

            /*
            settings.container.innerHTML =
              '<object type="application/x-shockwave-flash" id="' + settings.pluginId + '" data="//www.youtube.com/apiplayer?enablejsapi=1&amp;playerapiid=' + settings.pluginId  + '&amp;version=3&amp;autoplay=0&amp;controls=0&amp;modestbranding=1&loop=0" ' +
                'width="' + settings.width + '" height="' + settings.height + '" style="visibility: visible; " class="mejs-shim">' +
                '<param name="allowScriptAccess" value="always">' +
                '<param name="wmode" value="transparent">' +
              '</object>';
            */

            var specialIEContainer,
                youtubeUrl = '//www.youtube.com/apiplayer?enablejsapi=1&amp;playerapiid=' + settings.pluginId + '&amp;version=3&amp;autoplay=0&amp;controls=0&amp;modestbranding=1&loop=0';

            if (mejs.MediaFeatures.isIE) {

                specialIEContainer = document.createElement('div');
                settings.container.appendChild(specialIEContainer);
                specialIEContainer.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" ' +
                    'id="' + settings.pluginId + '" width="' + settings.width + '" height="' + settings.height + '" class="mejs-shim">' +
                    '<param name="movie" value="' + youtubeUrl + '" />' +
                    '<param name="wmode" value="transparent" />' +
                    '<param name="allowScriptAccess" value="always" />' +
                    '<param name="allowFullScreen" value="true" />' +
                    '</object>';
            } else {
                settings.container.innerHTML =
                    '<object type="application/x-shockwave-flash" id="' + settings.pluginId + '" data="' + youtubeUrl + '" ' +
                    'width="' + settings.width + '" height="' + settings.height + '" style="visibility: visible; " class="mejs-shim">' +
                    '<param name="allowScriptAccess" value="always">' +
                    '<param name="wmode" value="transparent">' +
                    '</object>';
            }

        },

        flashReady: function(id) {
            var
                settings = this.flashPlayers[id],
                player = document.getElementById(id),
                pluginMediaElement = settings.pluginMediaElement;

            // hook up and return to MediaELementPlayer.success
            pluginMediaElement.pluginApi =
                pluginMediaElement.pluginElement = player;
            mejs.MediaPluginBridge.initPlugin(id);

            // load the youtube video
            player.cueVideoById(settings.videoId);

            var callbackName = settings.containerId + '_callback';

            window[callbackName] = function(e) {
                mejs.YouTubeApi.handleStateChange(e, player, pluginMediaElement);
            }

            player.addEventListener('onStateChange', callbackName);

            setInterval(function() {
                mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'timeupdate');
            }, 250);

            mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'canplay');
        },

        handleStateChange: function(youTubeState, player, pluginMediaElement) {
            switch (youTubeState) {
                case -1: // not started
                    pluginMediaElement.paused = true;
                    pluginMediaElement.ended = true;
                    mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'loadedmetadata');
                    //createYouTubeEvent(player, pluginMediaElement, 'loadeddata');
                    break;
                case 0:
                    pluginMediaElement.paused = false;
                    pluginMediaElement.ended = true;
                    mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'ended');
                    break;
                case 1:
                    pluginMediaElement.paused = false;
                    pluginMediaElement.ended = false;
                    mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'play');
                    mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'playing');
                    break;
                case 2:
                    pluginMediaElement.paused = true;
                    pluginMediaElement.ended = false;
                    mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'pause');
                    break;
                case 3: // buffering
                    mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'progress');
                    break;
                case 5:
                    // cued?
                    break;

            }

        }
    }
    // IFRAME
function onYouTubePlayerAPIReady() {
    mejs.YouTubeApi.iFrameReady();
}
// FLASH
function onYouTubePlayerReady(id) {
    mejs.YouTubeApi.flashReady(id);
}

window.mejs = mejs;
window.MediaElement = mejs.MediaElement;

/*!
 * Adds Internationalization and localization to mediaelement.
 *
 * This file does not contain translations, you have to add the manually.
 * The schema is always the same: me-i18n-locale-[ISO_639-1 Code].js
 *
 * Examples are provided both for german and chinese translation.
 *
 *
 * What is the concept beyond i18n?
 *   http://en.wikipedia.org/wiki/Internationalization_and_localization
 *
 * What langcode should i use?
 *   http://en.wikipedia.org/wiki/ISO_639-1
 *
 *
 * License?
 *
 *   The i18n file uses methods from the Drupal project (drupal.js):
 *     - i18n.methods.t() (modified)
 *     - i18n.methods.checkPlain() (full copy)
 *
 *   The Drupal project is (like mediaelementjs) licensed under GPLv2.
 *    - http://drupal.org/licensing/faq/#q1
 *    - https://github.com/johndyer/mediaelement
 *    - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 *
 *
 * @author
 *   Tim Latz (latz.tim@gmail.com)
 *
 *
 * @params
 *  - context - document, iframe ..
 *  - exports - CommonJS, window ..
 *
 */
;
(function(context, exports, undefined) {
    "use strict";
    var i18n = {
        "locale": {
            "language": '',
            "strings": {}
        },
        "methods": {}
    };
    // start i18n


    /**
     * Get language, fallback to browser's language if empty
     */
    i18n.getLanguage = function() {
        var language = i18n.locale.language || window.navigator.userLanguage || window.navigator.language;
        // convert to iso 639-1 (2-letters, lower case)
        return language.substr(0, 2).toLowerCase();
    };

    // i18n fixes for compatibility with WordPress
    if (typeof mejsL10n != 'undefined') {
        i18n.locale.language = mejsL10n.language;
    }



    /**
     * Encode special characters in a plain-text string for display as HTML.
     */
    i18n.methods.checkPlain = function(str) {
        var character, regex,
            replace = {
                '&': '&amp;',
                '"': '&quot;',
                '<': '&lt;',
                '>': '&gt;'
            };
        str = String(str);
        for (character in replace) {
            if (replace.hasOwnProperty(character)) {
                regex = new RegExp(character, 'g');
                str = str.replace(regex, replace[character]);
            }
        }
        return str;
    };

    /**
     * Translate strings to the page language or a given language.
     *
     *
     * @param str
     *   A string containing the English string to translate.
     *
     * @param options
     *   - 'context' (defaults to the default context): The context the source string
     *     belongs to.
     *
     * @return
     *   The translated string, escaped via i18n.methods.checkPlain()
     */
    i18n.methods.t = function(str, options) {

        // Fetch the localized version of the string.
        if (i18n.locale.strings && i18n.locale.strings[options.context] && i18n.locale.strings[options.context][str]) {
            str = i18n.locale.strings[options.context][str];
        }

        return i18n.methods.checkPlain(str);
    };


    /**
     * Wrapper for i18n.methods.t()
     *
     * @see i18n.methods.t()
     * @throws InvalidArgumentException
     */
    i18n.t = function(str, options) {

        if (typeof str === 'string' && str.length > 0) {

            // check every time due language can change for
            // different reasons (translation, lang switcher ..)
            var language = i18n.getLanguage();

            options = options || {
                "context": language
            };

            return i18n.methods.t(str, options);
        } else {
            throw {
                "name": 'InvalidArgumentException',
                "message": 'First argument is either not a string or empty.'
            };
        }
    };

    // end i18n
    exports.i18n = i18n;
}(document, mejs));

// i18n fixes for compatibility with WordPress
;
(function(exports, undefined) {

    "use strict";

    if (typeof mejsL10n != 'undefined') {
        exports[mejsL10n.language] = mejsL10n.strings;
    }

}(mejs.i18n.locale.strings));

/*!
 * This is a i18n.locale language object.
 *
 * German translation by Tim Latz, latz.tim@gmail.com
 *
 * @author
 *   Tim Latz (latz.tim@gmail.com)
 *
 * @see
 *   me-i18n.js
 *
 * @params
 *  - exports - CommonJS, window ..
 */
;
(function(exports, undefined) {

    "use strict";

    if (typeof exports.de === 'undefined') {
        exports.de = {
            "Fullscreen": "Vollbild",
            "Go Fullscreen": "Vollbild an",
            "Turn off Fullscreen": "Vollbild aus",
            "Close": "Schließen"
        };
    }

}(mejs.i18n.locale.strings));
/*!
 * This is a i18n.locale language object.
 *
 * Traditional chinese translation by Tim Latz, latz.tim@gmail.com
 *
 * @author
 *   Tim Latz (latz.tim@gmail.com)
 *
 * @see
 *   me-i18n.js
 *
 * @params
 *  - exports - CommonJS, window ..
 */
;
(function(exports, undefined) {

    "use strict";

    if (typeof exports.zh === 'undefined') {
        exports.zh = {
            "Fullscreen": "全螢幕",
            "Go Fullscreen": "全屏模式",
            "Turn off Fullscreen": "退出全屏模式",
            "Close": "關閉"
        };
    }

}(mejs.i18n.locale.strings));


/*!
 * MediaElementPlayer
 * http://mediaelementjs.com/
 *
 * Creates a controller bar for HTML5 <video> add <audio> tags
 * using jQuery and MediaElement.js (HTML5 Flash/Silverlight wrapper)
 *
 * Copyright 2010-2013, John Dyer (http://j.hn/)
 * License: MIT
 *
 */
if (typeof jQuery != 'undefined') {
    mejs.$ = jQuery;
} else if (typeof ender != 'undefined') {
    mejs.$ = ender;
}
(function($) {

    // default player values
    mejs.MepDefaults = {
        // url to poster (to fix iOS 3.x)
        poster: '',
        // When the video is ended, we can show the poster.
        showPosterWhenEnded: false,
        // default if the <video width> is not specified
        defaultVideoWidth: 480,
        // default if the <video height> is not specified
        defaultVideoHeight: 270,
        // if set, overrides <video width>
        videoWidth: -1,
        // if set, overrides <video height>
        videoHeight: -1,
        // default if the user doesn't specify
        defaultAudioWidth: 400,
        // default if the user doesn't specify
        defaultAudioHeight: 30,

        // default amount to move back when back key is pressed
        defaultSeekBackwardInterval: function(media) {
            return (media.duration * 0.05);
        },
        // default amount to move forward when forward key is pressed
        defaultSeekForwardInterval: function(media) {
            return (media.duration * 0.05);
        },

        // set dimensions via JS instead of CSS
        setDimensions: true,

        // width of audio player
        audioWidth: -1,
        // height of audio player
        audioHeight: -1,
        // initial volume when the player starts (overrided by user cookie)
        startVolume: 0.8,
        // useful for <audio> player loops
        loop: false,
        // rewind to beginning when media ends
        autoRewind: true,
        // resize to media dimensions
        enableAutosize: true,
        // forces the hour marker (##:00:00)
        alwaysShowHours: false,

        // show framecount in timecode (##:00:00:00)
        showTimecodeFrameCount: false,
        // used when showTimecodeFrameCount is set to true
        framesPerSecond: 25,

        // automatically calculate the width of the progress bar based on the sizes of other elements
        autosizeProgress: true,
        // Hide controls when playing and mouse is not over the video
        alwaysShowControls: false,
        // Display the video control
        hideVideoControlsOnLoad: false,
        // Enable click video element to toggle play/pause
        clickToPlayPause: true,
        // force iPad's native controls
        iPadUseNativeControls: false,
        // force iPhone's native controls
        iPhoneUseNativeControls: false,
        // force Android's native controls
        AndroidUseNativeControls: false,
        // features to show
        features: ['playpause', 'current', 'progress', 'duration', 'tracks', 'volume', 'fullscreen'],
        // only for dynamic
        isVideo: true,

        // turns keyboard support on and off for this instance
        enableKeyboard: true,

        // whenthis player starts, it will pause other players
        pauseOtherPlayers: true,

        // array of keyboard actions such as play pause
        keyActions: [{
            keys: [
                32, // SPACE
                179 // GOOGLE play/pause button
            ],
            action: function(player, media) {
                if (media.paused || media.ended) {
                    player.play();
                } else {
                    player.pause();
                }
            }
        }, {
            keys: [38], // UP
            action: function(player, media) {
                player.container.find('.mejs-volume-slider').css('display', 'block');
                if (player.isVideo) {
                    player.showControls();
                    player.startControlsTimer();
                }

                var newVolume = Math.min(media.volume + 0.1, 1);
                media.setVolume(newVolume);
            }
        }, {
            keys: [40], // DOWN
            action: function(player, media) {
                player.container.find('.mejs-volume-slider').css('display', 'block');
                if (player.isVideo) {
                    player.showControls();
                    player.startControlsTimer();
                }

                var newVolume = Math.max(media.volume - 0.1, 0);
                media.setVolume(newVolume);
            }
        }, {
            keys: [
                37, // LEFT
                227 // Google TV rewind
            ],
            action: function(player, media) {
                if (!isNaN(media.duration) && media.duration > 0) {
                    if (player.isVideo) {
                        player.showControls();
                        player.startControlsTimer();
                    }

                    // 5%
                    var newTime = Math.max(media.currentTime - player.options.defaultSeekBackwardInterval(media), 0);
                    media.setCurrentTime(newTime);
                }
            }
        }, {
            keys: [
                39, // RIGHT
                228 // Google TV forward
            ],
            action: function(player, media) {
                if (!isNaN(media.duration) && media.duration > 0) {
                    if (player.isVideo) {
                        player.showControls();
                        player.startControlsTimer();
                    }

                    // 5%
                    var newTime = Math.min(media.currentTime + player.options.defaultSeekForwardInterval(media), media.duration);
                    media.setCurrentTime(newTime);
                }
            }
        }, {
            keys: [70], // F
            action: function(player, media) {
                if (typeof player.enterFullScreen != 'undefined') {
                    if (player.isFullScreen) {
                        player.exitFullScreen();
                    } else {
                        player.enterFullScreen();
                    }
                }
            }
        }, {
            keys: [77], // M
            action: function(player, media) {
                player.container.find('.mejs-volume-slider').css('display', 'block');
                if (player.isVideo) {
                    player.showControls();
                    player.startControlsTimer();
                }
                if (player.media.muted) {
                    player.setMuted(false);
                } else {
                    player.setMuted(true);
                }
            }
        }]
    };

    mejs.mepIndex = 0;

    mejs.players = {};

    // wraps a MediaElement object in player controls
    mejs.MediaElementPlayer = function(node, o) {
        // enforce object, even without "new" (via John Resig)
        if (!(this instanceof mejs.MediaElementPlayer)) {
            return new mejs.MediaElementPlayer(node, o);
        }

        var t = this;

        // these will be reset after the MediaElement.success fires
        t.$media = t.$node = $(node);
        t.node = t.media = t.$media[0];

        // check for existing player
        if (typeof t.node.player != 'undefined') {
            return t.node.player;
        } else {
            // attach player to DOM node for reference
            t.node.player = t;
        }


        // try to get options from data-mejsoptions
        if (typeof o == 'undefined') {
            o = t.$node.data('mejsoptions');
        }

        // extend default options
        t.options = $.extend({}, mejs.MepDefaults, o);

        // unique ID
        t.id = 'mep_' + mejs.mepIndex++;

        // add to player array (for focus events)
        mejs.players[t.id] = t;

        // start up
        t.init();

        return t;
    };

    // actual player
    mejs.MediaElementPlayer.prototype = {

        hasFocus: false,

        controlsAreVisible: true,

        init: function() {

            var
                t = this,
                mf = mejs.MediaFeatures,
                // options for MediaElement (shim)
                meOptions = $.extend(true, {}, t.options, {
                    success: function(media, domNode) {
                        t.meReady(media, domNode);
                    },
                    error: function(e) {
                        t.handleError(e);
                    }
                }),
                tagName = t.media.tagName.toLowerCase();

            t.isDynamic = (tagName !== 'audio' && tagName !== 'video');

            if (t.isDynamic) {
                // get video from src or href?
                t.isVideo = t.options.isVideo;
            } else {
                t.isVideo = (tagName !== 'audio' && t.options.isVideo);
            }

            // use native controls in iPad, iPhone, and Android
            if ((mf.isiPad && t.options.iPadUseNativeControls) || (mf.isiPhone && t.options.iPhoneUseNativeControls)) {

                // add controls and stop
                t.$media.attr('controls', 'controls');

                // attempt to fix iOS 3 bug
                //t.$media.removeAttr('poster');
                // no Issue found on iOS3 -ttroxell

                // override Apple's autoplay override for iPads
                if (mf.isiPad && t.media.getAttribute('autoplay') !== null) {
                    t.play();
                }

            } else if (mf.isAndroid && t.options.AndroidUseNativeControls) {

                // leave default player

            } else {

                // DESKTOP: use MediaElementPlayer controls

                // remove native controls
                t.$media.removeAttr('controls');

                // build container
                t.container =
                    $('<div id="' + t.id + '" class="mejs-container ' + (mejs.MediaFeatures.svg ? 'svg' : 'no-svg') + '">' +
                        '<div class="mejs-inner">' +
                        '<div class="mejs-mediaelement"></div>' +
                        '<div class="mejs-layers"></div>' +
                        '<div class="mejs-controls"></div>' +
                        '<div class="mejs-clear"></div>' +
                        '</div>' +
                        '</div>')
                    .addClass(t.$media[0].className)
                    .insertBefore(t.$media);

                // add classes for user and content
                t.container.addClass(
                    (mf.isAndroid ? 'mejs-android ' : '') +
                    (mf.isiOS ? 'mejs-ios ' : '') +
                    (mf.isiPad ? 'mejs-ipad ' : '') +
                    (mf.isiPhone ? 'mejs-iphone ' : '') +
                    (t.isVideo ? 'mejs-video ' : 'mejs-audio ')
                );


                // move the <video/video> tag into the right spot
                if (mf.isiOS) {

                    // sadly, you can't move nodes in iOS, so we have to destroy and recreate it!
                    var $newMedia = t.$media.clone();

                    t.container.find('.mejs-mediaelement').append($newMedia);

                    t.$media.remove();
                    t.$node = t.$media = $newMedia;
                    t.node = t.media = $newMedia[0]

                } else {

                    // normal way of moving it into place (doesn't work on iOS)
                    t.container.find('.mejs-mediaelement').append(t.$media);
                }

                // find parts
                t.controls = t.container.find('.mejs-controls');
                t.layers = t.container.find('.mejs-layers');

                // determine the size

                /* size priority:
                  (1) videoWidth (forced),
                  (2) style="width;height;"
                  (3) width attribute,
                  (4) defaultVideoWidth (for unspecified cases)
                */

                var tagType = (t.isVideo ? 'video' : 'audio'),
                    capsTagName = tagType.substring(0, 1).toUpperCase() + tagType.substring(1);



                if (t.options[tagType + 'Width'] > 0 || t.options[tagType + 'Width'].toString().indexOf('%') > -1) {
                    t.width = t.options[tagType + 'Width'];
                } else if (t.media.style.width !== '' && t.media.style.width !== null) {
                    t.width = t.media.style.width;
                } else if (t.media.getAttribute('width') !== null) {
                    t.width = t.$media.attr('width');
                } else {
                    t.width = t.options['default' + capsTagName + 'Width'];
                }

                if (t.options[tagType + 'Height'] > 0 || t.options[tagType + 'Height'].toString().indexOf('%') > -1) {
                    t.height = t.options[tagType + 'Height'];
                } else if (t.media.style.height !== '' && t.media.style.height !== null) {
                    t.height = t.media.style.height;
                } else if (t.$media[0].getAttribute('height') !== null) {
                    t.height = t.$media.attr('height');
                } else {
                    t.height = t.options['default' + capsTagName + 'Height'];
                }

                // set the size, while we wait for the plugins to load below
                t.setPlayerSize(t.width, t.height);

                // create MediaElementShim
                meOptions.pluginWidth = t.width;
                meOptions.pluginHeight = t.height;
            }

            // create MediaElement shim
            mejs.MediaElement(t.$media[0], meOptions);

            if (typeof(t.container) != 'undefined' && t.controlsAreVisible) {
                // controls are shown when loaded
                t.container.trigger('controlsshown');
            }
        },

        showControls: function(doAnimation) {
            var t = this;

            doAnimation = typeof doAnimation == 'undefined' || doAnimation;

            if (t.controlsAreVisible)
                return;

            if (doAnimation) {
                t.controls
                    .css('visibility', 'visible')
                    .stop(true, true).fadeIn(200, function() {
                        t.controlsAreVisible = true;
                        t.container.trigger('controlsshown');
                    });

                // any additional controls people might add and want to hide
                t.container.find('.mejs-control')
                    .css('visibility', 'visible')
                    .stop(true, true).fadeIn(200, function() {
                        t.controlsAreVisible = true;
                    });

            } else {
                t.controls
                    .css('visibility', 'visible')
                    .css('display', 'block');

                // any additional controls people might add and want to hide
                t.container.find('.mejs-control')
                    .css('visibility', 'visible')
                    .css('display', 'block');

                t.controlsAreVisible = true;
                t.container.trigger('controlsshown');
            }

            t.setControlsSize();

        },

        hideControls: function(doAnimation) {
            var t = this;

            doAnimation = typeof doAnimation == 'undefined' || doAnimation;

            if (!t.controlsAreVisible || t.options.alwaysShowControls)
                return;

            if (doAnimation) {
                // fade out main controls
                t.controls.stop(true, true).fadeOut(200, function() {
                    $(this)
                        .css('visibility', 'hidden')
                        .css('display', 'block');

                    t.controlsAreVisible = false;
                    t.container.trigger('controlshidden');
                });

                // any additional controls people might add and want to hide
                t.container.find('.mejs-control').stop(true, true).fadeOut(200, function() {
                    $(this)
                        .css('visibility', 'hidden')
                        .css('display', 'block');
                });
            } else {

                // hide main controls
                t.controls
                    .css('visibility', 'hidden')
                    .css('display', 'block');

                // hide others
                t.container.find('.mejs-control')
                    .css('visibility', 'hidden')
                    .css('display', 'block');

                t.controlsAreVisible = false;
                t.container.trigger('controlshidden');
            }
        },

        controlsTimer: null,

        startControlsTimer: function(timeout) {

            var t = this;

            timeout = typeof timeout != 'undefined' ? timeout : 1500;

            t.killControlsTimer('start');

            t.controlsTimer = setTimeout(function() {
                //
                t.hideControls();
                t.killControlsTimer('hide');
            }, timeout);
        },

        killControlsTimer: function(src) {

            var t = this;

            if (t.controlsTimer !== null) {
                clearTimeout(t.controlsTimer);
                delete t.controlsTimer;
                t.controlsTimer = null;
            }
        },

        controlsEnabled: true,

        disableControls: function() {
            var t = this;

            t.killControlsTimer();
            t.hideControls(false);
            this.controlsEnabled = false;
        },

        enableControls: function() {
            var t = this;

            t.showControls(false);

            t.controlsEnabled = true;
        },


        // Sets up all controls and events
        meReady: function(media, domNode) {


            var t = this,
                mf = mejs.MediaFeatures,
                autoplayAttr = domNode.getAttribute('autoplay'),
                autoplay = !(typeof autoplayAttr == 'undefined' || autoplayAttr === null || autoplayAttr === 'false'),
                featureIndex,
                feature;

            // make sure it can't create itself again if a plugin reloads
            if (t.created) {
                return;
            } else {
                t.created = true;
            }

            t.media = media;
            t.domNode = domNode;

            if (!(mf.isAndroid && t.options.AndroidUseNativeControls) && !(mf.isiPad && t.options.iPadUseNativeControls) && !(mf.isiPhone && t.options.iPhoneUseNativeControls)) {

                // two built in features
                t.buildposter(t, t.controls, t.layers, t.media);
                t.buildkeyboard(t, t.controls, t.layers, t.media);
                t.buildoverlays(t, t.controls, t.layers, t.media);

                // grab for use by features
                t.findTracks();

                // add user-defined features/controls
                for (featureIndex in t.options.features) {
                    feature = t.options.features[featureIndex];
                    if (t['build' + feature]) {
                        try {
                            t['build' + feature](t, t.controls, t.layers, t.media);
                        } catch (e) {
                            // TODO: report control error
                            //throw e;


                        }
                    }
                }

                t.container.trigger('controlsready');

                // reset all layers and controls
                t.setPlayerSize(t.width, t.height);
                t.setControlsSize();


                // controls fade
                if (t.isVideo) {

                    if (mejs.MediaFeatures.hasTouch) {

                        // for touch devices (iOS, Android)
                        // show/hide without animation on touch

                        t.$media.bind('touchstart', function() {


                            // toggle controls
                            if (t.controlsAreVisible) {
                                t.hideControls(false);
                            } else {
                                if (t.controlsEnabled) {
                                    t.showControls(false);
                                }
                            }
                        });

                    } else {

                        // create callback here since it needs access to current
                        // MediaElement object
                        t.clickToPlayPauseCallback = function() {
                            if (t.options.clickToPlayPause) {
                                if (t.media.paused) {
                                    t.play();
                                } else {
                                    t.pause();
                                }
                            }
                        };

                        // click to play/pause
                        t.media.addEventListener('click', t.clickToPlayPauseCallback, false);

                        // show/hide controls
                        t.container
                            .bind('mouseenter mouseover', function() {
                                if (t.controlsEnabled) {
                                    if (!t.options.alwaysShowControls) {
                                        t.killControlsTimer('enter');
                                        t.showControls();
                                        t.startControlsTimer(2500);
                                    }
                                }
                            })
                            .bind('mousemove', function() {
                                if (t.controlsEnabled) {
                                    if (!t.controlsAreVisible) {
                                        t.showControls();
                                    }
                                    if (!t.options.alwaysShowControls) {
                                        t.startControlsTimer(2500);
                                    }
                                }
                            })
                            .bind('mouseleave', function() {
                                if (t.controlsEnabled) {
                                    if (!t.media.paused && !t.options.alwaysShowControls) {
                                        t.startControlsTimer(1000);
                                    }
                                }
                            });
                    }

                    if (t.options.hideVideoControlsOnLoad) {
                        t.hideControls(false);
                    }

                    // check for autoplay
                    if (autoplay && !t.options.alwaysShowControls) {
                        t.hideControls();
                    }

                    // resizer
                    if (t.options.enableAutosize) {
                        t.media.addEventListener('loadedmetadata', function(e) {
                            // if the <video height> was not set and the options.videoHeight was not set
                            // then resize to the real dimensions
                            if (t.options.videoHeight <= 0 && t.domNode.getAttribute('height') === null && !isNaN(e.target.videoHeight)) {
                                t.setPlayerSize(e.target.videoWidth, e.target.videoHeight);
                                t.setControlsSize();
                                t.media.setVideoSize(e.target.videoWidth, e.target.videoHeight);
                            }
                        }, false);
                    }
                }

                // EVENTS

                // FOCUS: when a video starts playing, it takes focus from other players (possibily pausing them)
                media.addEventListener('play', function() {
                    var playerIndex;

                    // go through all other players
                    for (playerIndex in mejs.players) {
                        var p = mejs.players[playerIndex];
                        if (p.id != t.id && t.options.pauseOtherPlayers && !p.paused && !p.ended) {
                            p.pause();
                        }
                        p.hasFocus = false;
                    }

                    t.hasFocus = true;
                }, false);


                // ended for all
                t.media.addEventListener('ended', function(e) {
                    if (t.options.autoRewind) {
                        try {
                            t.media.setCurrentTime(0);
                        } catch (exp) {

                        }
                    }
                    t.media.pause();

                    if (t.setProgressRail) {
                        t.setProgressRail();
                    }
                    if (t.setCurrentRail) {
                        t.setCurrentRail();
                    }

                    if (t.options.loop) {
                        t.play();
                    } else if (!t.options.alwaysShowControls && t.controlsEnabled) {
                        t.showControls();
                    }
                }, false);

                // resize on the first play
                t.media.addEventListener('loadedmetadata', function(e) {
                    if (t.updateDuration) {
                        t.updateDuration();
                    }
                    if (t.updateCurrent) {
                        t.updateCurrent();
                    }

                    if (!t.isFullScreen) {
                        t.setPlayerSize(t.width, t.height);
                        t.setControlsSize();
                    }
                }, false);


                // webkit has trouble doing this without a delay
                setTimeout(function() {
                    t.setPlayerSize(t.width, t.height);
                    t.setControlsSize();
                }, 50);

                // adjust controls whenever window sizes (used to be in fullscreen only)
                t.globalBind('resize', function() {

                    // don't resize for fullscreen mode
                    if (!(t.isFullScreen || (mejs.MediaFeatures.hasTrueNativeFullScreen && document.webkitIsFullScreen))) {
                        t.setPlayerSize(t.width, t.height);
                    }

                    // always adjust controls
                    t.setControlsSize();
                });

                // TEMP: needs to be moved somewhere else
                if (t.media.pluginType == 'youtube' && t.options.autoplay) {
                    //LOK-Soft: added t.options.autoplay to if -- I can only guess this is for hiding play button when autoplaying youtube, general hiding play button layer causes missing button on player load
                    t.container.find('.mejs-overlay-play').hide();
                }
            }

            // force autoplay for HTML5
            if (autoplay && media.pluginType == 'native') {
                t.play();
            }


            if (t.options.success) {

                if (typeof t.options.success == 'string') {
                    window[t.options.success](t.media, t.domNode, t);
                } else {
                    t.options.success(t.media, t.domNode, t);
                }
            }
        },

        handleError: function(e) {
            var t = this;

            t.controls.hide();

            // Tell user that the file cannot be played
            if (t.options.error) {
                t.options.error(e);
            }
        },

        setPlayerSize: function(width, height) {
            var t = this;

            if (!t.options.setDimensions) {
                return false;
            }

            if (typeof width != 'undefined') {
                t.width = width;
            }

            if (typeof height != 'undefined') {
                t.height = height;
            }

            // detect 100% mode - use currentStyle for IE since css() doesn't return percentages
            if (t.height.toString().indexOf('%') > 0 || t.$node.css('max-width') === '100%' || (t.$node[0].currentStyle && t.$node[0].currentStyle.maxWidth === '100%')) {

                // do we have the native dimensions yet?
                var nativeWidth = (function() {
                    if (t.isVideo) {
                        if (t.media.videoWidth && t.media.videoWidth > 0) {
                            return t.media.videoWidth;
                        } else if (t.media.getAttribute('width') !== null) {
                            return t.media.getAttribute('width');
                        } else {
                            return t.options.defaultVideoWidth;
                        }
                    } else {
                        return t.options.defaultAudioWidth;
                    }
                })();

                var nativeHeight = (function() {
                    if (t.isVideo) {
                        if (t.media.videoHeight && t.media.videoHeight > 0) {
                            return t.media.videoHeight;
                        } else if (t.media.getAttribute('height') !== null) {
                            return t.media.getAttribute('height');
                        } else {
                            return t.options.defaultVideoHeight;
                        }
                    } else {
                        return t.options.defaultAudioHeight;
                    }
                })();

                var
                    parentWidth = t.container.parent().closest(':visible').width(),
                    parentHeight = t.container.parent().closest(':visible').height(),
                    newHeight = t.isVideo || !t.options.autosizeProgress ? parseInt(parentWidth * nativeHeight / nativeWidth, 10) : nativeHeight;

                // When we use percent, the newHeight can't be calculated so we get the container height
                if (isNaN(newHeight) || (parentHeight != 0 && newHeight > parentHeight)) {
                    newHeight = parentHeight;
                }

                if (t.container.parent()[0].tagName.toLowerCase() === 'body') { // && t.container.siblings().count == 0) {
                    parentWidth = $(window).width();
                    newHeight = $(window).height();
                }

                if (newHeight != 0 && parentWidth != 0) {
                    // set outer container size
                    t.container
                        .width(parentWidth)
                        .height(newHeight);

                    // set native <video> or <audio> and shims
                    t.$media.add(t.container.find('.mejs-shim'))
                        .width('100%')
                        .height('100%');

                    // if shim is ready, send the size to the embeded plugin
                    if (t.isVideo) {
                        if (t.media.setVideoSize) {
                            t.media.setVideoSize(parentWidth, newHeight);
                        }
                    }

                    // set the layers
                    t.layers.children('.mejs-layer')
                        .width('100%')
                        .height('100%');
                }


            } else {

                t.container
                    .width(t.width)
                    .height(t.height);

                t.layers.children('.mejs-layer')
                    .width(t.width)
                    .height(t.height);

            }

            // special case for big play button so it doesn't go over the controls area
            var playLayer = t.layers.find('.mejs-overlay-play'),
                playButton = playLayer.find('.mejs-overlay-button');

            playLayer.height(t.container.height() - t.controls.height());
            playButton.css('margin-top', '-' + (playButton.height() / 2 - t.controls.height() / 2).toString() + 'px');

        },

        setControlsSize: function() {
            var t = this,
                usedWidth = 0,
                railWidth = 0,
                rail = t.controls.find('.mejs-time-rail'),
                total = t.controls.find('.mejs-time-total'),
                current = t.controls.find('.mejs-time-current'),
                loaded = t.controls.find('.mejs-time-loaded'),
                others = rail.siblings(),
                lastControl = others.last(),
                lastControlPosition = null;

            // skip calculation if hidden
            if (!t.container.is(':visible') || !rail.length || !rail.is(':visible')) {
                return;
            }


            // allow the size to come from custom CSS
            if (t.options && !t.options.autosizeProgress) {
                // Also, frontends devs can be more flexible
                // due the opportunity of absolute positioning.
                railWidth = parseInt(rail.css('width'));
            }

            // attempt to autosize
            if (railWidth === 0 || !railWidth) {

                // find the size of all the other controls besides the rail
                others.each(function() {
                    var $this = $(this);
                    if ($this.css('position') != 'absolute' && $this.is(':visible')) {
                        usedWidth += $(this).outerWidth(true);
                    }
                });

                // fit the rail into the remaining space
                railWidth = t.controls.width() - usedWidth - (rail.outerWidth(true) - rail.width());
            }

            // resize the rail,
            // but then check if the last control (say, the fullscreen button) got pushed down
            // this often happens when zoomed
            do {
                // outer area
                rail.width(railWidth);
                // dark space
                total.width(railWidth - (total.outerWidth(true) - total.width()));

                if (lastControl.css('position') != 'absolute') {
                    lastControlPosition = lastControl.position();
                    railWidth--;
                }
            } while (lastControlPosition != null && lastControlPosition.top > 0 && railWidth > 0);

            if (t.setProgressRail)
                t.setProgressRail();
            if (t.setCurrentRail)
                t.setCurrentRail();
        },


        buildposter: function(player, controls, layers, media) {
            var t = this,
                poster =
                $('<div class="mejs-poster mejs-layer">' +
                    '</div>')
                .appendTo(layers),
                posterUrl = player.$media.attr('poster');

            // prioriy goes to option (this is useful if you need to support iOS 3.x (iOS completely fails with poster)
            if (player.options.poster !== '') {
                posterUrl = player.options.poster;
            }

            // second, try the real poster
            if (posterUrl !== '' && posterUrl != null) {
                t.setPoster(posterUrl);
            } else {
                poster.hide();
            }

            media.addEventListener('play', function() {
                poster.hide();
            }, false);

            if (player.options.showPosterWhenEnded && player.options.autoRewind) {
                media.addEventListener('ended', function() {
                    poster.show();
                }, false);
            }
        },

        setPoster: function(url) {
            var t = this,
                posterDiv = t.container.find('.mejs-poster'),
                posterImg = posterDiv.find('img');

            if (posterImg.length == 0) {
                posterImg = $('<img width="100%" height="100%" />').appendTo(posterDiv);
            }

            posterImg.attr('src', url);
            posterDiv.css({
                'background-image': 'url(' + url + ')'
            });
        },

        buildoverlays: function(player, controls, layers, media) {
            var t = this;
            if (!player.isVideo)
                return;

            var
                loading =
                $('<div class="mejs-overlay mejs-layer">' +
                    '<div class="mejs-overlay-loading"><span></span></div>' +
                    '</div>')
                .hide() // start out hidden
                .appendTo(layers),
                error =
                $('<div class="mejs-overlay mejs-layer">' +
                    '<div class="mejs-overlay-error"></div>' +
                    '</div>')
                .hide() // start out hidden
                .appendTo(layers),
                // this needs to come last so it's on top
                bigPlay =
                $('<div class="mejs-overlay mejs-layer mejs-overlay-play">' +
                    '<div class="mejs-overlay-button-wrapper">' +
                    '<div class="mejs-overlay-button"></div>' +
                    '</div>' +
                    '</div>')
                .appendTo(layers)
                .bind('click', function() { // Removed 'touchstart' due issues on Samsung Android devices where a tap on bigPlay started and immediately stopped the video
                    if (t.options.clickToPlayPause) {
                        if (media.paused) {
                            media.play();
                        } else {
                            media.pause();
                        }
                    }
                });

            /*
            if (mejs.MediaFeatures.isiOS || mejs.MediaFeatures.isAndroid) {
              bigPlay.remove();
              loading.remove();
            }
            */

            var bigPlayButton = $(bigPlay.find('.mejs-overlay-button-wrapper'));

            // show/hide big play button
            media.addEventListener('play', function() {
                bigPlayButton.hide();
                loading.hide();
                controls.find('.mejs-time-buffering').hide();
                error.hide();
            }, false);

            media.addEventListener('playing', function() {
                bigPlayButton.hide();
                loading.hide();
                controls.find('.mejs-time-buffering').hide();
                error.hide();
            }, false);

            media.addEventListener('seeking', function() {
                loading.show();
                controls.find('.mejs-time-buffering').show();
            }, false);

            media.addEventListener('seeked', function() {
                loading.hide();
                controls.find('.mejs-time-buffering').hide();
            }, false);

            media.addEventListener('pause', function() {
                if (!mejs.MediaFeatures.isiPhone) {
                    bigPlayButton.show();
                }
            }, false);

            media.addEventListener('waiting', function() {
                loading.show();
                controls.find('.mejs-time-buffering').show();
            }, false);


            // show/hide loading
            media.addEventListener('loadeddata', function() {
                // for some reason Chrome is firing this event
                //if (mejs.MediaFeatures.isChrome && media.getAttribute && media.getAttribute('preload') === 'none')
                //  return;

                loading.show();
                controls.find('.mejs-time-buffering').show();
            }, false);
            media.addEventListener('canplay', function() {
                loading.hide();
                controls.find('.mejs-time-buffering').hide();
            }, false);

            // error handling
            media.addEventListener('error', function() {
                loading.hide();
                controls.find('.mejs-time-buffering').hide();
                error.show();
                error.find('mejs-overlay-error').html("Error loading this resource");
            }, false);

            media.addEventListener('keydown', function(e) {
                t.onkeydown(player, media, e);
            }, false);
        },

        buildkeyboard: function(player, controls, layers, media) {

            var t = this;

            // listen for key presses
            t.globalBind('keydown', function(e) {
                return t.onkeydown(player, media, e);
            });

            // check if someone clicked outside a player region, then kill its focus
            t.globalBind('click', function(event) {
                player.hasFocus = $(event.target).closest('.mejs-container').length != 0;
            });

        },
        onkeydown: function(player, media, e) {
            if (player.hasFocus && player.options.enableKeyboard) {
                // find a matching key
                for (var i = 0, il = player.options.keyActions.length; i < il; i++) {
                    var keyAction = player.options.keyActions[i];

                    for (var j = 0, jl = keyAction.keys.length; j < jl; j++) {
                        if (e.keyCode == keyAction.keys[j]) {
                            if (typeof(e.preventDefault) == "function") e.preventDefault();
                            keyAction.action(player, media, e.keyCode);
                            return false;
                        }
                    }
                }
            }

            return true;
        },

        findTracks: function() {
            var t = this,
                tracktags = t.$media.find('track');

            // store for use by plugins
            t.tracks = [];
            tracktags.each(function(index, track) {

                track = $(track);

                t.tracks.push({
                    srclang: (track.attr('srclang')) ? track.attr('srclang').toLowerCase() : '',
                    src: track.attr('src'),
                    kind: track.attr('kind'),
                    label: track.attr('label') || '',
                    entries: [],
                    isLoaded: false
                });
            });
        },
        changeSkin: function(className) {
            this.container[0].className = 'mejs-container ' + className;
            this.setPlayerSize(this.width, this.height);
            this.setControlsSize();
        },
        play: function() {
            this.load();
            this.media.play();
        },
        pause: function() {
            try {
                this.media.pause();
            } catch (e) {}
        },
        load: function() {
            if (!this.isLoaded) {
                this.media.load();
            }

            this.isLoaded = true;
        },
        setMuted: function(muted) {
            this.media.setMuted(muted);
        },
        setCurrentTime: function(time) {
            this.media.setCurrentTime(time);
        },
        getCurrentTime: function() {
            return this.media.currentTime;
        },
        setVolume: function(volume) {
            this.media.setVolume(volume);
        },
        getVolume: function() {
            return this.media.volume;
        },
        setSrc: function(src) {
            this.media.setSrc(src);
        },
        remove: function() {
            var t = this,
                featureIndex, feature;

            // invoke features cleanup
            for (featureIndex in t.options.features) {
                feature = t.options.features[featureIndex];
                if (t['clean' + feature]) {
                    try {
                        t['clean' + feature](t);
                    } catch (e) {
                        // TODO: report control error
                        //throw e;
                        //
                        //
                    }
                }
            }

            // grab video and put it back in place
            if (!t.isDynamic) {
                t.$media.prop('controls', true);
                // detach events from the video
                // TODO: detach event listeners better than this;
                //       also detach ONLY the events attached by this plugin!
                t.$node.clone().insertBefore(t.container).show();
                t.$node.remove();
            } else {
                t.$node.insertBefore(t.container);
            }

            if (t.media.pluginType !== 'native') {
                t.media.remove();
            }

            // Remove the player from the mejs.players object so that pauseOtherPlayers doesn't blow up when trying to pause a non existance flash api.
            delete mejs.players[t.id];

            if (typeof t.container == 'object') {
                t.container.remove();
            }
            t.globalUnbind();
            delete t.node.player;
        }
    };

    (function() {
        var rwindow = /^((after|before)print|(before)?unload|hashchange|message|o(ff|n)line|page(hide|show)|popstate|resize|storage)\b/;

        function splitEvents(events, id) {
            // add player ID as an event namespace so it's easier to unbind them all later
            var ret = {
                d: [],
                w: []
            };
            $.each((events || '').split(' '), function(k, v) {
                var eventname = v + '.' + id;
                if (eventname.indexOf('.') === 0) {
                    ret.d.push(eventname);
                    ret.w.push(eventname);
                } else {
                    ret[rwindow.test(v) ? 'w' : 'd'].push(eventname);
                }
            });
            ret.d = ret.d.join(' ');
            ret.w = ret.w.join(' ');
            return ret;
        }

        mejs.MediaElementPlayer.prototype.globalBind = function(events, data, callback) {
            var t = this;
            events = splitEvents(events, t.id);
            if (events.d) $(document).bind(events.d, data, callback);
            if (events.w) $(window).bind(events.w, data, callback);
        };

        mejs.MediaElementPlayer.prototype.globalUnbind = function(events, callback) {
            var t = this;
            events = splitEvents(events, t.id);
            if (events.d) $(document).unbind(events.d, callback);
            if (events.w) $(window).unbind(events.w, callback);
        };
    })();

    // turn into jQuery plugin
    if (typeof $ != 'undefined') {
        $.fn.mediaelementplayer = function(options) {
            if (options === false) {
                this.each(function() {
                    var player = $(this).data('mediaelementplayer');
                    if (player) {
                        player.remove();
                    }
                    $(this).removeData('mediaelementplayer');
                });
            } else {
                this.each(function() {
                    $(this).data('mediaelementplayer', new mejs.MediaElementPlayer(this, options));
                });
            }
            return this;
        };


        $(document).ready(function() {
            // auto enable using JSON attribute
            $('.mejs-player').mediaelementplayer();
        });
    }

    // push out to window
    window.MediaElementPlayer = mejs.MediaElementPlayer;

})(mejs.$);

(function($) {

    $.extend(mejs.MepDefaults, {
        playpauseText: mejs.i18n.t('Play/Pause')
    });

    // PLAY/pause BUTTON
    $.extend(MediaElementPlayer.prototype, {
        buildplaypause: function(player, controls, layers, media) {
            var
                t = this,
                play =
                $('<div class="mejs-button mejs-playpause-button mejs-play" >' +
                    '<button type="button" aria-controls="' + t.id + '" title="' + t.options.playpauseText + '" aria-label="' + t.options.playpauseText + '"></button>' +
                    '</div>')
                .appendTo(controls)
                .click(function(e) {
                    e.preventDefault();

                    if (media.paused) {
                        media.play();
                    } else {
                        media.pause();
                    }

                    return false;
                });

            media.addEventListener('play', function() {
                play.removeClass('mejs-play').addClass('mejs-pause');
            }, false);
            media.addEventListener('playing', function() {
                play.removeClass('mejs-play').addClass('mejs-pause');
            }, false);


            media.addEventListener('pause', function() {
                play.removeClass('mejs-pause').addClass('mejs-play');
            }, false);
            media.addEventListener('paused', function() {
                play.removeClass('mejs-pause').addClass('mejs-play');
            }, false);
        }
    });

})(mejs.$);

(function($) {

    $.extend(mejs.MepDefaults, {
        stopText: 'Stop'
    });

    // STOP BUTTON
    $.extend(MediaElementPlayer.prototype, {
        buildstop: function(player, controls, layers, media) {
            var t = this,
                stop =
                $('<div class="mejs-button mejs-stop-button mejs-stop">' +
                    '<button type="button" aria-controls="' + t.id + '" title="' + t.options.stopText + '" aria-label="' + t.options.stopText + '"></button>' +
                    '</div>')
                .appendTo(controls)
                .click(function() {
                    if (!media.paused) {
                        media.pause();
                    }
                    if (media.currentTime > 0) {
                        media.setCurrentTime(0);
                        media.pause();
                        controls.find('.mejs-time-current').width('0px');
                        controls.find('.mejs-time-handle').css('left', '0px');
                        controls.find('.mejs-time-float-current').html(mejs.Utility.secondsToTimeCode(0));
                        controls.find('.mejs-currenttime').html(mejs.Utility.secondsToTimeCode(0));
                        layers.find('.mejs-poster').show();
                    }
                });
        }
    });

})(mejs.$);

(function($) {
    // progress/loaded bar
    $.extend(MediaElementPlayer.prototype, {
        buildprogress: function(player, controls, layers, media) {

            if (mejs.MediaFeatures.isAndroid || mejs.MediaFeatures.isiOS)
                return;

            $('<div class="mejs-time-rail">' +
                    '<span class="mejs-time-total">' +
                    '<span class="mejs-time-buffering"></span>' +
                    '<span class="mejs-time-loaded"></span>' +
                    '<span class="mejs-time-current"></span>' +
                    '<span class="mejs-time-handle"></span>' +
                    '<span class="mejs-time-float">' +
                    '<span class="mejs-time-float-current">00:00</span>' +
                    '<span class="mejs-time-float-corner"></span>' +
                    '</span>' +
                    '</span>' +
                    '</div>')
                .appendTo(controls);
            controls.find('.mejs-time-buffering').hide();

            var
                t = this,
                total = controls.find('.mejs-time-total'),
                loaded = controls.find('.mejs-time-loaded'),
                current = controls.find('.mejs-time-current'),
                handle = controls.find('.mejs-time-handle'),
                timefloat = controls.find('.mejs-time-float'),
                timefloatcurrent = controls.find('.mejs-time-float-current'),
                handleMouseMove = function(e) {
                    // mouse or touch position relative to the object
                    if (e.originalEvent.changedTouches) {
                        var x = e.originalEvent.changedTouches[0].pageX;
                    } else {
                        var x = e.pageX;
                    }

                    var offset = total.offset(),
                        width = total.outerWidth(true),
                        percentage = 0,
                        newTime = 0,
                        pos = 0;


                    if (media.duration) {
                        if (x < offset.left) {
                            x = offset.left;
                        } else if (x > width + offset.left) {
                            x = width + offset.left;
                        }

                        pos = x - offset.left;
                        percentage = (pos / width);
                        newTime = (percentage <= 0.02) ? 0 : percentage * media.duration;

                        // seek to where the mouse is
                        if (mouseIsDown && newTime !== media.currentTime) {
                            media.setCurrentTime(newTime);
                        }

                        // position floating time box
                        if (!mejs.MediaFeatures.hasTouch) {
                            timefloat.css('left', pos);
                            timefloatcurrent.html(mejs.Utility.secondsToTimeCode(newTime));
                            timefloat.addClass('active');
                        }
                    }
                },
                mouseIsDown = false,
                mouseIsOver = false;

            // handle clicks
            //controls.find('.mejs-time-rail').delegate('span', 'click', handleMouseMove);
            total
                .bind('mousedown touchstart', function(e) {
                    // only handle left clicks or touch
                    if (e.which === 1 || e.which === 0) {
                        mouseIsDown = true;
                        handleMouseMove(e);
                        t.globalBind('mousemove.dur touchmove.dur', function(e) {
                            handleMouseMove(e);
                        });
                        t.globalBind('mouseup.dur touchend.dur', function(e) {
                            mouseIsDown = false;
                            timefloat.removeClass('active');
                            t.globalUnbind('.dur');
                        });
                        return false;
                    }
                })
                .bind('mouseenter', function(e) {
                    mouseIsOver = true;
                    t.globalBind('mousemove.dur', function(e) {
                        handleMouseMove(e);
                    });
                    if (!mejs.MediaFeatures.hasTouch) {
                        timefloat.addClass('active');
                    }
                })
                .bind('mouseleave', function(e) {
                    mouseIsOver = false;
                    if (!mouseIsDown) {
                        t.globalUnbind('.dur');
                        timefloat.removeClass('active');
                    }
                });

            // loading
            media.addEventListener('progress', function(e) {
                player.setProgressRail(e);
                player.setCurrentRail(e);
            }, false);

            // current time
            media.addEventListener('timeupdate', function(e) {
                player.setProgressRail(e);
                player.setCurrentRail(e);
            }, false);


            // store for later use
            t.loaded = loaded;
            t.total = total;
            t.current = current;
            t.handle = handle;
        },
        setProgressRail: function(e) {

            var
                t = this,
                target = (e != undefined) ? e.target : t.media,
                percent = null;

            // newest HTML5 spec has buffered array (FF4, Webkit)
            if (target && target.buffered && target.buffered.length > 0 && target.buffered.end && target.duration) {
                // TODO: account for a real array with multiple values (only Firefox 4 has this so far)
                percent = target.buffered.end(0) / target.duration;
            }
            // Some browsers (e.g., FF3.6 and Safari 5) cannot calculate target.bufferered.end()
            // to be anything other than 0. If the byte count is available we use this instead.
            // Browsers that support the else if do not seem to have the bufferedBytes value and
            // should skip to there. Tested in Safari 5, Webkit head, FF3.6, Chrome 6, IE 7/8.
            else if (target && target.bytesTotal != undefined && target.bytesTotal > 0 && target.bufferedBytes != undefined) {
                percent = target.bufferedBytes / target.bytesTotal;
            }
            // Firefox 3 with an Ogg file seems to go this way
            else if (e && e.lengthComputable && e.total != 0) {
                percent = e.loaded / e.total;
            }

            // finally update the progress bar
            if (percent !== null) {
                percent = Math.min(1, Math.max(0, percent));
                // update loaded bar
                if (t.loaded && t.total) {
                    t.loaded.width(t.total.width() * percent);
                }
            }
        },
        setCurrentRail: function() {

            var t = this;

            if (t.media.currentTime != undefined && t.media.duration) {

                // update bar and handle
                if (t.total && t.handle) {
                    var
                        newWidth = Math.round(t.total.width() * t.media.currentTime / t.media.duration),
                        handlePos = newWidth - Math.round(t.handle.outerWidth(true) / 2);

                    t.current.width(newWidth);
                    t.handle.css('left', handlePos);
                }
            }

        }
    });
})(mejs.$);

(function($) {

    // options
    $.extend(mejs.MepDefaults, {
        duration: -1,
        timeAndDurationSeparator: '<span> | </span>'
    });


    // current and duration 00:00 / 00:00
    $.extend(MediaElementPlayer.prototype, {
        buildcurrent: function(player, controls, layers, media) {
            var t = this;

            $('<div class="mejs-time">' +
                    '<span class="mejs-currenttime">' + (player.options.alwaysShowHours ? '00:' : '') +
                    (player.options.showTimecodeFrameCount ? '00:00:00' : '00:00') + '</span>' +
                    '</div>')
                .appendTo(controls);

            t.currenttime = t.controls.find('.mejs-currenttime');

            media.addEventListener('timeupdate', function() {
                player.updateCurrent();
            }, false);
        },


        buildduration: function(player, controls, layers, media) {
            var t = this;

            if (controls.children().last().find('.mejs-currenttime').length > 0) {
                $(t.options.timeAndDurationSeparator +
                        '<span class="mejs-duration">' +
                        (t.options.duration > 0 ?
                            mejs.Utility.secondsToTimeCode(t.options.duration, t.options.alwaysShowHours || t.media.duration > 3600, t.options.showTimecodeFrameCount, t.options.framesPerSecond || 25) :
                            ((player.options.alwaysShowHours ? '00:' : '') + (player.options.showTimecodeFrameCount ? '00:00:00' : '00:00'))
                        ) +
                        '</span>')
                    .appendTo(controls.find('.mejs-time'));
            } else {

                // add class to current time
                controls.find('.mejs-currenttime').parent().addClass('mejs-currenttime-container');

                $('<div class="mejs-time mejs-duration-container">' +
                        '<span class="mejs-duration">' +
                        (t.options.duration > 0 ?
                            mejs.Utility.secondsToTimeCode(t.options.duration, t.options.alwaysShowHours || t.media.duration > 3600, t.options.showTimecodeFrameCount, t.options.framesPerSecond || 25) :
                            ((player.options.alwaysShowHours ? '00:' : '') + (player.options.showTimecodeFrameCount ? '00:00:00' : '00:00'))
                        ) +
                        '</span>' +
                        '</div>')
                    .appendTo(controls);
            }

            t.durationD = t.controls.find('.mejs-duration');

            media.addEventListener('timeupdate', function() {
                player.updateDuration();
            }, false);
        },

        updateCurrent: function() {
            var t = this;

            if (t.currenttime) {
                t.currenttime.html(mejs.Utility.secondsToTimeCode(t.media.currentTime, t.options.alwaysShowHours || t.media.duration > 3600, t.options.showTimecodeFrameCount, t.options.framesPerSecond || 25));
            }
        },

        updateDuration: function() {
            var t = this;

            //Toggle the long video class if the video is longer than an hour.
            t.container.toggleClass("mejs-long-video", t.media.duration > 3600);

            if (t.durationD && (t.options.duration > 0 || t.media.duration)) {
                t.durationD.html(mejs.Utility.secondsToTimeCode(t.options.duration > 0 ? t.options.duration : t.media.duration, t.options.alwaysShowHours, t.options.showTimecodeFrameCount, t.options.framesPerSecond || 25));
            }
        }
    });

})(mejs.$);

(function($) {

    $.extend(mejs.MepDefaults, {
        muteText: mejs.i18n.t('Mute Toggle'),
        hideVolumeOnTouchDevices: true,

        audioVolume: 'horizontal',
        videoVolume: 'vertical'
    });

    $.extend(MediaElementPlayer.prototype, {
        buildvolume: function(player, controls, layers, media) {

            // Android and iOS don't support volume controls
            if ((mejs.MediaFeatures.isAndroid || mejs.MediaFeatures.isiOS) && this.options.hideVolumeOnTouchDevices)
                return;

            var t = this,
                mode = (t.isVideo) ? t.options.videoVolume : t.options.audioVolume,
                mute = (mode == 'horizontal') ?

                // horizontal version
                $('<div class="mejs-button mejs-volume-button mejs-mute">' +
                    '<button type="button" aria-controls="' + t.id + '" title="' + t.options.muteText + '" aria-label="' + t.options.muteText + '"></button>' +
                    '</div>' +
                    '<div class="mejs-horizontal-volume-slider">' + // outer background
                    '<div class="mejs-horizontal-volume-total"></div>' + // line background
                    '<div class="mejs-horizontal-volume-current"></div>' + // current volume
                    '<div class="mejs-horizontal-volume-handle"></div>' + // handle
                    '</div>'
                )
                .appendTo(controls) :

                // vertical version
                $('<div class="mejs-button mejs-volume-button mejs-mute">' +
                    '<button type="button" aria-controls="' + t.id + '" title="' + t.options.muteText + '" aria-label="' + t.options.muteText + '"></button>' +
                    '<div class="mejs-volume-slider">' + // outer background
                    '<div class="mejs-volume-total"></div>' + // line background
                    '<div class="mejs-volume-current"></div>' + // current volume
                    '<div class="mejs-volume-handle"></div>' + // handle
                    '</div>' +
                    '</div>')
                .appendTo(controls),
                volumeSlider = t.container.find('.mejs-volume-slider, .mejs-horizontal-volume-slider'),
                volumeTotal = t.container.find('.mejs-volume-total, .mejs-horizontal-volume-total'),
                volumeCurrent = t.container.find('.mejs-volume-current, .mejs-horizontal-volume-current'),
                volumeHandle = t.container.find('.mejs-volume-handle, .mejs-horizontal-volume-handle'),

                positionVolumeHandle = function(volume, secondTry) {

                    if (!volumeSlider.is(':visible') && typeof secondTry == 'undefined') {
                        volumeSlider.show();
                        positionVolumeHandle(volume, true);
                        volumeSlider.hide()
                        return;
                    }

                    // correct to 0-1
                    volume = Math.max(0, volume);
                    volume = Math.min(volume, 1);

                    // ajust mute button style
                    if (volume == 0) {
                        mute.removeClass('mejs-mute').addClass('mejs-unmute');
                    } else {
                        mute.removeClass('mejs-unmute').addClass('mejs-mute');
                    }

                    // position slider
                    if (mode == 'vertical') {
                        var

                        // height of the full size volume slider background
                            totalHeight = volumeTotal.height(),

                            // top/left of full size volume slider background
                            totalPosition = volumeTotal.position(),

                            // the new top position based on the current volume
                            // 70% volume on 100px height == top:30px
                            newTop = totalHeight - (totalHeight * volume);

                        // handle
                        volumeHandle.css('top', Math.round(totalPosition.top + newTop - (volumeHandle.height() / 2)));

                        // show the current visibility
                        volumeCurrent.height(totalHeight - newTop);
                        volumeCurrent.css('top', totalPosition.top + newTop);
                    } else {
                        var

                        // height of the full size volume slider background
                            totalWidth = volumeTotal.width(),

                            // top/left of full size volume slider background
                            totalPosition = volumeTotal.position(),

                            // the new left position based on the current volume
                            newLeft = totalWidth * volume;

                        // handle
                        volumeHandle.css('left', Math.round(totalPosition.left + newLeft - (volumeHandle.width() / 2)));

                        // rezize the current part of the volume bar
                        volumeCurrent.width(Math.round(newLeft));
                    }
                },
                handleVolumeMove = function(e) {

                    var volume = null,
                        totalOffset = volumeTotal.offset();

                    // calculate the new volume based on the moust position
                    if (mode == 'vertical') {

                        var
                            railHeight = volumeTotal.height(),
                            totalTop = parseInt(volumeTotal.css('top').replace(/px/, ''), 10),
                            newY = e.pageY - totalOffset.top;

                        volume = (railHeight - newY) / railHeight;

                        // the controls just hide themselves (usually when mouse moves too far up)
                        if (totalOffset.top == 0 || totalOffset.left == 0)
                            return;

                    } else {
                        var
                            railWidth = volumeTotal.width(),
                            newX = e.pageX - totalOffset.left;

                        volume = newX / railWidth;
                    }

                    // ensure the volume isn't outside 0-1
                    volume = Math.max(0, volume);
                    volume = Math.min(volume, 1);

                    // position the slider and handle
                    positionVolumeHandle(volume);

                    // set the media object (this will trigger the volumechanged event)
                    if (volume == 0) {
                        media.setMuted(true);
                    } else {
                        media.setMuted(false);
                    }
                    media.setVolume(volume);
                },
                mouseIsDown = false,
                mouseIsOver = false;

            // SLIDER

            mute
                .hover(function() {
                    volumeSlider.show();
                    mouseIsOver = true;
                }, function() {
                    mouseIsOver = false;

                    if (!mouseIsDown && mode == 'vertical') {
                        volumeSlider.hide();
                    }
                });

            volumeSlider
                .bind('mouseover', function() {
                    mouseIsOver = true;
                })
                .bind('mousedown', function(e) {
                    handleVolumeMove(e);
                    t.globalBind('mousemove.vol', function(e) {
                        handleVolumeMove(e);
                    });
                    t.globalBind('mouseup.vol', function() {
                        mouseIsDown = false;
                        t.globalUnbind('.vol');

                        if (!mouseIsOver && mode == 'vertical') {
                            volumeSlider.hide();
                        }
                    });
                    mouseIsDown = true;

                    return false;
                });


            // MUTE button
            mute.find('button').click(function() {
                media.setMuted(!media.muted);
            });

            // listen for volume change events from other sources
            media.addEventListener('volumechange', function(e) {
                if (!mouseIsDown) {
                    if (media.muted) {
                        positionVolumeHandle(0);
                        mute.removeClass('mejs-mute').addClass('mejs-unmute');
                    } else {
                        positionVolumeHandle(media.volume);
                        mute.removeClass('mejs-unmute').addClass('mejs-mute');
                    }
                }
            }, false);

            if (t.container.is(':visible')) {
                // set initial volume
                positionVolumeHandle(player.options.startVolume);

                // mutes the media and sets the volume icon muted if the initial volume is set to 0
                if (player.options.startVolume === 0) {
                    media.setMuted(true);
                }

                // shim gets the startvolume as a parameter, but we have to set it on the native <video> and <audio> elements
                if (media.pluginType === 'native') {
                    media.setVolume(player.options.startVolume);
                }
            }
        }
    });

})(mejs.$);

(function($) {

    $.extend(mejs.MepDefaults, {
        usePluginFullScreen: true,
        newWindowCallback: function() {
            return '';
        },
        fullscreenText: mejs.i18n.t('Fullscreen')
    });

    $.extend(MediaElementPlayer.prototype, {

        isFullScreen: false,

        isNativeFullScreen: false,

        isInIframe: false,

        buildfullscreen: function(player, controls, layers, media) {

            if (!player.isVideo ||  mejs.MediaFeatures.isAndroid || mejs.MediaFeatures.isiOS || (media.pluginType !== 'native'))
                return;

            player.isInIframe = (window.location != window.parent.location);

            // native events
            if (mejs.MediaFeatures.hasTrueNativeFullScreen) {

                // chrome doesn't alays fire this in an iframe
                var func = function(e) {
                    if (player.isFullScreen) {
                        if (mejs.MediaFeatures.isFullScreen()) {
                            player.isNativeFullScreen = true;
                            // reset the controls once we are fully in full screen
                            player.setControlsSize();
                        } else {
                            player.isNativeFullScreen = false;
                            // when a user presses ESC
                            // make sure to put the player back into place
                            player.exitFullScreen();
                        }
                    }
                };

                player.globalBind(mejs.MediaFeatures.fullScreenEventName, func);
            }

            var t = this,
                normalHeight = 0,
                normalWidth = 0,
                container = player.container,
                fullscreenBtn =
                $('<div class="mejs-button mejs-fullscreen-button">' +
                    '<button type="button" aria-controls="' + t.id + '" title="' + t.options.fullscreenText + '" aria-label="' + t.options.fullscreenText + '"></button>' +
                    '</div>')
                .appendTo(controls);

            if (t.media.pluginType === 'native' || (!t.options.usePluginFullScreen && !mejs.MediaFeatures.isFirefox)) {

                fullscreenBtn.click(function() {
                    var isFullScreen = (mejs.MediaFeatures.hasTrueNativeFullScreen && mejs.MediaFeatures.isFullScreen()) || player.isFullScreen;

                    if (isFullScreen) {
                        player.exitFullScreen();
                    } else {
                        player.enterFullScreen();
                    }
                });

            } else {

                var hideTimeout = null,
                    supportsPointerEvents = (function() {
                        // TAKEN FROM MODERNIZR
                        var element = document.createElement('x'),
                            documentElement = document.documentElement,
                            getComputedStyle = window.getComputedStyle,
                            supports;
                        if (!('pointerEvents' in element.style)) {
                            return false;
                        }
                        element.style.pointerEvents = 'auto';
                        element.style.pointerEvents = 'x';
                        documentElement.appendChild(element);
                        supports = getComputedStyle &&
                            getComputedStyle(element, '').pointerEvents === 'auto';
                        documentElement.removeChild(element);
                        return !!supports;
                    })();

                //

                if (supportsPointerEvents && !mejs.MediaFeatures.isOpera) { // opera doesn't allow this :(

                    // allows clicking through the fullscreen button and controls down directly to Flash

                    /*
                     When a user puts his mouse over the fullscreen button, the controls are disabled
                     So we put a div over the video and another one on iether side of the fullscreen button
                     that caputre mouse movement
                     and restore the controls once the mouse moves outside of the fullscreen button
                    */

                    var fullscreenIsDisabled = false,
                        restoreControls = function() {
                            if (fullscreenIsDisabled) {
                                // hide the hovers
                                for (var i in hoverDivs) {
                                    hoverDivs[i].hide();
                                }

                                // restore the control bar
                                fullscreenBtn.css('pointer-events', '');
                                t.controls.css('pointer-events', '');

                                // prevent clicks from pausing video
                                t.media.removeEventListener('click', t.clickToPlayPauseCallback);

                                // store for later
                                fullscreenIsDisabled = false;
                            }
                        },
                        hoverDivs = {},
                        hoverDivNames = ['top', 'left', 'right', 'bottom'],
                        i, len,
                        positionHoverDivs = function() {
                            var fullScreenBtnOffsetLeft = fullscreenBtn.offset().left - t.container.offset().left,
                                fullScreenBtnOffsetTop = fullscreenBtn.offset().top - t.container.offset().top,
                                fullScreenBtnWidth = fullscreenBtn.outerWidth(true),
                                fullScreenBtnHeight = fullscreenBtn.outerHeight(true),
                                containerWidth = t.container.width(),
                                containerHeight = t.container.height();

                            for (i in hoverDivs) {
                                hoverDivs[i].css({
                                    position: 'absolute',
                                    top: 0,
                                    left: 0
                                }); //, backgroundColor: '#f00'});
                            }

                            // over video, but not controls
                            hoverDivs['top']
                                .width(containerWidth)
                                .height(fullScreenBtnOffsetTop);

                            // over controls, but not the fullscreen button
                            hoverDivs['left']
                                .width(fullScreenBtnOffsetLeft)
                                .height(fullScreenBtnHeight)
                                .css({
                                    top: fullScreenBtnOffsetTop
                                });

                            // after the fullscreen button
                            hoverDivs['right']
                                .width(containerWidth - fullScreenBtnOffsetLeft - fullScreenBtnWidth)
                                .height(fullScreenBtnHeight)
                                .css({
                                    top: fullScreenBtnOffsetTop,
                                    left: fullScreenBtnOffsetLeft + fullScreenBtnWidth
                                });

                            // under the fullscreen button
                            hoverDivs['bottom']
                                .width(containerWidth)
                                .height(containerHeight - fullScreenBtnHeight - fullScreenBtnOffsetTop)
                                .css({
                                    top: fullScreenBtnOffsetTop + fullScreenBtnHeight
                                });
                        };

                    t.globalBind('resize', function() {
                        positionHoverDivs();
                    });

                    for (i = 0, len = hoverDivNames.length; i < len; i++) {
                        hoverDivs[hoverDivNames[i]] = $('<div class="mejs-fullscreen-hover" />').appendTo(t.container).mouseover(restoreControls).hide();
                    }

                    // on hover, kill the fullscreen button's HTML handling, allowing clicks down to Flash
                    fullscreenBtn.on('mouseover', function() {

                        if (!t.isFullScreen) {

                            var buttonPos = fullscreenBtn.offset(),
                                containerPos = player.container.offset();

                            // move the button in Flash into place
                            media.positionFullscreenButton(buttonPos.left - containerPos.left, buttonPos.top - containerPos.top, false);

                            // allows click through
                            fullscreenBtn.css('pointer-events', 'none');
                            t.controls.css('pointer-events', 'none');

                            // restore click-to-play
                            t.media.addEventListener('click', t.clickToPlayPauseCallback);

                            // show the divs that will restore things
                            for (i in hoverDivs) {
                                hoverDivs[i].show();
                            }

                            positionHoverDivs();

                            fullscreenIsDisabled = true;
                        }

                    });

                    // restore controls anytime the user enters or leaves fullscreen
                    media.addEventListener('fullscreenchange', function(e) {
                        t.isFullScreen = !t.isFullScreen;
                        // don't allow plugin click to pause video - messes with
                        // plugin's controls
                        if (t.isFullScreen) {
                            t.media.removeEventListener('click', t.clickToPlayPauseCallback);
                        } else {
                            t.media.addEventListener('click', t.clickToPlayPauseCallback);
                        }
                        restoreControls();
                    });


                    // the mouseout event doesn't work on the fullscren button, because we already killed the pointer-events
                    // so we use the document.mousemove event to restore controls when the mouse moves outside the fullscreen button

                    t.globalBind('mousemove', function(e) {

                        // if the mouse is anywhere but the fullsceen button, then restore it all
                        if (fullscreenIsDisabled) {

                            var fullscreenBtnPos = fullscreenBtn.offset();


                            if (e.pageY < fullscreenBtnPos.top || e.pageY > fullscreenBtnPos.top + fullscreenBtn.outerHeight(true) ||
                                e.pageX < fullscreenBtnPos.left || e.pageX > fullscreenBtnPos.left + fullscreenBtn.outerWidth(true)
                            ) {

                                fullscreenBtn.css('pointer-events', '');
                                t.controls.css('pointer-events', '');

                                fullscreenIsDisabled = false;
                            }
                        }
                    });



                } else {

                    // the hover state will show the fullscreen button in Flash to hover up and click

                    fullscreenBtn
                        .on('mouseover', function() {

                            if (hideTimeout !== null) {
                                clearTimeout(hideTimeout);
                                delete hideTimeout;
                            }

                            var buttonPos = fullscreenBtn.offset(),
                                containerPos = player.container.offset();

                            media.positionFullscreenButton(buttonPos.left - containerPos.left, buttonPos.top - containerPos.top, true);

                        })
                        .on('mouseout', function() {

                            if (hideTimeout !== null) {
                                clearTimeout(hideTimeout);
                                delete hideTimeout;
                            }

                            hideTimeout = setTimeout(function() {
                                media.hideFullscreenButton();
                            }, 1500);


                        });
                }
            }

            player.fullscreenBtn = fullscreenBtn;

            t.globalBind('keydown', function(e) {
                if (((mejs.MediaFeatures.hasTrueNativeFullScreen && mejs.MediaFeatures.isFullScreen()) || t.isFullScreen) && e.keyCode == 27) {
                    player.exitFullScreen();
                }
            });

        },

        cleanfullscreen: function(player) {
            player.exitFullScreen();
        },

        containerSizeTimeout: null,

        enterFullScreen: function() {

            var t = this;

            // firefox+flash can't adjust plugin sizes without resetting :(
            if (t.media.pluginType !== 'native' && (mejs.MediaFeatures.isFirefox || t.options.usePluginFullScreen)) {
                //t.media.setFullscreen(true);
                //player.isFullScreen = true;
                return;
            }

            // set it to not show scroll bars so 100% will work
            $(document.documentElement).addClass('mejs-fullscreen');

            // store sizing
            normalHeight = t.container.height();
            normalWidth = t.container.width();

            // attempt to do true fullscreen (Safari 5.1 and Firefox Nightly only for now)
            if (t.media.pluginType === 'native') {
                if (mejs.MediaFeatures.hasTrueNativeFullScreen) {

                    mejs.MediaFeatures.requestFullScreen(t.container[0]);
                    //return;

                    if (t.isInIframe) {
                        // sometimes exiting from fullscreen doesn't work
                        // notably in Chrome <iframe>. Fixed in version 17
                        setTimeout(function checkFullscreen() {

                            if (t.isNativeFullScreen) {
                                var zoomMultiplier = window["devicePixelRatio"] || 1;
                                // Use a percent error margin since devicePixelRatio is a float and not exact.
                                var percentErrorMargin = 0.002; // 0.2%
                                var windowWidth = zoomMultiplier * $(window).width();
                                var screenWidth = screen.width;
                                var absDiff = Math.abs(screenWidth - windowWidth);
                                var marginError = screenWidth * percentErrorMargin;

                                // check if the video is suddenly not really fullscreen
                                if (absDiff > marginError) {
                                    // manually exit
                                    t.exitFullScreen();
                                } else {
                                    // test again
                                    setTimeout(checkFullscreen, 500);
                                }
                            }


                        }, 500);
                    }

                } else if (mejs.MediaFeatures.hasSemiNativeFullScreen) {
                    t.media.webkitEnterFullscreen();
                    return;
                }
            }

            // check for iframe launch
            if (t.isInIframe) {
                var url = t.options.newWindowCallback(this);


                if (url !== '') {

                    // launch immediately
                    if (!mejs.MediaFeatures.hasTrueNativeFullScreen) {
                        t.pause();
                        window.open(url, t.id, 'top=0,left=0,width=' + screen.availWidth + ',height=' + screen.availHeight + ',resizable=yes,scrollbars=no,status=no,toolbar=no');
                        return;
                    } else {
                        setTimeout(function() {
                            if (!t.isNativeFullScreen) {
                                t.pause();
                                window.open(url, t.id, 'top=0,left=0,width=' + screen.availWidth + ',height=' + screen.availHeight + ',resizable=yes,scrollbars=no,status=no,toolbar=no');
                            }
                        }, 250);
                    }
                }

            }

            // full window code



            // make full size
            t.container
                .addClass('mejs-container-fullscreen')
                .width('100%')
                .height('100%');
            //.css({position: 'fixed', left: 0, top: 0, right: 0, bottom: 0, overflow: 'hidden', width: '100%', height: '100%', 'z-index': 1000});

            // Only needed for safari 5.1 native full screen, can cause display issues elsewhere
            // Actually, it seems to be needed for IE8, too
            //if (mejs.MediaFeatures.hasTrueNativeFullScreen) {
            t.containerSizeTimeout = setTimeout(function() {
                t.container.css({
                    width: '100%',
                    height: '100%'
                });
                t.setControlsSize();
            }, 500);
            //}

            if (t.media.pluginType === 'native') {
                t.$media
                    .width('100%')
                    .height('100%');
            } else {
                t.container.find('.mejs-shim')
                    .width('100%')
                    .height('100%');

                //if (!mejs.MediaFeatures.hasTrueNativeFullScreen) {
                t.media.setVideoSize($(window).width(), $(window).height());
                //}
            }

            t.layers.children('div')
                .width('100%')
                .height('100%');

            if (t.fullscreenBtn) {
                t.fullscreenBtn
                    .removeClass('mejs-fullscreen')
                    .addClass('mejs-unfullscreen');
            }

            t.setControlsSize();
            t.isFullScreen = true;

            t.container.find('.mejs-captions-text').css('font-size', screen.width / t.width * 1.00 * 100 + '%');
            t.container.find('.mejs-captions-position').css('bottom', '45px');
        },

        exitFullScreen: function() {

            var t = this;

            // Prevent container from attempting to stretch a second time
            clearTimeout(t.containerSizeTimeout);

            // firefox can't adjust plugins
            if (t.media.pluginType !== 'native' && mejs.MediaFeatures.isFirefox) {
                t.media.setFullscreen(false);
                //player.isFullScreen = false;
                return;
            }

            // come outo of native fullscreen
            if (mejs.MediaFeatures.hasTrueNativeFullScreen && (mejs.MediaFeatures.isFullScreen() || t.isFullScreen)) {
                mejs.MediaFeatures.cancelFullScreen();
            }

            // restore scroll bars to document
            $(document.documentElement).removeClass('mejs-fullscreen');

            t.container
                .removeClass('mejs-container-fullscreen')
                .width(normalWidth)
                .height(normalHeight);
            //.css({position: '', left: '', top: '', right: '', bottom: '', overflow: 'inherit', width: normalWidth + 'px', height: normalHeight + 'px', 'z-index': 1});

            if (t.media.pluginType === 'native') {
                t.$media
                    .width(normalWidth)
                    .height(normalHeight);
            } else {
                t.container.find('.mejs-shim')
                    .width(normalWidth)
                    .height(normalHeight);

                t.media.setVideoSize(normalWidth, normalHeight);
            }

            t.layers.children('div')
                .width(normalWidth)
                .height(normalHeight);

            t.fullscreenBtn
                .removeClass('mejs-unfullscreen')
                .addClass('mejs-fullscreen');

            t.setControlsSize();
            t.isFullScreen = false;

            t.container.find('.mejs-captions-text').css('font-size', '');
            t.container.find('.mejs-captions-position').css('bottom', '');
        }
    });

})(mejs.$);

(function($) {

    // Speed
    $.extend(mejs.MepDefaults, {

        speeds: ['1.50', '1.25', '1.00', '0.75'],

        defaultSpeed: '1.00'

    });

    $.extend(MediaElementPlayer.prototype, {

        buildspeed: function(player, controls, layers, media) {
            var t = this;

            if (t.media.pluginType == 'native') {
                var s = '<div class="mejs-button mejs-speed-button"><button type="button">' + t.options.defaultSpeed + 'x</button><div class="mejs-speed-selector"><ul>';
                var i, ss;

                if ($.inArray(t.options.defaultSpeed, t.options.speeds) === -1) {
                    t.options.speeds.push(t.options.defaultSpeed);
                }

                t.options.speeds.sort(function(a, b) {
                    return parseFloat(b) - parseFloat(a);
                });

                for (i = 0; i < t.options.speeds.length; i++) {
                    s += '<li><input type="radio" name="speed" value="' + t.options.speeds[i] + '" id="' + t.options.speeds[i] + '" ';
                    if (t.options.speeds[i] == t.options.defaultSpeed) {
                        s += 'checked=true ';
                        s += '/><label for="' + t.options.speeds[i] + '" class="mejs-speed-selected">' + t.options.speeds[i] + 'x</label></li>';
                    } else {
                        s += '/><label for="' + t.options.speeds[i] + '">' + t.options.speeds[i] + 'x</label></li>';
                    }
                }
                s += '</ul></div></div>';

                player.speedButton = $(s).appendTo(controls);

                player.playbackspeed = t.options.defaultSpeed;

                player.speedButton
                    .on('click', 'input[type=radio]', function() {
                        player.playbackspeed = $(this).attr('value');
                        media.playbackRate = parseFloat(player.playbackspeed);
                        player.speedButton.find('button').text(player.playbackspeed + 'x');
                        player.speedButton.find('.mejs-speed-selected').removeClass('mejs-speed-selected');
                        player.speedButton.find('input[type=radio]:checked').next().addClass('mejs-speed-selected');
                    });

                ss = player.speedButton.find('.mejs-speed-selector');
                ss.height(this.speedButton.find('.mejs-speed-selector ul').outerHeight(true) + player.speedButton.find('.mejs-speed-translations').outerHeight(true));
                ss.css('top', (-1 * ss.height()) + 'px');
            }
        }
    });

})(mejs.$);

(function($) {

    // add extra default options
    $.extend(mejs.MepDefaults, {
        // this will automatically turn on a <track>
        startLanguage: '',

        tracksText: mejs.i18n.t('Captions/Subtitles'),

        // option to remove the [cc] button when no <track kind="subtitles"> are present
        hideCaptionsButtonWhenEmpty: true,

        // If true and we only have one track, change captions to popup
        toggleCaptionsButtonWhenOnlyOne: false,

        // #id or .class
        slidesSelector: ''
    });

    $.extend(MediaElementPlayer.prototype, {

        hasChapters: false,

        buildtracks: function(player, controls, layers, media) {
            if (player.tracks.length === 0)
                return;

            var t = this,
                i,
                options = '';

            if (t.domNode.textTracks) { // if browser will do native captions, prefer mejs captions, loop through tracks and hide
                for (i = t.domNode.textTracks.length - 1; i >= 0; i--) {
                    t.domNode.textTracks[i].mode = "hidden";
                }
            }
            player.chapters =
                $('<div class="mejs-chapters mejs-layer"></div>')
                .prependTo(layers).hide();
            player.captions =
                $('<div class="mejs-captions-layer mejs-layer"><div class="mejs-captions-position mejs-captions-position-hover"><span class="mejs-captions-text"></span></div></div>')
                .prependTo(layers).hide();
            player.captionsText = player.captions.find('.mejs-captions-text');
            player.captionsButton =
                $('<div class="mejs-button mejs-captions-button">' +
                    '<button type="button" aria-controls="' + t.id + '" title="' + t.options.tracksText + '" aria-label="' + t.options.tracksText + '"></button>' +
                    '<div class="mejs-captions-selector">' +
                    '<ul>' +
                    '<li>' +
                    '<input type="radio" name="' + player.id + '_captions" id="' + player.id + '_captions_none" value="none" checked="checked" />' +
                    '<label for="' + player.id + '_captions_none">' + mejs.i18n.t('None') + '</label>' +
                    '</li>' +
                    '</ul>' +
                    '</div>' +
                    '</div>')
                .appendTo(controls);


            var subtitleCount = 0;
            for (i = 0; i < player.tracks.length; i++) {
                if (player.tracks[i].kind == 'subtitles') {
                    subtitleCount++;
                }
            }

            // if only one language then just make the button a toggle
            if (t.options.toggleCaptionsButtonWhenOnlyOne && subtitleCount == 1) {
                // click
                player.captionsButton.on('click', function() {
                    if (player.selectedTrack === null) {
                        lang = player.tracks[0].srclang;
                    } else {
                        lang = 'none';
                    }
                    player.setTrack(lang);
                });
            } else {
                // hover or keyboard focus
                player.captionsButton.on('mouseenter focusin', function() {
                    $(this).find('.mejs-captions-selector').css('visibility', 'visible');
                })

                // handle clicks to the language radio buttons
                .on('click', 'input[type=radio]', function() {
                    lang = this.value;
                    player.setTrack(lang);
                });

                player.captionsButton.on('mouseleave focusout', function() {
                    $(this).find(".mejs-captions-selector").css("visibility", "hidden");
                });

            }

            if (!player.options.alwaysShowControls) {
                // move with controls
                player.container
                    .bind('controlsshown', function() {
                        // push captions above controls
                        player.container.find('.mejs-captions-position').addClass('mejs-captions-position-hover');

                    })
                    .bind('controlshidden', function() {
                        if (!media.paused) {
                            // move back to normal place
                            player.container.find('.mejs-captions-position').removeClass('mejs-captions-position-hover');
                        }
                    });
            } else {
                player.container.find('.mejs-captions-position').addClass('mejs-captions-position-hover');
            }

            player.trackToLoad = -1;
            player.selectedTrack = null;
            player.isLoadingTrack = false;

            // add to list
            for (i = 0; i < player.tracks.length; i++) {
                if (player.tracks[i].kind == 'subtitles') {
                    player.addTrackButton(player.tracks[i].srclang, player.tracks[i].label);
                }
            }

            // start loading tracks
            player.loadNextTrack();

            media.addEventListener('timeupdate', function(e) {
                player.displayCaptions();
            }, false);

            if (player.options.slidesSelector !== '') {
                player.slidesContainer = $(player.options.slidesSelector);

                media.addEventListener('timeupdate', function(e) {
                    player.displaySlides();
                }, false);

            }

            media.addEventListener('loadedmetadata', function(e) {
                player.displayChapters();
            }, false);

            player.container.hover(
                function() {
                    // chapters
                    if (player.hasChapters) {
                        player.chapters.css('visibility', 'visible');
                        player.chapters.fadeIn(200).height(player.chapters.find('.mejs-chapter').outerHeight());
                    }
                },
                function() {
                    if (player.hasChapters && !media.paused) {
                        player.chapters.fadeOut(200, function() {
                            $(this).css('visibility', 'hidden');
                            $(this).css('display', 'block');
                        });
                    }
                });

            // check for autoplay
            if (player.node.getAttribute('autoplay') !== null) {
                player.chapters.css('visibility', 'hidden');
            }
        },

        setTrack: function(lang) {

            var t = this,
                i;

            if (lang == 'none') {
                t.selectedTrack = null;
                t.captionsButton.removeClass('mejs-captions-enabled');
            } else {
                for (i = 0; i < t.tracks.length; i++) {
                    if (t.tracks[i].srclang == lang) {
                        if (t.selectedTrack === null)
                            t.captionsButton.addClass('mejs-captions-enabled');
                        t.selectedTrack = t.tracks[i];
                        t.captions.attr('lang', t.selectedTrack.srclang);
                        t.displayCaptions();
                        break;
                    }
                }
            }
        },

        loadNextTrack: function() {
            var t = this;

            t.trackToLoad++;
            if (t.trackToLoad < t.tracks.length) {
                t.isLoadingTrack = true;
                t.loadTrack(t.trackToLoad);
            } else {
                // add done?
                t.isLoadingTrack = false;

                t.checkForTracks();
            }
        },

        loadTrack: function(index) {
            var
                t = this,
                track = t.tracks[index],
                after = function() {

                    track.isLoaded = true;

                    // create button
                    //t.addTrackButton(track.srclang);
                    t.enableTrackButton(track.srclang, track.label);

                    t.loadNextTrack();

                };


            $.ajax({
                url: track.src,
                dataType: "text",
                success: function(d) {

                    // parse the loaded file
                    if (typeof d == "string" && (/<tt\s+xml/ig).exec(d)) {
                        track.entries = mejs.TrackFormatParser.dfxp.parse(d);
                    } else {
                        track.entries = mejs.TrackFormatParser.webvtt.parse(d);
                    }

                    after();

                    if (track.kind == 'chapters') {
                        t.media.addEventListener('play', function(e) {
                            if (t.media.duration > 0) {
                                t.displayChapters(track);
                            }
                        }, false);
                    }

                    if (track.kind == 'slides') {
                        t.setupSlides(track);
                    }
                },
                error: function() {
                    t.loadNextTrack();
                }
            });
        },

        enableTrackButton: function(lang, label) {
            var t = this;

            if (label === '') {
                label = mejs.language.codes[lang] || lang;
            }

            t.captionsButton
                .find('input[value=' + lang + ']')
                .prop('disabled', false)
                .siblings('label')
                .html(label);

            // auto select
            if (t.options.startLanguage == lang) {
                $('#' + t.id + '_captions_' + lang).prop('checked', true).trigger('click');
            }

            t.adjustLanguageBox();
        },

        addTrackButton: function(lang, label) {
            var t = this;
            if (label === '') {
                label = mejs.language.codes[lang] || lang;
            }

            t.captionsButton.find('ul').append(
                $('<li>' +
                    '<input type="radio" name="' + t.id + '_captions" id="' + t.id + '_captions_' + lang + '" value="' + lang + '" disabled="disabled" />' +
                    '<label for="' + t.id + '_captions_' + lang + '">' + label + ' (loading)' + '</label>' +
                    '</li>')
            );

            t.adjustLanguageBox();

            // remove this from the dropdownlist (if it exists)
            t.container.find('.mejs-captions-translations option[value=' + lang + ']').remove();
        },

        adjustLanguageBox: function() {
            var t = this;
            // adjust the size of the outer box
            t.captionsButton.find('.mejs-captions-selector').height(
                t.captionsButton.find('.mejs-captions-selector ul').outerHeight(true) +
                t.captionsButton.find('.mejs-captions-translations').outerHeight(true)
            );
        },

        checkForTracks: function() {
            var
                t = this,
                hasSubtitles = false;

            // check if any subtitles
            if (t.options.hideCaptionsButtonWhenEmpty) {
                for (i = 0; i < t.tracks.length; i++) {
                    if (t.tracks[i].kind == 'subtitles') {
                        hasSubtitles = true;
                        break;
                    }
                }

                if (!hasSubtitles) {
                    t.captionsButton.hide();
                    t.setControlsSize();
                }
            }
        },

        displayCaptions: function() {

            if (typeof this.tracks == 'undefined')
                return;

            var
                t = this,
                i,
                track = t.selectedTrack;

            if (track !== null && track.isLoaded) {
                for (i = 0; i < track.entries.times.length; i++) {
                    if (t.media.currentTime >= track.entries.times[i].start && t.media.currentTime <= track.entries.times[i].stop) {
                        // Set the line before the timecode as a class so the cue can be targeted if needed
                        t.captionsText.html(track.entries.text[i]).attr('class', 'mejs-captions-text ' + (track.entries.times[i].identifier || ''));
                        t.captions.show().height(0);
                        return; // exit out if one is visible;
                    }
                }
                t.captions.hide();
            } else {
                t.captions.hide();
            }
        },

        setupSlides: function(track) {
            var t = this;

            t.slides = track;
            t.slides.entries.imgs = [t.slides.entries.text.length];
            t.showSlide(0);

        },

        showSlide: function(index) {
            if (typeof this.tracks == 'undefined' || typeof this.slidesContainer == 'undefined') {
                return;
            }

            var t = this,
                url = t.slides.entries.text[index],
                img = t.slides.entries.imgs[index];

            if (typeof img == 'undefined' || typeof img.fadeIn == 'undefined') {

                t.slides.entries.imgs[index] = img = $('<img src="' + url + '">')
                    .on('load', function() {
                        img.appendTo(t.slidesContainer)
                            .hide()
                            .fadeIn()
                            .siblings(':visible')
                            .fadeOut();

                    });

            } else {

                if (!img.is(':visible') && !img.is(':animated')) {

                    //

                    img.fadeIn()
                        .siblings(':visible')
                        .fadeOut();
                }
            }

        },

        displaySlides: function() {

            if (typeof this.slides == 'undefined')
                return;

            var
                t = this,
                slides = t.slides,
                i;

            for (i = 0; i < slides.entries.times.length; i++) {
                if (t.media.currentTime >= slides.entries.times[i].start && t.media.currentTime <= slides.entries.times[i].stop) {

                    t.showSlide(i);

                    return; // exit out if one is visible;
                }
            }
        },

        displayChapters: function() {
            var
                t = this,
                i;

            for (i = 0; i < t.tracks.length; i++) {
                if (t.tracks[i].kind == 'chapters' && t.tracks[i].isLoaded) {
                    t.drawChapters(t.tracks[i]);
                    t.hasChapters = true;
                    break;
                }
            }
        },

        drawChapters: function(chapters) {
            var
                t = this,
                i,
                dur,
                //width,
                //left,
                percent = 0,
                usedPercent = 0;

            t.chapters.empty();

            for (i = 0; i < chapters.entries.times.length; i++) {
                dur = chapters.entries.times[i].stop - chapters.entries.times[i].start;
                percent = Math.floor(dur / t.media.duration * 100);
                if (percent + usedPercent > 100 || // too large
                    i == chapters.entries.times.length - 1 && percent + usedPercent < 100) // not going to fill it in
                {
                    percent = 100 - usedPercent;
                }
                //width = Math.floor(t.width * dur / t.media.duration);
                //left = Math.floor(t.width * chapters.entries.times[i].start / t.media.duration);
                //if (left + width > t.width) {
                //  width = t.width - left;
                //}

                t.chapters.append($(
                    '<div class="mejs-chapter" rel="' + chapters.entries.times[i].start + '" style="left: ' + usedPercent.toString() + '%;width: ' + percent.toString() + '%;">' +
                    '<div class="mejs-chapter-block' + ((i == chapters.entries.times.length - 1) ? ' mejs-chapter-block-last' : '') + '">' +
                    '<span class="ch-title">' + chapters.entries.text[i] + '</span>' +
                    '<span class="ch-time">' + mejs.Utility.secondsToTimeCode(chapters.entries.times[i].start) + '&ndash;' + mejs.Utility.secondsToTimeCode(chapters.entries.times[i].stop) + '</span>' +
                    '</div>' +
                    '</div>'));
                usedPercent += percent;
            }

            t.chapters.find('div.mejs-chapter').click(function() {
                t.media.setCurrentTime(parseFloat($(this).attr('rel')));
                if (t.media.paused) {
                    t.media.play();
                }
            });

            t.chapters.show();
        }
    });



    mejs.language = {
        codes: {
            af: 'Afrikaans',
            sq: 'Albanian',
            ar: 'Arabic',
            be: 'Belarusian',
            bg: 'Bulgarian',
            ca: 'Catalan',
            zh: 'Chinese',
            'zh-cn': 'Chinese Simplified',
            'zh-tw': 'Chinese Traditional',
            hr: 'Croatian',
            cs: 'Czech',
            da: 'Danish',
            nl: 'Dutch',
            en: 'English',
            et: 'Estonian',
            fl: 'Filipino',
            fi: 'Finnish',
            fr: 'French',
            gl: 'Galician',
            de: 'German',
            el: 'Greek',
            ht: 'Haitian Creole',
            iw: 'Hebrew',
            hi: 'Hindi',
            hu: 'Hungarian',
            is: 'Icelandic',
            id: 'Indonesian',
            ga: 'Irish',
            it: 'Italian',
            ja: 'Japanese',
            ko: 'Korean',
            lv: 'Latvian',
            lt: 'Lithuanian',
            mk: 'Macedonian',
            ms: 'Malay',
            mt: 'Maltese',
            no: 'Norwegian',
            fa: 'Persian',
            pl: 'Polish',
            pt: 'Portuguese',
            // 'pt-pt':'Portuguese (Portugal)',
            ro: 'Romanian',
            ru: 'Russian',
            sr: 'Serbian',
            sk: 'Slovak',
            sl: 'Slovenian',
            es: 'Spanish',
            sw: 'Swahili',
            sv: 'Swedish',
            tl: 'Tagalog',
            th: 'Thai',
            tr: 'Turkish',
            uk: 'Ukrainian',
            vi: 'Vietnamese',
            cy: 'Welsh',
            yi: 'Yiddish'
        }
    };

    /*
    Parses WebVTT format which should be formatted as
    ================================
    WEBVTT

    1
    00:00:01,1 --> 00:00:05,000
    A line of text

    2
    00:01:15,1 --> 00:02:05,000
    A second line of text

    ===============================

    Adapted from: http://www.delphiki.com/html5/playr
    */
    mejs.TrackFormatParser = {
        webvtt: {
            pattern_timecode: /^((?:[0-9]{1,2}:)?[0-9]{2}:[0-9]{2}([,.][0-9]{1,3})?) --\> ((?:[0-9]{1,2}:)?[0-9]{2}:[0-9]{2}([,.][0-9]{3})?)(.*)$/,

            parse: function(trackText) {
                var
                    i = 0,
                    lines = mejs.TrackFormatParser.split2(trackText, /\r?\n/),
                    entries = {
                        text: [],
                        times: []
                    },
                    timecode,
                    text,
                    identifier;
                for (; i < lines.length; i++) {
                    timecode = this.pattern_timecode.exec(lines[i]);

                    if (timecode && i < lines.length) {
                        if ((i - 1) >= 0 && lines[i - 1] !== '') {
                            identifier = lines[i - 1];
                        }
                        i++;
                        // grab all the (possibly multi-line) text that follows
                        text = lines[i];
                        i++;
                        while (lines[i] !== '' && i < lines.length) {
                            text = text + '\n' + lines[i];
                            i++;
                        }
                        text = $.trim(text).replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig, "<a href='$1' target='_blank'>$1</a>");
                        // Text is in a different array so I can use .join
                        entries.text.push(text);
                        entries.times.push({
                            identifier: identifier,
                            start: (mejs.Utility.convertSMPTEtoSeconds(timecode[1]) === 0) ? 0.200 : mejs.Utility.convertSMPTEtoSeconds(timecode[1]),
                            stop: mejs.Utility.convertSMPTEtoSeconds(timecode[3]),
                            settings: timecode[5]
                        });
                    }
                    identifier = '';
                }
                return entries;
            }
        },
        // Thanks to Justin Capella: https://github.com/johndyer/mediaelement/pull/420
        dfxp: {
            parse: function(trackText) {
                trackText = $(trackText).filter("tt");
                var
                    i = 0,
                    container = trackText.children("div").eq(0),
                    lines = container.find("p"),
                    styleNode = trackText.find("#" + container.attr("style")),
                    styles,
                    begin,
                    end,
                    text,
                    entries = {
                        text: [],
                        times: []
                    };


                if (styleNode.length) {
                    var attributes = styleNode.removeAttr("id").get(0).attributes;
                    if (attributes.length) {
                        styles = {};
                        for (i = 0; i < attributes.length; i++) {
                            styles[attributes[i].name.split(":")[1]] = attributes[i].value;
                        }
                    }
                }

                for (i = 0; i < lines.length; i++) {
                    var style;
                    var _temp_times = {
                        start: null,
                        stop: null,
                        style: null
                    };
                    if (lines.eq(i).attr("begin")) _temp_times.start = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i).attr("begin"));
                    if (!_temp_times.start && lines.eq(i - 1).attr("end")) _temp_times.start = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i - 1).attr("end"));
                    if (lines.eq(i).attr("end")) _temp_times.stop = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i).attr("end"));
                    if (!_temp_times.stop && lines.eq(i + 1).attr("begin")) _temp_times.stop = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i + 1).attr("begin"));
                    if (styles) {
                        style = "";
                        for (var _style in styles) {
                            style += _style + ":" + styles[_style] + ";";
                        }
                    }
                    if (style) _temp_times.style = style;
                    if (_temp_times.start === 0) _temp_times.start = 0.200;
                    entries.times.push(_temp_times);
                    text = $.trim(lines.eq(i).html()).replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig, "<a href='$1' target='_blank'>$1</a>");
                    entries.text.push(text);
                    if (entries.times.start === 0) entries.times.start = 2;
                }
                return entries;
            }
        },
        split2: function(text, regex) {
            // normal version for compliant browsers
            // see below for IE fix
            return text.split(regex);
        }
    };

    // test for browsers with bad String.split method.
    if ('x\n\ny'.split(/\n/gi).length != 3) {
        // add super slow IE8 and below version
        mejs.TrackFormatParser.split2 = function(text, regex) {
            var
                parts = [],
                chunk = '',
                i;

            for (i = 0; i < text.length; i++) {
                chunk += text.substring(i, i + 1);
                if (regex.test(chunk)) {
                    parts.push(chunk.replace(regex, ''));
                    chunk = '';
                }
            }
            parts.push(chunk);
            return parts;
        };
    }

})(mejs.$);

/*
 * ContextMenu Plugin
 *
 *
 */

(function($) {

    $.extend(mejs.MepDefaults, {
        'contextMenuItems': [
            // demo of a fullscreen option
            {
                render: function(player) {

                    // check for fullscreen plugin
                    if (typeof player.enterFullScreen == 'undefined')
                        return null;

                    if (player.isFullScreen) {
                        return mejs.i18n.t('Turn off Fullscreen');
                    } else {
                        return mejs.i18n.t('Go Fullscreen');
                    }
                },
                click: function(player) {
                    if (player.isFullScreen) {
                        player.exitFullScreen();
                    } else {
                        player.enterFullScreen();
                    }
                }
            },
            // demo of a mute/unmute button
            {
                render: function(player) {
                    if (player.media.muted) {
                        return mejs.i18n.t('Unmute');
                    } else {
                        return mejs.i18n.t('Mute');
                    }
                },
                click: function(player) {
                    if (player.media.muted) {
                        player.setMuted(false);
                    } else {
                        player.setMuted(true);
                    }
                }
            },
            // separator
            {
                isSeparator: true
            },
            // demo of simple download video
            {
                render: function(player) {
                    return mejs.i18n.t('Download Video');
                },
                click: function(player) {
                    window.location.href = player.media.currentSrc;
                }
            }
        ]
    });


    $.extend(MediaElementPlayer.prototype, {
        buildcontextmenu: function(player, controls, layers, media) {

            // create context menu
            player.contextMenu = $('<div class="mejs-contextmenu"></div>')
                .appendTo($('body'))
                .hide();

            // create events for showing context menu
            player.container.bind('contextmenu', function(e) {
                if (player.isContextMenuEnabled) {
                    e.preventDefault();
                    player.renderContextMenu(e.clientX - 1, e.clientY - 1);
                    return false;
                }
            });
            player.container.bind('click', function() {
                player.contextMenu.hide();
            });
            player.contextMenu.bind('mouseleave', function() {

                //
                player.startContextMenuTimer();

            });
        },

        cleancontextmenu: function(player) {
            player.contextMenu.remove();
        },

        isContextMenuEnabled: true,
        enableContextMenu: function() {
            this.isContextMenuEnabled = true;
        },
        disableContextMenu: function() {
            this.isContextMenuEnabled = false;
        },

        contextMenuTimeout: null,
        startContextMenuTimer: function() {
            //

            var t = this;

            t.killContextMenuTimer();

            t.contextMenuTimer = setTimeout(function() {
                t.hideContextMenu();
                t.killContextMenuTimer();
            }, 750);
        },
        killContextMenuTimer: function() {
            var timer = this.contextMenuTimer;

            //

            if (timer != null) {
                clearTimeout(timer);
                delete timer;
                timer = null;
            }
        },

        hideContextMenu: function() {
            this.contextMenu.hide();
        },

        renderContextMenu: function(x, y) {

            // alway re-render the items so that things like "turn fullscreen on" and "turn fullscreen off" are always written correctly
            var t = this,
                html = '',
                items = t.options.contextMenuItems;

            for (var i = 0, il = items.length; i < il; i++) {

                if (items[i].isSeparator) {
                    html += '<div class="mejs-contextmenu-separator"></div>';
                } else {

                    var rendered = items[i].render(t);

                    // render can return null if the item doesn't need to be used at the moment
                    if (rendered != null) {
                        html += '<div class="mejs-contextmenu-item" data-itemindex="' + i + '" id="element-' + (Math.random() * 1000000) + '">' + rendered + '</div>';
                    }
                }
            }

            // position and show the context menu
            t.contextMenu
                .empty()
                .append($(html))
                .css({
                    top: y,
                    left: x
                })
                .show();

            // bind events
            t.contextMenu.find('.mejs-contextmenu-item').each(function() {

                // which one is this?
                var $dom = $(this),
                    itemIndex = parseInt($dom.data('itemindex'), 10),
                    item = t.options.contextMenuItems[itemIndex];

                // bind extra functionality?
                if (typeof item.show != 'undefined')
                    item.show($dom, t);

                // bind click action
                $dom.click(function() {
                    // perform click action
                    if (typeof item.click != 'undefined')
                        item.click(t);

                    // close
                    t.contextMenu.hide();
                });
            });

            // stop the controls from hiding
            setTimeout(function() {
                t.killControlsTimer('rev3');
            }, 100);

        }
    });

})(mejs.$);
/**
 * Postroll plugin
 */
(function($) {

    $.extend(mejs.MepDefaults, {
        postrollCloseText: mejs.i18n.t('Close')
    });

    // Postroll
    $.extend(MediaElementPlayer.prototype, {
        buildpostroll: function(player, controls, layers, media) {
            var
                t = this,
                postrollLink = t.container.find('link[rel="postroll"]').attr('href');

            if (typeof postrollLink !== 'undefined') {
                player.postroll =
                    $('<div class="mejs-postroll-layer mejs-layer"><a class="mejs-postroll-close" onclick="$(this).parent().hide();return false;">' + t.options.postrollCloseText + '</a><div class="mejs-postroll-layer-content"></div></div>').prependTo(layers).hide();

                t.media.addEventListener('ended', function(e) {
                    $.ajax({
                        dataType: 'html',
                        url: postrollLink,
                        success: function(data, textStatus) {
                            layers.find('.mejs-postroll-layer-content').html(data);
                        }
                    });
                    player.postroll.show();
                }, false);
            }
        }
    });

})(mejs.$);
/**
 * Social Share plugin
 */
(function($) {

    $.extend(MediaElementPlayer.prototype, {
        buildsocialshare: function(player, controls, layers, media) {

            if (mejs.MediaFeatures.isAndroid || mejs.MediaFeatures.isiOS)
                return;

            var t = this;
            var videoId = t.$node.find('video').selector.split(' ')[0];
            var videoUrl = document.URL.split('#')[0] + videoId;

            // Break if Social Sharing not enabled in Sitecore
            if (!t.$node.data('socialSharing'))
                return;

            var socialSharingUrl = t.$node.data('socialSharingUrl');

            player.socialshareButton =
                $('<div class="mejs-button mejs-social-sharing">' +
                    '<button class="mejs-social-sharing-button" type="button" aria-controls="' + t.id + '">Share</button>' +
                    '</div>')
                .delegate('.mejs-social-sharing-button', 'click', function(event) {
                    event.preventDefault();
                    t.toggleSocialSharing(media);
                })
                .appendTo(controls);

            t.renderSocialSharing(player, media, videoUrl, socialSharingUrl);

        },

        zeroClipboard: function() {

            ZeroClipboard.config({
                swfPath: "/Static/zeroclipboard/ZeroClipboard.swf"
            });
            var client = new ZeroClipboard($('.mejs-social-sharing-copy button'));

            client.on('ready', function(event) {

                client.on('copy', function(event) {
                    event.clipboardData.setData('text/plain', $('.mejs-social-sharing-link input').val());
                });
                client.on('aftercopy', function(event) {
                    // console.log('Copied text to clipboard: ' + event.data['text/plain']);
                });

            });

            client.on('error', function(event) {
                // console.log( 'ZeroClipboard error of type "' + event.name + '": ' + event.message );
                ZeroClipboard.destroy();
            });

        },

        setSocialSharingItems: function(url) {

            var t = this;

            $.getJSON(url, function(data) {
                var shareUrl = encodeURIComponent(document.location);
                var shareTitle = encodeURIComponent(document.title);
                var alternatives = "";

                $.each(data.socialSharingItems, function(i, item) {
                    alternatives += ' <a href="#" class="social-sharelink" data-sharelink="' + item.shareLink.href + '" data-sharesubject="' + item.shareSubject + '"><i class="icon ' + (item.iconAlternativeClass != '' && item.iconAlternativeClass != null ? item.iconAlternativeClass : item.iconClass) + '"></i></a>';
                });

                $(alternatives).appendTo($('.mejs-sharing-alternatives'));
            });

        },

        renderSocialSharing: function(player, media, videoUrl, socialSharingUrl) {

            var t = this;

            player.socialshareOverlay =
                $('<div class="mejs-social-sharing-overlay-wrapper">' +
                    '<div class="mejs-social-sharing-overlay">' + // overlay
                    '<a href="#" class="mejs-social-sharing-close">&#x2715;</a>' +
                    '<h3>Share Video</h3>' +
                    '<div class="mejs-social-sharing-link">' +
                    '<input name="video-link" type="text" value="' + videoUrl + '">' +
                    '<div class="mejs-social-sharing-copy">' +
                    '<button class="button-small button-opaque">COPY</button>' +
                    '</div>' +
                    '</div>' +
                    '<div class="mejs-sharing-alternatives social">' +
                    '</div>' +
                    '</div>' +
                    '</div>')
                .delegate('.mejs-social-sharing-close', 'click', function(event) {
                    event.preventDefault();
                    t.toggleSocialSharing(media);
                })
                .appendTo($('.mejs-layers'));

            t.zeroClipboard();
            t.setSocialSharingItems(socialSharingUrl);

            // auto component does not work in IE8 if rendered after page load
            if ($('html').hasClass('lt-ie9')) {
                new vc.SocialSharing({
                    el: player.socialshareOverlay.find('.social')
                });
            }
        },

        toggleSocialSharing: function(media) {

            var t = this;
            var socialSharing = $('.mejs-social-sharing-overlay-wrapper');

            // Opening overlay
            if (!socialSharing.hasClass('active')) {

                // Remember if video was playing or not when overlay opened
                if (!media.paused) {
                    socialSharing.addClass('playing');
                    media.pause();
                }

                socialSharing.addClass('active');
            }

            // Closing overlay
            else {

                // If video was playing before, start playing again
                if (socialSharing.hasClass('playing')) {
                    socialSharing.removeClass('playing');
                    media.paused ? media.play() : "";
                }
                socialSharing.removeClass('active');
            }
        }
    });

})(mejs.$);
//
// owlCarousel old - we don't know origin for this library - which version is this and so on
// in order to fix conflict between old and new owl.carousel plugin renaming
// owlCarousel to owlCarouselX
// it looks like old one is used in corporate-communications.js while car-configurator and
// gallery grid module are dependent on new one added through bower-components repos
// ------------------------------------------------------------------------------------------
//
! function($, t, e, i) {
    function s(t, e) {
        this.settings = null, this.options = $.extend({}, s.Defaults, e), this.$element = $(t), this.state = $.extend({}, a), this.e = $.extend({}, l), this._plugins = {}, this._supress = {}, this._current = null, this._speed = null, this._coordinates = [], this._breakpoint = null, this._width = null, this._items = [], this._clones = [], this._mergers = [], this._invalidated = {}, this._pipe = [], $.each(s.Plugins, $.proxy(function(t, e) {
            this._plugins[t[0].toLowerCase() + t.slice(1)] = new e(this)
        }, this)), $.each(s.Pipe, $.proxy(function(t, e) {
            this._pipe.push({
                filter: e.filter,
                run: $.proxy(e.run, this)
            })
        }, this)), this.setup(), this.initialize()
    }

    function n(t) {
        var i, s, n = e.createElement("div"),
            r = t;
        for (i in r)
            if (s = r[i], "undefined" != typeof n.style[s]) return n = null, [s, i];
        return [!1]
    }

    function r() {
        return n(["transition", "WebkitTransition", "MozTransition", "OTransition"])[1]
    }

    function o() {
        return n(["transform", "WebkitTransform", "MozTransform", "OTransform", "msTransform"])[0]
    }

    function h() {
        return n(["perspective", "webkitPerspective", "MozPerspective", "OPerspective", "MsPerspective"])[0]
    }
    var a, l;
    a = {
        isScrolling: !1,
        isSwiping: !1,
        direction: !1,
        inMotion: !1
    }, l = {
        _transitionEnd: null,
        _resizer: null,
        _responsiveCall: null,
        _goToLoop: null,
        _checkVisibile: null
    }, s.Defaults = {
        items: 3,
        margin: 0,
        stagePadding: 0,
        startPosition: 0,
        smartSpeed: 250,
        fluidSpeed: !1,
        responsive: {},
        responsiveRefreshRate: 200,
        responsiveBaseElement: t,
        responsiveClass: !1,
        fallbackEasing: "swing",
        itemElement: "li",
        stageElement: "ul",
        baseClass: "owl-carousel",
        itemClass: "owl-item",
        activeClass: "active"
    }, s.Width = {
        Default: "default",
        Inner: "inner",
        Outer: "outer"
    }, s.Plugins = {}, s.Pipe = [{
        filter: ["width", "items", "settings"],
        run: function(t) {
            t.current = this._items && this._items[this.relative(this._current)]
        }
    }, {
        filter: ["width", "items", "settings"],
        run: function() {
            var t = (this.width() / this.settings.items).toFixed(3),
                e = 0,
                i, s;
            for (this._coordinates = [], i = 0, s = this._clones.length + this._items.length; s > i; i++) e += -1 * t, this._coordinates.push(e)
        }
    }, {
        filter: ["width", "items", "settings"],
        run: function() {
            var t, e, i = (this.width() / this.settings.items).toFixed(3),
                s = {
                    width: Math.abs(this._coordinates[this._coordinates.length - 1]) + 2 * this.settings.stagePadding,
                    "padding-left": this.settings.stagePadding || "",
                    "padding-right": this.settings.stagePadding || ""
                };
            this.$stage.css(s), s = {
                width: Math.floor(10 * (i - this.settings.margin)) / 10
            }, s["margin-right"] = this.settings.margin, this.$stage.children().css(s)
        }
    }, {
        filter: ["width", "items", "settings"],
        run: function(t) {
            t.current && this.reset(this.$stage.children().index(t.current))
        }
    }, {
        filter: ["position"],
        run: function() {
            this.animate(this.coordinates(this._current))
        }
    }, {
        filter: ["width", "position", "items", "settings"],
        run: function() {
            var t = 2 * this.settings.stagePadding,
                e = this.coordinates(this.current()) + t,
                i = e + -1 * this.width(),
                s, n, r = [],
                o, h;
            for (o = 0, h = this._coordinates.length; h > o; o++) s = this._coordinates[o - 1] || 0, n = Math.abs(this._coordinates[o]) + -1 * t, (e >= s && s > i || e > n && n > i) && r.push(o);
            this.$stage.children("." + this.settings.activeClass).removeClass(this.settings.activeClass), this.$stage.children(":eq(" + r.join("), :eq(") + ")").addClass(this.settings.activeClass)
        }
    }], s.prototype.initialize = function() {
        this.trigger("initialize"), this.browserSupport(), this.$element.addClass("owl-loading"), this.$stage = this.$element.find(".owl-stage"), this.replace(this.$stage.children().not(this.$stage.parent())), this._width = this.$element.width(), this.refresh(), this.$element.removeClass("owl-loading").addClass("owl-loaded"), this.eventsCall(), this.internalEvents(), this.addTriggerableEvents(), this.trigger("initialized")
    }, s.prototype.setup = function() {
        var t = this.viewport(),
            e = this.options.responsive,
            i = -1,
            s = null;
        e ? ($.each(e, function(e) {
            t >= e && e > i && (i = Number(e))
        }), s = $.extend({}, this.options, e[i]), delete s.responsive, s.responsiveClass && this.$element.attr("class", function(t, e) {
            return e.replace(/\b owl-responsive-\S+/g, "")
        }).addClass("owl-responsive-" + i)) : s = $.extend({}, this.options), (null === this.settings || this._breakpoint !== i) && (this.trigger("change", {
            property: {
                name: "settings",
                value: s
            }
        }), this._breakpoint = i, this.settings = s, this.invalidate("settings"), this.trigger("changed", {
            property: {
                name: "settings",
                value: this.settings
            }
        }))
    }, s.prototype.prepare = function(t) {
        var e = this.trigger("prepare", {
            content: t
        });
        return e.data || (e.data = $("<" + this.settings.itemElement + "/>").addClass(this.settings.itemClass).append(t)), this.trigger("prepared", {
            content: e.data
        }), e.data
    }, s.prototype.update = function() {
        for (var t = 0, e = this._pipe.length, i = $.proxy(function(t) {
                return this[t]
            }, this._invalidated), s = {}; e > t;)(this._invalidated.all || $.grep(this._pipe[t].filter, i).length > 0) && this._pipe[t].run(s), t++;
        this._invalidated = {}
    }, s.prototype.width = function(t) {
        switch (t = t || s.Width.Default) {
            case s.Width.Inner:
            case s.Width.Outer:
                return this._width;
            default:
                return this._width - 2 * this.settings.stagePadding + this.settings.margin
        }
    }, s.prototype.refresh = function() {
        if (0 === this._items.length) return !1;
        var e = (new Date).getTime();
        this.trigger("refresh"), this.setup(), this.$stage.addClass("owl-refresh"), this.update(), this.$stage.removeClass("owl-refresh"), this.state.orientation = t.orientation, this.watchVisibility(), this.trigger("refreshed")
    }, s.prototype.eventsCall = function() {
        this.e._onResize = $.proxy(function(t) {
            this.onResize(t)
        }, this), this.e._transitionEnd = $.proxy(function(t) {
            this.transitionEnd(t)
        }, this), this.e._preventClick = $.proxy(function(t) {
            this.preventClick(t)
        }, this)
    }, s.prototype.onThrottledResize = function() {
        t.clearTimeout(this.resizeTimer), this.resizeTimer = t.setTimeout(this.e._onResize, this.settings.responsiveRefreshRate)
    }, s.prototype.onResize = function() {
        return this._items.length ? this._width === this.$element.width() ? !1 : this.trigger("resize").isDefaultPrevented() ? !1 : (this._width = this.$element.width(), this.invalidate("width"), this.refresh(), void this.trigger("resized")) : !1
    }, s.prototype.internalEvents = function() {
        this.transitionEndVendor && this.on(this.$stage.get(0), this.transitionEndVendor, this.e._transitionEnd, !1), this.settings.responsive !== !1 && this.on(t, "resize", $.proxy(this.onThrottledResize, this))
    }, s.prototype.preventClick = function(t) {
        t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), $(t.target).off("click.preventClick")
    }, s.prototype.getTransformProperty = function() {
        var e, i;
        return e = t.getComputedStyle(this.$stage.get(0), null).getPropertyValue(this.vendorName + "transform"), e = e.replace(/matrix(3d)?\(|\)/g, "").split(","), i = 16 === e.length, i !== !0 ? e[4] : e[12]
    }, s.prototype.closest = function(t) {
        var e = -1,
            i = 30,
            s = this.width(),
            n = this.coordinates();
        return t > n[this.minimum()] ? e = t = this.minimum() : t < n[this.maximum()] && (e = t = this.maximum()), e
    }, s.prototype.animate = function(t) {
        this.trigger("translate"), this.state.inMotion = this.speed() > 0, this.support3d ? this.$stage.css({
            transform: "translate3d(" + t + "px,0px, 0px)",
            transition: this.speed() / 1e3 + "s"
        }) : this.$stage.animate({
            left: t
        }, this.speed() / 1e3, this.settings.fallbackEasing, $.proxy(function() {
            this.state.inMotion && this.transitionEnd()
        }, this))
    }, s.prototype.current = function(t) {
        if (t === i) return this._current;
        if (0 === this._items.length) return i;
        if (t = this.normalize(t), this._current !== t) {
            var e = this.trigger("change", {
                property: {
                    name: "position",
                    value: t
                }
            });
            e.data !== i && (t = this.normalize(e.data)), this._current = t, this.invalidate("position"), this.trigger("changed", {
                property: {
                    name: "position",
                    value: this._current
                }
            })
        }
        return this._current
    }, s.prototype.invalidate = function(t) {
        this._invalidated[t] = !0
    }, s.prototype.reset = function(t) {
        t = this.normalize(t), t !== i && (this._speed = 0, this._current = t, this.suppress(["translate", "translated"]), this.animate(this.coordinates(t)), this.release(["translate", "translated"]))
    }, s.prototype.normalize = function(t, e) {
        var s = e ? this._items.length : this._items.length + this._clones.length;
        return !$.isNumeric(t) || 1 > s ? i : t = this._clones.length ? (t % s + s) % s : Math.max(this.minimum(e), Math.min(this.maximum(e), t))
    }, s.prototype.relative = function(t) {
        return t = this.normalize(t), t -= this._clones.length / 2, this.normalize(t, !0)
    }, s.prototype.maximum = function(t) {
        var e, i, s = 0,
            n, r = this.settings;
        return t ? this._items.length - 1 : e = this._items.length - r.items
    }, s.prototype.minimum = function(t) {
        return t ? 0 : this._clones.length / 2
    }, s.prototype.items = function(t) {
        return t === i ? this._items.slice() : (t = this.normalize(t, !0), this._items[t])
    }, s.prototype.speed = function(t) {
        return t !== i && (this._speed = t), this._speed
    }, s.prototype.coordinates = function(t) {
        var e = null;
        return t === i ? $.map(this._coordinates, $.proxy(function(t, e) {
            return this.coordinates(e)
        }, this)) : e = this._coordinates[t - 1] || 0
    }, s.prototype.duration = function(t, e, i) {
        return Math.min(Math.max(Math.abs(e - t), 1), 6) * Math.abs(i || this.settings.smartSpeed)
    }, s.prototype.to = function(t, e) {
        this.speed(this.duration(this.current(), t, e)), this.current(t), this.update()
    }, s.prototype.next = function(t) {
        t = t || !1, this.to(this.relative(this.current()) + 1, t)
    }, s.prototype.prev = function(t) {
        t = t || !1, this.to(this.relative(this.current()) - 1, t)
    }, s.prototype.transitionEnd = function(t) {
        return t !== i && (t.stopPropagation(), (t.target || t.srcElement || t.originalTarget) !== this.$stage.get(0)) ? !1 : (this.state.inMotion = !1, void this.trigger("translated"))
    }, s.prototype.viewport = function() {
        var i;
        if (this.options.responsiveBaseElement !== t) i = $(this.options.responsiveBaseElement).width();
        else if (t.innerWidth) i = t.innerWidth;
        else {
            if (!e.documentElement || !e.documentElement.clientWidth) throw "Can not detect viewport width.";
            i = e.documentElement.clientWidth
        }
        return i
    }, s.prototype.replace = function(t) {
        this.$stage.empty(), this._items = [], t && (t = t instanceof jQuery ? t : $(t)), t.filter(function() {
            return 1 === this.nodeType
        }).each($.proxy(function(t, e) {
            e = this.prepare(e), this.$stage.append(e), this._items.push(e), this._mergers.push(1 * e.find("[data-merge]").andSelf("[data-merge]").attr("data-merge") || 1)
        }, this)), this.reset($.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0), this.invalidate("items")
    }, s.prototype.addTriggerableEvents = function() {
        var t = $.proxy(function(t, e) {
            return $.proxy(function(i) {
                i.relatedTarget !== this && (this.suppress([e]), t.apply(this, [].slice.call(arguments, 1)), this.release([e]))
            }, this)
        }, this);
        $.each({
            next: this.next,
            prev: this.prev,
            to: this.to,
            refresh: this.refresh
        }, $.proxy(function(e, i) {
            this.$element.on(e + ".owl.carousel", t(i, e + ".owl.carousel"))
        }, this))
    }, s.prototype.watchVisibility = function() {
        function e(t) {
            return t.offsetWidth > 0 && t.offsetHeight > 0
        }

        function i() {
            e(this.$element.get(0)) && (this.$element.removeClass("owl-hidden"), this.refresh(), t.clearInterval(this.e._checkVisibile))
        }
        e(this.$element.get(0)) || (this.$element.addClass("owl-hidden"), t.clearInterval(this.e._checkVisibile), this.e._checkVisibile = t.setInterval($.proxy(i, this), 500))
    }, s.prototype.on = function(t, e, i, s) {
        t.addEventListener ? t.addEventListener(e, i, s) : t.attachEvent && t.attachEvent("on" + e, i)
    }, s.prototype.off = function(t, e, i, s) {
        t.removeEventListener ? t.removeEventListener(e, i, s) : t.detachEvent && t.detachEvent("on" + e, i)
    }, s.prototype.trigger = function(t, e, i) {
        var s = {
                item: {
                    count: this._items.length,
                    index: this.current()
                }
            },
            n = $.camelCase($.grep(["on", t, i], function(t) {
                return t
            }).join("-").toLowerCase()),
            r = $.Event([t, "owl", i || "carousel"].join(".").toLowerCase(), $.extend({
                relatedTarget: this
            }, s, e));
        return this._supress[t] || ($.each(this._plugins, function(t, e) {
            e.onTrigger && e.onTrigger(r)
        }), this.$element.trigger(r), this.settings && "function" == typeof this.settings[n] && this.settings[n].apply(this, r)), r
    }, s.prototype.suppress = function(t) {
        $.each(t, $.proxy(function(t, e) {
            this._supress[e] = !0
        }, this))
    }, s.prototype.release = function(t) {
        $.each(t, $.proxy(function(t, e) {
            delete this._supress[e]
        }, this))
    }, s.prototype.browserSupport = function() {
        if (this.support3d = h(), this.support3d) {
            this.transformVendor = o();
            var e = ["transitionend", "webkitTransitionEnd", "transitionend", "oTransitionEnd"];
            this.transitionEndVendor = e[r()], this.vendorName = this.transformVendor.replace(/Transform/i, ""), this.vendorName = "" !== this.vendorName ? "-" + this.vendorName.toLowerCase() + "-" : ""
        }
        this.state.orientation = t.orientation
    }, $.fn.owlCarouselX = function(t) {
        return this.each(function() {
            $(this).data("owlCarouselX") || $(this).data("owlCarouselX", new s(this, t))
        })
    }, $.fn.owlCarouselX.Constructor = s
}(window.jQuery, window, document),
function($, t, e, i) {
    "use strict";
    var s = function(t) {
        this._core = t, this._initialized = !1, this._pages = [], this._controls = {}, this._templates = [], this.$element = this._core.$element, this._overrides = {
            next: this._core.next,
            prev: this._core.prev,
            to: this._core.to
        }, this._handlers = {
            "changed.owl.carousel": $.proxy(function(t) {
                "position" == t.property.name && this.draw()
            }, this),
            "refreshed.owl.carousel": $.proxy(function() {
                this._initialized || (this.initialize(), this._initialized = !0), this._core.trigger("refresh", null, "navigation"), this.update(), this.draw(), this._core.trigger("refreshed", null, "navigation")
            }, this)
        }, this._core.options = $.extend({}, s.Defaults, this._core.options), this.$element.on(this._handlers)
    };
    s.Defaults = {
        nav: !1,
        navText: ["prev", "next"],
        navElement: "div",
        navContainerClass: "owl-nav",
        navClass: ["owl-prev", "owl-next"],
        slideBy: 1,
        controlsClass: "owl-controls"
    }, s.prototype.initialize = function() {
        var t, e, i = this._core.settings;
        this._controls.$container = $("<div>").addClass(i.controlsClass).appendTo(this.$element), t = $("<div>").addClass(i.navContainerClass).prependTo(this._controls.$container), this._controls.$next = $("<" + i.navElement + ">"), this._controls.$previous = this._controls.$next.clone(), this._controls.$previous.addClass(i.navClass[0]).html(i.navText[0]).hide().prependTo(t).on("click", $.proxy(function(t) {
            this.prev(!1)
        }, this)), this._controls.$next.addClass(i.navClass[1]).html(i.navText[1]).hide().appendTo(t).on("click", $.proxy(function(t) {
            this.next(!1)
        }, this));
        for (e in this._overrides) this._core[e] = $.proxy(this[e], this)
    }, s.prototype.update = function() {
        var t, e, i, s = this._core.settings,
            n = 0,
            r = n + this._core.items().length,
            o = s.dotData ? 1 : s.dotsEach || s.items;
        "page" !== s.slideBy && (s.slideBy = Math.min(s.slideBy, s.items))
    }, s.prototype.draw = function() {
        var t, e, i = this._core.settings,
            s = this._core.relative(this._core.current());
        i.nav && (this._controls.$previous.toggleClass("disabled", 0 >= s), this._controls.$next.toggleClass("disabled", s >= this._core.maximum())), this._controls.$previous.toggle(i.nav), this._controls.$next.toggle(i.nav)
    }, s.prototype.onTrigger = function(t) {
        var e = this._core.settings;
        t.page = {
            index: $.inArray(this.current(), this._pages),
            count: this._pages.length,
            size: e && (e.dotData ? 1 : e.dotsEach || e.items)
        }
    }, s.prototype.current = function() {
        var t = this._core.relative(this._core.current());
        return $.grep(this._pages, function(e) {
            return e.start <= t && e.end >= t
        }).pop()
    }, s.prototype.getPosition = function(t) {
        var e, i, s = this._core.settings;
        return "page" == s.slideBy ? (e = $.inArray(this.current(), this._pages), i = this._pages.length, t ? ++e : --e, e = this._pages[(e % i + i) % i].start) : (e = this._core.relative(this._core.current()), i = this._core.items().length, t ? e += s.slideBy : e -= s.slideBy), e
    }, s.prototype.next = function(t) {
        $.proxy(this._overrides.to, this._core)(this.getPosition(!0), t)
    }, s.prototype.prev = function(t) {
        $.proxy(this._overrides.to, this._core)(this.getPosition(!1), t)
    }, s.prototype.to = function(t, e, i) {
        var s;
        i ? $.proxy(this._overrides.to, this._core)(t, e) : (s = this._pages.length, $.proxy(this._overrides.to, this._core)(this._pages[(t % s + s) % s].start, e))
    }, $.fn.owlCarouselX.Constructor.Plugins.Navigation = s
}(window.jQuery, window, document);
// Generated by CoffeeScript 1.9.2

/**
@license Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
 */

(function() {
    var $, win;

    $ = this.jQuery || window.jQuery;

    win = $(window);

    $.fn.stick_in_parent = function(opts) {
        var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, parent_selector, recalc_every, sticky_class;
        if (opts == null) {
            opts = {};
        }
        sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
        if (offset_top == null) {
            offset_top = 0;
        }
        if (parent_selector == null) {
            parent_selector = void 0;
        }
        if (inner_scrolling == null) {
            inner_scrolling = true;
        }
        if (sticky_class == null) {
            sticky_class = "is_stuck";
        }
        doc = $(document);
        if (enable_bottoming == null) {
            enable_bottoming = true;
        }
        fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
            var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
            if (elm.data("sticky_kit")) {
                return;
            }
            elm.data("sticky_kit", true);
            last_scroll_height = doc.height();
            parent = elm.parent();
            if (parent_selector != null) {
                parent = parent.closest(parent_selector);
            }
            if (!parent.length) {
                throw "failed to find stick parent";
            }
            fixed = false;
            bottomed = false;
            spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
            if (spacer) {
                spacer.css('position', elm.css('position'));
            }
            recalc = function() {
                var border_top, padding_top, restore;
                if (detached) {
                    return;
                }
                last_scroll_height = doc.height();
                border_top = parseInt(parent.css("border-top-width"), 10);
                padding_top = parseInt(parent.css("padding-top"), 10);
                padding_bottom = parseInt(parent.css("padding-bottom"), 10);
                parent_top = parent.offset().top + border_top + padding_top;
                parent_height = parent.height();
                if (fixed) {
                    fixed = false;
                    bottomed = false;
                    if (manual_spacer == null) {
                        elm.insertAfter(spacer);
                        spacer.detach();
                    }
                    elm.css({
                        position: "",
                        top: "",
                        width: "",
                        bottom: ""
                    }).removeClass(sticky_class);
                    restore = true;
                }
                top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top;
                height = elm.outerHeight(true);
                el_float = elm.css("float");
                if (spacer) {
                    spacer.css({
                        width: elm.outerWidth(true),
                        height: height,
                        display: elm.css("display"),
                        "vertical-align": elm.css("vertical-align"),
                        "float": el_float
                    });
                }
                if (restore) {
                    return tick();
                }
            };
            recalc();
            if (height === parent_height) {
                return;
            }
            last_pos = void 0;
            offset = offset_top;
            recalc_counter = recalc_every;
            tick = function() {
                var css, delta, recalced, scroll, will_bottom, win_height;
                if (detached) {
                    return;
                }
                recalced = false;
                if (recalc_counter != null) {
                    recalc_counter -= 1;
                    if (recalc_counter <= 0) {
                        recalc_counter = recalc_every;
                        recalc();
                        recalced = true;
                    }
                }
                if (!recalced && doc.height() !== last_scroll_height) {
                    recalc();
                    recalced = true;
                }
                scroll = win.scrollTop();
                if (last_pos != null) {
                    delta = scroll - last_pos;
                }
                last_pos = scroll;
                if (fixed) {
                    if (enable_bottoming) {
                        will_bottom = scroll + height + offset > parent_height + parent_top;
                        if (bottomed && !will_bottom) {
                            bottomed = false;
                            elm.css({
                                position: "fixed",
                                bottom: "",
                                top: offset
                            }).trigger("sticky_kit:unbottom");
                        }
                    }
                    if (scroll < top) {
                        fixed = false;
                        offset = offset_top;
                        if (manual_spacer == null) {
                            if (el_float === "left" || el_float === "right") {
                                elm.insertAfter(spacer);
                            }
                            spacer.detach();
                        }
                        css = {
                            position: "",
                            width: "",
                            top: ""
                        };
                        elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick");
                    }
                    if (inner_scrolling) {
                        win_height = win.height();
                        if (height + offset_top > win_height) {
                            if (!bottomed) {
                                offset -= delta;
                                offset = Math.max(win_height - height, offset);
                                offset = Math.min(offset_top, offset);
                                if (fixed) {
                                    elm.css({
                                        top: offset + "px"
                                    });
                                }
                            }
                        }
                    }
                } else {
                    if (scroll > top) {
                        fixed = true;
                        css = {
                            position: "fixed",
                            top: offset
                        };
                        css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
                        elm.css(css).addClass(sticky_class);
                        if (manual_spacer == null) {
                            elm.after(spacer);
                            if (el_float === "left" || el_float === "right") {
                                spacer.append(elm);
                            }
                        }
                        elm.trigger("sticky_kit:stick");
                    }
                }
                if (fixed && enable_bottoming) {
                    if (will_bottom == null) {
                        will_bottom = scroll + height + offset > parent_height + parent_top;
                    }
                    if (!bottomed && will_bottom) {
                        bottomed = true;
                        if (parent.css("position") === "static") {
                            parent.css({
                                position: "relative"
                            });
                        }
                        return elm.css({
                            position: "absolute",
                            bottom: padding_bottom,
                            top: "auto"
                        }).trigger("sticky_kit:bottom");
                    }
                }
            };
            recalc_and_tick = function() {
                recalc();
                return tick();
            };
            detach = function() {
                detached = true;
                win.off("touchmove", tick);
                win.off("scroll", tick);
                win.off("resize", recalc_and_tick);
                $(document.body).off("sticky_kit:recalc", recalc_and_tick);
                elm.off("sticky_kit:detach", detach);
                elm.removeData("sticky_kit");
                elm.css({
                    position: "",
                    bottom: "",
                    top: "",
                    width: ""
                });
                parent.position("position", "");
                if (fixed) {
                    if (manual_spacer == null) {
                        if (el_float === "left" || el_float === "right") {
                            elm.insertAfter(spacer);
                        }
                        spacer.remove();
                    }
                    return elm.removeClass(sticky_class);
                }
            };
            win.on("touchmove", tick);
            win.on("scroll", tick);
            win.on("resize", recalc_and_tick);
            $(document.body).on("sticky_kit:recalc", recalc_and_tick);
            elm.on("sticky_kit:detach", detach);
            return setTimeout(tick, 0);
        };
        for (i = 0, len = this.length; i < len; i++) {
            elm = this[i];
            fn($(elm));
        }
        return this;
    };

}).call(this);

/*!
 * @copyright Copyright &copy; Kartik Visweswaran, Krajee.com, 2014 - 2015
 * @version 1.3.3
 *
 * Date formatter utility library that allows formatting date/time variables or Date objects using PHP DateTime format.
 * @see http://php.net/manual/en/function.date.php
 *
 * For more JQuery plugins visit http://plugins.krajee.com
 * For more Yii related demos visit http://demos.krajee.com
 */
var DateFormatter;
(function() {
    "use strict";

    var _compare, _lpad, _extend, defaultSettings, DAY, HOUR;
    DAY = 1000 * 60 * 60 * 24;
    HOUR = 3600;

    _compare = function(str1, str2) {
        return typeof(str1) === 'string' && typeof(str2) === 'string' && str1.toLowerCase() === str2.toLowerCase();
    };
    _lpad = function(value, length, char) {
        var chr = char || '0',
            val = value.toString();
        return val.length < length ? _lpad(chr + val, length) : val;
    };
    _extend = function(out) {
        var i, obj;
        out = out || {};
        for (i = 1; i < arguments.length; i++) {
            obj = arguments[i];
            if (!obj) {
                continue;
            }
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (typeof obj[key] === 'object') {
                        _extend(out[key], obj[key]);
                    } else {
                        out[key] = obj[key];
                    }
                }
            }
        }
        return out;
    };
    defaultSettings = {
        dateSettings: {
            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            months: [
                'January', 'February', 'March', 'April', 'May', 'June', 'July',
                'August', 'September', 'October', 'November', 'December'
            ],
            monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            meridiem: ['AM', 'PM'],
            ordinal: function(number) {
                var n = number % 10,
                    suffixes = {
                        1: 'st',
                        2: 'nd',
                        3: 'rd'
                    };
                return Math.floor(number % 100 / 10) === 1 || !suffixes[n] ? 'th' : suffixes[n];
            }
        },
        separators: /[ \-+\/\.T:@]/g,
        validParts: /[dDjlNSwzWFmMntLoYyaABgGhHisueTIOPZcrU]/g,
        intParts: /[djwNzmnyYhHgGis]/g,
        tzParts: /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        tzClip: /[^-+\dA-Z]/g
    };

    DateFormatter = function(options) {
        var self = this,
            config = _extend(defaultSettings, options);
        self.dateSettings = config.dateSettings;
        self.separators = config.separators;
        self.validParts = config.validParts;
        self.intParts = config.intParts;
        self.tzParts = config.tzParts;
        self.tzClip = config.tzClip;
    };

    DateFormatter.prototype = {
        constructor: DateFormatter,
        parseDate: function(vDate, vFormat) {
            var self = this,
                vFormatParts, vDateParts, i, vDateFlag = false,
                vTimeFlag = false,
                vDatePart, iDatePart,
                vSettings = self.dateSettings,
                vMonth, vMeriIndex, vMeriOffset, len, mer,
                out = {
                    date: null,
                    year: null,
                    month: null,
                    day: null,
                    hour: 0,
                    min: 0,
                    sec: 0
                };
            if (!vDate) {
                return undefined;
            }
            if (vDate instanceof Date) {
                return vDate;
            }
            if (typeof vDate === 'number') {
                return new Date(vDate);
            }
            if (vFormat === 'U') {
                i = parseInt(vDate);
                return i ? new Date(i * 1000) : vDate;
            }
            if (typeof vDate !== 'string') {
                return '';
            }
            vFormatParts = vFormat.match(self.validParts);
            if (!vFormatParts || vFormatParts.length === 0) {
                throw new Error("Invalid date format definition.");
            }
            vDateParts = vDate.replace(self.separators, '\0').split('\0');
            for (i = 0; i < vDateParts.length; i++) {
                vDatePart = vDateParts[i];
                iDatePart = parseInt(vDatePart);
                switch (vFormatParts[i]) {
                    case 'y':
                    case 'Y':
                        len = vDatePart.length;
                        if (len === 2) {
                            out.year = parseInt((iDatePart < 70 ? '20' : '19') + vDatePart);
                        } else if (len === 4) {
                            out.year = iDatePart;
                        }
                        vDateFlag = true;
                        break;
                    case 'm':
                    case 'n':
                    case 'M':
                    case 'F':
                        if (isNaN(vDatePart)) {
                            vMonth = vSettings.monthsShort.indexOf(vDatePart);
                            if (vMonth > -1) {
                                out.month = vMonth + 1;
                            }
                            vMonth = vSettings.months.indexOf(vDatePart);
                            if (vMonth > -1) {
                                out.month = vMonth + 1;
                            }
                        } else {
                            if (iDatePart >= 1 && iDatePart <= 12) {
                                out.month = iDatePart;
                            }
                        }
                        vDateFlag = true;
                        break;
                    case 'd':
                    case 'j':
                        if (iDatePart >= 1 && iDatePart <= 31) {
                            out.day = iDatePart;
                        }
                        vDateFlag = true;
                        break;
                    case 'g':
                    case 'h':
                        vMeriIndex = (vFormatParts.indexOf('a') > -1) ? vFormatParts.indexOf('a') :
                            (vFormatParts.indexOf('A') > -1) ? vFormatParts.indexOf('A') : -1;
                        mer = vDateParts[vMeriIndex];
                        if (vMeriIndex > -1) {
                            vMeriOffset = _compare(mer, vSettings.meridiem[0]) ? 0 :
                                (_compare(mer, vSettings.meridiem[1]) ? 12 : -1);
                            if (iDatePart >= 1 && iDatePart <= 12 && vMeriOffset > -1) {
                                out.hour = iDatePart + vMeriOffset - 1;
                            } else if (iDatePart >= 0 && iDatePart <= 23) {
                                out.hour = iDatePart;
                            }
                        } else if (iDatePart >= 0 && iDatePart <= 23) {
                            out.hour = iDatePart;
                        }
                        vTimeFlag = true;
                        break;
                    case 'G':
                    case 'H':
                        if (iDatePart >= 0 && iDatePart <= 23) {
                            out.hour = iDatePart;
                        }
                        vTimeFlag = true;
                        break;
                    case 'i':
                        if (iDatePart >= 0 && iDatePart <= 59) {
                            out.min = iDatePart;
                        }
                        vTimeFlag = true;
                        break;
                    case 's':
                        if (iDatePart >= 0 && iDatePart <= 59) {
                            out.sec = iDatePart;
                        }
                        vTimeFlag = true;
                        break;
                }
            }
            if (vDateFlag === true && out.year && out.month && out.day) {
                out.date = new Date(out.year, out.month - 1, out.day, out.hour, out.min, out.sec, 0);
            } else {
                if (vTimeFlag !== true) {
                    return false;
                }
                out.date = new Date(0, 0, 0, out.hour, out.min, out.sec, 0);
            }
            return out.date;
        },
        guessDate: function(vDateStr, vFormat) {
            if (typeof vDateStr !== 'string') {
                return vDateStr;
            }
            var self = this,
                vParts = vDateStr.replace(self.separators, '\0').split('\0'),
                vPattern = /^[djmn]/g,
                vFormatParts = vFormat.match(self.validParts),
                vDate = new Date(),
                vDigit = 0,
                vYear, i, iPart, iSec;

            if (!vPattern.test(vFormatParts[0])) {
                return vDateStr;
            }

            for (i = 0; i < vParts.length; i++) {
                vDigit = 2;
                iPart = vParts[i];
                iSec = parseInt(iPart.substr(0, 2));
                switch (i) {
                    case 0:
                        if (vFormatParts[0] === 'm' || vFormatParts[0] === 'n') {
                            vDate.setMonth(iSec - 1);
                        } else {
                            vDate.setDate(iSec);
                        }
                        break;
                    case 1:
                        if (vFormatParts[0] === 'm' || vFormatParts[0] === 'n') {
                            vDate.setDate(iSec);
                        } else {
                            vDate.setMonth(iSec - 1);
                        }
                        break;
                    case 2:
                        vYear = vDate.getFullYear();
                        if (iPart.length < 4) {
                            vDate.setFullYear(parseInt(vYear.toString().substr(0, 4 - iPart.length) + iPart));
                            vDigit = iPart.length;
                        } else {
                            vDate.setFullYear = parseInt(iPart.substr(0, 4));
                            vDigit = 4;
                        }
                        break;
                    case 3:
                        vDate.setHours(iSec);
                        break;
                    case 4:
                        vDate.setMinutes(iSec);
                        break;
                    case 5:
                        vDate.setSeconds(iSec);
                        break;
                }
                if (iPart.substr(vDigit).length > 0) {
                    vParts.splice(i + 1, 0, iPart.substr(vDigit));
                }
            }
            return vDate;
        },
        parseFormat: function(vChar, vDate) {
            var self = this,
                vSettings = self.dateSettings,
                fmt, backspace = /\\?(.?)/gi,
                doFormat = function(t, s) {
                    return fmt[t] ? fmt[t]() : s;
                };
            fmt = {
                /////////
                // DAY //
                /////////
                /**
                 * Day of month with leading 0: `01..31`
                 * @return {string}
                 */
                d: function() {
                    return _lpad(fmt.j(), 2);
                },
                /**
                 * Shorthand day name: `Mon...Sun`
                 * @return {string}
                 */
                D: function() {
                    return vSettings.daysShort[fmt.w()];
                },
                /**
                 * Day of month: `1..31`
                 * @return {number}
                 */
                j: function() {
                    return vDate.getDate();
                },
                /**
                 * Full day name: `Monday...Sunday`
                 * @return {number}
                 */
                l: function() {
                    return vSettings.days[fmt.w()];
                },
                /**
                 * ISO-8601 day of week: `1[Mon]..7[Sun]`
                 * @return {number}
                 */
                N: function() {
                    return fmt.w() || 7;
                },
                /**
                 * Day of week: `0[Sun]..6[Sat]`
                 * @return {number}
                 */
                w: function() {
                    return vDate.getDay();
                },
                /**
                 * Day of year: `0..365`
                 * @return {number}
                 */
                z: function() {
                    var a = new Date(fmt.Y(), fmt.n() - 1, fmt.j()),
                        b = new Date(fmt.Y(), 0, 1);
                    return Math.round((a - b) / DAY);
                },

                //////////
                // WEEK //
                //////////
                /**
                 * ISO-8601 week number
                 * @return {number}
                 */
                W: function() {
                    var a = new Date(fmt.Y(), fmt.n() - 1, fmt.j() - fmt.N() + 3),
                        b = new Date(a.getFullYear(), 0, 4);
                    return _lpad(1 + Math.round((a - b) / DAY / 7), 2);
                },

                ///////////
                // MONTH //
                ///////////
                /**
                 * Full month name: `January...December`
                 * @return {string}
                 */
                F: function() {
                    return vSettings.months[vDate.getMonth()];
                },
                /**
                 * Month w/leading 0: `01..12`
                 * @return {string}
                 */
                m: function() {
                    return _lpad(fmt.n(), 2);
                },
                /**
                 * Shorthand month name; `Jan...Dec`
                 * @return {string}
                 */
                M: function() {
                    return vSettings.monthsShort[vDate.getMonth()];
                },
                /**
                 * Month: `1...12`
                 * @return {number}
                 */
                n: function() {
                    return vDate.getMonth() + 1;
                },
                /**
                 * Days in month: `28...31`
                 * @return {number}
                 */
                t: function() {
                    return (new Date(fmt.Y(), fmt.n(), 0)).getDate();
                },

                //////////
                // YEAR //
                //////////
                /**
                 * Is leap year? `0 or 1`
                 * @return {number}
                 */
                L: function() {
                    var Y = fmt.Y();
                    return (Y % 4 === 0 && Y % 100 !== 0 || Y % 400 === 0) ? 1 : 0;
                },
                /**
                 * ISO-8601 year
                 * @return {number}
                 */
                o: function() {
                    var n = fmt.n(),
                        W = fmt.W(),
                        Y = fmt.Y();
                    return Y + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0);
                },
                /**
                 * Full year: `e.g. 1980...2010`
                 * @return {number}
                 */
                Y: function() {
                    return vDate.getFullYear();
                },
                /**
                 * Last two digits of year: `00...99`
                 * @return {string}
                 */
                y: function() {
                    return fmt.Y().toString().slice(-2);
                },

                //////////
                // TIME //
                //////////
                /**
                 * Meridian lower: `am or pm`
                 * @return {string}
                 */
                a: function() {
                    return fmt.A().toLowerCase();
                },
                /**
                 * Meridian upper: `AM or PM`
                 * @return {string}
                 */
                A: function() {
                    var n = fmt.G() < 12 ? 0 : 1;
                    return vSettings.meridiem[n];
                },
                /**
                 * Swatch Internet time: `000..999`
                 * @return {string}
                 */
                B: function() {
                    var H = vDate.getUTCHours() * HOUR,
                        i = vDate.getUTCMinutes() * 60,
                        s = vDate.getUTCSeconds();
                    return _lpad(Math.floor((H + i + s + HOUR) / 86.4) % 1000, 3);
                },
                /**
                 * 12-Hours: `1..12`
                 * @return {number}
                 */
                g: function() {
                    return fmt.G() % 12 || 12;
                },
                /**
                 * 24-Hours: `0..23`
                 * @return {number}
                 */
                G: function() {
                    return vDate.getHours();
                },
                /**
                 * 12-Hours with leading 0: `01..12`
                 * @return {string}
                 */
                h: function() {
                    return _lpad(fmt.g(), 2);
                },
                /**
                 * 24-Hours w/leading 0: `00..23`
                 * @return {string}
                 */
                H: function() {
                    return _lpad(fmt.G(), 2);
                },
                /**
                 * Minutes w/leading 0: `00..59`
                 * @return {string}
                 */
                i: function() {
                    return _lpad(vDate.getMinutes(), 2);
                },
                /**
                 * Seconds w/leading 0: `00..59`
                 * @return {string}
                 */
                s: function() {
                    return _lpad(vDate.getSeconds(), 2);
                },
                /**
                 * Microseconds: `000000-999000`
                 * @return {string}
                 */
                u: function() {
                    return _lpad(vDate.getMilliseconds() * 1000, 6);
                },

                //////////////
                // TIMEZONE //
                //////////////
                /**
                 * Timezone identifier: `e.g. Atlantic/Azores, ...`
                 * @return {string}
                 */
                e: function() {
                    var str = /\((.*)\)/.exec(String(vDate))[1];
                    return str || 'Coordinated Universal Time';
                },
                /**
                 * Timezone abbreviation: `e.g. EST, MDT, ...`
                 * @return {string}
                 */
                T: function() {
                    var str = (String(vDate).match(self.tzParts) || [""]).pop().replace(self.tzClip, "");
                    return str || 'UTC';
                },
                /**
                 * DST observed? `0 or 1`
                 * @return {number}
                 */
                I: function() {
                    var a = new Date(fmt.Y(), 0),
                        c = Date.UTC(fmt.Y(), 0),
                        b = new Date(fmt.Y(), 6),
                        d = Date.UTC(fmt.Y(), 6);
                    return ((a - c) !== (b - d)) ? 1 : 0;
                },
                /**
                 * Difference to GMT in hour format: `e.g. +0200`
                 * @return {string}
                 */
                O: function() {
                    var tzo = vDate.getTimezoneOffset(),
                        a = Math.abs(tzo);
                    return (tzo > 0 ? '-' : '+') + _lpad(Math.floor(a / 60) * 100 + a % 60, 4);
                },
                /**
                 * Difference to GMT with colon: `e.g. +02:00`
                 * @return {string}
                 */
                P: function() {
                    var O = fmt.O();
                    return (O.substr(0, 3) + ':' + O.substr(3, 2));
                },
                /**
                 * Timezone offset in seconds: `-43200...50400`
                 * @return {number}
                 */
                Z: function() {
                    return -vDate.getTimezoneOffset() * 60;
                },

                ////////////////////
                // FULL DATE TIME //
                ////////////////////
                /**
                 * ISO-8601 date
                 * @return {string}
                 */
                c: function() {
                    return 'Y-m-d\\TH:i:sP'.replace(backspace, doFormat);
                },
                /**
                 * RFC 2822 date
                 * @return {string}
                 */
                r: function() {
                    return 'D, d M Y H:i:s O'.replace(backspace, doFormat);
                },
                /**
                 * Seconds since UNIX epoch
                 * @return {number}
                 */
                U: function() {
                    return vDate.getTime() / 1000 || 0;
                }
            };
            return doFormat(vChar, vChar);
        },
        formatDate: function(vDate, vFormat) {
            var self = this,
                i, n, len, str, vChar, vDateStr = '';
            if (typeof vDate === 'string') {
                vDate = self.parseDate(vDate, vFormat);
                if (vDate === false) {
                    return false;
                }
            }
            if (vDate instanceof Date) {
                len = vFormat.length;
                for (i = 0; i < len; i++) {
                    vChar = vFormat.charAt(i);
                    if (vChar === 'S') {
                        continue;
                    }
                    str = self.parseFormat(vChar, vDate);
                    if (i !== (len - 1) && self.intParts.test(vChar) && vFormat.charAt(i + 1) === 'S') {
                        n = parseInt(str);
                        str += self.dateSettings.ordinal(n);
                    }
                    vDateStr += str;
                }
                return vDateStr;
            }
            return '';
        }
    };
})();
/**
 * @preserve jQuery DateTimePicker plugin v2.5.1
 * @homepage http://xdsoft.net/jqplugins/datetimepicker/
 * @author Chupurnov Valeriy (<chupurnov@gmail.com>)
 */
/*global DateFormatter, document,window,jQuery,setTimeout,clearTimeout,HighlightedDate,getCurrentValue*/
;
(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery', 'jquery-mousewheel'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {
    'use strict';
    var default_options = {
        i18n: {
            ar: { // Arabic
                months: [
                    "كانون الثاني", "شباط", "آذار", "نيسان", "مايو", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"
                ],
                dayOfWeekShort: [
                    "ن", "ث", "ع", "خ", "ج", "س", "ح"
                ],
                dayOfWeek: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت", "الأحد"]
            },
            ro: { // Romanian
                months: [
                    "Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"
                ],
                dayOfWeekShort: [
                    "Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sâ"
                ],
                dayOfWeek: ["Duminică", "Luni", "Marţi", "Miercuri", "Joi", "Vineri", "Sâmbătă"]
            },
            id: { // Indonesian
                months: [
                    "Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"
                ],
                dayOfWeekShort: [
                    "Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"
                ],
                dayOfWeek: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
            },
            is: { // Icelandic
                months: [
                    "Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní", "Júlí", "Ágúst", "September", "Október", "Nóvember", "Desember"
                ],
                dayOfWeekShort: [
                    "Sun", "Mán", "Þrið", "Mið", "Fim", "Fös", "Lau"
                ],
                dayOfWeek: ["Sunnudagur", "Mánudagur", "Þriðjudagur", "Miðvikudagur", "Fimmtudagur", "Föstudagur", "Laugardagur"]
            },
            bg: { // Bulgarian
                months: [
                    "Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"
                ],
                dayOfWeekShort: [
                    "Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"
                ],
                dayOfWeek: ["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"]
            },
            fa: { // Persian/Farsi
                months: [
                    'فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'
                ],
                dayOfWeekShort: [
                    'یکشنبه', 'دوشنبه', 'سه شنبه', 'چهارشنبه', 'پنجشنبه', 'جمعه', 'شنبه'
                ],
                dayOfWeek: ["یک‌شنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنج‌شنبه", "جمعه", "شنبه", "یک‌شنبه"]
            },
            ru: { // Russian
                months: [
                    'Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'
                ],
                dayOfWeekShort: [
                    "Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"
                ],
                dayOfWeek: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"]
            },
            uk: { // Ukrainian
                months: [
                    'Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жовтень', 'Листопад', 'Грудень'
                ],
                dayOfWeekShort: [
                    "Ндл", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Сбт"
                ],
                dayOfWeek: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"]
            },
            en: { // English
                months: [
                    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
                ],
                dayOfWeekShort: [
                    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
                ],
                dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
            },
            el: { // Ελληνικά
                months: [
                    "Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"
                ],
                dayOfWeekShort: [
                    "Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"
                ],
                dayOfWeek: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"]
            },
            de: { // German
                months: [
                    'Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'
                ],
                dayOfWeekShort: [
                    "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"
                ],
                dayOfWeek: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
            },
            nl: { // Dutch
                months: [
                    "januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"
                ],
                dayOfWeekShort: [
                    "zo", "ma", "di", "wo", "do", "vr", "za"
                ],
                dayOfWeek: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
            },
            tr: { // Turkish
                months: [
                    "Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"
                ],
                dayOfWeekShort: [
                    "Paz", "Pts", "Sal", "Çar", "Per", "Cum", "Cts"
                ],
                dayOfWeek: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"]
            },
            fr: { //French
                months: [
                    "Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"
                ],
                dayOfWeekShort: [
                    "Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"
                ],
                dayOfWeek: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
            },
            es: { // Spanish
                months: [
                    "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
                ],
                dayOfWeekShort: [
                    "Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"
                ],
                dayOfWeek: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"]
            },
            th: { // Thai
                months: [
                    'มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'
                ],
                dayOfWeekShort: [
                    'อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'
                ],
                dayOfWeek: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัส", "ศุกร์", "เสาร์", "อาทิตย์"]
            },
            pl: { // Polish
                months: [
                    "styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień"
                ],
                dayOfWeekShort: [
                    "nd", "pn", "wt", "śr", "cz", "pt", "sb"
                ],
                dayOfWeek: ["niedziela", "poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota"]
            },
            pt: { // Portuguese
                months: [
                    "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
                ],
                dayOfWeekShort: [
                    "Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"
                ],
                dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
            },
            ch: { // Simplified Chinese
                months: [
                    "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"
                ],
                dayOfWeekShort: [
                    "日", "一", "二", "三", "四", "五", "六"
                ]
            },
            se: { // Swedish
                months: [
                    "Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"
                ],
                dayOfWeekShort: [
                    "Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"
                ]
            },
            kr: { // Korean
                months: [
                    "1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"
                ],
                dayOfWeekShort: [
                    "일", "월", "화", "수", "목", "금", "토"
                ],
                dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
            },
            it: { // Italian
                months: [
                    "Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
                ],
                dayOfWeekShort: [
                    "Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"
                ],
                dayOfWeek: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"]
            },
            da: { // Dansk
                months: [
                    "January", "Februar", "Marts", "April", "Maj", "Juni", "July", "August", "September", "Oktober", "November", "December"
                ],
                dayOfWeekShort: [
                    "Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"
                ],
                dayOfWeek: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"]
            },
            no: { // Norwegian
                months: [
                    "Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"
                ],
                dayOfWeekShort: [
                    "Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"
                ],
                dayOfWeek: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag']
            },
            ja: { // Japanese
                months: [
                    "1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"
                ],
                dayOfWeekShort: [
                    "日", "月", "火", "水", "木", "金", "土"
                ],
                dayOfWeek: ["日曜", "月曜", "火曜", "水曜", "木曜", "金曜", "土曜"]
            },
            vi: { // Vietnamese
                months: [
                    "Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"
                ],
                dayOfWeekShort: [
                    "CN", "T2", "T3", "T4", "T5", "T6", "T7"
                ],
                dayOfWeek: ["Chủ nhật", "Thứ hai", "Thứ ba", "Thứ tư", "Thứ năm", "Thứ sáu", "Thứ bảy"]
            },
            sl: { // Slovenščina
                months: [
                    "Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"
                ],
                dayOfWeekShort: [
                    "Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"
                ],
                dayOfWeek: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "Četrtek", "Petek", "Sobota"]
            },
            cs: { // Čeština
                months: [
                    "Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"
                ],
                dayOfWeekShort: [
                    "Ne", "Po", "Út", "St", "Čt", "Pá", "So"
                ]
            },
            hu: { // Hungarian
                months: [
                    "Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"
                ],
                dayOfWeekShort: [
                    "Va", "Hé", "Ke", "Sze", "Cs", "Pé", "Szo"
                ],
                dayOfWeek: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"]
            },
            az: { //Azerbaijanian (Azeri)
                months: [
                    "Yanvar", "Fevral", "Mart", "Aprel", "May", "Iyun", "Iyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"
                ],
                dayOfWeekShort: [
                    "B", "Be", "Ça", "Ç", "Ca", "C", "Ş"
                ],
                dayOfWeek: ["Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə"]
            },
            bs: { //Bosanski
                months: [
                    "Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"
                ],
                dayOfWeekShort: [
                    "Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"
                ],
                dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
            },
            ca: { //Català
                months: [
                    "Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"
                ],
                dayOfWeekShort: [
                    "Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"
                ],
                dayOfWeek: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
            },
            'en-GB': { //English (British)
                months: [
                    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
                ],
                dayOfWeekShort: [
                    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
                ],
                dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
            },
            et: { //"Eesti"
                months: [
                    "Jaanuar", "Veebruar", "Märts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"
                ],
                dayOfWeekShort: [
                    "P", "E", "T", "K", "N", "R", "L"
                ],
                dayOfWeek: ["Pühapäev", "Esmaspäev", "Teisipäev", "Kolmapäev", "Neljapäev", "Reede", "Laupäev"]
            },
            eu: { //Euskara
                months: [
                    "Urtarrila", "Otsaila", "Martxoa", "Apirila", "Maiatza", "Ekaina", "Uztaila", "Abuztua", "Iraila", "Urria", "Azaroa", "Abendua"
                ],
                dayOfWeekShort: [
                    "Ig.", "Al.", "Ar.", "Az.", "Og.", "Or.", "La."
                ],
                dayOfWeek: ['Igandea', 'Astelehena', 'Asteartea', 'Asteazkena', 'Osteguna', 'Ostirala', 'Larunbata']
            },
            fi: { //Finnish (Suomi)
                months: [
                    "Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kesäkuu", "Heinäkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"
                ],
                dayOfWeekShort: [
                    "Su", "Ma", "Ti", "Ke", "To", "Pe", "La"
                ],
                dayOfWeek: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"]
            },
            gl: { //Galego
                months: [
                    "Xan", "Feb", "Maz", "Abr", "Mai", "Xun", "Xul", "Ago", "Set", "Out", "Nov", "Dec"
                ],
                dayOfWeekShort: [
                    "Dom", "Lun", "Mar", "Mer", "Xov", "Ven", "Sab"
                ],
                dayOfWeek: ["Domingo", "Luns", "Martes", "Mércores", "Xoves", "Venres", "Sábado"]
            },
            hr: { //Hrvatski
                months: [
                    "Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"
                ],
                dayOfWeekShort: [
                    "Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"
                ],
                dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
            },
            ko: { //Korean (한국어)
                months: [
                    "1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"
                ],
                dayOfWeekShort: [
                    "일", "월", "화", "수", "목", "금", "토"
                ],
                dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
            },
            lt: { //Lithuanian (lietuvių)
                months: [
                    "Sausio", "Vasario", "Kovo", "Balandžio", "Gegužės", "Birželio", "Liepos", "Rugpjūčio", "Rugsėjo", "Spalio", "Lapkričio", "Gruodžio"
                ],
                dayOfWeekShort: [
                    "Sek", "Pir", "Ant", "Tre", "Ket", "Pen", "Šeš"
                ],
                dayOfWeek: ["Sekmadienis", "Pirmadienis", "Antradienis", "Trečiadienis", "Ketvirtadienis", "Penktadienis", "Šeštadienis"]
            },
            lv: { //Latvian (Latviešu)
                months: [
                    "Janvāris", "Februāris", "Marts", "Aprīlis ", "Maijs", "Jūnijs", "Jūlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"
                ],
                dayOfWeekShort: [
                    "Sv", "Pr", "Ot", "Tr", "Ct", "Pk", "St"
                ],
                dayOfWeek: ["Svētdiena", "Pirmdiena", "Otrdiena", "Trešdiena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
            },
            mk: { //Macedonian (Македонски)
                months: [
                    "јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"
                ],
                dayOfWeekShort: [
                    "нед", "пон", "вто", "сре", "чет", "пет", "саб"
                ],
                dayOfWeek: ["Недела", "Понеделник", "Вторник", "Среда", "Четврток", "Петок", "Сабота"]
            },
            mn: { //Mongolian (Монгол)
                months: [
                    "1-р сар", "2-р сар", "3-р сар", "4-р сар", "5-р сар", "6-р сар", "7-р сар", "8-р сар", "9-р сар", "10-р сар", "11-р сар", "12-р сар"
                ],
                dayOfWeekShort: [
                    "Дав", "Мяг", "Лха", "Пүр", "Бсн", "Бям", "Ням"
                ],
                dayOfWeek: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
            },
            'pt-BR': { //Português(Brasil)
                months: [
                    "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
                ],
                dayOfWeekShort: [
                    "Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"
                ],
                dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
            },
            sk: { //Slovenčina
                months: [
                    "Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"
                ],
                dayOfWeekShort: [
                    "Ne", "Po", "Ut", "St", "Št", "Pi", "So"
                ],
                dayOfWeek: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"]
            },
            sq: { //Albanian (Shqip)
                months: [
                    "Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nëntor", "Dhjetor"
                ],
                dayOfWeekShort: [
                    "Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Shtu"
                ],
                dayOfWeek: ["E Diel", "E Hënë", "E Martē", "E Mërkurë", "E Enjte", "E Premte", "E Shtunë"]
            },
            'sr-YU': { //Serbian (Srpski)
                months: [
                    "Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"
                ],
                dayOfWeekShort: [
                    "Ned", "Pon", "Uto", "Sre", "čet", "Pet", "Sub"
                ],
                dayOfWeek: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "Četvrtak", "Petak", "Subota"]
            },
            sr: { //Serbian Cyrillic (Српски)
                months: [
                    "јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар"
                ],
                dayOfWeekShort: [
                    "нед", "пон", "уто", "сре", "чет", "пет", "суб"
                ],
                dayOfWeek: ["Недеља", "Понедељак", "Уторак", "Среда", "Четвртак", "Петак", "Субота"]
            },
            sv: { //Svenska
                months: [
                    "Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"
                ],
                dayOfWeekShort: [
                    "Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"
                ],
                dayOfWeek: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"]
            },
            'zh-TW': { //Traditional Chinese (繁體中文)
                months: [
                    "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"
                ],
                dayOfWeekShort: [
                    "日", "一", "二", "三", "四", "五", "六"
                ],
                dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
            },
            zh: { //Simplified Chinese (简体中文)
                months: [
                    "一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"
                ],
                dayOfWeekShort: [
                    "日", "一", "二", "三", "四", "五", "六"
                ],
                dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
            },
            he: { //Hebrew (עברית)
                months: [
                    'ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'
                ],
                dayOfWeekShort: [
                    'א\'', 'ב\'', 'ג\'', 'ד\'', 'ה\'', 'ו\'', 'שבת'
                ],
                dayOfWeek: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת", "ראשון"]
            },
            hy: { // Armenian
                months: [
                    "Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր"
                ],
                dayOfWeekShort: [
                    "Կի", "Երկ", "Երք", "Չոր", "Հնգ", "Ուրբ", "Շբթ"
                ],
                dayOfWeek: ["Կիրակի", "Երկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "Ուրբաթ", "Շաբաթ"]
            },
            kg: { // Kyrgyz
                months: [
                    'Үчтүн айы', 'Бирдин айы', 'Жалган Куран', 'Чын Куран', 'Бугу', 'Кулжа', 'Теке', 'Баш Оона', 'Аяк Оона', 'Тогуздун айы', 'Жетинин айы', 'Бештин айы'
                ],
                dayOfWeekShort: [
                    "Жек", "Дүй", "Шей", "Шар", "Бей", "Жум", "Ише"
                ],
                dayOfWeek: [
                    "Жекшемб", "Дүйшөмб", "Шейшемб", "Шаршемб", "Бейшемби", "Жума", "Ишенб"
                ]
            },
            rm: { // Romansh
                months: [
                    "Schaner", "Favrer", "Mars", "Avrigl", "Matg", "Zercladur", "Fanadur", "Avust", "Settember", "October", "November", "December"
                ],
                dayOfWeekShort: [
                    "Du", "Gli", "Ma", "Me", "Gie", "Ve", "So"
                ],
                dayOfWeek: [
                    "Dumengia", "Glindesdi", "Mardi", "Mesemna", "Gievgia", "Venderdi", "Sonda"
                ]
            },
        },
        value: '',
        rtl: false,

        format: 'Y/m/d H:i',
        formatTime: 'H:i',
        formatDate: 'Y/m/d',

        startDate: false, // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05',
        step: 60,
        monthChangeSpinner: true,

        closeOnDateSelect: false,
        closeOnTimeSelect: true,
        closeOnWithoutClick: true,
        closeOnInputClick: true,

        timepicker: true,
        datepicker: true,
        weeks: false,

        defaultTime: false, // use formatTime format (ex. '10:00' for formatTime:	'H:i')
        defaultDate: false, // use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05')

        minDate: false,
        maxDate: false,
        minTime: false,
        maxTime: false,
        disabledMinTime: false,
        disabledMaxTime: false,

        allowTimes: [],
        opened: false,
        initTime: true,
        inline: false,
        theme: '',

        onSelectDate: function() {},
        onSelectTime: function() {},
        onChangeMonth: function() {},
        onGetWeekOfYear: function() {},
        onChangeYear: function() {},
        onChangeDateTime: function() {},
        onShow: function() {},
        onClose: function() {},
        onGenerate: function() {},

        withoutCopyright: true,
        inverseButton: false,
        hours12: false,
        next: 'xdsoft_next',
        prev: 'xdsoft_prev',
        dayOfWeekStart: 0,
        parentID: 'body',
        timeHeightInTimePicker: 25,
        timepickerScrollbar: true,
        todayButton: true,
        prevButton: true,
        nextButton: true,
        defaultSelect: true,

        scrollMonth: true,
        scrollTime: true,
        scrollInput: true,

        lazyInit: false,
        mask: false,
        validateOnBlur: true,
        allowBlank: true,
        yearStart: 1950,
        yearEnd: 2050,
        monthStart: 0,
        monthEnd: 11,
        style: '',
        id: '',
        fixed: false,
        roundTime: 'round', // ceil, floor
        className: '',
        weekends: [],
        highlightedDates: [],
        highlightedPeriods: [],
        allowDates: [],
        allowDateRe: null,
        disabledDates: [],
        disabledWeekDays: [],
        yearOffset: 0,
        beforeShowDay: null,

        enterLikeTab: true,
        showApplyButton: false
    };

    var dateHelper = null,
        globalLocaleDefault = 'en',
        globalLocale = 'en';

    var dateFormatterOptionsDefault = {
        meridiem: ['AM', 'PM']
    };

    var initDateFormatter = function() {
        var locale = default_options.i18n[globalLocale],
            opts = {
                days: locale.dayOfWeek,
                daysShort: locale.dayOfWeekShort,
                months: locale.months,
                monthsShort: $.map(locale.months, function(n) {
                    return n.substring(0, 3)
                }),
            };

        dateHelper = new DateFormatter({
            dateSettings: $.extend({}, dateFormatterOptionsDefault, opts)
        });
    };

    // for locale settings
    $.datetimepicker = {
        setLocale: function(locale) {
            var newLocale = default_options.i18n[locale] ? locale : globalLocaleDefault;
            if (globalLocale != newLocale) {
                globalLocale = newLocale;
                // reinit date formatter
                initDateFormatter();
            }
        },

        RFC_2822: 'D, d M Y H:i:s O',
        ATOM: 'Y-m-d\TH:i:sP',
        ISO_8601: 'Y-m-d\TH:i:sO',
        RFC_822: 'D, d M y H:i:s O',
        RFC_850: 'l, d-M-y H:i:s T',
        RFC_1036: 'D, d M y H:i:s O',
        RFC_1123: 'D, d M Y H:i:s O',
        RSS: 'D, d M Y H:i:s O',
        W3C: 'Y-m-d\TH:i:sP'
    };

    // first init date formatter
    initDateFormatter();

    // fix for ie8
    if (!window.getComputedStyle) {
        window.getComputedStyle = function(el, pseudo) {
            this.el = el;
            this.getPropertyValue = function(prop) {
                var re = /(\-([a-z]){1})/g;
                if (prop === 'float') {
                    prop = 'styleFloat';
                }
                if (re.test(prop)) {
                    prop = prop.replace(re, function(a, b, c) {
                        return c.toUpperCase();
                    });
                }
                return el.currentStyle[prop] || null;
            };
            return this;
        };
    }
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(obj, start) {
            var i, j;
            for (i = (start || 0), j = this.length; i < j; i += 1) {
                if (this[i] === obj) {
                    return i;
                }
            }
            return -1;
        };
    }
    Date.prototype.countDaysInMonth = function() {
        return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
    };
    $.fn.xdsoftScroller = function(percent) {
        return this.each(function() {
            var timeboxparent = $(this),
                pointerEventToXY = function(e) {
                    var out = {
                            x: 0,
                            y: 0
                        },
                        touch;
                    if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
                        touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
                        out.x = touch.clientX;
                        out.y = touch.clientY;
                    } else if (e.type === 'mousedown' || e.type === 'mouseup' || e.type === 'mousemove' || e.type === 'mouseover' || e.type === 'mouseout' || e.type === 'mouseenter' || e.type === 'mouseleave') {
                        out.x = e.clientX;
                        out.y = e.clientY;
                    }
                    return out;
                },
                timebox,
                parentHeight,
                height,
                scrollbar,
                scroller,
                maximumOffset = 100,
                start = false,
                startY = 0,
                startTop = 0,
                h1 = 0,
                touchStart = false,
                startTopScroll = 0,
                calcOffset = function() {};
            if (percent === 'hide') {
                timeboxparent.find('.xdsoft_scrollbar').hide();
                return;
            }
            if (!$(this).hasClass('xdsoft_scroller_box')) {
                timebox = timeboxparent.children().eq(0);
                parentHeight = timeboxparent[0].clientHeight;
                height = timebox[0].offsetHeight;
                scrollbar = $('<div class="xdsoft_scrollbar"></div>');
                scroller = $('<div class="xdsoft_scroller"></div>');
                scrollbar.append(scroller);

                timeboxparent.addClass('xdsoft_scroller_box').append(scrollbar);
                calcOffset = function calcOffset(event) {
                    var offset = pointerEventToXY(event).y - startY + startTopScroll;
                    if (offset < 0) {
                        offset = 0;
                    }
                    if (offset + scroller[0].offsetHeight > h1) {
                        offset = h1 - scroller[0].offsetHeight;
                    }
                    timeboxparent.trigger('scroll_element.xdsoft_scroller', [maximumOffset ? offset / maximumOffset : 0]);
                };

                scroller
                    .on('touchstart.xdsoft_scroller mousedown.xdsoft_scroller', function(event) {
                        if (!parentHeight) {
                            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
                        }

                        startY = pointerEventToXY(event).y;
                        startTopScroll = parseInt(scroller.css('margin-top'), 10);
                        h1 = scrollbar[0].offsetHeight;

                        if (event.type === 'mousedown' || event.type === 'touchstart') {
                            if (document) {
                                $(document.body).addClass('xdsoft_noselect');
                            }
                            $([document.body, window]).on('touchend mouseup.xdsoft_scroller', function arguments_callee() {
                                $([document.body, window]).off('touchend mouseup.xdsoft_scroller', arguments_callee)
                                    .off('mousemove.xdsoft_scroller', calcOffset)
                                    .removeClass('xdsoft_noselect');
                            });
                            $(document.body).on('mousemove.xdsoft_scroller', calcOffset);
                        } else {
                            touchStart = true;
                            event.stopPropagation();
                            event.preventDefault();
                        }
                    })
                    .on('touchmove', function(event) {
                        if (touchStart) {
                            event.preventDefault();
                            calcOffset(event);
                        }
                    })
                    .on('touchend touchcancel', function() {
                        touchStart = false;
                        startTopScroll = 0;
                    });

                timeboxparent
                    .on('scroll_element.xdsoft_scroller', function(event, percentage) {
                        if (!parentHeight) {
                            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percentage, true]);
                        }
                        percentage = percentage > 1 ? 1 : (percentage < 0 || isNaN(percentage)) ? 0 : percentage;

                        scroller.css('margin-top', maximumOffset * percentage);

                        setTimeout(function() {
                            timebox.css('marginTop', -parseInt((timebox[0].offsetHeight - parentHeight) * percentage, 10));
                        }, 10);
                    })
                    .on('resize_scroll.xdsoft_scroller', function(event, percentage, noTriggerScroll) {
                        var percent, sh;
                        parentHeight = timeboxparent[0].clientHeight;
                        height = timebox[0].offsetHeight;
                        percent = parentHeight / height;
                        sh = percent * scrollbar[0].offsetHeight;
                        if (percent > 1) {
                            scroller.hide();
                        } else {
                            scroller.show();
                            scroller.css('height', parseInt(sh > 10 ? sh : 10, 10));
                            maximumOffset = scrollbar[0].offsetHeight - scroller[0].offsetHeight;
                            if (noTriggerScroll !== true) {
                                timeboxparent.trigger('scroll_element.xdsoft_scroller', [percentage || Math.abs(parseInt(timebox.css('marginTop'), 10)) / (height - parentHeight)]);
                            }
                        }
                    });

                timeboxparent.on('mousewheel', function(event) {
                    var top = Math.abs(parseInt(timebox.css('marginTop'), 10));

                    top = top - (event.deltaY * 20);
                    if (top < 0) {
                        top = 0;
                    }

                    timeboxparent.trigger('scroll_element.xdsoft_scroller', [top / (height - parentHeight)]);
                    event.stopPropagation();
                    return false;
                });

                timeboxparent.on('touchstart', function(event) {
                    start = pointerEventToXY(event);
                    startTop = Math.abs(parseInt(timebox.css('marginTop'), 10));
                });

                timeboxparent.on('touchmove', function(event) {
                    if (start) {
                        event.preventDefault();
                        var coord = pointerEventToXY(event);
                        timeboxparent.trigger('scroll_element.xdsoft_scroller', [(startTop - (coord.y - start.y)) / (height - parentHeight)]);
                    }
                });

                timeboxparent.on('touchend touchcancel', function() {
                    start = false;
                    startTop = 0;
                });
            }
            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
        });
    };

    $.fn.datetimepicker = function(opt, opt2) {
        var result = this,
            KEY0 = 48,
            KEY9 = 57,
            _KEY0 = 96,
            _KEY9 = 105,
            CTRLKEY = 17,
            DEL = 46,
            ENTER = 13,
            ESC = 27,
            BACKSPACE = 8,
            ARROWLEFT = 37,
            ARROWUP = 38,
            ARROWRIGHT = 39,
            ARROWDOWN = 40,
            TAB = 9,
            F5 = 116,
            AKEY = 65,
            CKEY = 67,
            VKEY = 86,
            ZKEY = 90,
            YKEY = 89,
            ctrlDown = false,
            options = ($.isPlainObject(opt) || !opt) ? $.extend(true, {}, default_options, opt) : $.extend(true, {}, default_options),

            lazyInitTimer = 0,
            createDateTimePicker,
            destroyDateTimePicker,

            lazyInit = function(input) {
                input
                    .on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function initOnActionCallback() {
                        if (input.is(':disabled') || input.data('xdsoft_datetimepicker')) {
                            return;
                        }
                        clearTimeout(lazyInitTimer);
                        lazyInitTimer = setTimeout(function() {

                            if (!input.data('xdsoft_datetimepicker')) {
                                createDateTimePicker(input);
                            }
                            input
                                .off('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', initOnActionCallback)
                                .trigger('open.xdsoft');
                        }, 100);
                    });
            };

        createDateTimePicker = function(input) {
            var datetimepicker = $('<div class="xdsoft_datetimepicker xdsoft_noselect"></div>'),
                xdsoft_copyright = $('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
                datepicker = $('<div class="xdsoft_datepicker active"></div>'),
                mounth_picker = $('<div class="xdsoft_mounthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button>' +
                    '<div class="xdsoft_label xdsoft_month"><span></span><i></i></div>' +
                    '<div class="xdsoft_label xdsoft_year"><span></span><i></i></div>' +
                    '<button type="button" class="xdsoft_next"></button></div>'),
                calendar = $('<div class="xdsoft_calendar"></div>'),
                timepicker = $('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
                timeboxparent = timepicker.find('.xdsoft_time_box').eq(0),
                timebox = $('<div class="xdsoft_time_variant"></div>'),
                applyButton = $('<button type="button" class="xdsoft_save_selected blue-gradient-button">Save Selected</button>'),

                monthselect = $('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>'),
                yearselect = $('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>'),
                triggerAfterOpen = false,
                XDSoft_datetime,

                xchangeTimer,
                timerclick,
                current_time_index,
                setPos,
                timer = 0,
                _xdsoft_datetime,
                forEachAncestorOf;

            if (options.id) {
                datetimepicker.attr('id', options.id);
            }
            if (options.style) {
                datetimepicker.attr('style', options.style);
            }
            if (options.weeks) {
                datetimepicker.addClass('xdsoft_showweeks');
            }
            if (options.rtl) {
                datetimepicker.addClass('xdsoft_rtl');
            }

            datetimepicker.addClass('xdsoft_' + options.theme);
            datetimepicker.addClass(options.className);

            mounth_picker
                .find('.xdsoft_month span')
                .after(monthselect);
            mounth_picker
                .find('.xdsoft_year span')
                .after(yearselect);

            mounth_picker
                .find('.xdsoft_month,.xdsoft_year')
                .on('touchstart mousedown.xdsoft', function(event) {
                    var select = $(this).find('.xdsoft_select').eq(0),
                        val = 0,
                        top = 0,
                        visible = select.is(':visible'),
                        items,
                        i;

                    mounth_picker
                        .find('.xdsoft_select')
                        .hide();
                    if (_xdsoft_datetime.currentTime) {
                        val = _xdsoft_datetime.currentTime[$(this).hasClass('xdsoft_month') ? 'getMonth' : 'getFullYear']();
                    }

                    select[visible ? 'hide' : 'show']();
                    for (items = select.find('div.xdsoft_option'), i = 0; i < items.length; i += 1) {
                        if (items.eq(i).data('value') === val) {
                            break;
                        } else {
                            top += items[0].offsetHeight;
                        }
                    }

                    select.xdsoftScroller(top / (select.children()[0].offsetHeight - (select[0].clientHeight)));
                    event.stopPropagation();
                    return false;
                });

            mounth_picker
                .find('.xdsoft_select')
                .xdsoftScroller()
                .on('touchstart mousedown.xdsoft', function(event) {
                    event.stopPropagation();
                    event.preventDefault();
                })
                .on('touchstart mousedown.xdsoft', '.xdsoft_option', function() {
                    if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
                        _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                    }

                    var year = _xdsoft_datetime.currentTime.getFullYear();
                    if (_xdsoft_datetime && _xdsoft_datetime.currentTime) {
                        _xdsoft_datetime.currentTime[$(this).parent().parent().hasClass('xdsoft_monthselect') ? 'setMonth' : 'setFullYear']($(this).data('value'));
                    }

                    $(this).parent().parent().hide();

                    datetimepicker.trigger('xchange.xdsoft');
                    if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
                        options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }

                    if (year !== _xdsoft_datetime.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
                        options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }
                });

            datetimepicker.getValue = function() {
                return _xdsoft_datetime.getCurrentTime();
            };

            datetimepicker.setOptions = function(_options) {
                var highlightedDates = {};

                options = $.extend(true, {}, options, _options);

                if (_options.allowTimes && $.isArray(_options.allowTimes) && _options.allowTimes.length) {
                    options.allowTimes = $.extend(true, [], _options.allowTimes);
                }

                if (_options.weekends && $.isArray(_options.weekends) && _options.weekends.length) {
                    options.weekends = $.extend(true, [], _options.weekends);
                }

                if (_options.allowDates && $.isArray(_options.allowDates) && _options.allowDates.length) {
                    options.allowDates = $.extend(true, [], _options.allowDates);
                }

                if (_options.allowDateRe && Object.prototype.toString.call(_options.allowDateRe) === "[object String]") {
                    options.allowDateRe = new RegExp(_options.allowDateRe);
                }

                if (_options.highlightedDates && $.isArray(_options.highlightedDates) && _options.highlightedDates.length) {
                    $.each(_options.highlightedDates, function(index, value) {
                        var splitData = $.map(value.split(','), $.trim),
                            exDesc,
                            hDate = new HighlightedDate(dateHelper.parseDate(splitData[0], options.formatDate), splitData[1], splitData[2]), // date, desc, style
                            keyDate = dateHelper.formatDate(hDate.date, options.formatDate);
                        if (highlightedDates[keyDate] !== undefined) {
                            exDesc = highlightedDates[keyDate].desc;
                            if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                                highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
                            }
                        } else {
                            highlightedDates[keyDate] = hDate;
                        }
                    });

                    options.highlightedDates = $.extend(true, [], highlightedDates);
                }

                if (_options.highlightedPeriods && $.isArray(_options.highlightedPeriods) && _options.highlightedPeriods.length) {
                    highlightedDates = $.extend(true, [], options.highlightedDates);
                    $.each(_options.highlightedPeriods, function(index, value) {
                        var dateTest, // start date
                            dateEnd,
                            desc,
                            hDate,
                            keyDate,
                            exDesc,
                            style;
                        if ($.isArray(value)) {
                            dateTest = value[0];
                            dateEnd = value[1];
                            desc = value[2];
                            style = value[3];
                        } else {
                            var splitData = $.map(value.split(','), $.trim);
                            dateTest = dateHelper.parseDate(splitData[0], options.formatDate);
                            dateEnd = dateHelper.parseDate(splitData[1], options.formatDate);
                            desc = splitData[2];
                            style = splitData[3];
                        }

                        while (dateTest <= dateEnd) {
                            hDate = new HighlightedDate(dateTest, desc, style);
                            keyDate = dateHelper.formatDate(dateTest, options.formatDate);
                            dateTest.setDate(dateTest.getDate() + 1);
                            if (highlightedDates[keyDate] !== undefined) {
                                exDesc = highlightedDates[keyDate].desc;
                                if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                                    highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
                                }
                            } else {
                                highlightedDates[keyDate] = hDate;
                            }
                        }
                    });

                    options.highlightedDates = $.extend(true, [], highlightedDates);
                }

                if (_options.disabledDates && $.isArray(_options.disabledDates) && _options.disabledDates.length) {
                    options.disabledDates = $.extend(true, [], _options.disabledDates);
                }

                if (_options.disabledWeekDays && $.isArray(_options.disabledWeekDays) && _options.disabledWeekDays.length) {
                    options.disabledWeekDays = $.extend(true, [], _options.disabledWeekDays);
                }

                if ((options.open || options.opened) && (!options.inline)) {
                    input.trigger('open.xdsoft');
                }

                if (options.inline) {
                    triggerAfterOpen = true;
                    datetimepicker.addClass('xdsoft_inline');
                    input.after(datetimepicker).hide();
                }

                if (options.inverseButton) {
                    options.next = 'xdsoft_prev';
                    options.prev = 'xdsoft_next';
                }

                if (options.datepicker) {
                    datepicker.addClass('active');
                } else {
                    datepicker.removeClass('active');
                }

                if (options.timepicker) {
                    timepicker.addClass('active');
                } else {
                    timepicker.removeClass('active');
                }

                if (options.value) {
                    _xdsoft_datetime.setCurrentTime(options.value);
                    if (input && input.val) {
                        input.val(_xdsoft_datetime.str);
                    }
                }

                if (isNaN(options.dayOfWeekStart)) {
                    options.dayOfWeekStart = 0;
                } else {
                    options.dayOfWeekStart = parseInt(options.dayOfWeekStart, 10) % 7;
                }

                if (!options.timepickerScrollbar) {
                    timeboxparent.xdsoftScroller('hide');
                }

                if (options.minDate && /^[\+\-](.*)$/.test(options.minDate)) {
                    options.minDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.minDate), options.formatDate);
                }

                if (options.maxDate && /^[\+\-](.*)$/.test(options.maxDate)) {
                    options.maxDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.maxDate), options.formatDate);
                }

                applyButton.toggle(options.showApplyButton);

                mounth_picker
                    .find('.xdsoft_today_button')
                    .css('visibility', !options.todayButton ? 'hidden' : 'visible');

                mounth_picker
                    .find('.' + options.prev)
                    .css('visibility', !options.prevButton ? 'hidden' : 'visible');

                mounth_picker
                    .find('.' + options.next)
                    .css('visibility', !options.nextButton ? 'hidden' : 'visible');

                setMask(options);

                if (options.validateOnBlur) {
                    input
                        .off('blur.xdsoft')
                        .on('blur.xdsoft', function() {
                            if (options.allowBlank && (!$.trim($(this).val()).length || $.trim($(this).val()) === options.mask.replace(/[0-9]/g, '_'))) {
                                $(this).val(null);
                                datetimepicker.data('xdsoft_datetime').empty();
                            } else if (!dateHelper.parseDate($(this).val(), options.format)) {
                                var splittedHours = +([$(this).val()[0], $(this).val()[1]].join('')),
                                    splittedMinutes = +([$(this).val()[2], $(this).val()[3]].join(''));

                                // parse the numbers as 0312 => 03:12
                                if (!options.datepicker && options.timepicker && splittedHours >= 0 && splittedHours < 24 && splittedMinutes >= 0 && splittedMinutes < 60) {
                                    $(this).val([splittedHours, splittedMinutes].map(function(item) {
                                        return item > 9 ? item : '0' + item;
                                    }).join(':'));
                                } else {
                                    $(this).val(dateHelper.formatDate(_xdsoft_datetime.now(), options.format));
                                }

                                datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
                            } else {
                                datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
                            }

                            datetimepicker.trigger('changedatetime.xdsoft');
                            datetimepicker.trigger('close.xdsoft');
                        });
                }
                options.dayOfWeekStartPrev = (options.dayOfWeekStart === 0) ? 6 : options.dayOfWeekStart - 1;

                datetimepicker
                    .trigger('xchange.xdsoft')
                    .trigger('afterOpen.xdsoft');
            };

            datetimepicker
                .data('options', options)
                .on('touchstart mousedown.xdsoft', function(event) {
                    event.stopPropagation();
                    event.preventDefault();
                    yearselect.hide();
                    monthselect.hide();
                    return false;
                });

            //scroll_element = timepicker.find('.xdsoft_time_box');
            timeboxparent.append(timebox);
            timeboxparent.xdsoftScroller();

            datetimepicker.on('afterOpen.xdsoft', function() {
                timeboxparent.xdsoftScroller();
            });

            datetimepicker
                .append(datepicker)
                .append(timepicker);

            if (options.withoutCopyright !== true) {
                datetimepicker
                    .append(xdsoft_copyright);
            }

            datepicker
                .append(mounth_picker)
                .append(calendar)
                .append(applyButton);

            $(options.parentID)
                .append(datetimepicker);

            XDSoft_datetime = function() {
                var _this = this;
                _this.now = function(norecursion) {
                    var d = new Date(),
                        date,
                        time;

                    if (!norecursion && options.defaultDate) {
                        date = _this.strToDateTime(options.defaultDate);
                        d.setFullYear(date.getFullYear());
                        d.setMonth(date.getMonth());
                        d.setDate(date.getDate());
                    }

                    if (options.yearOffset) {
                        d.setFullYear(d.getFullYear() + options.yearOffset);
                    }

                    if (!norecursion && options.defaultTime) {
                        time = _this.strtotime(options.defaultTime);
                        d.setHours(time.getHours());
                        d.setMinutes(time.getMinutes());
                    }
                    return d;
                };

                _this.isValidDate = function(d) {
                    if (Object.prototype.toString.call(d) !== "[object Date]") {
                        return false;
                    }
                    return !isNaN(d.getTime());
                };

                _this.setCurrentTime = function(dTime) {
                    _this.currentTime = (typeof dTime === 'string') ? _this.strToDateTime(dTime) : _this.isValidDate(dTime) ? dTime : _this.now();
                    datetimepicker.trigger('xchange.xdsoft');
                };

                _this.empty = function() {
                    _this.currentTime = null;
                };

                _this.getCurrentTime = function(dTime) {
                    return _this.currentTime;
                };

                _this.nextMonth = function() {

                    if (_this.currentTime === undefined || _this.currentTime === null) {
                        _this.currentTime = _this.now();
                    }

                    var month = _this.currentTime.getMonth() + 1,
                        year;
                    if (month === 12) {
                        _this.currentTime.setFullYear(_this.currentTime.getFullYear() + 1);
                        month = 0;
                    }

                    year = _this.currentTime.getFullYear();

                    _this.currentTime.setDate(
                        Math.min(
                            new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(),
                            _this.currentTime.getDate()
                        )
                    );
                    _this.currentTime.setMonth(month);

                    if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
                        options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }

                    if (year !== _this.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
                        options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }

                    datetimepicker.trigger('xchange.xdsoft');
                    return month;
                };

                _this.prevMonth = function() {

                    if (_this.currentTime === undefined || _this.currentTime === null) {
                        _this.currentTime = _this.now();
                    }

                    var month = _this.currentTime.getMonth() - 1;
                    if (month === -1) {
                        _this.currentTime.setFullYear(_this.currentTime.getFullYear() - 1);
                        month = 11;
                    }
                    _this.currentTime.setDate(
                        Math.min(
                            new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(),
                            _this.currentTime.getDate()
                        )
                    );
                    _this.currentTime.setMonth(month);
                    if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
                        options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }
                    datetimepicker.trigger('xchange.xdsoft');
                    return month;
                };

                _this.getWeekOfYear = function(datetime) {
                    if (options.onGetWeekOfYear && $.isFunction(options.onGetWeekOfYear)) {
                        var week = options.onGetWeekOfYear.call(datetimepicker, datetime);
                        if (typeof week !== 'undefined') {
                            return week;
                        }
                    }
                    var onejan = new Date(datetime.getFullYear(), 0, 1);
                    //First week of the year is th one with the first Thursday according to ISO8601
                    if (onejan.getDay() != 4)
                        onejan.setMonth(0, 1 + ((4 - onejan.getDay() + 7) % 7));
                    return Math.ceil((((datetime - onejan) / 86400000) + onejan.getDay() + 1) / 7);
                };

                _this.strToDateTime = function(sDateTime) {
                    var tmpDate = [],
                        timeOffset, currentTime;

                    if (sDateTime && sDateTime instanceof Date && _this.isValidDate(sDateTime)) {
                        return sDateTime;
                    }

                    tmpDate = /^(\+|\-)(.*)$/.exec(sDateTime);
                    if (tmpDate) {
                        tmpDate[2] = dateHelper.parseDate(tmpDate[2], options.formatDate);
                    }
                    if (tmpDate && tmpDate[2]) {
                        timeOffset = tmpDate[2].getTime() - (tmpDate[2].getTimezoneOffset()) * 60000;
                        currentTime = new Date((_this.now(true)).getTime() + parseInt(tmpDate[1] + '1', 10) * timeOffset);
                    } else {
                        currentTime = sDateTime ? dateHelper.parseDate(sDateTime, options.format) : _this.now();
                    }

                    if (!_this.isValidDate(currentTime)) {
                        currentTime = _this.now();
                    }

                    return currentTime;
                };

                _this.strToDate = function(sDate) {
                    if (sDate && sDate instanceof Date && _this.isValidDate(sDate)) {
                        return sDate;
                    }

                    var currentTime = sDate ? dateHelper.parseDate(sDate, options.formatDate) : _this.now(true);
                    if (!_this.isValidDate(currentTime)) {
                        currentTime = _this.now(true);
                    }
                    return currentTime;
                };

                _this.strtotime = function(sTime) {
                    if (sTime && sTime instanceof Date && _this.isValidDate(sTime)) {
                        return sTime;
                    }
                    var currentTime = sTime ? dateHelper.parseDate(sTime, options.formatTime) : _this.now(true);
                    if (!_this.isValidDate(currentTime)) {
                        currentTime = _this.now(true);
                    }
                    return currentTime;
                };

                _this.str = function() {
                    return dateHelper.formatDate(_this.currentTime, options.format);
                };
                _this.currentTime = this.now();
            };

            _xdsoft_datetime = new XDSoft_datetime();

            applyButton.on('touchend click', function(e) { //pathbrite
                e.preventDefault();
                datetimepicker.data('changed', true);
                _xdsoft_datetime.setCurrentTime(getCurrentValue());
                input.val(_xdsoft_datetime.str());
                datetimepicker.trigger('close.xdsoft');
            });
            mounth_picker
                .find('.xdsoft_today_button')
                .on('touchend mousedown.xdsoft', function() {
                    datetimepicker.data('changed', true);
                    _xdsoft_datetime.setCurrentTime(0);
                    datetimepicker.trigger('afterOpen.xdsoft');
                }).on('dblclick.xdsoft', function() {
                    var currentDate = _xdsoft_datetime.getCurrentTime(),
                        minDate, maxDate;
                    currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
                    minDate = _xdsoft_datetime.strToDate(options.minDate);
                    minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
                    if (currentDate < minDate) {
                        return;
                    }
                    maxDate = _xdsoft_datetime.strToDate(options.maxDate);
                    maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());
                    if (currentDate > maxDate) {
                        return;
                    }
                    input.val(_xdsoft_datetime.str());
                    input.trigger('change');
                    datetimepicker.trigger('close.xdsoft');
                });
            mounth_picker
                .find('.xdsoft_prev,.xdsoft_next')
                .on('touchend mousedown.xdsoft', function() {
                    var $this = $(this),
                        timer = 0,
                        stop = false;

                    (function arguments_callee1(v) {
                        if ($this.hasClass(options.next)) {
                            _xdsoft_datetime.nextMonth();
                        } else if ($this.hasClass(options.prev)) {
                            _xdsoft_datetime.prevMonth();
                        }
                        if (options.monthChangeSpinner) {
                            if (!stop) {
                                timer = setTimeout(arguments_callee1, v || 100);
                            }
                        }
                    }(500));

                    $([document.body, window]).on('touchend mouseup.xdsoft', function arguments_callee2() {
                        clearTimeout(timer);
                        stop = true;
                        $([document.body, window]).off('touchend mouseup.xdsoft', arguments_callee2);
                    });
                });

            timepicker
                .find('.xdsoft_prev,.xdsoft_next')
                .on('touchend mousedown.xdsoft', function() {
                    var $this = $(this),
                        timer = 0,
                        stop = false,
                        period = 110;
                    (function arguments_callee4(v) {
                        var pheight = timeboxparent[0].clientHeight,
                            height = timebox[0].offsetHeight,
                            top = Math.abs(parseInt(timebox.css('marginTop'), 10));
                        if ($this.hasClass(options.next) && (height - pheight) - options.timeHeightInTimePicker >= top) {
                            timebox.css('marginTop', '-' + (top + options.timeHeightInTimePicker) + 'px');
                        } else if ($this.hasClass(options.prev) && top - options.timeHeightInTimePicker >= 0) {
                            timebox.css('marginTop', '-' + (top - options.timeHeightInTimePicker) + 'px');
                        }
                        timeboxparent.trigger('scroll_element.xdsoft_scroller', [Math.abs(parseInt(timebox.css('marginTop'), 10) / (height - pheight))]);
                        period = (period > 10) ? 10 : period - 10;
                        if (!stop) {
                            timer = setTimeout(arguments_callee4, v || period);
                        }
                    }(500));
                    $([document.body, window]).on('touchend mouseup.xdsoft', function arguments_callee5() {
                        clearTimeout(timer);
                        stop = true;
                        $([document.body, window])
                            .off('touchend mouseup.xdsoft', arguments_callee5);
                    });
                });

            xchangeTimer = 0;
            // base handler - generating a calendar and timepicker
            datetimepicker
                .on('xchange.xdsoft', function(event) {
                    clearTimeout(xchangeTimer);
                    xchangeTimer = setTimeout(function() {

                        if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
                            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                        }

                        var table = '',
                            start = new Date(_xdsoft_datetime.currentTime.getFullYear(), _xdsoft_datetime.currentTime.getMonth(), 1, 12, 0, 0),
                            i = 0,
                            j,
                            today = _xdsoft_datetime.now(),
                            maxDate = false,
                            minDate = false,
                            hDate,
                            day,
                            d,
                            y,
                            m,
                            w,
                            classes = [],
                            customDateSettings,
                            newRow = true,
                            time = '',
                            h = '',
                            line_time,
                            description;

                        while (start.getDay() !== options.dayOfWeekStart) {
                            start.setDate(start.getDate() - 1);
                        }

                        table += '<table><thead><tr>';

                        if (options.weeks) {
                            table += '<th></th>';
                        }

                        for (j = 0; j < 7; j += 1) {
                            table += '<th>' + options.i18n[globalLocale].dayOfWeekShort[(j + options.dayOfWeekStart) % 7] + '</th>';
                        }

                        table += '</tr></thead>';
                        table += '<tbody>';

                        if (options.maxDate !== false) {
                            maxDate = _xdsoft_datetime.strToDate(options.maxDate);
                            maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate(), 23, 59, 59, 999);
                        }

                        if (options.minDate !== false) {
                            minDate = _xdsoft_datetime.strToDate(options.minDate);
                            minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
                        }

                        while (i < _xdsoft_datetime.currentTime.countDaysInMonth() || start.getDay() !== options.dayOfWeekStart || _xdsoft_datetime.currentTime.getMonth() === start.getMonth()) {
                            classes = [];
                            i += 1;

                            day = start.getDay();
                            d = start.getDate();
                            y = start.getFullYear();
                            m = start.getMonth();
                            w = _xdsoft_datetime.getWeekOfYear(start);
                            description = '';

                            classes.push('xdsoft_date');

                            if (options.beforeShowDay && $.isFunction(options.beforeShowDay.call)) {
                                customDateSettings = options.beforeShowDay.call(datetimepicker, start);
                            } else {
                                customDateSettings = null;
                            }

                            if (options.allowDateRe && Object.prototype.toString.call(options.allowDateRe) === "[object RegExp]") {
                                if (!options.allowDateRe.test(dateHelper.formatDate(start, options.formatDate))) {
                                    classes.push('xdsoft_disabled');
                                }
                            } else if (options.allowDates && options.allowDates.length > 0) {
                                if (options.allowDates.indexOf(dateHelper.formatDate(start, options.formatDate)) === -1) {
                                    classes.push('xdsoft_disabled');
                                }
                            } else if ((maxDate !== false && start > maxDate) || (minDate !== false && start < minDate) || (customDateSettings && customDateSettings[0] === false)) {
                                classes.push('xdsoft_disabled');
                            } else if (options.disabledDates.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
                                classes.push('xdsoft_disabled');
                            } else if (options.disabledWeekDays.indexOf(day) !== -1) {
                                classes.push('xdsoft_disabled');
                            }

                            /*else if (input.is('[readonly]')) {
								classes.push('xdsoft_disabled');
							}*/

                            if (customDateSettings && customDateSettings[1] !== "") {
                                classes.push(customDateSettings[1]);
                            }

                            if (_xdsoft_datetime.currentTime.getMonth() !== m) {
                                classes.push('xdsoft_other_month');
                            }

                            if ((options.defaultSelect || datetimepicker.data('changed')) && dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
                                classes.push('xdsoft_current');
                            }

                            if (dateHelper.formatDate(today, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
                                classes.push('xdsoft_today');
                            }

                            if (start.getDay() === 0 || start.getDay() === 6 || options.weekends.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
                                classes.push('xdsoft_weekend');
                            }

                            if (options.highlightedDates[dateHelper.formatDate(start, options.formatDate)] !== undefined) {
                                hDate = options.highlightedDates[dateHelper.formatDate(start, options.formatDate)];
                                classes.push(hDate.style === undefined ? 'xdsoft_highlighted_default' : hDate.style);
                                description = hDate.desc === undefined ? '' : hDate.desc;
                            }

                            if (options.beforeShowDay && $.isFunction(options.beforeShowDay)) {
                                classes.push(options.beforeShowDay(start));
                            }

                            if (newRow) {
                                table += '<tr>';
                                newRow = false;
                                if (options.weeks) {
                                    table += '<th>' + w + '</th>';
                                }
                            }

                            table += '<td data-date="' + d + '" data-month="' + m + '" data-year="' + y + '"' + ' class="xdsoft_date xdsoft_day_of_week' + start.getDay() + ' ' + classes.join(' ') + '" title="' + description + '">' +
                                '<div>' + d + '</div>' +
                                '</td>';

                            if (start.getDay() === options.dayOfWeekStartPrev) {
                                table += '</tr>';
                                newRow = true;
                            }

                            start.setDate(d + 1);
                        }
                        table += '</tbody></table>';

                        calendar.html(table);

                        mounth_picker.find('.xdsoft_label span').eq(0).text(options.i18n[globalLocale].months[_xdsoft_datetime.currentTime.getMonth()]);
                        mounth_picker.find('.xdsoft_label span').eq(1).text(_xdsoft_datetime.currentTime.getFullYear());

                        // generate timebox
                        time = '';
                        h = '';
                        m = '';

                        line_time = function line_time(h, m) {
                            var now = _xdsoft_datetime.now(),
                                optionDateTime, current_time,
                                isALlowTimesInit = options.allowTimes && $.isArray(options.allowTimes) && options.allowTimes.length;
                            now.setHours(h);
                            h = parseInt(now.getHours(), 10);
                            now.setMinutes(m);
                            m = parseInt(now.getMinutes(), 10);
                            optionDateTime = new Date(_xdsoft_datetime.currentTime);
                            optionDateTime.setHours(h);
                            optionDateTime.setMinutes(m);
                            classes = [];
                            if ((options.minDateTime !== false && options.minDateTime > optionDateTime) || (options.maxTime !== false && _xdsoft_datetime.strtotime(options.maxTime).getTime() < now.getTime()) || (options.minTime !== false && _xdsoft_datetime.strtotime(options.minTime).getTime() > now.getTime())) {
                                classes.push('xdsoft_disabled');
                            } else if ((options.minDateTime !== false && options.minDateTime > optionDateTime) || ((options.disabledMinTime !== false && now.getTime() > _xdsoft_datetime.strtotime(options.disabledMinTime).getTime()) && (options.disabledMaxTime !== false && now.getTime() < _xdsoft_datetime.strtotime(options.disabledMaxTime).getTime()))) {
                                classes.push('xdsoft_disabled');
                            } else if (input.is('[readonly]')) {
                                classes.push('xdsoft_disabled');
                            }

                            current_time = new Date(_xdsoft_datetime.currentTime);
                            current_time.setHours(parseInt(_xdsoft_datetime.currentTime.getHours(), 10));

                            if (!isALlowTimesInit) {
                                current_time.setMinutes(Math[options.roundTime](_xdsoft_datetime.currentTime.getMinutes() / options.step) * options.step);
                            }

                            if ((options.initTime || options.defaultSelect || datetimepicker.data('changed')) && current_time.getHours() === parseInt(h, 10) && ((!isALlowTimesInit && options.step > 59) || current_time.getMinutes() === parseInt(m, 10))) {
                                if (options.defaultSelect || datetimepicker.data('changed')) {
                                    classes.push('xdsoft_current');
                                } else if (options.initTime) {
                                    classes.push('xdsoft_init_time');
                                }
                            }
                            if (parseInt(today.getHours(), 10) === parseInt(h, 10) && parseInt(today.getMinutes(), 10) === parseInt(m, 10)) {
                                classes.push('xdsoft_today');
                            }
                            time += '<div class="xdsoft_time ' + classes.join(' ') + '" data-hour="' + h + '" data-minute="' + m + '">' + dateHelper.formatDate(now, options.formatTime) + '</div>';
                        };

                        if (!options.allowTimes || !$.isArray(options.allowTimes) || !options.allowTimes.length) {
                            for (i = 0, j = 0; i < (options.hours12 ? 12 : 24); i += 1) {
                                for (j = 0; j < 60; j += options.step) {
                                    h = (i < 10 ? '0' : '') + i;
                                    m = (j < 10 ? '0' : '') + j;
                                    line_time(h, m);
                                }
                            }
                        } else {
                            for (i = 0; i < options.allowTimes.length; i += 1) {
                                h = _xdsoft_datetime.strtotime(options.allowTimes[i]).getHours();
                                m = _xdsoft_datetime.strtotime(options.allowTimes[i]).getMinutes();
                                line_time(h, m);
                            }
                        }

                        timebox.html(time);

                        opt = '';
                        i = 0;

                        for (i = parseInt(options.yearStart, 10) + options.yearOffset; i <= parseInt(options.yearEnd, 10) + options.yearOffset; i += 1) {
                            opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getFullYear() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + i + '</div>';
                        }
                        yearselect.children().eq(0)
                            .html(opt);

                        for (i = parseInt(options.monthStart, 10), opt = ''; i <= parseInt(options.monthEnd, 10); i += 1) {
                            opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getMonth() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + options.i18n[globalLocale].months[i] + '</div>';
                        }
                        monthselect.children().eq(0).html(opt);
                        $(datetimepicker)
                            .trigger('generate.xdsoft');
                    }, 10);
                    event.stopPropagation();
                })
                .on('afterOpen.xdsoft', function() {
                    if (options.timepicker) {
                        var classType, pheight, height, top;
                        if (timebox.find('.xdsoft_current').length) {
                            classType = '.xdsoft_current';
                        } else if (timebox.find('.xdsoft_init_time').length) {
                            classType = '.xdsoft_init_time';
                        }
                        if (classType) {
                            pheight = timeboxparent[0].clientHeight;
                            height = timebox[0].offsetHeight;
                            top = timebox.find(classType).index() * options.timeHeightInTimePicker + 1;
                            if ((height - pheight) < top) {
                                top = height - pheight;
                            }
                            timeboxparent.trigger('scroll_element.xdsoft_scroller', [parseInt(top, 10) / (height - pheight)]);
                        } else {
                            timeboxparent.trigger('scroll_element.xdsoft_scroller', [0]);
                        }
                    }
                });

            timerclick = 0;
            calendar
                .on('touchend click.xdsoft', 'td', function(xdevent) {
                    xdevent.stopPropagation(); // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap
                    timerclick += 1;
                    var $this = $(this),
                        currentTime = _xdsoft_datetime.currentTime;

                    if (currentTime === undefined || currentTime === null) {
                        _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                        currentTime = _xdsoft_datetime.currentTime;
                    }

                    if ($this.hasClass('xdsoft_disabled')) {
                        return false;
                    }

                    currentTime.setDate(1);
                    currentTime.setFullYear($this.data('year'));
                    currentTime.setMonth($this.data('month'));
                    currentTime.setDate($this.data('date'));

                    datetimepicker.trigger('select.xdsoft', [currentTime]);

                    input.val(_xdsoft_datetime.str());

                    if (options.onSelectDate && $.isFunction(options.onSelectDate)) {
                        options.onSelectDate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
                    }

                    datetimepicker.data('changed', true);
                    datetimepicker.trigger('xchange.xdsoft');
                    datetimepicker.trigger('changedatetime.xdsoft');
                    if ((timerclick > 1 || (options.closeOnDateSelect === true || (options.closeOnDateSelect === false && !options.timepicker))) && !options.inline) {
                        datetimepicker.trigger('close.xdsoft');
                    }
                    setTimeout(function() {
                        timerclick = 0;
                    }, 200);
                });

            timebox
                .on('touchend click.xdsoft', 'div', function(xdevent) {
                    xdevent.stopPropagation();
                    var $this = $(this),
                        currentTime = _xdsoft_datetime.currentTime;

                    if (currentTime === undefined || currentTime === null) {
                        _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                        currentTime = _xdsoft_datetime.currentTime;
                    }

                    if ($this.hasClass('xdsoft_disabled')) {
                        return false;
                    }
                    currentTime.setHours($this.data('hour'));
                    currentTime.setMinutes($this.data('minute'));
                    datetimepicker.trigger('select.xdsoft', [currentTime]);

                    datetimepicker.data('input').val(_xdsoft_datetime.str());

                    if (options.onSelectTime && $.isFunction(options.onSelectTime)) {
                        options.onSelectTime.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
                    }
                    datetimepicker.data('changed', true);
                    datetimepicker.trigger('xchange.xdsoft');
                    datetimepicker.trigger('changedatetime.xdsoft');
                    if (options.inline !== true && options.closeOnTimeSelect === true) {
                        datetimepicker.trigger('close.xdsoft');
                    }
                });

            datepicker
                .on('mousewheel.xdsoft', function(event) {
                    if (!options.scrollMonth) {
                        return true;
                    }
                    if (event.deltaY < 0) {
                        _xdsoft_datetime.nextMonth();
                    } else {
                        _xdsoft_datetime.prevMonth();
                    }
                    return false;
                });

            input
                .on('mousewheel.xdsoft', function(event) {
                    if (!options.scrollInput) {
                        return true;
                    }
                    if (!options.datepicker && options.timepicker) {
                        current_time_index = timebox.find('.xdsoft_current').length ? timebox.find('.xdsoft_current').eq(0).index() : 0;
                        if (current_time_index + event.deltaY >= 0 && current_time_index + event.deltaY < timebox.children().length) {
                            current_time_index += event.deltaY;
                        }
                        if (timebox.children().eq(current_time_index).length) {
                            timebox.children().eq(current_time_index).trigger('mousedown');
                        }
                        return false;
                    }
                    if (options.datepicker && !options.timepicker) {
                        datepicker.trigger(event, [event.deltaY, event.deltaX, event.deltaY]);
                        if (input.val) {
                            input.val(_xdsoft_datetime.str());
                        }
                        datetimepicker.trigger('changedatetime.xdsoft');
                        return false;
                    }
                });

            datetimepicker
                .on('changedatetime.xdsoft', function(event) {
                    if (options.onChangeDateTime && $.isFunction(options.onChangeDateTime)) {
                        var $input = datetimepicker.data('input');
                        options.onChangeDateTime.call(datetimepicker, _xdsoft_datetime.currentTime, $input, event);
                        delete options.value;
                        $input.trigger('change');
                    }
                })
                .on('generate.xdsoft', function() {
                    if (options.onGenerate && $.isFunction(options.onGenerate)) {
                        options.onGenerate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
                    }
                    if (triggerAfterOpen) {
                        datetimepicker.trigger('afterOpen.xdsoft');
                        triggerAfterOpen = false;
                    }
                })
                .on('click.xdsoft', function(xdevent) {
                    xdevent.stopPropagation();
                });

            current_time_index = 0;

            /**
             * Runs the callback for each of the specified node's ancestors.
             *
             * Return FALSE from the callback to stop ascending.
             *
             * @param {DOMNode} node
             * @param {Function} callback
             * @returns {undefined}
             */
            forEachAncestorOf = function(node, callback) {
                do {
                    node = node.parentNode;

                    if (callback(node) === false) {
                        break;
                    }
                } while (node.nodeName !== 'HTML');
            };

            /**
             * Sets the position of the picker.
             *
             * @returns {undefined}
             */
            setPos = function() {
                var dateInputOffset,
                    dateInputElem,
                    verticalPosition,
                    left,
                    position,
                    datetimepickerElem,
                    dateInputHasFixedAncestor,
                    $dateInput,
                    windowWidth,
                    verticalAnchorEdge,
                    datetimepickerCss,
                    windowHeight,
                    windowScrollTop;

                $dateInput = datetimepicker.data('input');
                dateInputOffset = $dateInput.offset();
                dateInputElem = $dateInput[0];

                verticalAnchorEdge = 'top';
                verticalPosition = (dateInputOffset.top + dateInputElem.offsetHeight) - 1;
                left = dateInputOffset.left;
                position = "absolute";

                windowWidth = $(window).width();
                windowHeight = $(window).height();
                windowScrollTop = $(window).scrollTop();

                if ((document.documentElement.clientWidth - dateInputOffset.left) < datepicker.parent().outerWidth(true)) {
                    var diff = datepicker.parent().outerWidth(true) - dateInputElem.offsetWidth;
                    left = left - diff;
                }

                if ($dateInput.parent().css('direction') === 'rtl') {
                    left -= (datetimepicker.outerWidth() - $dateInput.outerWidth());
                }

                if (options.fixed) {
                    verticalPosition -= windowScrollTop;
                    left -= $(window).scrollLeft();
                    position = "fixed";
                } else {
                    dateInputHasFixedAncestor = false;

                    forEachAncestorOf(dateInputElem, function(ancestorNode) {
                        if (window.getComputedStyle(ancestorNode).getPropertyValue('position') === 'fixed') {
                            dateInputHasFixedAncestor = true;
                            return false;
                        }
                    });

                    if (dateInputHasFixedAncestor) {
                        position = 'fixed';

                        //If the picker won't fit entirely within the viewport then display it above the date input.
                        if (verticalPosition + datetimepicker.outerHeight() > windowHeight + windowScrollTop) {
                            verticalAnchorEdge = 'bottom';
                            verticalPosition = (windowHeight + windowScrollTop) - dateInputOffset.top;
                        } else {
                            verticalPosition -= windowScrollTop;
                        }
                    } else {
                        if (verticalPosition + dateInputElem.offsetHeight > windowHeight + windowScrollTop) {
                            verticalPosition = dateInputOffset.top - dateInputElem.offsetHeight + 1;
                        }
                    }

                    if (verticalPosition < 0) {
                        verticalPosition = 0;
                    }

                    if (left + dateInputElem.offsetWidth > windowWidth) {
                        left = windowWidth - dateInputElem.offsetWidth;
                    }
                }

                datetimepickerElem = datetimepicker[0];

                forEachAncestorOf(datetimepickerElem, function(ancestorNode) {
                    var ancestorNodePosition;

                    ancestorNodePosition = window.getComputedStyle(ancestorNode).getPropertyValue('position');

                    if (ancestorNodePosition === 'relative' && windowWidth >= ancestorNode.offsetWidth) {
                        left = left - ((windowWidth - ancestorNode.offsetWidth) / 2);
                        return false;
                    }
                });

                datetimepickerCss = {
                    position: position,
                    left: left,
                    top: '', //Initialize to prevent previous values interfering with new ones.
                    bottom: '' //Initialize to prevent previous values interfering with new ones.
                };

                datetimepickerCss[verticalAnchorEdge] = verticalPosition;

                datetimepicker.css(datetimepickerCss);
            };

            datetimepicker
                .on('open.xdsoft', function(event) {
                    var onShow = true;
                    if (options.onShow && $.isFunction(options.onShow)) {
                        onShow = options.onShow.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
                    }
                    if (onShow !== false) {
                        datetimepicker.show();
                        setPos();
                        $(window)
                            .off('resize.xdsoft', setPos)
                            .on('resize.xdsoft', setPos);

                        if (options.closeOnWithoutClick) {
                            $([document.body, window]).on('touchstart mousedown.xdsoft', function arguments_callee6() {
                                datetimepicker.trigger('close.xdsoft');
                                $([document.body, window]).off('touchstart mousedown.xdsoft', arguments_callee6);
                            });
                        }
                    }
                })
                .on('close.xdsoft', function(event) {
                    var onClose = true;
                    mounth_picker
                        .find('.xdsoft_month,.xdsoft_year')
                        .find('.xdsoft_select')
                        .hide();
                    if (options.onClose && $.isFunction(options.onClose)) {
                        onClose = options.onClose.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
                    }
                    if (onClose !== false && !options.opened && !options.inline) {
                        datetimepicker.hide();
                    }
                    event.stopPropagation();
                })
                .on('toggle.xdsoft', function() {
                    if (datetimepicker.is(':visible')) {
                        datetimepicker.trigger('close.xdsoft');
                    } else {
                        datetimepicker.trigger('open.xdsoft');
                    }
                })
                .data('input', input);

            timer = 0;

            datetimepicker.data('xdsoft_datetime', _xdsoft_datetime);
            datetimepicker.setOptions(options);

            function getCurrentValue() {
                var ct = false,
                    time;

                if (options.startDate) {
                    ct = _xdsoft_datetime.strToDate(options.startDate);
                } else {
                    ct = options.value || ((input && input.val && input.val()) ? input.val() : '');
                    if (ct) {
                        ct = _xdsoft_datetime.strToDateTime(ct);
                    } else if (options.defaultDate) {
                        ct = _xdsoft_datetime.strToDateTime(options.defaultDate);
                        if (options.defaultTime) {
                            time = _xdsoft_datetime.strtotime(options.defaultTime);
                            ct.setHours(time.getHours());
                            ct.setMinutes(time.getMinutes());
                        }
                    }
                }

                if (ct && _xdsoft_datetime.isValidDate(ct)) {
                    datetimepicker.data('changed', true);
                } else {
                    ct = '';
                }

                return ct || 0;
            }

            function setMask(options) {

                var isValidValue = function(mask, value) {
                        var reg = mask
                            .replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g, '\\$1')
                            .replace(/_/g, '{digit+}')
                            .replace(/([0-9]{1})/g, '{digit$1}')
                            .replace(/\{digit([0-9]{1})\}/g, '[0-$1_]{1}')
                            .replace(/\{digit[\+]\}/g, '[0-9_]{1}');
                        return (new RegExp(reg)).test(value);
                    },
                    getCaretPos = function(input) {
                        try {
                            if (document.selection && document.selection.createRange) {
                                var range = document.selection.createRange();
                                return range.getBookmark().charCodeAt(2) - 2;
                            }
                            if (input.setSelectionRange) {
                                return input.selectionStart;
                            }
                        } catch (e) {
                            return 0;
                        }
                    },
                    setCaretPos = function(node, pos) {
                        node = (typeof node === "string" || node instanceof String) ? document.getElementById(node) : node;
                        if (!node) {
                            return false;
                        }
                        if (node.createTextRange) {
                            var textRange = node.createTextRange();
                            textRange.collapse(true);
                            textRange.moveEnd('character', pos);
                            textRange.moveStart('character', pos);
                            textRange.select();
                            return true;
                        }
                        if (node.setSelectionRange) {
                            node.setSelectionRange(pos, pos);
                            return true;
                        }
                        return false;
                    };
                if (options.mask) {
                    input.off('keydown.xdsoft');
                }
                if (options.mask === true) {
                    if (typeof moment != 'undefined') {
                        options.mask = options.format
                            .replace(/Y{4}/g, '9999')
                            .replace(/Y{2}/g, '99')
                            .replace(/M{2}/g, '19')
                            .replace(/D{2}/g, '39')
                            .replace(/H{2}/g, '29')
                            .replace(/m{2}/g, '59')
                            .replace(/s{2}/g, '59');
                    } else {
                        options.mask = options.format
                            .replace(/Y/g, '9999')
                            .replace(/F/g, '9999')
                            .replace(/m/g, '19')
                            .replace(/d/g, '39')
                            .replace(/H/g, '29')
                            .replace(/i/g, '59')
                            .replace(/s/g, '59');
                    }
                }

                if ($.type(options.mask) === 'string') {
                    if (!isValidValue(options.mask, input.val())) {
                        input.val(options.mask.replace(/[0-9]/g, '_'));
                        setCaretPos(input[0], 0);
                    }

                    input.on('keydown.xdsoft', function(event) {
                        var val = this.value,
                            key = event.which,
                            pos,
                            digit;

                        if (((key >= KEY0 && key <= KEY9) || (key >= _KEY0 && key <= _KEY9)) || (key === BACKSPACE || key === DEL)) {
                            pos = getCaretPos(this);
                            digit = (key !== BACKSPACE && key !== DEL) ? String.fromCharCode((_KEY0 <= key && key <= _KEY9) ? key - KEY0 : key) : '_';

                            if ((key === BACKSPACE || key === DEL) && pos) {
                                pos -= 1;
                                digit = '_';
                            }

                            while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
                                pos += (key === BACKSPACE || key === DEL) ? -1 : 1;
                            }

                            val = val.substr(0, pos) + digit + val.substr(pos + 1);
                            if ($.trim(val) === '') {
                                val = options.mask.replace(/[0-9]/g, '_');
                            } else {
                                if (pos === options.mask.length) {
                                    event.preventDefault();
                                    return false;
                                }
                            }

                            pos += (key === BACKSPACE || key === DEL) ? 0 : 1;
                            while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
                                pos += (key === BACKSPACE || key === DEL) ? -1 : 1;
                            }

                            if (isValidValue(options.mask, val)) {
                                this.value = val;
                                setCaretPos(this, pos);
                            } else if ($.trim(val) === '') {
                                this.value = options.mask.replace(/[0-9]/g, '_');
                            } else {
                                input.trigger('error_input.xdsoft');
                            }
                        } else {
                            if (([AKEY, CKEY, VKEY, ZKEY, YKEY].indexOf(key) !== -1 && ctrlDown) || [ESC, ARROWUP, ARROWDOWN, ARROWLEFT, ARROWRIGHT, F5, CTRLKEY, TAB, ENTER].indexOf(key) !== -1) {
                                return true;
                            }
                        }

                        event.preventDefault();
                        return false;
                    });
                }
            }

            _xdsoft_datetime.setCurrentTime(getCurrentValue());

            input
                .data('xdsoft_datetimepicker', datetimepicker)
                .on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function() {
                    if (input.is(':disabled') || (input.data('xdsoft_datetimepicker').is(':visible') && options.closeOnInputClick)) {
                        return;
                    }
                    clearTimeout(timer);
                    timer = setTimeout(function() {
                        if (input.is(':disabled')) {
                            return;
                        }

                        triggerAfterOpen = true;
                        _xdsoft_datetime.setCurrentTime(getCurrentValue());
                        if (options.mask) {
                            setMask(options);
                        }
                        datetimepicker.trigger('open.xdsoft');
                    }, 100);
                })
                .on('keydown.xdsoft', function(event) {
                    var elementSelector,
                        key = event.which;
                    if ([ENTER].indexOf(key) !== -1 && options.enterLikeTab) {
                        elementSelector = $("input:visible,textarea:visible,button:visible,a:visible");
                        datetimepicker.trigger('close.xdsoft');
                        elementSelector.eq(elementSelector.index(this) + 1).focus();
                        return false;
                    }
                    if ([TAB].indexOf(key) !== -1) {
                        datetimepicker.trigger('close.xdsoft');
                        return true;
                    }
                })
                .on('blur.xdsoft', function() {
                    datetimepicker.trigger('close.xdsoft');
                });
        };
        destroyDateTimePicker = function(input) {
            var datetimepicker = input.data('xdsoft_datetimepicker');
            if (datetimepicker) {
                datetimepicker.data('xdsoft_datetime', null);
                datetimepicker.remove();
                input
                    .data('xdsoft_datetimepicker', null)
                    .off('.xdsoft');
                $(window).off('resize.xdsoft');
                $([window, document.body]).off('mousedown.xdsoft touchstart');
                if (input.unmousewheel) {
                    input.unmousewheel();
                }
            }
        };
        $(document)
            .off('keydown.xdsoftctrl keyup.xdsoftctrl')
            .on('keydown.xdsoftctrl', function(e) {
                if (e.keyCode === CTRLKEY) {
                    ctrlDown = true;
                }
            })
            .on('keyup.xdsoftctrl', function(e) {
                if (e.keyCode === CTRLKEY) {
                    ctrlDown = false;
                }
            });

        this.each(function() {
            var datetimepicker = $(this).data('xdsoft_datetimepicker'),
                $input;
            if (datetimepicker) {
                if ($.type(opt) === 'string') {
                    switch (opt) {
                        case 'show':
                            $(this).select().focus();
                            datetimepicker.trigger('open.xdsoft');
                            break;
                        case 'hide':
                            datetimepicker.trigger('close.xdsoft');
                            break;
                        case 'toggle':
                            datetimepicker.trigger('toggle.xdsoft');
                            break;
                        case 'destroy':
                            destroyDateTimePicker($(this));
                            break;
                        case 'reset':
                            this.value = this.defaultValue;
                            if (!this.value || !datetimepicker.data('xdsoft_datetime').isValidDate(dateHelper.parseDate(this.value, options.format))) {
                                datetimepicker.data('changed', false);
                            }
                            datetimepicker.data('xdsoft_datetime').setCurrentTime(this.value);
                            break;
                        case 'validate':
                            $input = datetimepicker.data('input');
                            $input.trigger('blur.xdsoft');
                            break;
                        default:
                            if (datetimepicker[opt] && $.isFunction(datetimepicker[opt])) {
                                result = datetimepicker[opt](opt2);
                            }
                    }
                } else {
                    datetimepicker
                        .setOptions(opt);
                }
                return 0;
            }
            if ($.type(opt) !== 'string') {
                if (!options.lazyInit || options.open || options.inline) {
                    createDateTimePicker($(this));
                } else {
                    lazyInit($(this));
                }
            }
        });

        return result;
    };

    $.fn.datetimepicker.defaults = default_options;

    function HighlightedDate(date, desc, style) {
        "use strict";
        this.date = date;
        this.desc = desc;
        this.style = style;
    }
}));
/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ('onwheel' in document || document.documentMode >= 9) ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ($.event.fixHooks) {
        for (var i = toFix.length; i;) {
            $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if (this.addEventListener) {
                for (var i = toBind.length; i;) {
                    this.addEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if (this.removeEventListener) {
                for (var i = toBind.length; i;) {
                    this.removeEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0,
            offsetX = 0,
            offsetY = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ('detail' in orgEvent) {
            deltaY = orgEvent.detail * -1;
        }
        if ('wheelDelta' in orgEvent) {
            deltaY = orgEvent.wheelDelta;
        }
        if ('wheelDeltaY' in orgEvent) {
            deltaY = orgEvent.wheelDeltaY;
        }
        if ('wheelDeltaX' in orgEvent) {
            deltaX = orgEvent.wheelDeltaX * -1;
        }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ('deltaY' in orgEvent) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if ('deltaX' in orgEvent) {
            deltaX = orgEvent.deltaX;
            if (deltaY === 0) {
                delta = deltaX * -1;
            }
        }

        // No change actually happened, no reason to go any further
        if (deltaY === 0 && deltaX === 0) {
            return;
        }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if (orgEvent.deltaMode === 1) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if (orgEvent.deltaMode === 2) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

        if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
            // Divide all the things by 40!
            delta /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if (special.settings.normalizeOffset && this.getBoundingClientRect) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) {
            clearTimeout(nullLowestDeltaTimeout);
        }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

/*!
 * VERSION: 1.18.2
 * DATE: 2015-12-22
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2016, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";
        _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(a, b, c) {
                var d = function(a) {
                        var b, c = [],
                            d = a.length;
                        for (b = 0; b !== d; c.push(a[b++]));
                        return c
                    },
                    e = function(a, b, c) {
                        var d, e, f = a.cycle;
                        for (d in f) e = f[d], a[d] = "function" == typeof e ? e.call(b[c], c) : e[c % e.length];
                        delete a.cycle
                    },
                    f = function(a, b, d) {
                        c.call(this, a, b, d), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = f.prototype.render
                    },
                    g = 1e-10,
                    h = c._internals,
                    i = h.isSelector,
                    j = h.isArray,
                    k = f.prototype = c.to({}, .1, {}),
                    l = [];
                f.version = "1.18.2", k.constructor = f, k.kill()._gc = !1, f.killTweensOf = f.killDelayedCallsTo = c.killTweensOf, f.getTweensOf = c.getTweensOf, f.lagSmoothing = c.lagSmoothing, f.ticker = c.ticker, f.render = c.render, k.invalidate = function() {
                    return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), c.prototype.invalidate.call(this)
                }, k.updateTo = function(a, b) {
                    var d, e = this.ratio,
                        f = this.vars.immediateRender || a.immediateRender;
                    b && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                    for (d in a) this.vars[d] = a[d];
                    if (this._initted || f)
                        if (b) this._initted = !1, f && this.render(0, !0, !0);
                        else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && c._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                        var g = this._totalTime;
                        this.render(0, !0, !1), this._initted = !1, this.render(g, !0, !1)
                    } else if (this._initted = !1, this._init(), this._time > 0 || f)
                        for (var h, i = 1 / (1 - e), j = this._firstPT; j;) h = j.s + j.c, j.c *= i, j.s = h - j.c, j = j._next;
                    return this
                }, k.render = function(a, b, c) {
                    this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                    var d, e, f, i, j, k, l, m, n = this._dirty ? this.totalDuration() : this._totalDuration,
                        o = this._time,
                        p = this._totalTime,
                        q = this._cycle,
                        r = this._duration,
                        s = this._rawPrevTime;
                    if (a >= n - 1e-7 ? (this._totalTime = n, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = r, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (d = !0, e = "onComplete", c = c || this._timeline.autoRemoveChildren), 0 === r && (this._initted || !this.vars.lazy || c) && (this._startTime === this._timeline._duration && (a = 0), (0 > s || 0 >= a && a >= -1e-7 || s === g && "isPause" !== this.data) && s !== a && (c = !0, s > g && (e = "onReverseComplete")), this._rawPrevTime = m = !b || a || s === a ? a : g)) : 1e-7 > a ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== p || 0 === r && s > 0) && (e = "onReverseComplete", d = this._reversed), 0 > a && (this._active = !1, 0 === r && (this._initted || !this.vars.lazy || c) && (s >= 0 && (c = !0), this._rawPrevTime = m = !b || a || s === a ? a : g)), this._initted || (c = !0)) : (this._totalTime = this._time = a, 0 !== this._repeat && (i = r + this._repeatDelay, this._cycle = this._totalTime / i >> 0, 0 !== this._cycle && this._cycle === this._totalTime / i && this._cycle--, this._time = this._totalTime - this._cycle * i, this._yoyo && 0 !== (1 & this._cycle) && (this._time = r - this._time), this._time > r ? this._time = r : this._time < 0 && (this._time = 0)), this._easeType ? (j = this._time / r, k = this._easeType, l = this._easePower, (1 === k || 3 === k && j >= .5) && (j = 1 - j), 3 === k && (j *= 2), 1 === l ? j *= j : 2 === l ? j *= j * j : 3 === l ? j *= j * j * j : 4 === l && (j *= j * j * j * j), 1 === k ? this.ratio = 1 - j : 2 === k ? this.ratio = j : this._time / r < .5 ? this.ratio = j / 2 : this.ratio = 1 - j / 2) : this.ratio = this._ease.getRatio(this._time / r)), o === this._time && !c && q === this._cycle) return void(p !== this._totalTime && this._onUpdate && (b || this._callback("onUpdate")));
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!c && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = o, this._totalTime = p, this._rawPrevTime = s, this._cycle = q, h.lazyTweens.push(this), void(this._lazy = [a, b]);
                        this._time && !d ? this.ratio = this._ease.getRatio(this._time / r) : d && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== o && a >= 0 && (this._active = !0), 0 === p && (2 === this._initted && a > 0 && this._init(), this._startAt && (a >= 0 ? this._startAt.render(a, b, c) : e || (e = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === r) && (b || this._callback("onStart"))), f = this._firstPT; f;) f.f ? f.t[f.p](f.c * this.ratio + f.s) : f.t[f.p] = f.c * this.ratio + f.s, f = f._next;
                    this._onUpdate && (0 > a && this._startAt && this._startTime && this._startAt.render(a, b, c), b || (this._totalTime !== p || d) && this._callback("onUpdate")), this._cycle !== q && (b || this._gc || this.vars.onRepeat && this._callback("onRepeat")), e && (!this._gc || c) && (0 > a && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(a, b, c), d && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[e] && this._callback(e), 0 === r && this._rawPrevTime === g && m !== g && (this._rawPrevTime = 0))
                }, f.to = function(a, b, c) {
                    return new f(a, b, c)
                }, f.from = function(a, b, c) {
                    return c.runBackwards = !0, c.immediateRender = 0 != c.immediateRender, new f(a, b, c)
                }, f.fromTo = function(a, b, c, d) {
                    return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, new f(a, b, d)
                }, f.staggerTo = f.allTo = function(a, b, g, h, k, m, n) {
                    h = h || 0;
                    var o, p, q, r, s = 0,
                        t = [],
                        u = function() {
                            g.onComplete && g.onComplete.apply(g.onCompleteScope || this, arguments), k.apply(n || g.callbackScope || this, m || l)
                        },
                        v = g.cycle,
                        w = g.startAt && g.startAt.cycle;
                    for (j(a) || ("string" == typeof a && (a = c.selector(a) || a), i(a) && (a = d(a))), a = a || [], 0 > h && (a = d(a), a.reverse(), h *= -1), o = a.length - 1, q = 0; o >= q; q++) {
                        p = {};
                        for (r in g) p[r] = g[r];
                        if (v && e(p, a, q), w) {
                            w = p.startAt = {};
                            for (r in g.startAt) w[r] = g.startAt[r];
                            e(p.startAt, a, q)
                        }
                        p.delay = s + (p.delay || 0), q === o && k && (p.onComplete = u), t[q] = new f(a[q], b, p), s += h
                    }
                    return t
                }, f.staggerFrom = f.allFrom = function(a, b, c, d, e, g, h) {
                    return c.runBackwards = !0, c.immediateRender = 0 != c.immediateRender, f.staggerTo(a, b, c, d, e, g, h)
                }, f.staggerFromTo = f.allFromTo = function(a, b, c, d, e, g, h, i) {
                    return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, f.staggerTo(a, b, d, e, g, h, i)
                }, f.delayedCall = function(a, b, c, d, e) {
                    return new f(b, 0, {
                        delay: a,
                        onComplete: b,
                        onCompleteParams: c,
                        callbackScope: d,
                        onReverseComplete: b,
                        onReverseCompleteParams: c,
                        immediateRender: !1,
                        useFrames: e,
                        overwrite: 0
                    })
                }, f.set = function(a, b) {
                    return new f(a, 0, b)
                }, f.isTweening = function(a) {
                    return c.getTweensOf(a, !0).length > 0
                };
                var m = function(a, b) {
                        for (var d = [], e = 0, f = a._first; f;) f instanceof c ? d[e++] = f : (b && (d[e++] = f), d = d.concat(m(f, b)), e = d.length), f = f._next;
                        return d
                    },
                    n = f.getAllTweens = function(b) {
                        return m(a._rootTimeline, b).concat(m(a._rootFramesTimeline, b))
                    };
                f.killAll = function(a, c, d, e) {
                    null == c && (c = !0), null == d && (d = !0);
                    var f, g, h, i = n(0 != e),
                        j = i.length,
                        k = c && d && e;
                    for (h = 0; j > h; h++) g = i[h], (k || g instanceof b || (f = g.target === g.vars.onComplete) && d || c && !f) && (a ? g.totalTime(g._reversed ? 0 : g.totalDuration()) : g._enabled(!1, !1))
                }, f.killChildTweensOf = function(a, b) {
                    if (null != a) {
                        var e, g, k, l, m, n = h.tweenLookup;
                        if ("string" == typeof a && (a = c.selector(a) || a), i(a) && (a = d(a)), j(a))
                            for (l = a.length; --l > -1;) f.killChildTweensOf(a[l], b);
                        else {
                            e = [];
                            for (k in n)
                                for (g = n[k].target.parentNode; g;) g === a && (e = e.concat(n[k].tweens)), g = g.parentNode;
                            for (m = e.length, l = 0; m > l; l++) b && e[l].totalTime(e[l].totalDuration()), e[l]._enabled(!1, !1)
                        }
                    }
                };
                var o = function(a, c, d, e) {
                    c = c !== !1, d = d !== !1, e = e !== !1;
                    for (var f, g, h = n(e), i = c && d && e, j = h.length; --j > -1;) g = h[j], (i || g instanceof b || (f = g.target === g.vars.onComplete) && d || c && !f) && g.paused(a)
                };
                return f.pauseAll = function(a, b, c) {
                    o(!0, a, b, c)
                }, f.resumeAll = function(a, b, c) {
                    o(!1, a, b, c)
                }, f.globalTimeScale = function(b) {
                    var d = a._rootTimeline,
                        e = c.ticker.time;
                    return arguments.length ? (b = b || g, d._startTime = e - (e - d._startTime) * d._timeScale / b, d = a._rootFramesTimeline, e = c.ticker.frame, d._startTime = e - (e - d._startTime) * d._timeScale / b, d._timeScale = a._rootTimeline._timeScale = b, b) : d._timeScale
                }, k.progress = function(a) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - a : a) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
                }, k.totalProgress = function(a) {
                    return arguments.length ? this.totalTime(this.totalDuration() * a, !1) : this._totalTime / this.totalDuration()
                }, k.time = function(a, b) {
                    return arguments.length ? (this._dirty && this.totalDuration(), a > this._duration && (a = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? a = this._duration - a + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (a += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(a, b)) : this._time
                }, k.duration = function(b) {
                    return arguments.length ? a.prototype.duration.call(this, b) : this._duration
                }, k.totalDuration = function(a) {
                    return arguments.length ? -1 === this._repeat ? this : this.duration((a - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                }, k.repeat = function(a) {
                    return arguments.length ? (this._repeat = a, this._uncache(!0)) : this._repeat
                }, k.repeatDelay = function(a) {
                    return arguments.length ? (this._repeatDelay = a, this._uncache(!0)) : this._repeatDelay
                }, k.yoyo = function(a) {
                    return arguments.length ? (this._yoyo = a, this) : this._yoyo
                }, f
            }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(a, b, c) {
                var d = function(a) {
                        b.call(this, a), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                        var c, d, e = this.vars;
                        for (d in e) c = e[d], i(c) && -1 !== c.join("").indexOf("{self}") && (e[d] = this._swapSelfInParams(c));
                        i(e.tweens) && this.add(e.tweens, 0, e.align, e.stagger)
                    },
                    e = 1e-10,
                    f = c._internals,
                    g = d._internals = {},
                    h = f.isSelector,
                    i = f.isArray,
                    j = f.lazyTweens,
                    k = f.lazyRender,
                    l = _gsScope._gsDefine.globals,
                    m = function(a) {
                        var b, c = {};
                        for (b in a) c[b] = a[b];
                        return c
                    },
                    n = function(a, b, c) {
                        var d, e, f = a.cycle;
                        for (d in f) e = f[d], a[d] = "function" == typeof e ? e.call(b[c], c) : e[c % e.length];
                        delete a.cycle
                    },
                    o = g.pauseCallback = function() {},
                    p = function(a) {
                        var b, c = [],
                            d = a.length;
                        for (b = 0; b !== d; c.push(a[b++]));
                        return c
                    },
                    q = d.prototype = new b;
                return d.version = "1.18.2", q.constructor = d, q.kill()._gc = q._forcingPlayhead = q._hasPause = !1, q.to = function(a, b, d, e) {
                    var f = d.repeat && l.TweenMax || c;
                    return b ? this.add(new f(a, b, d), e) : this.set(a, d, e)
                }, q.from = function(a, b, d, e) {
                    return this.add((d.repeat && l.TweenMax || c).from(a, b, d), e)
                }, q.fromTo = function(a, b, d, e, f) {
                    var g = e.repeat && l.TweenMax || c;
                    return b ? this.add(g.fromTo(a, b, d, e), f) : this.set(a, e, f)
                }, q.staggerTo = function(a, b, e, f, g, i, j, k) {
                    var l, o, q = new d({
                            onComplete: i,
                            onCompleteParams: j,
                            callbackScope: k,
                            smoothChildTiming: this.smoothChildTiming
                        }),
                        r = e.cycle;
                    for ("string" == typeof a && (a = c.selector(a) || a), a = a || [], h(a) && (a = p(a)), f = f || 0, 0 > f && (a = p(a), a.reverse(), f *= -1), o = 0; o < a.length; o++) l = m(e), l.startAt && (l.startAt = m(l.startAt), l.startAt.cycle && n(l.startAt, a, o)), r && n(l, a, o), q.to(a[o], b, l, o * f);
                    return this.add(q, g)
                }, q.staggerFrom = function(a, b, c, d, e, f, g, h) {
                    return c.immediateRender = 0 != c.immediateRender, c.runBackwards = !0, this.staggerTo(a, b, c, d, e, f, g, h)
                }, q.staggerFromTo = function(a, b, c, d, e, f, g, h, i) {
                    return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, this.staggerTo(a, b, d, e, f, g, h, i)
                }, q.call = function(a, b, d, e) {
                    return this.add(c.delayedCall(0, a, b, d), e)
                }, q.set = function(a, b, d) {
                    return d = this._parseTimeOrLabel(d, 0, !0), null == b.immediateRender && (b.immediateRender = d === this._time && !this._paused), this.add(new c(a, 0, b), d)
                }, d.exportRoot = function(a, b) {
                    a = a || {}, null == a.smoothChildTiming && (a.smoothChildTiming = !0);
                    var e, f, g = new d(a),
                        h = g._timeline;
                    for (null == b && (b = !0), h._remove(g, !0), g._startTime = 0, g._rawPrevTime = g._time = g._totalTime = h._time, e = h._first; e;) f = e._next, b && e instanceof c && e.target === e.vars.onComplete || g.add(e, e._startTime - e._delay), e = f;
                    return h.add(g, 0), g
                }, q.add = function(e, f, g, h) {
                    var j, k, l, m, n, o;
                    if ("number" != typeof f && (f = this._parseTimeOrLabel(f, 0, !0, e)), !(e instanceof a)) {
                        if (e instanceof Array || e && e.push && i(e)) {
                            for (g = g || "normal", h = h || 0, j = f, k = e.length, l = 0; k > l; l++) i(m = e[l]) && (m = new d({
                                tweens: m
                            })), this.add(m, j), "string" != typeof m && "function" != typeof m && ("sequence" === g ? j = m._startTime + m.totalDuration() / m._timeScale : "start" === g && (m._startTime -= m.delay())), j += h;
                            return this._uncache(!0)
                        }
                        if ("string" == typeof e) return this.addLabel(e, f);
                        if ("function" != typeof e) throw "Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string.";
                        e = c.delayedCall(0, e)
                    }
                    if (b.prototype.add.call(this, e, f), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                        for (n = this, o = n.rawTime() > e._startTime; n._timeline;) o && n._timeline.smoothChildTiming ? n.totalTime(n._totalTime, !0) : n._gc && n._enabled(!0, !1), n = n._timeline;
                    return this
                }, q.remove = function(b) {
                    if (b instanceof a) {
                        this._remove(b, !1);
                        var c = b._timeline = b.vars.useFrames ? a._rootFramesTimeline : a._rootTimeline;
                        return b._startTime = (b._paused ? b._pauseTime : c._time) - (b._reversed ? b.totalDuration() - b._totalTime : b._totalTime) / b._timeScale, this
                    }
                    if (b instanceof Array || b && b.push && i(b)) {
                        for (var d = b.length; --d > -1;) this.remove(b[d]);
                        return this
                    }
                    return "string" == typeof b ? this.removeLabel(b) : this.kill(null, b)
                }, q._remove = function(a, c) {
                    b.prototype._remove.call(this, a, c);
                    var d = this._last;
                    return d ? this._time > d._startTime + d._totalDuration / d._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                }, q.append = function(a, b) {
                    return this.add(a, this._parseTimeOrLabel(null, b, !0, a))
                }, q.insert = q.insertMultiple = function(a, b, c, d) {
                    return this.add(a, b || 0, c, d)
                }, q.appendMultiple = function(a, b, c, d) {
                    return this.add(a, this._parseTimeOrLabel(null, b, !0, a), c, d)
                }, q.addLabel = function(a, b) {
                    return this._labels[a] = this._parseTimeOrLabel(b), this
                }, q.addPause = function(a, b, d, e) {
                    var f = c.delayedCall(0, o, d, e || this);
                    return f.vars.onComplete = f.vars.onReverseComplete = b, f.data = "isPause", this._hasPause = !0, this.add(f, a)
                }, q.removeLabel = function(a) {
                    return delete this._labels[a], this
                }, q.getLabelTime = function(a) {
                    return null != this._labels[a] ? this._labels[a] : -1
                }, q._parseTimeOrLabel = function(b, c, d, e) {
                    var f;
                    if (e instanceof a && e.timeline === this) this.remove(e);
                    else if (e && (e instanceof Array || e.push && i(e)))
                        for (f = e.length; --f > -1;) e[f] instanceof a && e[f].timeline === this && this.remove(e[f]);
                    if ("string" == typeof c) return this._parseTimeOrLabel(c, d && "number" == typeof b && null == this._labels[c] ? b - this.duration() : 0, d);
                    if (c = c || 0, "string" != typeof b || !isNaN(b) && null == this._labels[b]) null == b && (b = this.duration());
                    else {
                        if (f = b.indexOf("="), -1 === f) return null == this._labels[b] ? d ? this._labels[b] = this.duration() + c : c : this._labels[b] + c;
                        c = parseInt(b.charAt(f - 1) + "1", 10) * Number(b.substr(f + 1)), b = f > 1 ? this._parseTimeOrLabel(b.substr(0, f - 1), 0, d) : this.duration()
                    }
                    return Number(b) + c
                }, q.seek = function(a, b) {
                    return this.totalTime("number" == typeof a ? a : this._parseTimeOrLabel(a), b !== !1)
                }, q.stop = function() {
                    return this.paused(!0)
                }, q.gotoAndPlay = function(a, b) {
                    return this.play(a, b)
                }, q.gotoAndStop = function(a, b) {
                    return this.pause(a, b)
                }, q.render = function(a, b, c) {
                    this._gc && this._enabled(!0, !1);
                    var d, f, g, h, i, l, m, n = this._dirty ? this.totalDuration() : this._totalDuration,
                        o = this._time,
                        p = this._startTime,
                        q = this._timeScale,
                        r = this._paused;
                    if (a >= n - 1e-7) this._totalTime = this._time = n, this._reversed || this._hasPausedChild() || (f = !0, h = "onComplete", i = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= a && a >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === e) && this._rawPrevTime !== a && this._first && (i = !0, this._rawPrevTime > e && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e, a = n + 1e-4;
                    else if (1e-7 > a)
                        if (this._totalTime = this._time = 0, (0 !== o || 0 === this._duration && this._rawPrevTime !== e && (this._rawPrevTime > 0 || 0 > a && this._rawPrevTime >= 0)) && (h = "onReverseComplete", f = this._reversed), 0 > a) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (i = f = !0, h = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (i = !0), this._rawPrevTime = a;
                        else {
                            if (this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e, 0 === a && f)
                                for (d = this._first; d && 0 === d._startTime;) d._duration || (f = !1), d = d._next;
                            a = 0, this._initted || (i = !0)
                        }
                    else {
                        if (this._hasPause && !this._forcingPlayhead && !b) {
                            if (a >= o)
                                for (d = this._first; d && d._startTime <= a && !l;) d._duration || "isPause" !== d.data || d.ratio || 0 === d._startTime && 0 === this._rawPrevTime || (l = d), d = d._next;
                            else
                                for (d = this._last; d && d._startTime >= a && !l;) d._duration || "isPause" === d.data && d._rawPrevTime > 0 && (l = d), d = d._prev;
                            l && (this._time = a = l._startTime, this._totalTime = a + this._cycle * (this._totalDuration + this._repeatDelay))
                        }
                        this._totalTime = this._time = this._rawPrevTime = a
                    }
                    if (this._time !== o && this._first || c || i || l) {
                        if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== o && a > 0 && (this._active = !0), 0 === o && this.vars.onStart && 0 !== this._time && (b || this._callback("onStart")), m = this._time, m >= o)
                            for (d = this._first; d && (g = d._next, m === this._time && (!this._paused || r));)(d._active || d._startTime <= m && !d._paused && !d._gc) && (l === d && this.pause(), d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c)), d = g;
                        else
                            for (d = this._last; d && (g = d._prev, m === this._time && (!this._paused || r));) {
                                if (d._active || d._startTime <= o && !d._paused && !d._gc) {
                                    if (l === d) {
                                        for (l = d._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (a - l._startTime) * l._timeScale : (a - l._startTime) * l._timeScale, b, c), l = l._prev;
                                        l = null, this.pause()
                                    }
                                    d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c)
                                }
                                d = g
                            }
                        this._onUpdate && (b || (j.length && k(), this._callback("onUpdate"))), h && (this._gc || (p === this._startTime || q !== this._timeScale) && (0 === this._time || n >= this.totalDuration()) && (f && (j.length && k(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[h] && this._callback(h)))
                    }
                }, q._hasPausedChild = function() {
                    for (var a = this._first; a;) {
                        if (a._paused || a instanceof d && a._hasPausedChild()) return !0;
                        a = a._next
                    }
                    return !1
                }, q.getChildren = function(a, b, d, e) {
                    e = e || -9999999999;
                    for (var f = [], g = this._first, h = 0; g;) g._startTime < e || (g instanceof c ? b !== !1 && (f[h++] = g) : (d !== !1 && (f[h++] = g), a !== !1 && (f = f.concat(g.getChildren(!0, b, d)), h = f.length))), g = g._next;
                    return f
                }, q.getTweensOf = function(a, b) {
                    var d, e, f = this._gc,
                        g = [],
                        h = 0;
                    for (f && this._enabled(!0, !0), d = c.getTweensOf(a), e = d.length; --e > -1;)(d[e].timeline === this || b && this._contains(d[e])) && (g[h++] = d[e]);
                    return f && this._enabled(!1, !0), g
                }, q.recent = function() {
                    return this._recent
                }, q._contains = function(a) {
                    for (var b = a.timeline; b;) {
                        if (b === this) return !0;
                        b = b.timeline
                    }
                    return !1
                }, q.shiftChildren = function(a, b, c) {
                    c = c || 0;
                    for (var d, e = this._first, f = this._labels; e;) e._startTime >= c && (e._startTime += a), e = e._next;
                    if (b)
                        for (d in f) f[d] >= c && (f[d] += a);
                    return this._uncache(!0)
                }, q._kill = function(a, b) {
                    if (!a && !b) return this._enabled(!1, !1);
                    for (var c = b ? this.getTweensOf(b) : this.getChildren(!0, !0, !1), d = c.length, e = !1; --d > -1;) c[d]._kill(a, b) && (e = !0);
                    return e
                }, q.clear = function(a) {
                    var b = this.getChildren(!1, !0, !0),
                        c = b.length;
                    for (this._time = this._totalTime = 0; --c > -1;) b[c]._enabled(!1, !1);
                    return a !== !1 && (this._labels = {}), this._uncache(!0)
                }, q.invalidate = function() {
                    for (var b = this._first; b;) b.invalidate(), b = b._next;
                    return a.prototype.invalidate.call(this)
                }, q._enabled = function(a, c) {
                    if (a === this._gc)
                        for (var d = this._first; d;) d._enabled(a, !0), d = d._next;
                    return b.prototype._enabled.call(this, a, c)
                }, q.totalTime = function(b, c, d) {
                    this._forcingPlayhead = !0;
                    var e = a.prototype.totalTime.apply(this, arguments);
                    return this._forcingPlayhead = !1, e
                }, q.duration = function(a) {
                    return arguments.length ? (0 !== this.duration() && 0 !== a && this.timeScale(this._duration / a), this) : (this._dirty && this.totalDuration(), this._duration)
                }, q.totalDuration = function(a) {
                    if (!arguments.length) {
                        if (this._dirty) {
                            for (var b, c, d = 0, e = this._last, f = 999999999999; e;) b = e._prev, e._dirty && e.totalDuration(), e._startTime > f && this._sortChildren && !e._paused ? this.add(e, e._startTime - e._delay) : f = e._startTime, e._startTime < 0 && !e._paused && (d -= e._startTime, this._timeline.smoothChildTiming && (this._startTime += e._startTime / this._timeScale), this.shiftChildren(-e._startTime, !1, -9999999999), f = 0), c = e._startTime + e._totalDuration / e._timeScale, c > d && (d = c), e = b;
                            this._duration = this._totalDuration = d, this._dirty = !1
                        }
                        return this._totalDuration
                    }
                    return a && this.totalDuration() ? this.timeScale(this._totalDuration / a) : this
                }, q.paused = function(b) {
                    if (!b)
                        for (var c = this._first, d = this._time; c;) c._startTime === d && "isPause" === c.data && (c._rawPrevTime = 0), c = c._next;
                    return a.prototype.paused.apply(this, arguments)
                }, q.usesFrames = function() {
                    for (var b = this._timeline; b._timeline;) b = b._timeline;
                    return b === a._rootFramesTimeline
                }, q.rawTime = function() {
                    return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
                }, d
            }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(a, b, c) {
                var d = function(b) {
                        a.call(this, b), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
                    },
                    e = 1e-10,
                    f = b._internals,
                    g = f.lazyTweens,
                    h = f.lazyRender,
                    i = new c(null, null, 1, 0),
                    j = d.prototype = new a;
                return j.constructor = d, j.kill()._gc = !1, d.version = "1.18.2", j.invalidate = function() {
                    return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), a.prototype.invalidate.call(this)
                }, j.addCallback = function(a, c, d, e) {
                    return this.add(b.delayedCall(0, a, d, e), c)
                }, j.removeCallback = function(a, b) {
                    if (a)
                        if (null == b) this._kill(null, a);
                        else
                            for (var c = this.getTweensOf(a, !1), d = c.length, e = this._parseTimeOrLabel(b); --d > -1;) c[d]._startTime === e && c[d]._enabled(!1, !1);
                    return this
                }, j.removePause = function(b) {
                    return this.removeCallback(a._internals.pauseCallback, b)
                }, j.tweenTo = function(a, c) {
                    c = c || {};
                    var d, e, f, g = {
                        ease: i,
                        useFrames: this.usesFrames(),
                        immediateRender: !1
                    };
                    for (e in c) g[e] = c[e];
                    return g.time = this._parseTimeOrLabel(a), d = Math.abs(Number(g.time) - this._time) / this._timeScale || .001, f = new b(this, d, g), g.onStart = function() {
                        f.target.paused(!0), f.vars.time !== f.target.time() && d === f.duration() && f.duration(Math.abs(f.vars.time - f.target.time()) / f.target._timeScale), c.onStart && f._callback("onStart")
                    }, f
                }, j.tweenFromTo = function(a, b, c) {
                    c = c || {}, a = this._parseTimeOrLabel(a), c.startAt = {
                        onComplete: this.seek,
                        onCompleteParams: [a],
                        callbackScope: this
                    }, c.immediateRender = c.immediateRender !== !1;
                    var d = this.tweenTo(b, c);
                    return d.duration(Math.abs(d.vars.time - a) / this._timeScale || .001)
                }, j.render = function(a, b, c) {
                    this._gc && this._enabled(!0, !1);
                    var d, f, i, j, k, l, m, n, o = this._dirty ? this.totalDuration() : this._totalDuration,
                        p = this._duration,
                        q = this._time,
                        r = this._totalTime,
                        s = this._startTime,
                        t = this._timeScale,
                        u = this._rawPrevTime,
                        v = this._paused,
                        w = this._cycle;
                    if (a >= o - 1e-7) this._locked || (this._totalTime = o, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (f = !0, j = "onComplete", k = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= a && a >= -1e-7 || 0 > u || u === e) && u !== a && this._first && (k = !0, u > e && (j = "onReverseComplete"))), this._rawPrevTime = this._duration || !b || a || this._rawPrevTime === a ? a : e, this._yoyo && 0 !== (1 & this._cycle) ? this._time = a = 0 : (this._time = p, a = p + 1e-4);
                    else if (1e-7 > a)
                        if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== q || 0 === p && u !== e && (u > 0 || 0 > a && u >= 0) && !this._locked) && (j = "onReverseComplete", f = this._reversed), 0 > a) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (k = f = !0, j = "onReverseComplete") : u >= 0 && this._first && (k = !0), this._rawPrevTime = a;
                        else {
                            if (this._rawPrevTime = p || !b || a || this._rawPrevTime === a ? a : e, 0 === a && f)
                                for (d = this._first; d && 0 === d._startTime;) d._duration || (f = !1), d = d._next;
                            a = 0, this._initted || (k = !0)
                        }
                    else if (0 === p && 0 > u && (k = !0), this._time = this._rawPrevTime = a, this._locked || (this._totalTime = a, 0 !== this._repeat && (l = p + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 !== (1 & this._cycle) && (this._time = p - this._time), this._time > p ? (this._time = p, a = p + 1e-4) : this._time < 0 ? this._time = a = 0 : a = this._time)), this._hasPause && !this._forcingPlayhead && !b) {
                        if (a = this._time, a >= q)
                            for (d = this._first; d && d._startTime <= a && !m;) d._duration || "isPause" !== d.data || d.ratio || 0 === d._startTime && 0 === this._rawPrevTime || (m = d), d = d._next;
                        else
                            for (d = this._last; d && d._startTime >= a && !m;) d._duration || "isPause" === d.data && d._rawPrevTime > 0 && (m = d), d = d._prev;
                        m && (this._time = a = m._startTime, this._totalTime = a + this._cycle * (this._totalDuration + this._repeatDelay))
                    }
                    if (this._cycle !== w && !this._locked) {
                        var x = this._yoyo && 0 !== (1 & w),
                            y = x === (this._yoyo && 0 !== (1 & this._cycle)),
                            z = this._totalTime,
                            A = this._cycle,
                            B = this._rawPrevTime,
                            C = this._time;
                        if (this._totalTime = w * p, this._cycle < w ? x = !x : this._totalTime += p, this._time = q, this._rawPrevTime = 0 === p ? u - 1e-4 : u, this._cycle = w, this._locked = !0, q = x ? 0 : p, this.render(q, b, 0 === p), b || this._gc || this.vars.onRepeat && this._callback("onRepeat"), q !== this._time) return;
                        if (y && (q = x ? p + 1e-4 : -1e-4, this.render(q, !0, !1)), this._locked = !1, this._paused && !v) return;
                        this._time = C, this._totalTime = z, this._cycle = A, this._rawPrevTime = B
                    }
                    if (!(this._time !== q && this._first || c || k || m)) return void(r !== this._totalTime && this._onUpdate && (b || this._callback("onUpdate")));
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== r && a > 0 && (this._active = !0), 0 === r && this.vars.onStart && 0 !== this._totalTime && (b || this._callback("onStart")), n = this._time, n >= q)
                        for (d = this._first; d && (i = d._next, n === this._time && (!this._paused || v));)(d._active || d._startTime <= this._time && !d._paused && !d._gc) && (m === d && this.pause(), d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c)), d = i;
                    else
                        for (d = this._last; d && (i = d._prev, n === this._time && (!this._paused || v));) {
                            if (d._active || d._startTime <= q && !d._paused && !d._gc) {
                                if (m === d) {
                                    for (m = d._prev; m && m.endTime() > this._time;) m.render(m._reversed ? m.totalDuration() - (a - m._startTime) * m._timeScale : (a - m._startTime) * m._timeScale, b, c), m = m._prev;
                                    m = null, this.pause()
                                }
                                d._reversed ? d.render((d._dirty ? d.totalDuration() : d._totalDuration) - (a - d._startTime) * d._timeScale, b, c) : d.render((a - d._startTime) * d._timeScale, b, c)
                            }
                            d = i
                        }
                    this._onUpdate && (b || (g.length && h(), this._callback("onUpdate"))), j && (this._locked || this._gc || (s === this._startTime || t !== this._timeScale) && (0 === this._time || o >= this.totalDuration()) && (f && (g.length && h(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[j] && this._callback(j)))
                }, j.getActive = function(a, b, c) {
                    null == a && (a = !0), null == b && (b = !0), null == c && (c = !1);
                    var d, e, f = [],
                        g = this.getChildren(a, b, c),
                        h = 0,
                        i = g.length;
                    for (d = 0; i > d; d++) e = g[d], e.isActive() && (f[h++] = e);
                    return f
                }, j.getLabelAfter = function(a) {
                    a || 0 !== a && (a = this._time);
                    var b, c = this.getLabelsArray(),
                        d = c.length;
                    for (b = 0; d > b; b++)
                        if (c[b].time > a) return c[b].name;
                    return null
                }, j.getLabelBefore = function(a) {
                    null == a && (a = this._time);
                    for (var b = this.getLabelsArray(), c = b.length; --c > -1;)
                        if (b[c].time < a) return b[c].name;
                    return null
                }, j.getLabelsArray = function() {
                    var a, b = [],
                        c = 0;
                    for (a in this._labels) b[c++] = {
                        time: this._labels[a],
                        name: a
                    };
                    return b.sort(function(a, b) {
                        return a.time - b.time
                    }), b
                }, j.progress = function(a, b) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - a : a) + this._cycle * (this._duration + this._repeatDelay), b) : this._time / this.duration()
                }, j.totalProgress = function(a, b) {
                    return arguments.length ? this.totalTime(this.totalDuration() * a, b) : this._totalTime / this.totalDuration()
                }, j.totalDuration = function(b) {
                    return arguments.length ? -1 !== this._repeat && b ? this.timeScale(this.totalDuration() / b) : this : (this._dirty && (a.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                }, j.time = function(a, b) {
                    return arguments.length ? (this._dirty && this.totalDuration(), a > this._duration && (a = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? a = this._duration - a + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (a += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(a, b)) : this._time
                }, j.repeat = function(a) {
                    return arguments.length ? (this._repeat = a, this._uncache(!0)) : this._repeat
                }, j.repeatDelay = function(a) {
                    return arguments.length ? (this._repeatDelay = a, this._uncache(!0)) : this._repeatDelay
                }, j.yoyo = function(a) {
                    return arguments.length ? (this._yoyo = a, this) : this._yoyo
                }, j.currentLabel = function(a) {
                    return arguments.length ? this.seek(a, !0) : this.getLabelBefore(this._time + 1e-8)
                }, d
            }, !0),
            function() {
                var a = 180 / Math.PI,
                    b = [],
                    c = [],
                    d = [],
                    e = {},
                    f = _gsScope._gsDefine.globals,
                    g = function(a, b, c, d) {
                        this.a = a, this.b = b, this.c = c, this.d = d, this.da = d - a, this.ca = c - a, this.ba = b - a
                    },
                    h = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
                    i = function(a, b, c, d) {
                        var e = {
                                a: a
                            },
                            f = {},
                            g = {},
                            h = {
                                c: d
                            },
                            i = (a + b) / 2,
                            j = (b + c) / 2,
                            k = (c + d) / 2,
                            l = (i + j) / 2,
                            m = (j + k) / 2,
                            n = (m - l) / 8;
                        return e.b = i + (a - i) / 4, f.b = l + n, e.c = f.a = (e.b + f.b) / 2, f.c = g.a = (l + m) / 2, g.b = m - n, h.b = k + (d - k) / 4, g.c = h.a = (g.b + h.b) / 2, [e, f, g, h]
                    },
                    j = function(a, e, f, g, h) {
                        var j, k, l, m, n, o, p, q, r, s, t, u, v, w = a.length - 1,
                            x = 0,
                            y = a[0].a;
                        for (j = 0; w > j; j++) n = a[x], k = n.a, l = n.d, m = a[x + 1].d, h ? (t = b[j], u = c[j], v = (u + t) * e * .25 / (g ? .5 : d[j] || .5), o = l - (l - k) * (g ? .5 * e : 0 !== t ? v / t : 0), p = l + (m - l) * (g ? .5 * e : 0 !== u ? v / u : 0), q = l - (o + ((p - o) * (3 * t / (t + u) + .5) / 4 || 0))) : (o = l - (l - k) * e * .5, p = l + (m - l) * e * .5, q = l - (o + p) / 2), o += q, p += q, n.c = r = o, 0 !== j ? n.b = y : n.b = y = n.a + .6 * (n.c - n.a), n.da = l - k, n.ca = r - k, n.ba = y - k, f ? (s = i(k, y, r, l), a.splice(x, 1, s[0], s[1], s[2], s[3]), x += 4) : x++, y = p;
                        n = a[x], n.b = y, n.c = y + .4 * (n.d - y), n.da = n.d - n.a, n.ca = n.c - n.a, n.ba = y - n.a, f && (s = i(n.a, y, n.c, n.d), a.splice(x, 1, s[0], s[1], s[2], s[3]))
                    },
                    k = function(a, d, e, f) {
                        var h, i, j, k, l, m, n = [];
                        if (f)
                            for (a = [f].concat(a), i = a.length; --i > -1;) "string" == typeof(m = a[i][d]) && "=" === m.charAt(1) && (a[i][d] = f[d] + Number(m.charAt(0) + m.substr(2)));
                        if (h = a.length - 2, 0 > h) return n[0] = new g(a[0][d], 0, 0, a[-1 > h ? 0 : 1][d]), n;
                        for (i = 0; h > i; i++) j = a[i][d], k = a[i + 1][d], n[i] = new g(j, 0, 0, k), e && (l = a[i + 2][d], b[i] = (b[i] || 0) + (k - j) * (k - j), c[i] = (c[i] || 0) + (l - k) * (l - k));
                        return n[i] = new g(a[i][d], 0, 0, a[i + 1][d]), n
                    },
                    l = function(a, f, g, i, l, m) {
                        var n, o, p, q, r, s, t, u, v = {},
                            w = [],
                            x = m || a[0];
                        l = "string" == typeof l ? "," + l + "," : h, null == f && (f = 1);
                        for (o in a[0]) w.push(o);
                        if (a.length > 1) {
                            for (u = a[a.length - 1], t = !0, n = w.length; --n > -1;)
                                if (o = w[n], Math.abs(x[o] - u[o]) > .05) {
                                    t = !1;
                                    break
                                }
                            t && (a = a.concat(), m && a.unshift(m), a.push(a[1]), m = a[a.length - 3])
                        }
                        for (b.length = c.length = d.length = 0, n = w.length; --n > -1;) o = w[n], e[o] = -1 !== l.indexOf("," + o + ","), v[o] = k(a, o, e[o], m);
                        for (n = b.length; --n > -1;) b[n] = Math.sqrt(b[n]), c[n] = Math.sqrt(c[n]);
                        if (!i) {
                            for (n = w.length; --n > -1;)
                                if (e[o])
                                    for (p = v[w[n]], s = p.length - 1, q = 0; s > q; q++) r = p[q + 1].da / c[q] + p[q].da / b[q], d[q] = (d[q] || 0) + r * r;
                            for (n = d.length; --n > -1;) d[n] = Math.sqrt(d[n])
                        }
                        for (n = w.length, q = g ? 4 : 1; --n > -1;) o = w[n], p = v[o], j(p, f, g, i, e[o]), t && (p.splice(0, q), p.splice(p.length - q, q));
                        return v
                    },
                    m = function(a, b, c) {
                        b = b || "soft";
                        var d, e, f, h, i, j, k, l, m, n, o, p = {},
                            q = "cubic" === b ? 3 : 2,
                            r = "soft" === b,
                            s = [];
                        if (r && c && (a = [c].concat(a)), null == a || a.length < q + 1) throw "invalid Bezier data";
                        for (m in a[0]) s.push(m);
                        for (j = s.length; --j > -1;) {
                            for (m = s[j], p[m] = i = [], n = 0, l = a.length, k = 0; l > k; k++) d = null == c ? a[k][m] : "string" == typeof(o = a[k][m]) && "=" === o.charAt(1) ? c[m] + Number(o.charAt(0) + o.substr(2)) : Number(o), r && k > 1 && l - 1 > k && (i[n++] = (d + i[n - 2]) / 2), i[n++] = d;
                            for (l = n - q + 1, n = 0, k = 0; l > k; k += q) d = i[k], e = i[k + 1], f = i[k + 2], h = 2 === q ? 0 : i[k + 3], i[n++] = o = 3 === q ? new g(d, e, f, h) : new g(d, (2 * e + d) / 3, (2 * e + f) / 3, f);
                            i.length = n
                        }
                        return p
                    },
                    n = function(a, b, c) {
                        for (var d, e, f, g, h, i, j, k, l, m, n, o = 1 / c, p = a.length; --p > -1;)
                            for (m = a[p], f = m.a, g = m.d - f, h = m.c - f, i = m.b - f, d = e = 0, k = 1; c >= k; k++) j = o * k, l = 1 - j, d = e - (e = (j * j * g + 3 * l * (j * h + l * i)) * j), n = p * c + k - 1, b[n] = (b[n] || 0) + d * d
                    },
                    o = function(a, b) {
                        b = b >> 0 || 6;
                        var c, d, e, f, g = [],
                            h = [],
                            i = 0,
                            j = 0,
                            k = b - 1,
                            l = [],
                            m = [];
                        for (c in a) n(a[c], g, b);
                        for (e = g.length, d = 0; e > d; d++) i += Math.sqrt(g[d]), f = d % b, m[f] = i, f === k && (j += i, f = d / b >> 0, l[f] = m, h[f] = j, i = 0, m = []);
                        return {
                            length: j,
                            lengths: h,
                            segments: l
                        }
                    },
                    p = _gsScope._gsDefine.plugin({
                        propName: "bezier",
                        priority: -1,
                        version: "1.3.4",
                        API: 2,
                        global: !0,
                        init: function(a, b, c) {
                            this._target = a, b instanceof Array && (b = {
                                values: b
                            }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == b.timeResolution ? 6 : parseInt(b.timeResolution, 10);
                            var d, e, f, g, h, i = b.values || [],
                                j = {},
                                k = i[0],
                                n = b.autoRotate || c.vars.orientToBezier;
                            this._autoRotate = n ? n instanceof Array ? n : [
                                ["x", "y", "rotation", n === !0 ? 0 : Number(n) || 0]
                            ] : null;
                            for (d in k) this._props.push(d);
                            for (f = this._props.length; --f > -1;) d = this._props[f], this._overwriteProps.push(d), e = this._func[d] = "function" == typeof a[d], j[d] = e ? a[d.indexOf("set") || "function" != typeof a["get" + d.substr(3)] ? d : "get" + d.substr(3)]() : parseFloat(a[d]), h || j[d] !== i[0][d] && (h = j);
                            if (this._beziers = "cubic" !== b.type && "quadratic" !== b.type && "soft" !== b.type ? l(i, isNaN(b.curviness) ? 1 : b.curviness, !1, "thruBasic" === b.type, b.correlate, h) : m(i, b.type, j), this._segCount = this._beziers[d].length, this._timeRes) {
                                var p = o(this._beziers, this._timeRes);
                                this._length = p.length, this._lengths = p.lengths, this._segments = p.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                            }
                            if (n = this._autoRotate)
                                for (this._initialRotations = [], n[0] instanceof Array || (this._autoRotate = n = [n]), f = n.length; --f > -1;) {
                                    for (g = 0; 3 > g; g++) d = n[f][g], this._func[d] = "function" == typeof a[d] ? a[d.indexOf("set") || "function" != typeof a["get" + d.substr(3)] ? d : "get" + d.substr(3)] : !1;
                                    d = n[f][2], this._initialRotations[f] = this._func[d] ? this._func[d].call(this._target) : this._target[d]
                                }
                            return this._startRatio = c.vars.runBackwards ? 1 : 0, !0
                        },
                        set: function(b) {
                            var c, d, e, f, g, h, i, j, k, l, m = this._segCount,
                                n = this._func,
                                o = this._target,
                                p = b !== this._startRatio;
                            if (this._timeRes) {
                                if (k = this._lengths, l = this._curSeg, b *= this._length, e = this._li, b > this._l2 && m - 1 > e) {
                                    for (j = m - 1; j > e && (this._l2 = k[++e]) <= b;);
                                    this._l1 = k[e - 1], this._li = e, this._curSeg = l = this._segments[e], this._s2 = l[this._s1 = this._si = 0]
                                } else if (b < this._l1 && e > 0) {
                                    for (; e > 0 && (this._l1 = k[--e]) >= b;);
                                    0 === e && b < this._l1 ? this._l1 = 0 : e++, this._l2 = k[e], this._li = e, this._curSeg = l = this._segments[e], this._s1 = l[(this._si = l.length - 1) - 1] || 0, this._s2 = l[this._si]
                                }
                                if (c = e, b -= this._l1, e = this._si, b > this._s2 && e < l.length - 1) {
                                    for (j = l.length - 1; j > e && (this._s2 = l[++e]) <= b;);
                                    this._s1 = l[e - 1], this._si = e
                                } else if (b < this._s1 && e > 0) {
                                    for (; e > 0 && (this._s1 = l[--e]) >= b;);
                                    0 === e && b < this._s1 ? this._s1 = 0 : e++, this._s2 = l[e], this._si = e
                                }
                                h = (e + (b - this._s1) / (this._s2 - this._s1)) * this._prec
                            } else c = 0 > b ? 0 : b >= 1 ? m - 1 : m * b >> 0, h = (b - c * (1 / m)) * m;
                            for (d = 1 - h, e = this._props.length; --e > -1;) f = this._props[e], g = this._beziers[f][c], i = (h * h * g.da + 3 * d * (h * g.ca + d * g.ba)) * h + g.a, this._round[f] && (i = Math.round(i)), n[f] ? o[f](i) : o[f] = i;
                            if (this._autoRotate) {
                                var q, r, s, t, u, v, w, x = this._autoRotate;
                                for (e = x.length; --e > -1;) f = x[e][2], v = x[e][3] || 0, w = x[e][4] === !0 ? 1 : a, g = this._beziers[x[e][0]], q = this._beziers[x[e][1]], g && q && (g = g[c], q = q[c], r = g.a + (g.b - g.a) * h, t = g.b + (g.c - g.b) * h, r += (t - r) * h, t += (g.c + (g.d - g.c) * h - t) * h, s = q.a + (q.b - q.a) * h, u = q.b + (q.c - q.b) * h, s += (u - s) * h, u += (q.c + (q.d - q.c) * h - u) * h, i = p ? Math.atan2(u - s, t - r) * w + v : this._initialRotations[e], n[f] ? o[f](i) : o[f] = i)
                            }
                        }
                    }),
                    q = p.prototype;
                p.bezierThrough = l, p.cubicToQuadratic = i, p._autoCSS = !0, p.quadraticToCubic = function(a, b, c) {
                    return new g(a, (2 * b + a) / 3, (2 * b + c) / 3, c)
                }, p._cssRegister = function() {
                    var a = f.CSSPlugin;
                    if (a) {
                        var b = a._internals,
                            c = b._parseToProxy,
                            d = b._setPluginRatio,
                            e = b.CSSPropTween;
                        b._registerComplexSpecialProp("bezier", {
                            parser: function(a, b, f, g, h, i) {
                                b instanceof Array && (b = {
                                    values: b
                                }), i = new p;
                                var j, k, l, m = b.values,
                                    n = m.length - 1,
                                    o = [],
                                    q = {};
                                if (0 > n) return h;
                                for (j = 0; n >= j; j++) l = c(a, m[j], g, h, i, n !== j), o[j] = l.end;
                                for (k in b) q[k] = b[k];
                                return q.values = o, h = new e(a, "bezier", 0, 0, l.pt, 2), h.data = l, h.plugin = i, h.setRatio = d, 0 === q.autoRotate && (q.autoRotate = !0), !q.autoRotate || q.autoRotate instanceof Array || (j = q.autoRotate === !0 ? 0 : Number(q.autoRotate), q.autoRotate = null != l.end.left ? [
                                    ["left", "top", "rotation", j, !1]
                                ] : null != l.end.x ? [
                                    ["x", "y", "rotation", j, !1]
                                ] : !1), q.autoRotate && (g._transform || g._enableTransforms(!1), l.autoRotate = g._target._gsTransform), i._onInitTween(l.proxy, q, g._tween), h
                            }
                        })
                    }
                }, q._roundProps = function(a, b) {
                    for (var c = this._overwriteProps, d = c.length; --d > -1;)(a[c[d]] || a.bezier || a.bezierThrough) && (this._round[c[d]] = b)
                }, q._kill = function(a) {
                    var b, c, d = this._props;
                    for (b in this._beziers)
                        if (b in a)
                            for (delete this._beziers[b], delete this._func[b], c = d.length; --c > -1;) d[c] === b && d.splice(c, 1);
                    return this._super._kill.call(this, a)
                }
            }(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(a, b) {
                var c, d, e, f, g = function() {
                        a.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = g.prototype.setRatio
                    },
                    h = _gsScope._gsDefine.globals,
                    i = {},
                    j = g.prototype = new a("css");
                j.constructor = g, g.version = "1.18.2", g.API = 2, g.defaultTransformPerspective = 0, g.defaultSkewType = "compensated", g.defaultSmoothOrigin = !0, j = "px", g.suffixMap = {
                    top: j,
                    right: j,
                    bottom: j,
                    left: j,
                    width: j,
                    height: j,
                    fontSize: j,
                    padding: j,
                    margin: j,
                    perspective: j,
                    lineHeight: ""
                };
                var k, l, m, n, o, p, q = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
                    r = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                    s = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                    t = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                    u = /(?:\d|\-|\+|=|#|\.)*/g,
                    v = /opacity *= *([^)]*)/i,
                    w = /opacity:([^;]*)/i,
                    x = /alpha\(opacity *=.+?\)/i,
                    y = /^(rgb|hsl)/,
                    z = /([A-Z])/g,
                    A = /-([a-z])/gi,
                    B = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                    C = function(a, b) {
                        return b.toUpperCase()
                    },
                    D = /(?:Left|Right|Width)/i,
                    E = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                    F = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                    G = /,(?=[^\)]*(?:\(|$))/gi,
                    H = Math.PI / 180,
                    I = 180 / Math.PI,
                    J = {},
                    K = document,
                    L = function(a) {
                        return K.createElementNS ? K.createElementNS("http://www.w3.org/1999/xhtml", a) : K.createElement(a)
                    },
                    M = L("div"),
                    N = L("img"),
                    O = g._internals = {
                        _specialProps: i
                    },
                    P = navigator.userAgent,
                    Q = function() {
                        var a = P.indexOf("Android"),
                            b = L("a");
                        return m = -1 !== P.indexOf("Safari") && -1 === P.indexOf("Chrome") && (-1 === a || Number(P.substr(a + 8, 1)) > 3), o = m && Number(P.substr(P.indexOf("Version/") + 8, 1)) < 6, n = -1 !== P.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(P) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(P)) && (p = parseFloat(RegExp.$1)), b ? (b.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(b.style.opacity)) : !1
                    }(),
                    R = function(a) {
                        return v.test("string" == typeof a ? a : (a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                    },
                    S = function(a) {
                        window.console && console.log(a)
                    },
                    T = "",
                    U = "",
                    V = function(a, b) {
                        b = b || M;
                        var c, d, e = b.style;
                        if (void 0 !== e[a]) return a;
                        for (a = a.charAt(0).toUpperCase() + a.substr(1), c = ["O", "Moz", "ms", "Ms", "Webkit"], d = 5; --d > -1 && void 0 === e[c[d] + a];);
                        return d >= 0 ? (U = 3 === d ? "ms" : c[d], T = "-" + U.toLowerCase() + "-", U + a) : null
                    },
                    W = K.defaultView ? K.defaultView.getComputedStyle : function() {},
                    X = g.getStyle = function(a, b, c, d, e) {
                        var f;
                        return Q || "opacity" !== b ? (!d && a.style[b] ? f = a.style[b] : (c = c || W(a)) ? f = c[b] || c.getPropertyValue(b) || c.getPropertyValue(b.replace(z, "-$1").toLowerCase()) : a.currentStyle && (f = a.currentStyle[b]), null == e || f && "none" !== f && "auto" !== f && "auto auto" !== f ? f : e) : R(a)
                    },
                    Y = O.convertToPixels = function(a, c, d, e, f) {
                        if ("px" === e || !e) return d;
                        if ("auto" === e || !d) return 0;
                        var h, i, j, k = D.test(c),
                            l = a,
                            m = M.style,
                            n = 0 > d;
                        if (n && (d = -d), "%" === e && -1 !== c.indexOf("border")) h = d / 100 * (k ? a.clientWidth : a.clientHeight);
                        else {
                            if (m.cssText = "border:0 solid red;position:" + X(a, "position") + ";line-height:0;", "%" !== e && l.appendChild && "v" !== e.charAt(0) && "rem" !== e) m[k ? "borderLeftWidth" : "borderTopWidth"] = d + e;
                            else {
                                if (l = a.parentNode || K.body, i = l._gsCache, j = b.ticker.frame, i && k && i.time === j) return i.width * d / 100;
                                m[k ? "width" : "height"] = d + e
                            }
                            l.appendChild(M), h = parseFloat(M[k ? "offsetWidth" : "offsetHeight"]), l.removeChild(M), k && "%" === e && g.cacheWidths !== !1 && (i = l._gsCache = l._gsCache || {}, i.time = j, i.width = h / d * 100), 0 !== h || f || (h = Y(a, c, d, e, !0))
                        }
                        return n ? -h : h
                    },
                    Z = O.calculateOffset = function(a, b, c) {
                        if ("absolute" !== X(a, "position", c)) return 0;
                        var d = "left" === b ? "Left" : "Top",
                            e = X(a, "margin" + d, c);
                        return a["offset" + d] - (Y(a, b, parseFloat(e), e.replace(u, "")) || 0)
                    },
                    $ = function(a, b) {
                        var c, d, e, f = {};
                        if (b = b || W(a, null))
                            if (c = b.length)
                                for (; --c > -1;) e = b[c], (-1 === e.indexOf("-transform") || za === e) && (f[e.replace(A, C)] = b.getPropertyValue(e));
                            else
                                for (c in b)(-1 === c.indexOf("Transform") || ya === c) && (f[c] = b[c]);
                        else if (b = a.currentStyle || a.style)
                            for (c in b) "string" == typeof c && void 0 === f[c] && (f[c.replace(A, C)] = b[c]);
                        return Q || (f.opacity = R(a)), d = La(a, b, !1), f.rotation = d.rotation, f.skewX = d.skewX, f.scaleX = d.scaleX, f.scaleY = d.scaleY, f.x = d.x, f.y = d.y, Ba && (f.z = d.z, f.rotationX = d.rotationX, f.rotationY = d.rotationY, f.scaleZ = d.scaleZ), f.filters && delete f.filters, f
                    },
                    _ = function(a, b, c, d, e) {
                        var f, g, h, i = {},
                            j = a.style;
                        for (g in c) "cssText" !== g && "length" !== g && isNaN(g) && (b[g] !== (f = c[g]) || e && e[g]) && -1 === g.indexOf("Origin") && ("number" == typeof f || "string" == typeof f) && (i[g] = "auto" !== f || "left" !== g && "top" !== g ? "" !== f && "auto" !== f && "none" !== f || "string" != typeof b[g] || "" === b[g].replace(t, "") ? f : 0 : Z(a, g), void 0 !== j[g] && (h = new oa(j, g, j[g], h)));
                        if (d)
                            for (g in d) "className" !== g && (i[g] = d[g]);
                        return {
                            difs: i,
                            firstMPT: h
                        }
                    },
                    aa = {
                        width: ["Left", "Right"],
                        height: ["Top", "Bottom"]
                    },
                    ba = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                    ca = function(a, b, c) {
                        var d = parseFloat("width" === b ? a.offsetWidth : a.offsetHeight),
                            e = aa[b],
                            f = e.length;
                        for (c = c || W(a, null); --f > -1;) d -= parseFloat(X(a, "padding" + e[f], c, !0)) || 0, d -= parseFloat(X(a, "border" + e[f] + "Width", c, !0)) || 0;
                        return d
                    },
                    da = function(a, b) {
                        if ("contain" === a || "auto" === a || "auto auto" === a) return a + " ";
                        (null == a || "" === a) && (a = "0 0");
                        var c = a.split(" "),
                            d = -1 !== a.indexOf("left") ? "0%" : -1 !== a.indexOf("right") ? "100%" : c[0],
                            e = -1 !== a.indexOf("top") ? "0%" : -1 !== a.indexOf("bottom") ? "100%" : c[1];
                        return null == e ? e = "center" === d ? "50%" : "0" : "center" === e && (e = "50%"), ("center" === d || isNaN(parseFloat(d)) && -1 === (d + "").indexOf("=")) && (d = "50%"), a = d + " " + e + (c.length > 2 ? " " + c[2] : ""), b && (b.oxp = -1 !== d.indexOf("%"), b.oyp = -1 !== e.indexOf("%"), b.oxr = "=" === d.charAt(1), b.oyr = "=" === e.charAt(1), b.ox = parseFloat(d.replace(t, "")), b.oy = parseFloat(e.replace(t, "")), b.v = a), b || a
                    },
                    ea = function(a, b) {
                        return "string" == typeof a && "=" === a.charAt(1) ? parseInt(a.charAt(0) + "1", 10) * parseFloat(a.substr(2)) : parseFloat(a) - parseFloat(b)
                    },
                    fa = function(a, b) {
                        return null == a ? b : "string" == typeof a && "=" === a.charAt(1) ? parseInt(a.charAt(0) + "1", 10) * parseFloat(a.substr(2)) + b : parseFloat(a)
                    },
                    ga = function(a, b, c, d) {
                        var e, f, g, h, i, j = 1e-6;
                        return null == a ? h = b : "number" == typeof a ? h = a : (e = 360, f = a.split("_"), i = "=" === a.charAt(1), g = (i ? parseInt(a.charAt(0) + "1", 10) * parseFloat(f[0].substr(2)) : parseFloat(f[0])) * (-1 === a.indexOf("rad") ? 1 : I) - (i ? 0 : b), f.length && (d && (d[c] = b + g), -1 !== a.indexOf("short") && (g %= e, g !== g % (e / 2) && (g = 0 > g ? g + e : g - e)), -1 !== a.indexOf("_cw") && 0 > g ? g = (g + 9999999999 * e) % e - (g / e | 0) * e : -1 !== a.indexOf("ccw") && g > 0 && (g = (g - 9999999999 * e) % e - (g / e | 0) * e)), h = b + g), j > h && h > -j && (h = 0), h
                    },
                    ha = {
                        aqua: [0, 255, 255],
                        lime: [0, 255, 0],
                        silver: [192, 192, 192],
                        black: [0, 0, 0],
                        maroon: [128, 0, 0],
                        teal: [0, 128, 128],
                        blue: [0, 0, 255],
                        navy: [0, 0, 128],
                        white: [255, 255, 255],
                        fuchsia: [255, 0, 255],
                        olive: [128, 128, 0],
                        yellow: [255, 255, 0],
                        orange: [255, 165, 0],
                        gray: [128, 128, 128],
                        purple: [128, 0, 128],
                        green: [0, 128, 0],
                        red: [255, 0, 0],
                        pink: [255, 192, 203],
                        cyan: [0, 255, 255],
                        transparent: [255, 255, 255, 0]
                    },
                    ia = function(a, b, c) {
                        return a = 0 > a ? a + 1 : a > 1 ? a - 1 : a, 255 * (1 > 6 * a ? b + (c - b) * a * 6 : .5 > a ? c : 2 > 3 * a ? b + (c - b) * (2 / 3 - a) * 6 : b) + .5 | 0
                    },
                    ja = g.parseColor = function(a, b) {
                        var c, d, e, f, g, h, i, j, k, l, m;
                        if (a)
                            if ("number" == typeof a) c = [a >> 16, a >> 8 & 255, 255 & a];
                            else {
                                if ("," === a.charAt(a.length - 1) && (a = a.substr(0, a.length - 1)), ha[a]) c = ha[a];
                                else if ("#" === a.charAt(0)) 4 === a.length && (d = a.charAt(1), e = a.charAt(2), f = a.charAt(3), a = "#" + d + d + e + e + f + f), a = parseInt(a.substr(1), 16), c = [a >> 16, a >> 8 & 255, 255 & a];
                                else if ("hsl" === a.substr(0, 3))
                                    if (c = m = a.match(q), b) {
                                        if (-1 !== a.indexOf("=")) return a.match(r)
                                    } else g = Number(c[0]) % 360 / 360, h = Number(c[1]) / 100, i = Number(c[2]) / 100, e = .5 >= i ? i * (h + 1) : i + h - i * h, d = 2 * i - e, c.length > 3 && (c[3] = Number(a[3])), c[0] = ia(g + 1 / 3, d, e), c[1] = ia(g, d, e), c[2] = ia(g - 1 / 3, d, e);
                                else c = a.match(q) || ha.transparent;
                                c[0] = Number(c[0]), c[1] = Number(c[1]), c[2] = Number(c[2]), c.length > 3 && (c[3] = Number(c[3]))
                            }
                        else c = ha.black;
                        return b && !m && (d = c[0] / 255, e = c[1] / 255, f = c[2] / 255, j = Math.max(d, e, f), k = Math.min(d, e, f), i = (j + k) / 2, j === k ? g = h = 0 : (l = j - k, h = i > .5 ? l / (2 - j - k) : l / (j + k), g = j === d ? (e - f) / l + (f > e ? 6 : 0) : j === e ? (f - d) / l + 2 : (d - e) / l + 4, g *= 60), c[0] = g + .5 | 0, c[1] = 100 * h + .5 | 0, c[2] = 100 * i + .5 | 0), c
                    },
                    ka = function(a, b) {
                        var c, d, e, f = a.match(la) || [],
                            g = 0,
                            h = f.length ? "" : a;
                        for (c = 0; c < f.length; c++) d = f[c], e = a.substr(g, a.indexOf(d, g) - g), g += e.length + d.length, d = ja(d, b), 3 === d.length && d.push(1), h += e + (b ? "hsla(" + d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : "rgba(" + d.join(",")) + ")";
                        return h
                    },
                    la = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                for (j in ha) la += "|" + j + "\\b";
                la = new RegExp(la + ")", "gi"), g.colorStringFilter = function(a) {
                    var b, c = a[0] + a[1];
                    la.lastIndex = 0, la.test(c) && (b = -1 !== c.indexOf("hsl(") || -1 !== c.indexOf("hsla("), a[0] = ka(a[0], b), a[1] = ka(a[1], b))
                }, b.defaultStringFilter || (b.defaultStringFilter = g.colorStringFilter);
                var ma = function(a, b, c, d) {
                        if (null == a) return function(a) {
                            return a
                        };
                        var e, f = b ? (a.match(la) || [""])[0] : "",
                            g = a.split(f).join("").match(s) || [],
                            h = a.substr(0, a.indexOf(g[0])),
                            i = ")" === a.charAt(a.length - 1) ? ")" : "",
                            j = -1 !== a.indexOf(" ") ? " " : ",",
                            k = g.length,
                            l = k > 0 ? g[0].replace(q, "") : "";
                        return k ? e = b ? function(a) {
                            var b, m, n, o;
                            if ("number" == typeof a) a += l;
                            else if (d && G.test(a)) {
                                for (o = a.replace(G, "|").split("|"), n = 0; n < o.length; n++) o[n] = e(o[n]);
                                return o.join(",")
                            }
                            if (b = (a.match(la) || [f])[0], m = a.split(b).join("").match(s) || [], n = m.length, k > n--)
                                for (; ++n < k;) m[n] = c ? m[(n - 1) / 2 | 0] : g[n];
                            return h + m.join(j) + j + b + i + (-1 !== a.indexOf("inset") ? " inset" : "")
                        } : function(a) {
                            var b, f, m;
                            if ("number" == typeof a) a += l;
                            else if (d && G.test(a)) {
                                for (f = a.replace(G, "|").split("|"), m = 0; m < f.length; m++) f[m] = e(f[m]);
                                return f.join(",")
                            }
                            if (b = a.match(s) || [], m = b.length, k > m--)
                                for (; ++m < k;) b[m] = c ? b[(m - 1) / 2 | 0] : g[m];
                            return h + b.join(j) + i
                        } : function(a) {
                            return a
                        }
                    },
                    na = function(a) {
                        return a = a.split(","),
                            function(b, c, d, e, f, g, h) {
                                var i, j = (c + "").split(" ");
                                for (h = {}, i = 0; 4 > i; i++) h[a[i]] = j[i] = j[i] || j[(i - 1) / 2 >> 0];
                                return e.parse(b, h, f, g)
                            }
                    },
                    oa = (O._setPluginRatio = function(a) {
                        this.plugin.setRatio(a);
                        for (var b, c, d, e, f, g = this.data, h = g.proxy, i = g.firstMPT, j = 1e-6; i;) b = h[i.v], i.r ? b = Math.round(b) : j > b && b > -j && (b = 0), i.t[i.p] = b, i = i._next;
                        if (g.autoRotate && (g.autoRotate.rotation = h.rotation), 1 === a || 0 === a)
                            for (i = g.firstMPT, f = 1 === a ? "e" : "b"; i;) {
                                if (c = i.t, c.type) {
                                    if (1 === c.type) {
                                        for (e = c.xs0 + c.s + c.xs1, d = 1; d < c.l; d++) e += c["xn" + d] + c["xs" + (d + 1)];
                                        c[f] = e
                                    }
                                } else c[f] = c.s + c.xs0;
                                i = i._next
                            }
                    }, function(a, b, c, d, e) {
                        this.t = a, this.p = b, this.v = c, this.r = e, d && (d._prev = this, this._next = d)
                    }),
                    pa = (O._parseToProxy = function(a, b, c, d, e, f) {
                        var g, h, i, j, k, l = d,
                            m = {},
                            n = {},
                            o = c._transform,
                            p = J;
                        for (c._transform = null, J = b, d = k = c.parse(a, b, d, e), J = p, f && (c._transform = o, l && (l._prev = null, l._prev && (l._prev._next = null))); d && d !== l;) {
                            if (d.type <= 1 && (h = d.p, n[h] = d.s + d.c, m[h] = d.s, f || (j = new oa(d, "s", h, j, d.r), d.c = 0), 1 === d.type))
                                for (g = d.l; --g > 0;) i = "xn" + g, h = d.p + "_" + i, n[h] = d.data[i], m[h] = d[i], f || (j = new oa(d, i, h, j, d.rxp[i]));
                            d = d._next
                        }
                        return {
                            proxy: m,
                            end: n,
                            firstMPT: j,
                            pt: k
                        }
                    }, O.CSSPropTween = function(a, b, d, e, g, h, i, j, k, l, m) {
                        this.t = a, this.p = b, this.s = d, this.c = e, this.n = i || b, a instanceof pa || f.push(this.n), this.r = j, this.type = h || 0, k && (this.pr = k, c = !0), this.b = void 0 === l ? d : l, this.e = void 0 === m ? d + e : m, g && (this._next = g, g._prev = this)
                    }),
                    qa = function(a, b, c, d, e, f) {
                        var g = new pa(a, b, c, d - c, e, -1, f);
                        return g.b = c, g.e = g.xs0 = d, g
                    },
                    ra = g.parseComplex = function(a, b, c, d, e, f, g, h, i, j) {
                        c = c || f || "", g = new pa(a, b, 0, 0, g, j ? 2 : 1, null, !1, h, c, d), d += "";
                        var l, m, n, o, p, s, t, u, v, w, x, y, z, A = c.split(", ").join(",").split(" "),
                            B = d.split(", ").join(",").split(" "),
                            C = A.length,
                            D = k !== !1;
                        for ((-1 !== d.indexOf(",") || -1 !== c.indexOf(",")) && (A = A.join(" ").replace(G, ", ").split(" "), B = B.join(" ").replace(G, ", ").split(" "), C = A.length), C !== B.length && (A = (f || "").split(" "), C = A.length), g.plugin = i, g.setRatio = j, la.lastIndex = 0, l = 0; C > l; l++)
                            if (o = A[l], p = B[l], u = parseFloat(o), u || 0 === u) g.appendXtra("", u, ea(p, u), p.replace(r, ""), D && -1 !== p.indexOf("px"), !0);
                            else if (e && la.test(o)) y = "," === p.charAt(p.length - 1) ? ")," : ")", z = -1 !== p.indexOf("hsl") && Q, o = ja(o, z), p = ja(p, z), v = o.length + p.length > 6, v && !Q && 0 === p[3] ? (g["xs" + g.l] += g.l ? " transparent" : "transparent", g.e = g.e.split(B[l]).join("transparent")) : (Q || (v = !1), z ? g.appendXtra(v ? "hsla(" : "hsl(", o[0], ea(p[0], o[0]), ",", !1, !0).appendXtra("", o[1], ea(p[1], o[1]), "%,", !1).appendXtra("", o[2], ea(p[2], o[2]), v ? "%," : "%" + y, !1) : g.appendXtra(v ? "rgba(" : "rgb(", o[0], p[0] - o[0], ",", !0, !0).appendXtra("", o[1], p[1] - o[1], ",", !0).appendXtra("", o[2], p[2] - o[2], v ? "," : y, !0), v && (o = o.length < 4 ? 1 : o[3], g.appendXtra("", o, (p.length < 4 ? 1 : p[3]) - o, y, !1))), la.lastIndex = 0;
                        else if (s = o.match(q)) {
                            if (t = p.match(r), !t || t.length !== s.length) return g;
                            for (n = 0, m = 0; m < s.length; m++) x = s[m], w = o.indexOf(x, n), g.appendXtra(o.substr(n, w - n), Number(x), ea(t[m], x), "", D && "px" === o.substr(w + x.length, 2), 0 === m), n = w + x.length;
                            g["xs" + g.l] += o.substr(n)
                        } else g["xs" + g.l] += g.l ? " " + p : p;
                        if (-1 !== d.indexOf("=") && g.data) {
                            for (y = g.xs0 + g.data.s, l = 1; l < g.l; l++) y += g["xs" + l] + g.data["xn" + l];
                            g.e = y + g["xs" + l]
                        }
                        return g.l || (g.type = -1, g.xs0 = g.e), g.xfirst || g
                    },
                    sa = 9;
                for (j = pa.prototype, j.l = j.pr = 0; --sa > 0;) j["xn" + sa] = 0, j["xs" + sa] = "";
                j.xs0 = "", j._next = j._prev = j.xfirst = j.data = j.plugin = j.setRatio = j.rxp = null, j.appendXtra = function(a, b, c, d, e, f) {
                    var g = this,
                        h = g.l;
                    return g["xs" + h] += f && h ? " " + a : a || "", c || 0 === h || g.plugin ? (g.l++, g.type = g.setRatio ? 2 : 1, g["xs" + g.l] = d || "", h > 0 ? (g.data["xn" + h] = b + c, g.rxp["xn" + h] = e, g["xn" + h] = b, g.plugin || (g.xfirst = new pa(g, "xn" + h, b, c, g.xfirst || g, 0, g.n, e, g.pr), g.xfirst.xs0 = 0), g) : (g.data = {
                        s: b + c
                    }, g.rxp = {}, g.s = b, g.c = c, g.r = e, g)) : (g["xs" + h] += b + (d || ""), g)
                };
                var ta = function(a, b) {
                        b = b || {}, this.p = b.prefix ? V(a) || a : a, i[a] = i[this.p] = this, this.format = b.formatter || ma(b.defaultValue, b.color, b.collapsible, b.multi), b.parser && (this.parse = b.parser), this.clrs = b.color, this.multi = b.multi, this.keyword = b.keyword, this.dflt = b.defaultValue, this.pr = b.priority || 0
                    },
                    ua = O._registerComplexSpecialProp = function(a, b, c) {
                        "object" != typeof b && (b = {
                            parser: c
                        });
                        var d, e, f = a.split(","),
                            g = b.defaultValue;
                        for (c = c || [g], d = 0; d < f.length; d++) b.prefix = 0 === d && b.prefix, b.defaultValue = c[d] || g, e = new ta(f[d], b)
                    },
                    va = function(a) {
                        if (!i[a]) {
                            var b = a.charAt(0).toUpperCase() + a.substr(1) + "Plugin";
                            ua(a, {
                                parser: function(a, c, d, e, f, g, j) {
                                    var k = h.com.greensock.plugins[b];
                                    return k ? (k._cssRegister(), i[d].parse(a, c, d, e, f, g, j)) : (S("Error: " + b + " js file not loaded."), f)
                                }
                            })
                        }
                    };
                j = ta.prototype, j.parseComplex = function(a, b, c, d, e, f) {
                    var g, h, i, j, k, l, m = this.keyword;
                    if (this.multi && (G.test(c) || G.test(b) ? (h = b.replace(G, "|").split("|"), i = c.replace(G, "|").split("|")) : m && (h = [b], i = [c])), i) {
                        for (j = i.length > h.length ? i.length : h.length, g = 0; j > g; g++) b = h[g] = h[g] || this.dflt, c = i[g] = i[g] || this.dflt, m && (k = b.indexOf(m), l = c.indexOf(m), k !== l && (-1 === l ? h[g] = h[g].split(m).join("") : -1 === k && (h[g] += " " + m)));
                        b = h.join(", "), c = i.join(", ")
                    }
                    return ra(a, this.p, b, c, this.clrs, this.dflt, d, this.pr, e, f)
                }, j.parse = function(a, b, c, d, f, g, h) {
                    return this.parseComplex(a.style, this.format(X(a, this.p, e, !1, this.dflt)), this.format(b), f, g)
                }, g.registerSpecialProp = function(a, b, c) {
                    ua(a, {
                        parser: function(a, d, e, f, g, h, i) {
                            var j = new pa(a, e, 0, 0, g, 2, e, !1, c);
                            return j.plugin = h, j.setRatio = b(a, d, f._tween, e), j
                        },
                        priority: c
                    })
                }, g.useSVGTransformAttr = m || n;
                var wa, xa = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                    ya = V("transform"),
                    za = T + "transform",
                    Aa = V("transformOrigin"),
                    Ba = null !== V("perspective"),
                    Ca = O.Transform = function() {
                        this.perspective = parseFloat(g.defaultTransformPerspective) || 0, this.force3D = g.defaultForce3D !== !1 && Ba ? g.defaultForce3D || "auto" : !1
                    },
                    Da = window.SVGElement,
                    Ea = function(a, b, c) {
                        var d, e = K.createElementNS("http://www.w3.org/2000/svg", a),
                            f = /([a-z])([A-Z])/g;
                        for (d in c) e.setAttributeNS(null, d.replace(f, "$1-$2").toLowerCase(), c[d]);
                        return b.appendChild(e), e
                    },
                    Fa = K.documentElement,
                    Ga = function() {
                        var a, b, c, d = p || /Android/i.test(P) && !window.chrome;
                        return K.createElementNS && !d && (a = Ea("svg", Fa), b = Ea("rect", a, {
                            width: 100,
                            height: 50,
                            x: 100
                        }), c = b.getBoundingClientRect().width, b.style[Aa] = "50% 50%", b.style[ya] = "scaleX(0.5)", d = c === b.getBoundingClientRect().width && !(n && Ba), Fa.removeChild(a)), d
                    }(),
                    Ha = function(a, b, c, d, e) {
                        var f, h, i, j, k, l, m, n, o, p, q, r, s, t, u = a._gsTransform,
                            v = Ka(a, !0);
                        u && (s = u.xOrigin, t = u.yOrigin), (!d || (f = d.split(" ")).length < 2) && (m = a.getBBox(), b = da(b).split(" "), f = [(-1 !== b[0].indexOf("%") ? parseFloat(b[0]) / 100 * m.width : parseFloat(b[0])) + m.x, (-1 !== b[1].indexOf("%") ? parseFloat(b[1]) / 100 * m.height : parseFloat(b[1])) + m.y]), c.xOrigin = j = parseFloat(f[0]), c.yOrigin = k = parseFloat(f[1]), d && v !== Ja && (l = v[0], m = v[1], n = v[2], o = v[3], p = v[4], q = v[5], r = l * o - m * n, h = j * (o / r) + k * (-n / r) + (n * q - o * p) / r, i = j * (-m / r) + k * (l / r) - (l * q - m * p) / r, j = c.xOrigin = f[0] = h, k = c.yOrigin = f[1] = i), u && (e || e !== !1 && g.defaultSmoothOrigin !== !1 ? (h = j - s, i = k - t, u.xOffset += h * v[0] + i * v[2] - h, u.yOffset += h * v[1] + i * v[3] - i) : u.xOffset = u.yOffset = 0), a.setAttribute("data-svg-origin", f.join(" "))
                    },
                    Ia = function(a) {
                        return !!(Da && "function" == typeof a.getBBox && a.getCTM && (!a.parentNode || a.parentNode.getBBox && a.parentNode.getCTM))
                    },
                    Ja = [1, 0, 0, 1, 0, 0],
                    Ka = function(a, b) {
                        var c, d, e, f, g, h = a._gsTransform || new Ca,
                            i = 1e5;
                        if (ya ? d = X(a, za, null, !0) : a.currentStyle && (d = a.currentStyle.filter.match(E), d = d && 4 === d.length ? [d[0].substr(4), Number(d[2].substr(4)), Number(d[1].substr(4)), d[3].substr(4), h.x || 0, h.y || 0].join(",") : ""), c = !d || "none" === d || "matrix(1, 0, 0, 1, 0, 0)" === d, (h.svg || a.getBBox && Ia(a)) && (c && -1 !== (a.style[ya] + "").indexOf("matrix") && (d = a.style[ya], c = 0), e = a.getAttribute("transform"), c && e && (-1 !== e.indexOf("matrix") ? (d = e, c = 0) : -1 !== e.indexOf("translate") && (d = "matrix(1,0,0,1," + e.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", c = 0))), c) return Ja;
                        for (e = (d || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], sa = e.length; --sa > -1;) f = Number(e[sa]), e[sa] = (g = f - (f |= 0)) ? (g * i + (0 > g ? -.5 : .5) | 0) / i + f : f;
                        return b && e.length > 6 ? [e[0], e[1], e[4], e[5], e[12], e[13]] : e
                    },
                    La = O.getTransform = function(a, c, d, f) {
                        if (a._gsTransform && d && !f) return a._gsTransform;
                        var h, i, j, k, l, m, n = d ? a._gsTransform || new Ca : new Ca,
                            o = n.scaleX < 0,
                            p = 2e-5,
                            q = 1e5,
                            r = Ba ? parseFloat(X(a, Aa, c, !1, "0 0 0").split(" ")[2]) || n.zOrigin || 0 : 0,
                            s = parseFloat(g.defaultTransformPerspective) || 0;
                        if (n.svg = !(!a.getBBox || !Ia(a)), n.svg && (Ha(a, X(a, Aa, e, !1, "50% 50%") + "", n, a.getAttribute("data-svg-origin")), wa = g.useSVGTransformAttr || Ga), h = Ka(a), h !== Ja) {
                            if (16 === h.length) {
                                var t, u, v, w, x, y = h[0],
                                    z = h[1],
                                    A = h[2],
                                    B = h[3],
                                    C = h[4],
                                    D = h[5],
                                    E = h[6],
                                    F = h[7],
                                    G = h[8],
                                    H = h[9],
                                    J = h[10],
                                    K = h[12],
                                    L = h[13],
                                    M = h[14],
                                    N = h[11],
                                    O = Math.atan2(E, J);
                                n.zOrigin && (M = -n.zOrigin, K = G * M - h[12], L = H * M - h[13], M = J * M + n.zOrigin - h[14]), n.rotationX = O * I, O && (w = Math.cos(-O), x = Math.sin(-O), t = C * w + G * x, u = D * w + H * x, v = E * w + J * x, G = C * -x + G * w, H = D * -x + H * w, J = E * -x + J * w, N = F * -x + N * w, C = t, D = u, E = v), O = Math.atan2(-A, J), n.rotationY = O * I, O && (w = Math.cos(-O), x = Math.sin(-O), t = y * w - G * x, u = z * w - H * x, v = A * w - J * x, H = z * x + H * w, J = A * x + J * w, N = B * x + N * w, y = t, z = u, A = v), O = Math.atan2(z, y), n.rotation = O * I, O && (w = Math.cos(-O), x = Math.sin(-O), y = y * w + C * x, u = z * w + D * x, D = z * -x + D * w, E = A * -x + E * w, z = u), n.rotationX && Math.abs(n.rotationX) + Math.abs(n.rotation) > 359.9 && (n.rotationX = n.rotation = 0, n.rotationY = 180 - n.rotationY), n.scaleX = (Math.sqrt(y * y + z * z) * q + .5 | 0) / q, n.scaleY = (Math.sqrt(D * D + H * H) * q + .5 | 0) / q, n.scaleZ = (Math.sqrt(E * E + J * J) * q + .5 | 0) / q, n.skewX = 0, n.perspective = N ? 1 / (0 > N ? -N : N) : 0, n.x = K, n.y = L, n.z = M, n.svg && (n.x -= n.xOrigin - (n.xOrigin * y - n.yOrigin * C), n.y -= n.yOrigin - (n.yOrigin * z - n.xOrigin * D))
                            } else if ((!Ba || f || !h.length || n.x !== h[4] || n.y !== h[5] || !n.rotationX && !n.rotationY) && (void 0 === n.x || "none" !== X(a, "display", c))) {
                                var P = h.length >= 6,
                                    Q = P ? h[0] : 1,
                                    R = h[1] || 0,
                                    S = h[2] || 0,
                                    T = P ? h[3] : 1;
                                n.x = h[4] || 0, n.y = h[5] || 0, j = Math.sqrt(Q * Q + R * R), k = Math.sqrt(T * T + S * S), l = Q || R ? Math.atan2(R, Q) * I : n.rotation || 0, m = S || T ? Math.atan2(S, T) * I + l : n.skewX || 0, Math.abs(m) > 90 && Math.abs(m) < 270 && (o ? (j *= -1, m += 0 >= l ? 180 : -180, l += 0 >= l ? 180 : -180) : (k *= -1, m += 0 >= m ? 180 : -180)), n.scaleX = j, n.scaleY = k, n.rotation = l, n.skewX = m, Ba && (n.rotationX = n.rotationY = n.z = 0, n.perspective = s, n.scaleZ = 1), n.svg && (n.x -= n.xOrigin - (n.xOrigin * Q + n.yOrigin * S), n.y -= n.yOrigin - (n.xOrigin * R + n.yOrigin * T))
                            }
                            n.zOrigin = r;
                            for (i in n) n[i] < p && n[i] > -p && (n[i] = 0)
                        }
                        return d && (a._gsTransform = n, n.svg && (wa && a.style[ya] ? b.delayedCall(.001, function() {
                            Pa(a.style, ya)
                        }) : !wa && a.getAttribute("transform") && b.delayedCall(.001, function() {
                            a.removeAttribute("transform")
                        }))), n
                    },
                    Ma = function(a) {
                        var b, c, d = this.data,
                            e = -d.rotation * H,
                            f = e + d.skewX * H,
                            g = 1e5,
                            h = (Math.cos(e) * d.scaleX * g | 0) / g,
                            i = (Math.sin(e) * d.scaleX * g | 0) / g,
                            j = (Math.sin(f) * -d.scaleY * g | 0) / g,
                            k = (Math.cos(f) * d.scaleY * g | 0) / g,
                            l = this.t.style,
                            m = this.t.currentStyle;
                        if (m) {
                            c = i, i = -j, j = -c, b = m.filter, l.filter = "";
                            var n, o, q = this.t.offsetWidth,
                                r = this.t.offsetHeight,
                                s = "absolute" !== m.position,
                                t = "progid:DXImageTransform.Microsoft.Matrix(M11=" + h + ", M12=" + i + ", M21=" + j + ", M22=" + k,
                                w = d.x + q * d.xPercent / 100,
                                x = d.y + r * d.yPercent / 100;
                            if (null != d.ox && (n = (d.oxp ? q * d.ox * .01 : d.ox) - q / 2, o = (d.oyp ? r * d.oy * .01 : d.oy) - r / 2, w += n - (n * h + o * i), x += o - (n * j + o * k)), s ? (n = q / 2, o = r / 2, t += ", Dx=" + (n - (n * h + o * i) + w) + ", Dy=" + (o - (n * j + o * k) + x) + ")") : t += ", sizingMethod='auto expand')", -1 !== b.indexOf("DXImageTransform.Microsoft.Matrix(") ? l.filter = b.replace(F, t) : l.filter = t + " " + b, (0 === a || 1 === a) && 1 === h && 0 === i && 0 === j && 1 === k && (s && -1 === t.indexOf("Dx=0, Dy=0") || v.test(b) && 100 !== parseFloat(RegExp.$1) || -1 === b.indexOf(b.indexOf("Alpha")) && l.removeAttribute("filter")), !s) {
                                var y, z, A, B = 8 > p ? 1 : -1;
                                for (n = d.ieOffsetX || 0, o = d.ieOffsetY || 0, d.ieOffsetX = Math.round((q - ((0 > h ? -h : h) * q + (0 > i ? -i : i) * r)) / 2 + w), d.ieOffsetY = Math.round((r - ((0 > k ? -k : k) * r + (0 > j ? -j : j) * q)) / 2 + x), sa = 0; 4 > sa; sa++) z = ba[sa], y = m[z], c = -1 !== y.indexOf("px") ? parseFloat(y) : Y(this.t, z, parseFloat(y), y.replace(u, "")) || 0, A = c !== d[z] ? 2 > sa ? -d.ieOffsetX : -d.ieOffsetY : 2 > sa ? n - d.ieOffsetX : o - d.ieOffsetY, l[z] = (d[z] = Math.round(c - A * (0 === sa || 2 === sa ? 1 : B))) + "px"
                            }
                        }
                    },
                    Na = O.set3DTransformRatio = O.setTransformRatio = function(a) {
                        var b, c, d, e, f, g, h, i, j, k, l, m, o, p, q, r, s, t, u, v, w, x, y, z = this.data,
                            A = this.t.style,
                            B = z.rotation,
                            C = z.rotationX,
                            D = z.rotationY,
                            E = z.scaleX,
                            F = z.scaleY,
                            G = z.scaleZ,
                            I = z.x,
                            J = z.y,
                            K = z.z,
                            L = z.svg,
                            M = z.perspective,
                            N = z.force3D;
                        if (((1 === a || 0 === a) && "auto" === N && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !N) && !K && !M && !D && !C && 1 === G || wa && L || !Ba) return void(B || z.skewX || L ? (B *= H, x = z.skewX * H, y = 1e5, b = Math.cos(B) * E, e = Math.sin(B) * E, c = Math.sin(B - x) * -F, f = Math.cos(B - x) * F, x && "simple" === z.skewType && (s = Math.tan(x), s = Math.sqrt(1 + s * s), c *= s, f *= s, z.skewY && (b *= s, e *= s)), L && (I += z.xOrigin - (z.xOrigin * b + z.yOrigin * c) + z.xOffset, J += z.yOrigin - (z.xOrigin * e + z.yOrigin * f) + z.yOffset, wa && (z.xPercent || z.yPercent) && (p = this.t.getBBox(), I += .01 * z.xPercent * p.width, J += .01 * z.yPercent * p.height), p = 1e-6, p > I && I > -p && (I = 0), p > J && J > -p && (J = 0)), u = (b * y | 0) / y + "," + (e * y | 0) / y + "," + (c * y | 0) / y + "," + (f * y | 0) / y + "," + I + "," + J + ")", L && wa ? this.t.setAttribute("transform", "matrix(" + u) : A[ya] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix(" : "matrix(") + u) : A[ya] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix(" : "matrix(") + E + ",0,0," + F + "," + I + "," + J + ")");
                        if (n && (p = 1e-4, p > E && E > -p && (E = G = 2e-5), p > F && F > -p && (F = G = 2e-5), !M || z.z || z.rotationX || z.rotationY || (M = 0)), B || z.skewX) B *= H, q = b = Math.cos(B), r = e = Math.sin(B), z.skewX && (B -= z.skewX * H, q = Math.cos(B), r = Math.sin(B), "simple" === z.skewType && (s = Math.tan(z.skewX * H), s = Math.sqrt(1 + s * s), q *= s, r *= s, z.skewY && (b *= s, e *= s))), c = -r, f = q;
                        else {
                            if (!(D || C || 1 !== G || M || L)) return void(A[ya] = (z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) translate3d(" : "translate3d(") + I + "px," + J + "px," + K + "px)" + (1 !== E || 1 !== F ? " scale(" + E + "," + F + ")" : ""));
                            b = f = 1, c = e = 0
                        }
                        j = 1, d = g = h = i = k = l = 0, m = M ? -1 / M : 0, o = z.zOrigin, p = 1e-6, v = ",", w = "0", B = D * H, B && (q = Math.cos(B), r = Math.sin(B), h = -r, k = m * -r, d = b * r, g = e * r, j = q, m *= q, b *= q, e *= q), B = C * H, B && (q = Math.cos(B), r = Math.sin(B), s = c * q + d * r, t = f * q + g * r, i = j * r, l = m * r, d = c * -r + d * q, g = f * -r + g * q, j *= q, m *= q, c = s, f = t), 1 !== G && (d *= G, g *= G, j *= G, m *= G), 1 !== F && (c *= F, f *= F, i *= F, l *= F), 1 !== E && (b *= E, e *= E, h *= E, k *= E), (o || L) && (o && (I += d * -o, J += g * -o, K += j * -o + o), L && (I += z.xOrigin - (z.xOrigin * b + z.yOrigin * c) + z.xOffset, J += z.yOrigin - (z.xOrigin * e + z.yOrigin * f) + z.yOffset), p > I && I > -p && (I = w), p > J && J > -p && (J = w), p > K && K > -p && (K = 0)), u = z.xPercent || z.yPercent ? "translate(" + z.xPercent + "%," + z.yPercent + "%) matrix3d(" : "matrix3d(", u += (p > b && b > -p ? w : b) + v + (p > e && e > -p ? w : e) + v + (p > h && h > -p ? w : h), u += v + (p > k && k > -p ? w : k) + v + (p > c && c > -p ? w : c) + v + (p > f && f > -p ? w : f), C || D || 1 !== G ? (u += v + (p > i && i > -p ? w : i) + v + (p > l && l > -p ? w : l) + v + (p > d && d > -p ? w : d), u += v + (p > g && g > -p ? w : g) + v + (p > j && j > -p ? w : j) + v + (p > m && m > -p ? w : m) + v) : u += ",0,0,0,0,1,0,", u += I + v + J + v + K + v + (M ? 1 + -K / M : 1) + ")", A[ya] = u
                    };
                j = Ca.prototype, j.x = j.y = j.z = j.skewX = j.skewY = j.rotation = j.rotationX = j.rotationY = j.zOrigin = j.xPercent = j.yPercent = j.xOffset = j.yOffset = 0, j.scaleX = j.scaleY = j.scaleZ = 1, ua("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                    parser: function(a, b, c, d, f, h, i) {
                        if (d._lastParsedTransform === i) return f;
                        d._lastParsedTransform = i;
                        var j, k, l, m, n, o, p, q, r, s, t = a._gsTransform,
                            u = a.style,
                            v = 1e-6,
                            w = xa.length,
                            x = i,
                            y = {},
                            z = "transformOrigin";
                        if (i.display ? (m = X(a, "display"), u.display = "block", j = La(a, e, !0, i.parseTransform), u.display = m) : j = La(a, e, !0, i.parseTransform), d._transform = j, "string" == typeof x.transform && ya) m = M.style, m[ya] = x.transform, m.display = "block", m.position = "absolute", K.body.appendChild(M), k = La(M, null, !1), K.body.removeChild(M), k.perspective || (k.perspective = j.perspective), null != x.xPercent && (k.xPercent = fa(x.xPercent, j.xPercent)), null != x.yPercent && (k.yPercent = fa(x.yPercent, j.yPercent));
                        else if ("object" == typeof x) {
                            if (k = {
                                    scaleX: fa(null != x.scaleX ? x.scaleX : x.scale, j.scaleX),
                                    scaleY: fa(null != x.scaleY ? x.scaleY : x.scale, j.scaleY),
                                    scaleZ: fa(x.scaleZ, j.scaleZ),
                                    x: fa(x.x, j.x),
                                    y: fa(x.y, j.y),
                                    z: fa(x.z, j.z),
                                    xPercent: fa(x.xPercent, j.xPercent),
                                    yPercent: fa(x.yPercent, j.yPercent),
                                    perspective: fa(x.transformPerspective, j.perspective)
                                }, q = x.directionalRotation, null != q)
                                if ("object" == typeof q)
                                    for (m in q) x[m] = q[m];
                                else x.rotation = q;
                                "string" == typeof x.x && -1 !== x.x.indexOf("%") && (k.x = 0, k.xPercent = fa(x.x, j.xPercent)), "string" == typeof x.y && -1 !== x.y.indexOf("%") && (k.y = 0, k.yPercent = fa(x.y, j.yPercent)), k.rotation = ga("rotation" in x ? x.rotation : "shortRotation" in x ? x.shortRotation + "_short" : "rotationZ" in x ? x.rotationZ : j.rotation, j.rotation, "rotation", y), Ba && (k.rotationX = ga("rotationX" in x ? x.rotationX : "shortRotationX" in x ? x.shortRotationX + "_short" : j.rotationX || 0, j.rotationX, "rotationX", y), k.rotationY = ga("rotationY" in x ? x.rotationY : "shortRotationY" in x ? x.shortRotationY + "_short" : j.rotationY || 0, j.rotationY, "rotationY", y)), k.skewX = null == x.skewX ? j.skewX : ga(x.skewX, j.skewX), k.skewY = null == x.skewY ? j.skewY : ga(x.skewY, j.skewY), (l = k.skewY - j.skewY) && (k.skewX += l, k.rotation += l)
                        }
                        for (Ba && null != x.force3D && (j.force3D = x.force3D, p = !0), j.skewType = x.skewType || j.skewType || g.defaultSkewType, o = j.force3D || j.z || j.rotationX || j.rotationY || k.z || k.rotationX || k.rotationY || k.perspective, o || null == x.scale || (k.scaleZ = 1); --w > -1;) c = xa[w], n = k[c] - j[c], (n > v || -v > n || null != x[c] || null != J[c]) && (p = !0, f = new pa(j, c, j[c], n, f), c in y && (f.e = y[c]), f.xs0 = 0, f.plugin = h, d._overwriteProps.push(f.n));
                        return n = x.transformOrigin, j.svg && (n || x.svgOrigin) && (r = j.xOffset, s = j.yOffset, Ha(a, da(n), k, x.svgOrigin, x.smoothOrigin), f = qa(j, "xOrigin", (t ? j : k).xOrigin, k.xOrigin, f, z), f = qa(j, "yOrigin", (t ? j : k).yOrigin, k.yOrigin, f, z), (r !== j.xOffset || s !== j.yOffset) && (f = qa(j, "xOffset", t ? r : j.xOffset, j.xOffset, f, z), f = qa(j, "yOffset", t ? s : j.yOffset, j.yOffset, f, z)), n = wa ? null : "0px 0px"), (n || Ba && o && j.zOrigin) && (ya ? (p = !0, c = Aa, n = (n || X(a, c, e, !1, "50% 50%")) + "", f = new pa(u, c, 0, 0, f, -1, z), f.b = u[c], f.plugin = h, Ba ? (m = j.zOrigin, n = n.split(" "), j.zOrigin = (n.length > 2 && (0 === m || "0px" !== n[2]) ? parseFloat(n[2]) : m) || 0, f.xs0 = f.e = n[0] + " " + (n[1] || "50%") + " 0px", f = new pa(j, "zOrigin", 0, 0, f, -1, f.n), f.b = m, f.xs0 = f.e = j.zOrigin) : f.xs0 = f.e = n) : da(n + "", j)), p && (d._transformType = j.svg && wa || !o && 3 !== this._transformType ? 2 : 3), f
                    },
                    prefix: !0
                }), ua("boxShadow", {
                    defaultValue: "0px 0px 0px 0px #999",
                    prefix: !0,
                    color: !0,
                    multi: !0,
                    keyword: "inset"
                }), ua("borderRadius", {
                    defaultValue: "0px",
                    parser: function(a, b, c, f, g, h) {
                        b = this.format(b);
                        var i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                            z = a.style;
                        for (q = parseFloat(a.offsetWidth), r = parseFloat(a.offsetHeight), i = b.split(" "), j = 0; j < y.length; j++) this.p.indexOf("border") && (y[j] = V(y[j])), m = l = X(a, y[j], e, !1, "0px"), -1 !== m.indexOf(" ") && (l = m.split(" "), m = l[0], l = l[1]), n = k = i[j], o = parseFloat(m), t = m.substr((o + "").length), u = "=" === n.charAt(1), u ? (p = parseInt(n.charAt(0) + "1", 10), n = n.substr(2), p *= parseFloat(n), s = n.substr((p + "").length - (0 > p ? 1 : 0)) || "") : (p = parseFloat(n), s = n.substr((p + "").length)), "" === s && (s = d[c] || t), s !== t && (v = Y(a, "borderLeft", o, t), w = Y(a, "borderTop", o, t), "%" === s ? (m = v / q * 100 + "%", l = w / r * 100 + "%") : "em" === s ? (x = Y(a, "borderLeft", 1, "em"), m = v / x + "em", l = w / x + "em") : (m = v + "px", l = w + "px"), u && (n = parseFloat(m) + p + s, k = parseFloat(l) + p + s)), g = ra(z, y[j], m + " " + l, n + " " + k, !1, "0px", g);
                        return g
                    },
                    prefix: !0,
                    formatter: ma("0px 0px 0px 0px", !1, !0)
                }), ua("backgroundPosition", {
                    defaultValue: "0 0",
                    parser: function(a, b, c, d, f, g) {
                        var h, i, j, k, l, m, n = "background-position",
                            o = e || W(a, null),
                            q = this.format((o ? p ? o.getPropertyValue(n + "-x") + " " + o.getPropertyValue(n + "-y") : o.getPropertyValue(n) : a.currentStyle.backgroundPositionX + " " + a.currentStyle.backgroundPositionY) || "0 0"),
                            r = this.format(b);
                        if (-1 !== q.indexOf("%") != (-1 !== r.indexOf("%")) && (m = X(a, "backgroundImage").replace(B, ""), m && "none" !== m)) {
                            for (h = q.split(" "), i = r.split(" "), N.setAttribute("src", m), j = 2; --j > -1;) q = h[j], k = -1 !== q.indexOf("%"), k !== (-1 !== i[j].indexOf("%")) && (l = 0 === j ? a.offsetWidth - N.width : a.offsetHeight - N.height, h[j] = k ? parseFloat(q) / 100 * l + "px" : parseFloat(q) / l * 100 + "%");
                            q = h.join(" ")
                        }
                        return this.parseComplex(a.style, q, r, f, g)
                    },
                    formatter: da
                }), ua("backgroundSize", {
                    defaultValue: "0 0",
                    formatter: da
                }), ua("perspective", {
                    defaultValue: "0px",
                    prefix: !0
                }), ua("perspectiveOrigin", {
                    defaultValue: "50% 50%",
                    prefix: !0
                }), ua("transformStyle", {
                    prefix: !0
                }), ua("backfaceVisibility", {
                    prefix: !0
                }), ua("userSelect", {
                    prefix: !0
                }), ua("margin", {
                    parser: na("marginTop,marginRight,marginBottom,marginLeft")
                }), ua("padding", {
                    parser: na("paddingTop,paddingRight,paddingBottom,paddingLeft")
                }), ua("clip", {
                    defaultValue: "rect(0px,0px,0px,0px)",
                    parser: function(a, b, c, d, f, g) {
                        var h, i, j;
                        return 9 > p ? (i = a.currentStyle, j = 8 > p ? " " : ",", h = "rect(" + i.clipTop + j + i.clipRight + j + i.clipBottom + j + i.clipLeft + ")", b = this.format(b).split(",").join(j)) : (h = this.format(X(a, this.p, e, !1, this.dflt)), b = this.format(b)), this.parseComplex(a.style, h, b, f, g)
                    }
                }), ua("textShadow", {
                    defaultValue: "0px 0px 0px #999",
                    color: !0,
                    multi: !0
                }), ua("autoRound,strictUnits", {
                    parser: function(a, b, c, d, e) {
                        return e
                    }
                }), ua("border", {
                    defaultValue: "0px solid #000",
                    parser: function(a, b, c, d, f, g) {
                        return this.parseComplex(a.style, this.format(X(a, "borderTopWidth", e, !1, "0px") + " " + X(a, "borderTopStyle", e, !1, "solid") + " " + X(a, "borderTopColor", e, !1, "#000")), this.format(b), f, g)
                    },
                    color: !0,
                    formatter: function(a) {
                        var b = a.split(" ");
                        return b[0] + " " + (b[1] || "solid") + " " + (a.match(la) || ["#000"])[0]
                    }
                }), ua("borderWidth", {
                    parser: na("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                }), ua("float,cssFloat,styleFloat", {
                    parser: function(a, b, c, d, e, f) {
                        var g = a.style,
                            h = "cssFloat" in g ? "cssFloat" : "styleFloat";
                        return new pa(g, h, 0, 0, e, -1, c, !1, 0, g[h], b)
                    }
                });
                var Oa = function(a) {
                    var b, c = this.t,
                        d = c.filter || X(this.data, "filter") || "",
                        e = this.s + this.c * a | 0;
                    100 === e && (-1 === d.indexOf("atrix(") && -1 === d.indexOf("radient(") && -1 === d.indexOf("oader(") ? (c.removeAttribute("filter"), b = !X(this.data, "filter")) : (c.filter = d.replace(x, ""), b = !0)), b || (this.xn1 && (c.filter = d = d || "alpha(opacity=" + e + ")"), -1 === d.indexOf("pacity") ? 0 === e && this.xn1 || (c.filter = d + " alpha(opacity=" + e + ")") : c.filter = d.replace(v, "opacity=" + e))
                };
                ua("opacity,alpha,autoAlpha", {
                    defaultValue: "1",
                    parser: function(a, b, c, d, f, g) {
                        var h = parseFloat(X(a, "opacity", e, !1, "1")),
                            i = a.style,
                            j = "autoAlpha" === c;
                        return "string" == typeof b && "=" === b.charAt(1) && (b = ("-" === b.charAt(0) ? -1 : 1) * parseFloat(b.substr(2)) + h), j && 1 === h && "hidden" === X(a, "visibility", e) && 0 !== b && (h = 0), Q ? f = new pa(i, "opacity", h, b - h, f) : (f = new pa(i, "opacity", 100 * h, 100 * (b - h), f), f.xn1 = j ? 1 : 0, i.zoom = 1, f.type = 2, f.b = "alpha(opacity=" + f.s + ")", f.e = "alpha(opacity=" + (f.s + f.c) + ")", f.data = a, f.plugin = g, f.setRatio = Oa), j && (f = new pa(i, "visibility", 0, 0, f, -1, null, !1, 0, 0 !== h ? "inherit" : "hidden", 0 === b ? "hidden" : "inherit"), f.xs0 = "inherit", d._overwriteProps.push(f.n), d._overwriteProps.push(c)), f
                    }
                });
                var Pa = function(a, b) {
                        b && (a.removeProperty ? (("ms" === b.substr(0, 2) || "webkit" === b.substr(0, 6)) && (b = "-" + b), a.removeProperty(b.replace(z, "-$1").toLowerCase())) : a.removeAttribute(b))
                    },
                    Qa = function(a) {
                        if (this.t._gsClassPT = this, 1 === a || 0 === a) {
                            this.t.setAttribute("class", 0 === a ? this.b : this.e);
                            for (var b = this.data, c = this.t.style; b;) b.v ? c[b.p] = b.v : Pa(c, b.p), b = b._next;
                            1 === a && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                        } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                    };
                ua("className", {
                    parser: function(a, b, d, f, g, h, i) {
                        var j, k, l, m, n, o = a.getAttribute("class") || "",
                            p = a.style.cssText;
                        if (g = f._classNamePT = new pa(a, d, 0, 0, g, 2), g.setRatio = Qa, g.pr = -11, c = !0, g.b = o, k = $(a, e), l = a._gsClassPT) {
                            for (m = {}, n = l.data; n;) m[n.p] = 1, n = n._next;
                            l.setRatio(1)
                        }
                        return a._gsClassPT = g, g.e = "=" !== b.charAt(1) ? b : o.replace(new RegExp("\\s*\\b" + b.substr(2) + "\\b"), "") + ("+" === b.charAt(0) ? " " + b.substr(2) : ""), a.setAttribute("class", g.e), j = _(a, k, $(a), i, m), a.setAttribute("class", o), g.data = j.firstMPT, a.style.cssText = p, g = g.xfirst = f.parse(a, j.difs, g, h)
                    }
                });
                var Ra = function(a) {
                    if ((1 === a || 0 === a) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                        var b, c, d, e, f, g = this.t.style,
                            h = i.transform.parse;
                        if ("all" === this.e) g.cssText = "", e = !0;
                        else
                            for (b = this.e.split(" ").join("").split(","), d = b.length; --d > -1;) c = b[d], i[c] && (i[c].parse === h ? e = !0 : c = "transformOrigin" === c ? Aa : i[c].p), Pa(g, c);
                        e && (Pa(g, ya), f = this.t._gsTransform, f && (f.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                    }
                };
                for (ua("clearProps", {
                        parser: function(a, b, d, e, f) {
                            return f = new pa(a, d, 0, 0, f, 2), f.setRatio = Ra, f.e = b, f.pr = -10, f.data = e._tween, c = !0, f
                        }
                    }), j = "bezier,throwProps,physicsProps,physics2D".split(","), sa = j.length; sa--;) va(j[sa]);
                j = g.prototype, j._firstPT = j._lastParsedTransform = j._transform = null, j._onInitTween = function(a, b, h) {
                    if (!a.nodeType) return !1;
                    this._target = a, this._tween = h, this._vars = b, k = b.autoRound, c = !1, d = b.suffixMap || g.suffixMap, e = W(a, ""), f = this._overwriteProps;
                    var j, n, p, q, r, s, t, u, v, x = a.style;
                    if (l && "" === x.zIndex && (j = X(a, "zIndex", e), ("auto" === j || "" === j) && this._addLazySet(x, "zIndex", 0)), "string" == typeof b && (q = x.cssText, j = $(a, e), x.cssText = q + ";" + b, j = _(a, j, $(a)).difs, !Q && w.test(b) && (j.opacity = parseFloat(RegExp.$1)), b = j, x.cssText = q), b.className ? this._firstPT = n = i.className.parse(a, b.className, "className", this, null, null, b) : this._firstPT = n = this.parse(a, b, null), this._transformType) {
                        for (v = 3 === this._transformType, ya ? m && (l = !0, "" === x.zIndex && (t = X(a, "zIndex", e), ("auto" === t || "" === t) && this._addLazySet(x, "zIndex", 0)), o && this._addLazySet(x, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (v ? "visible" : "hidden"))) : x.zoom = 1, p = n; p && p._next;) p = p._next;
                        u = new pa(a, "transform", 0, 0, null, 2), this._linkCSSP(u, null, p), u.setRatio = ya ? Na : Ma, u.data = this._transform || La(a, e, !0), u.tween = h, u.pr = -1, f.pop()
                    }
                    if (c) {
                        for (; n;) {
                            for (s = n._next, p = q; p && p.pr > n.pr;) p = p._next;
                            (n._prev = p ? p._prev : r) ? n._prev._next = n: q = n, (n._next = p) ? p._prev = n : r = n, n = s
                        }
                        this._firstPT = q
                    }
                    return !0
                }, j.parse = function(a, b, c, f) {
                    var g, h, j, l, m, n, o, p, q, r, s = a.style;
                    for (g in b) n = b[g], h = i[g], h ? c = h.parse(a, n, g, this, c, f, b) : (m = X(a, g, e) + "", q = "string" == typeof n, "color" === g || "fill" === g || "stroke" === g || -1 !== g.indexOf("Color") || q && y.test(n) ? (q || (n = ja(n), n = (n.length > 3 ? "rgba(" : "rgb(") + n.join(",") + ")"), c = ra(s, g, m, n, !0, "transparent", c, 0, f)) : !q || -1 === n.indexOf(" ") && -1 === n.indexOf(",") ? (j = parseFloat(m), o = j || 0 === j ? m.substr((j + "").length) : "", ("" === m || "auto" === m) && ("width" === g || "height" === g ? (j = ca(a, g, e), o = "px") : "left" === g || "top" === g ? (j = Z(a, g, e), o = "px") : (j = "opacity" !== g ? 0 : 1, o = "")), r = q && "=" === n.charAt(1), r ? (l = parseInt(n.charAt(0) + "1", 10), n = n.substr(2), l *= parseFloat(n), p = n.replace(u, "")) : (l = parseFloat(n), p = q ? n.replace(u, "") : ""), "" === p && (p = g in d ? d[g] : o), n = l || 0 === l ? (r ? l + j : l) + p : b[g], o !== p && "" !== p && (l || 0 === l) && j && (j = Y(a, g, j, o), "%" === p ? (j /= Y(a, g, 100, "%") / 100, b.strictUnits !== !0 && (m = j + "%")) : "em" === p || "rem" === p || "vw" === p || "vh" === p ? j /= Y(a, g, 1, p) : "px" !== p && (l = Y(a, g, l, p), p = "px"), r && (l || 0 === l) && (n = l + j + p)), r && (l += j), !j && 0 !== j || !l && 0 !== l ? void 0 !== s[g] && (n || n + "" != "NaN" && null != n) ? (c = new pa(s, g, l || j || 0, 0, c, -1, g, !1, 0, m, n), c.xs0 = "none" !== n || "display" !== g && -1 === g.indexOf("Style") ? n : m) : S("invalid " + g + " tween value: " + b[g]) : (c = new pa(s, g, j, l - j, c, 0, g, k !== !1 && ("px" === p || "zIndex" === g), 0, m, n), c.xs0 = p)) : c = ra(s, g, m, n, !0, null, c, 0, f)), f && c && !c.plugin && (c.plugin = f);
                    return c
                }, j.setRatio = function(a) {
                    var b, c, d, e = this._firstPT,
                        f = 1e-6;
                    if (1 !== a || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                        if (a || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                            for (; e;) {
                                if (b = e.c * a + e.s, e.r ? b = Math.round(b) : f > b && b > -f && (b = 0), e.type)
                                    if (1 === e.type)
                                        if (d = e.l, 2 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2;
                                        else if (3 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3;
                                else if (4 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3 + e.xn3 + e.xs4;
                                else if (5 === d) e.t[e.p] = e.xs0 + b + e.xs1 + e.xn1 + e.xs2 + e.xn2 + e.xs3 + e.xn3 + e.xs4 + e.xn4 + e.xs5;
                                else {
                                    for (c = e.xs0 + b + e.xs1, d = 1; d < e.l; d++) c += e["xn" + d] + e["xs" + (d + 1)];
                                    e.t[e.p] = c
                                } else -1 === e.type ? e.t[e.p] = e.xs0 : e.setRatio && e.setRatio(a);
                                else e.t[e.p] = b + e.xs0;
                                e = e._next
                            } else
                                for (; e;) 2 !== e.type ? e.t[e.p] = e.b : e.setRatio(a), e = e._next;
                        else
                            for (; e;) {
                                if (2 !== e.type)
                                    if (e.r && -1 !== e.type)
                                        if (b = Math.round(e.s + e.c), e.type) {
                                            if (1 === e.type) {
                                                for (d = e.l, c = e.xs0 + b + e.xs1, d = 1; d < e.l; d++) c += e["xn" + d] + e["xs" + (d + 1)];
                                                e.t[e.p] = c
                                            }
                                        } else e.t[e.p] = b + e.xs0;
                                else e.t[e.p] = e.e;
                                else e.setRatio(a);
                                e = e._next
                            }
                }, j._enableTransforms = function(a) {
                    this._transform = this._transform || La(this._target, e, !0), this._transformType = this._transform.svg && wa || !a && 3 !== this._transformType ? 2 : 3
                };
                var Sa = function(a) {
                    this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                };
                j._addLazySet = function(a, b, c) {
                    var d = this._firstPT = new pa(a, b, 0, 0, this._firstPT, 2);
                    d.e = c, d.setRatio = Sa, d.data = this
                }, j._linkCSSP = function(a, b, c, d) {
                    return a && (b && (b._prev = a), a._next && (a._next._prev = a._prev), a._prev ? a._prev._next = a._next : this._firstPT === a && (this._firstPT = a._next, d = !0), c ? c._next = a : d || null !== this._firstPT || (this._firstPT = a), a._next = b, a._prev = c), a
                }, j._kill = function(b) {
                    var c, d, e, f = b;
                    if (b.autoAlpha || b.alpha) {
                        f = {};
                        for (d in b) f[d] = b[d];
                        f.opacity = 1, f.autoAlpha && (f.visibility = 1)
                    }
                    return b.className && (c = this._classNamePT) && (e = c.xfirst, e && e._prev ? this._linkCSSP(e._prev, c._next, e._prev._prev) : e === this._firstPT && (this._firstPT = c._next), c._next && this._linkCSSP(c._next, c._next._next, e._prev), this._classNamePT = null), a.prototype._kill.call(this, f)
                };
                var Ta = function(a, b, c) {
                    var d, e, f, g;
                    if (a.slice)
                        for (e = a.length; --e > -1;) Ta(a[e], b, c);
                    else
                        for (d = a.childNodes, e = d.length; --e > -1;) f = d[e], g = f.type, f.style && (b.push($(f)), c && c.push(f)), 1 !== g && 9 !== g && 11 !== g || !f.childNodes.length || Ta(f, b, c)
                };
                return g.cascadeTo = function(a, c, d) {
                    var e, f, g, h, i = b.to(a, c, d),
                        j = [i],
                        k = [],
                        l = [],
                        m = [],
                        n = b._internals.reservedProps;
                    for (a = i._targets || i.target, Ta(a, k, m), i.render(c, !0, !0), Ta(a, l), i.render(0, !0, !0), i._enabled(!0), e = m.length; --e > -1;)
                        if (f = _(m[e], k[e], l[e]), f.firstMPT) {
                            f = f.difs;
                            for (g in d) n[g] && (f[g] = d[g]);
                            h = {};
                            for (g in f) h[g] = k[e][g];
                            j.push(b.fromTo(m[e], c, h, f))
                        }
                    return j
                }, a.activate([g]), g
            }, !0),
            function() {
                var a = _gsScope._gsDefine.plugin({
                        propName: "roundProps",
                        version: "1.5",
                        priority: -1,
                        API: 2,
                        init: function(a, b, c) {
                            return this._tween = c, !0
                        }
                    }),
                    b = function(a) {
                        for (; a;) a.f || a.blob || (a.r = 1), a = a._next
                    },
                    c = a.prototype;
                c._onInitAllProps = function() {
                    for (var a, c, d, e = this._tween, f = e.vars.roundProps.join ? e.vars.roundProps : e.vars.roundProps.split(","), g = f.length, h = {}, i = e._propLookup.roundProps; --g > -1;) h[f[g]] = 1;
                    for (g = f.length; --g > -1;)
                        for (a = f[g], c = e._firstPT; c;) d = c._next, c.pg ? c.t._roundProps(h, !0) : c.n === a && (2 === c.f && c.t ? b(c.t._firstPT) : (this._add(c.t, a, c.s, c.c), d && (d._prev = c._prev), c._prev ? c._prev._next = d : e._firstPT === c && (e._firstPT = d), c._next = c._prev = null, e._propLookup[a] = i)), c = d;
                    return !1
                }, c._add = function(a, b, c, d) {
                    this._addTween(a, b, c, c + d, b, !0), this._overwriteProps.push(b)
                }
            }(),
            function() {
                _gsScope._gsDefine.plugin({
                    propName: "attr",
                    API: 2,
                    version: "0.5.0",
                    init: function(a, b, c) {
                        var d;
                        if ("function" != typeof a.setAttribute) return !1;
                        for (d in b) this._addTween(a, "setAttribute", a.getAttribute(d) + "", b[d] + "", d, !1, d), this._overwriteProps.push(d);
                        return !0
                    }
                })
            }(), _gsScope._gsDefine.plugin({
                propName: "directionalRotation",
                version: "0.2.1",
                API: 2,
                init: function(a, b, c) {
                    "object" != typeof b && (b = {
                        rotation: b
                    }), this.finals = {};
                    var d, e, f, g, h, i, j = b.useRadians === !0 ? 2 * Math.PI : 360,
                        k = 1e-6;
                    for (d in b) "useRadians" !== d && (i = (b[d] + "").split("_"), e = i[0], f = parseFloat("function" != typeof a[d] ? a[d] : a[d.indexOf("set") || "function" != typeof a["get" + d.substr(3)] ? d : "get" + d.substr(3)]()), g = this.finals[d] = "string" == typeof e && "=" === e.charAt(1) ? f + parseInt(e.charAt(0) + "1", 10) * Number(e.substr(2)) : Number(e) || 0, h = g - f, i.length && (e = i.join("_"), -1 !== e.indexOf("short") && (h %= j, h !== h % (j / 2) && (h = 0 > h ? h + j : h - j)), -1 !== e.indexOf("_cw") && 0 > h ? h = (h + 9999999999 * j) % j - (h / j | 0) * j : -1 !== e.indexOf("ccw") && h > 0 && (h = (h - 9999999999 * j) % j - (h / j | 0) * j)), (h > k || -k > h) && (this._addTween(a, d, f, f + h, d), this._overwriteProps.push(d)));
                    return !0
                },
                set: function(a) {
                    var b;
                    if (1 !== a) this._super.setRatio.call(this, a);
                    else
                        for (b = this._firstPT; b;) b.f ? b.t[b.p](this.finals[b.p]) : b.t[b.p] = this.finals[b.p], b = b._next
                }
            })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(a) {
                var b, c, d, e = _gsScope.GreenSockGlobals || _gsScope,
                    f = e.com.greensock,
                    g = 2 * Math.PI,
                    h = Math.PI / 2,
                    i = f._class,
                    j = function(b, c) {
                        var d = i("easing." + b, function() {}, !0),
                            e = d.prototype = new a;
                        return e.constructor = d, e.getRatio = c, d
                    },
                    k = a.register || function() {},
                    l = function(a, b, c, d, e) {
                        var f = i("easing." + a, {
                            easeOut: new b,
                            easeIn: new c,
                            easeInOut: new d
                        }, !0);
                        return k(f, a), f
                    },
                    m = function(a, b, c) {
                        this.t = a, this.v = b, c && (this.next = c, c.prev = this, this.c = c.v - b, this.gap = c.t - a)
                    },
                    n = function(b, c) {
                        var d = i("easing." + b, function(a) {
                                this._p1 = a || 0 === a ? a : 1.70158, this._p2 = 1.525 * this._p1
                            }, !0),
                            e = d.prototype = new a;
                        return e.constructor = d, e.getRatio = c, e.config = function(a) {
                            return new d(a)
                        }, d
                    },
                    o = l("Back", n("BackOut", function(a) {
                        return (a -= 1) * a * ((this._p1 + 1) * a + this._p1) + 1
                    }), n("BackIn", function(a) {
                        return a * a * ((this._p1 + 1) * a - this._p1)
                    }), n("BackInOut", function(a) {
                        return (a *= 2) < 1 ? .5 * a * a * ((this._p2 + 1) * a - this._p2) : .5 * ((a -= 2) * a * ((this._p2 + 1) * a + this._p2) + 2)
                    })),
                    p = i("easing.SlowMo", function(a, b, c) {
                        b = b || 0 === b ? b : .7, null == a ? a = .7 : a > 1 && (a = 1), this._p = 1 !== a ? b : 0, this._p1 = (1 - a) / 2, this._p2 = a, this._p3 = this._p1 + this._p2, this._calcEnd = c === !0
                    }, !0),
                    q = p.prototype = new a;
                return q.constructor = p, q.getRatio = function(a) {
                    var b = a + (.5 - a) * this._p;
                    return a < this._p1 ? this._calcEnd ? 1 - (a = 1 - a / this._p1) * a : b - (a = 1 - a / this._p1) * a * a * a * b : a > this._p3 ? this._calcEnd ? 1 - (a = (a - this._p3) / this._p1) * a : b + (a - b) * (a = (a - this._p3) / this._p1) * a * a * a : this._calcEnd ? 1 : b
                }, p.ease = new p(.7, .7), q.config = p.config = function(a, b, c) {
                    return new p(a, b, c)
                }, b = i("easing.SteppedEase", function(a) {
                    a = a || 1, this._p1 = 1 / a, this._p2 = a + 1
                }, !0), q = b.prototype = new a, q.constructor = b, q.getRatio = function(a) {
                    return 0 > a ? a = 0 : a >= 1 && (a = .999999999), (this._p2 * a >> 0) * this._p1
                }, q.config = b.config = function(a) {
                    return new b(a)
                }, c = i("easing.RoughEase", function(b) {
                    b = b || {};
                    for (var c, d, e, f, g, h, i = b.taper || "none", j = [], k = 0, l = 0 | (b.points || 20), n = l, o = b.randomize !== !1, p = b.clamp === !0, q = b.template instanceof a ? b.template : null, r = "number" == typeof b.strength ? .4 * b.strength : .4; --n > -1;) c = o ? Math.random() : 1 / l * n, d = q ? q.getRatio(c) : c, "none" === i ? e = r : "out" === i ? (f = 1 - c, e = f * f * r) : "in" === i ? e = c * c * r : .5 > c ? (f = 2 * c, e = f * f * .5 * r) : (f = 2 * (1 - c), e = f * f * .5 * r), o ? d += Math.random() * e - .5 * e : n % 2 ? d += .5 * e : d -= .5 * e, p && (d > 1 ? d = 1 : 0 > d && (d = 0)), j[k++] = {
                        x: c,
                        y: d
                    };
                    for (j.sort(function(a, b) {
                            return a.x - b.x
                        }), h = new m(1, 1, null), n = l; --n > -1;) g = j[n], h = new m(g.x, g.y, h);
                    this._prev = new m(0, 0, 0 !== h.t ? h : h.next)
                }, !0), q = c.prototype = new a, q.constructor = c, q.getRatio = function(a) {
                    var b = this._prev;
                    if (a > b.t) {
                        for (; b.next && a >= b.t;) b = b.next;
                        b = b.prev
                    } else
                        for (; b.prev && a <= b.t;) b = b.prev;
                    return this._prev = b, b.v + (a - b.t) / b.gap * b.c
                }, q.config = function(a) {
                    return new c(a)
                }, c.ease = new c, l("Bounce", j("BounceOut", function(a) {
                    return 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
                }), j("BounceIn", function(a) {
                    return (a = 1 - a) < 1 / 2.75 ? 1 - 7.5625 * a * a : 2 / 2.75 > a ? 1 - (7.5625 * (a -= 1.5 / 2.75) * a + .75) : 2.5 / 2.75 > a ? 1 - (7.5625 * (a -= 2.25 / 2.75) * a + .9375) : 1 - (7.5625 * (a -= 2.625 / 2.75) * a + .984375)
                }), j("BounceInOut", function(a) {
                    var b = .5 > a;
                    return a = b ? 1 - 2 * a : 2 * a - 1, a = 1 / 2.75 > a ? 7.5625 * a * a : 2 / 2.75 > a ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : 2.5 / 2.75 > a ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375, b ? .5 * (1 - a) : .5 * a + .5
                })), l("Circ", j("CircOut", function(a) {
                    return Math.sqrt(1 - (a -= 1) * a)
                }), j("CircIn", function(a) {
                    return -(Math.sqrt(1 - a * a) - 1)
                }), j("CircInOut", function(a) {
                    return (a *= 2) < 1 ? -.5 * (Math.sqrt(1 - a * a) - 1) : .5 * (Math.sqrt(1 - (a -= 2) * a) + 1)
                })), d = function(b, c, d) {
                    var e = i("easing." + b, function(a, b) {
                            this._p1 = a >= 1 ? a : 1, this._p2 = (b || d) / (1 > a ? a : 1), this._p3 = this._p2 / g * (Math.asin(1 / this._p1) || 0), this._p2 = g / this._p2
                        }, !0),
                        f = e.prototype = new a;
                    return f.constructor = e, f.getRatio = c, f.config = function(a, b) {
                        return new e(a, b)
                    }, e
                }, l("Elastic", d("ElasticOut", function(a) {
                    return this._p1 * Math.pow(2, -10 * a) * Math.sin((a - this._p3) * this._p2) + 1
                }, .3), d("ElasticIn", function(a) {
                    return -(this._p1 * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2))
                }, .3), d("ElasticInOut", function(a) {
                    return (a *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - this._p3) * this._p2) * .5 + 1
                }, .45)), l("Expo", j("ExpoOut", function(a) {
                    return 1 - Math.pow(2, -10 * a)
                }), j("ExpoIn", function(a) {
                    return Math.pow(2, 10 * (a - 1)) - .001
                }), j("ExpoInOut", function(a) {
                    return (a *= 2) < 1 ? .5 * Math.pow(2, 10 * (a - 1)) : .5 * (2 - Math.pow(2, -10 * (a - 1)))
                })), l("Sine", j("SineOut", function(a) {
                    return Math.sin(a * h)
                }), j("SineIn", function(a) {
                    return -Math.cos(a * h) + 1
                }), j("SineInOut", function(a) {
                    return -.5 * (Math.cos(Math.PI * a) - 1)
                })), i("easing.EaseLookup", {
                    find: function(b) {
                        return a.map[b]
                    }
                }, !0), k(e.SlowMo, "SlowMo", "ease,"), k(c, "RoughEase", "ease,"), k(b, "SteppedEase", "ease,"), o
            }, !0)
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    function(a, b) {
        "use strict";
        var c = a.GreenSockGlobals = a.GreenSockGlobals || a;
        if (!c.TweenLite) {
            var d, e, f, g, h, i = function(a) {
                    var b, d = a.split("."),
                        e = c;
                    for (b = 0; b < d.length; b++) e[d[b]] = e = e[d[b]] || {};
                    return e
                },
                j = i("com.greensock"),
                k = 1e-10,
                l = function(a) {
                    var b, c = [],
                        d = a.length;
                    for (b = 0; b !== d; c.push(a[b++]));
                    return c
                },
                m = function() {},
                n = function() {
                    var a = Object.prototype.toString,
                        b = a.call([]);
                    return function(c) {
                        return null != c && (c instanceof Array || "object" == typeof c && !!c.push && a.call(c) === b)
                    }
                }(),
                o = {},
                p = function(d, e, f, g) {
                    this.sc = o[d] ? o[d].sc : [], o[d] = this, this.gsClass = null, this.func = f;
                    var h = [];
                    this.check = function(j) {
                        for (var k, l, m, n, q, r = e.length, s = r; --r > -1;)(k = o[e[r]] || new p(e[r], [])).gsClass ? (h[r] = k.gsClass, s--) : j && k.sc.push(this);
                        if (0 === s && f)
                            for (l = ("com.greensock." + d).split("."), m = l.pop(), n = i(l.join("."))[m] = this.gsClass = f.apply(f, h), g && (c[m] = n, q = "undefined" != typeof module && module.exports, !q && "function" == typeof define && define.amd ? define((a.GreenSockAMDPath ? a.GreenSockAMDPath + "/" : "") + d.split(".").pop(), [], function() {
                                    return n
                                }) : d === b && q && (module.exports = n)), r = 0; r < this.sc.length; r++) this.sc[r].check()
                    }, this.check(!0)
                },
                q = a._gsDefine = function(a, b, c, d) {
                    return new p(a, b, c, d)
                },
                r = j._class = function(a, b, c) {
                    return b = b || function() {}, q(a, [], function() {
                        return b
                    }, c), b
                };
            q.globals = c;
            var s = [0, 0, 1, 1],
                t = [],
                u = r("easing.Ease", function(a, b, c, d) {
                    this._func = a, this._type = c || 0, this._power = d || 0, this._params = b ? s.concat(b) : s
                }, !0),
                v = u.map = {},
                w = u.register = function(a, b, c, d) {
                    for (var e, f, g, h, i = b.split(","), k = i.length, l = (c || "easeIn,easeOut,easeInOut").split(","); --k > -1;)
                        for (f = i[k], e = d ? r("easing." + f, null, !0) : j.easing[f] || {}, g = l.length; --g > -1;) h = l[g], v[f + "." + h] = v[h + f] = e[h] = a.getRatio ? a : a[h] || new a
                };
            for (f = u.prototype, f._calcEnd = !1, f.getRatio = function(a) {
                    if (this._func) return this._params[0] = a, this._func.apply(null, this._params);
                    var b = this._type,
                        c = this._power,
                        d = 1 === b ? 1 - a : 2 === b ? a : .5 > a ? 2 * a : 2 * (1 - a);
                    return 1 === c ? d *= d : 2 === c ? d *= d * d : 3 === c ? d *= d * d * d : 4 === c && (d *= d * d * d * d), 1 === b ? 1 - d : 2 === b ? d : .5 > a ? d / 2 : 1 - d / 2
                }, d = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], e = d.length; --e > -1;) f = d[e] + ",Power" + e, w(new u(null, null, 1, e), f, "easeOut", !0), w(new u(null, null, 2, e), f, "easeIn" + (0 === e ? ",easeNone" : "")), w(new u(null, null, 3, e), f, "easeInOut");
            v.linear = j.easing.Linear.easeIn, v.swing = j.easing.Quad.easeInOut;
            var x = r("events.EventDispatcher", function(a) {
                this._listeners = {}, this._eventTarget = a || this
            });
            f = x.prototype, f.addEventListener = function(a, b, c, d, e) {
                e = e || 0;
                var f, i, j = this._listeners[a],
                    k = 0;
                for (null == j && (this._listeners[a] = j = []), i = j.length; --i > -1;) f = j[i], f.c === b && f.s === c ? j.splice(i, 1) : 0 === k && f.pr < e && (k = i + 1);
                j.splice(k, 0, {
                    c: b,
                    s: c,
                    up: d,
                    pr: e
                }), this !== g || h || g.wake()
            }, f.removeEventListener = function(a, b) {
                var c, d = this._listeners[a];
                if (d)
                    for (c = d.length; --c > -1;)
                        if (d[c].c === b) return void d.splice(c, 1)
            }, f.dispatchEvent = function(a) {
                var b, c, d, e = this._listeners[a];
                if (e)
                    for (b = e.length, c = this._eventTarget; --b > -1;) d = e[b], d && (d.up ? d.c.call(d.s || c, {
                        type: a,
                        target: c
                    }) : d.c.call(d.s || c))
            };
            var y = a.requestAnimationFrame,
                z = a.cancelAnimationFrame,
                A = Date.now || function() {
                    return (new Date).getTime()
                },
                B = A();
            for (d = ["ms", "moz", "webkit", "o"], e = d.length; --e > -1 && !y;) y = a[d[e] + "RequestAnimationFrame"], z = a[d[e] + "CancelAnimationFrame"] || a[d[e] + "CancelRequestAnimationFrame"];
            r("Ticker", function(a, b) {
                var c, d, e, f, i, j = this,
                    l = A(),
                    n = b !== !1 && y ? "auto" : !1,
                    o = 500,
                    p = 33,
                    q = "tick",
                    r = function(a) {
                        var b, g, h = A() - B;
                        h > o && (l += h - p), B += h, j.time = (B - l) / 1e3, b = j.time - i, (!c || b > 0 || a === !0) && (j.frame++, i += b + (b >= f ? .004 : f - b), g = !0), a !== !0 && (e = d(r)), g && j.dispatchEvent(q)
                    };
                x.call(j), j.time = j.frame = 0, j.tick = function() {
                    r(!0)
                }, j.lagSmoothing = function(a, b) {
                    o = a || 1 / k, p = Math.min(b, o, 0)
                }, j.sleep = function() {
                    null != e && (n && z ? z(e) : clearTimeout(e), d = m, e = null, j === g && (h = !1))
                }, j.wake = function(a) {
                    null !== e ? j.sleep() : a ? l += -B + (B = A()) : j.frame > 10 && (B = A() - o + 5), d = 0 === c ? m : n && y ? y : function(a) {
                        return setTimeout(a, 1e3 * (i - j.time) + 1 | 0)
                    }, j === g && (h = !0), r(2)
                }, j.fps = function(a) {
                    return arguments.length ? (c = a, f = 1 / (c || 60), i = this.time + f, void j.wake()) : c
                }, j.useRAF = function(a) {
                    return arguments.length ? (j.sleep(), n = a, void j.fps(c)) : n
                }, j.fps(a), setTimeout(function() {
                    "auto" === n && j.frame < 5 && "hidden" !== document.visibilityState && j.useRAF(!1)
                }, 1500)
            }), f = j.Ticker.prototype = new j.events.EventDispatcher, f.constructor = j.Ticker;
            var C = r("core.Animation", function(a, b) {
                if (this.vars = b = b || {}, this._duration = this._totalDuration = a || 0, this._delay = Number(b.delay) || 0, this._timeScale = 1, this._active = b.immediateRender === !0, this.data = b.data, this._reversed = b.reversed === !0, V) {
                    h || g.wake();
                    var c = this.vars.useFrames ? U : V;
                    c.add(this, c._time), this.vars.paused && this.paused(!0)
                }
            });
            g = C.ticker = new j.Ticker, f = C.prototype, f._dirty = f._gc = f._initted = f._paused = !1, f._totalTime = f._time = 0, f._rawPrevTime = -1, f._next = f._last = f._onUpdate = f._timeline = f.timeline = null, f._paused = !1;
            var D = function() {
                h && A() - B > 2e3 && g.wake(), setTimeout(D, 2e3)
            };
            D(), f.play = function(a, b) {
                return null != a && this.seek(a, b), this.reversed(!1).paused(!1)
            }, f.pause = function(a, b) {
                return null != a && this.seek(a, b), this.paused(!0)
            }, f.resume = function(a, b) {
                return null != a && this.seek(a, b), this.paused(!1)
            }, f.seek = function(a, b) {
                return this.totalTime(Number(a), b !== !1)
            }, f.restart = function(a, b) {
                return this.reversed(!1).paused(!1).totalTime(a ? -this._delay : 0, b !== !1, !0)
            }, f.reverse = function(a, b) {
                return null != a && this.seek(a || this.totalDuration(), b), this.reversed(!0).paused(!1)
            }, f.render = function(a, b, c) {}, f.invalidate = function() {
                return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this
            }, f.isActive = function() {
                var a, b = this._timeline,
                    c = this._startTime;
                return !b || !this._gc && !this._paused && b.isActive() && (a = b.rawTime()) >= c && a < c + this.totalDuration() / this._timeScale
            }, f._enabled = function(a, b) {
                return h || g.wake(), this._gc = !a, this._active = this.isActive(), b !== !0 && (a && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !a && this.timeline && this._timeline._remove(this, !0)), !1
            }, f._kill = function(a, b) {
                return this._enabled(!1, !1)
            }, f.kill = function(a, b) {
                return this._kill(a, b), this
            }, f._uncache = function(a) {
                for (var b = a ? this : this.timeline; b;) b._dirty = !0, b = b.timeline;
                return this
            }, f._swapSelfInParams = function(a) {
                for (var b = a.length, c = a.concat(); --b > -1;) "{self}" === a[b] && (c[b] = this);
                return c
            }, f._callback = function(a) {
                var b = this.vars;
                b[a].apply(b[a + "Scope"] || b.callbackScope || this, b[a + "Params"] || t)
            }, f.eventCallback = function(a, b, c, d) {
                if ("on" === (a || "").substr(0, 2)) {
                    var e = this.vars;
                    if (1 === arguments.length) return e[a];
                    null == b ? delete e[a] : (e[a] = b, e[a + "Params"] = n(c) && -1 !== c.join("").indexOf("{self}") ? this._swapSelfInParams(c) : c, e[a + "Scope"] = d), "onUpdate" === a && (this._onUpdate = b)
                }
                return this
            }, f.delay = function(a) {
                return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + a - this._delay), this._delay = a, this) : this._delay
            }, f.duration = function(a) {
                return arguments.length ? (this._duration = this._totalDuration = a, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== a && this.totalTime(this._totalTime * (a / this._duration), !0), this) : (this._dirty = !1, this._duration)
            }, f.totalDuration = function(a) {
                return this._dirty = !1, arguments.length ? this.duration(a) : this._totalDuration
            }, f.time = function(a, b) {
                return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(a > this._duration ? this._duration : a, b)) : this._time
            }, f.totalTime = function(a, b, c) {
                if (h || g.wake(), !arguments.length) return this._totalTime;
                if (this._timeline) {
                    if (0 > a && !c && (a += this.totalDuration()), this._timeline.smoothChildTiming) {
                        this._dirty && this.totalDuration();
                        var d = this._totalDuration,
                            e = this._timeline;
                        if (a > d && !c && (a = d), this._startTime = (this._paused ? this._pauseTime : e._time) - (this._reversed ? d - a : a) / this._timeScale, e._dirty || this._uncache(!1), e._timeline)
                            for (; e._timeline;) e._timeline._time !== (e._startTime + e._totalTime) / e._timeScale && e.totalTime(e._totalTime, !0), e = e._timeline
                    }
                    this._gc && this._enabled(!0, !1), (this._totalTime !== a || 0 === this._duration) && (I.length && X(), this.render(a, b, !1), I.length && X())
                }
                return this
            }, f.progress = f.totalProgress = function(a, b) {
                var c = this.duration();
                return arguments.length ? this.totalTime(c * a, b) : c ? this._time / c : this.ratio
            }, f.startTime = function(a) {
                return arguments.length ? (a !== this._startTime && (this._startTime = a, this.timeline && this.timeline._sortChildren && this.timeline.add(this, a - this._delay)), this) : this._startTime
            }, f.endTime = function(a) {
                return this._startTime + (0 != a ? this.totalDuration() : this.duration()) / this._timeScale
            }, f.timeScale = function(a) {
                if (!arguments.length) return this._timeScale;
                if (a = a || k, this._timeline && this._timeline.smoothChildTiming) {
                    var b = this._pauseTime,
                        c = b || 0 === b ? b : this._timeline.totalTime();
                    this._startTime = c - (c - this._startTime) * this._timeScale / a
                }
                return this._timeScale = a, this._uncache(!1)
            }, f.reversed = function(a) {
                return arguments.length ? (a != this._reversed && (this._reversed = a, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
            }, f.paused = function(a) {
                if (!arguments.length) return this._paused;
                var b, c, d = this._timeline;
                return a != this._paused && d && (h || a || g.wake(), b = d.rawTime(), c = b - this._pauseTime, !a && d.smoothChildTiming && (this._startTime += c, this._uncache(!1)), this._pauseTime = a ? b : null, this._paused = a, this._active = this.isActive(), !a && 0 !== c && this._initted && this.duration() && (b = d.smoothChildTiming ? this._totalTime : (b - this._startTime) / this._timeScale, this.render(b, b === this._totalTime, !0))), this._gc && !a && this._enabled(!0, !1), this
            };
            var E = r("core.SimpleTimeline", function(a) {
                C.call(this, 0, a), this.autoRemoveChildren = this.smoothChildTiming = !0
            });
            f = E.prototype = new C, f.constructor = E, f.kill()._gc = !1, f._first = f._last = f._recent = null, f._sortChildren = !1, f.add = f.insert = function(a, b, c, d) {
                var e, f;
                if (a._startTime = Number(b || 0) + a._delay, a._paused && this !== a._timeline && (a._pauseTime = a._startTime + (this.rawTime() - a._startTime) / a._timeScale), a.timeline && a.timeline._remove(a, !0), a.timeline = a._timeline = this, a._gc && a._enabled(!0, !0), e = this._last, this._sortChildren)
                    for (f = a._startTime; e && e._startTime > f;) e = e._prev;
                return e ? (a._next = e._next, e._next = a) : (a._next = this._first, this._first = a), a._next ? a._next._prev = a : this._last = a, a._prev = e, this._recent = a, this._timeline && this._uncache(!0), this
            }, f._remove = function(a, b) {
                return a.timeline === this && (b || a._enabled(!1, !0), a._prev ? a._prev._next = a._next : this._first === a && (this._first = a._next), a._next ? a._next._prev = a._prev : this._last === a && (this._last = a._prev), a._next = a._prev = a.timeline = null, a === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
            }, f.render = function(a, b, c) {
                var d, e = this._first;
                for (this._totalTime = this._time = this._rawPrevTime = a; e;) d = e._next, (e._active || a >= e._startTime && !e._paused) && (e._reversed ? e.render((e._dirty ? e.totalDuration() : e._totalDuration) - (a - e._startTime) * e._timeScale, b, c) : e.render((a - e._startTime) * e._timeScale, b, c)), e = d
            }, f.rawTime = function() {
                return h || g.wake(), this._totalTime
            };
            var F = r("TweenLite", function(b, c, d) {
                    if (C.call(this, c, d), this.render = F.prototype.render, null == b) throw "Cannot tween a null target.";
                    this.target = b = "string" != typeof b ? b : F.selector(b) || b;
                    var e, f, g, h = b.jquery || b.length && b !== a && b[0] && (b[0] === a || b[0].nodeType && b[0].style && !b.nodeType),
                        i = this.vars.overwrite;
                    if (this._overwrite = i = null == i ? T[F.defaultOverwrite] : "number" == typeof i ? i >> 0 : T[i], (h || b instanceof Array || b.push && n(b)) && "number" != typeof b[0])
                        for (this._targets = g = l(b), this._propLookup = [], this._siblings = [], e = 0; e < g.length; e++) f = g[e], f ? "string" != typeof f ? f.length && f !== a && f[0] && (f[0] === a || f[0].nodeType && f[0].style && !f.nodeType) ? (g.splice(e--, 1), this._targets = g = g.concat(l(f))) : (this._siblings[e] = Y(f, this, !1), 1 === i && this._siblings[e].length > 1 && $(f, this, null, 1, this._siblings[e])) : (f = g[e--] = F.selector(f), "string" == typeof f && g.splice(e + 1, 1)) : g.splice(e--, 1);
                    else this._propLookup = {}, this._siblings = Y(b, this, !1), 1 === i && this._siblings.length > 1 && $(b, this, null, 1, this._siblings);
                    (this.vars.immediateRender || 0 === c && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -k, this.render(-this._delay))
                }, !0),
                G = function(b) {
                    return b && b.length && b !== a && b[0] && (b[0] === a || b[0].nodeType && b[0].style && !b.nodeType)
                },
                H = function(a, b) {
                    var c, d = {};
                    for (c in a) S[c] || c in b && "transform" !== c && "x" !== c && "y" !== c && "width" !== c && "height" !== c && "className" !== c && "border" !== c || !(!P[c] || P[c] && P[c]._autoCSS) || (d[c] = a[c], delete a[c]);
                    a.css = d
                };
            f = F.prototype = new C, f.constructor = F, f.kill()._gc = !1, f.ratio = 0, f._firstPT = f._targets = f._overwrittenProps = f._startAt = null, f._notifyPluginsOfEnabled = f._lazy = !1, F.version = "1.18.2", F.defaultEase = f._ease = new u(null, null, 1, 1), F.defaultOverwrite = "auto", F.ticker = g, F.autoSleep = 120, F.lagSmoothing = function(a, b) {
                g.lagSmoothing(a, b)
            }, F.selector = a.$ || a.jQuery || function(b) {
                var c = a.$ || a.jQuery;
                return c ? (F.selector = c, c(b)) : "undefined" == typeof document ? b : document.querySelectorAll ? document.querySelectorAll(b) : document.getElementById("#" === b.charAt(0) ? b.substr(1) : b)
            };
            var I = [],
                J = {},
                K = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                L = function(a) {
                    for (var b, c = this._firstPT, d = 1e-6; c;) b = c.blob ? a ? this.join("") : this.start : c.c * a + c.s, c.r ? b = Math.round(b) : d > b && b > -d && (b = 0), c.f ? c.fp ? c.t[c.p](c.fp, b) : c.t[c.p](b) : c.t[c.p] = b, c = c._next
                },
                M = function(a, b, c, d) {
                    var e, f, g, h, i, j, k, l = [a, b],
                        m = 0,
                        n = "",
                        o = 0;
                    for (l.start = a, c && (c(l), a = l[0], b = l[1]), l.length = 0, e = a.match(K) || [], f = b.match(K) || [], d && (d._next = null, d.blob = 1, l._firstPT = d), i = f.length, h = 0; i > h; h++) k = f[h], j = b.substr(m, b.indexOf(k, m) - m), n += j || !h ? j : ",", m += j.length, o ? o = (o + 1) % 5 : "rgba(" === j.substr(-5) && (o = 1), k === e[h] || e.length <= h ? n += k : (n && (l.push(n), n = ""), g = parseFloat(e[h]), l.push(g), l._firstPT = {
                        _next: l._firstPT,
                        t: l,
                        p: l.length - 1,
                        s: g,
                        c: ("=" === k.charAt(1) ? parseInt(k.charAt(0) + "1", 10) * parseFloat(k.substr(2)) : parseFloat(k) - g) || 0,
                        f: 0,
                        r: o && 4 > o
                    }), m += k.length;
                    return n += b.substr(m), n && l.push(n), l.setRatio = L, l
                },
                N = function(a, b, c, d, e, f, g, h) {
                    var i, j, k = "get" === c ? a[b] : c,
                        l = typeof a[b],
                        m = "string" == typeof d && "=" === d.charAt(1),
                        n = {
                            t: a,
                            p: b,
                            s: k,
                            f: "function" === l,
                            pg: 0,
                            n: e || b,
                            r: f,
                            pr: 0,
                            c: m ? parseInt(d.charAt(0) + "1", 10) * parseFloat(d.substr(2)) : parseFloat(d) - k || 0
                        };
                    return "number" !== l && ("function" === l && "get" === c && (j = b.indexOf("set") || "function" != typeof a["get" + b.substr(3)] ? b : "get" + b.substr(3), n.s = k = g ? a[j](g) : a[j]()), "string" == typeof k && (g || isNaN(k)) ? (n.fp = g, i = M(k, d, h || F.defaultStringFilter, n), n = {
                        t: i,
                        p: "setRatio",
                        s: 0,
                        c: 1,
                        f: 2,
                        pg: 0,
                        n: e || b,
                        pr: 0
                    }) : m || (n.s = parseFloat(k), n.c = parseFloat(d) - n.s || 0)), n.c ? ((n._next = this._firstPT) && (n._next._prev = n), this._firstPT = n, n) : void 0
                },
                O = F._internals = {
                    isArray: n,
                    isSelector: G,
                    lazyTweens: I,
                    blobDif: M
                },
                P = F._plugins = {},
                Q = O.tweenLookup = {},
                R = 0,
                S = O.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1,
                    lazy: 1,
                    onOverwrite: 1,
                    callbackScope: 1,
                    stringFilter: 1
                },
                T = {
                    none: 0,
                    all: 1,
                    auto: 2,
                    concurrent: 3,
                    allOnStart: 4,
                    preexisting: 5,
                    "true": 1,
                    "false": 0
                },
                U = C._rootFramesTimeline = new E,
                V = C._rootTimeline = new E,
                W = 30,
                X = O.lazyRender = function() {
                    var a, b = I.length;
                    for (J = {}; --b > -1;) a = I[b], a && a._lazy !== !1 && (a.render(a._lazy[0], a._lazy[1], !0), a._lazy = !1);
                    I.length = 0
                };
            V._startTime = g.time, U._startTime = g.frame, V._active = U._active = !0, setTimeout(X, 1), C._updateRoot = F.render = function() {
                var a, b, c;
                if (I.length && X(), V.render((g.time - V._startTime) * V._timeScale, !1, !1), U.render((g.frame - U._startTime) * U._timeScale, !1, !1), I.length && X(), g.frame >= W) {
                    W = g.frame + (parseInt(F.autoSleep, 10) || 120);
                    for (c in Q) {
                        for (b = Q[c].tweens, a = b.length; --a > -1;) b[a]._gc && b.splice(a, 1);
                        0 === b.length && delete Q[c]
                    }
                    if (c = V._first, (!c || c._paused) && F.autoSleep && !U._first && 1 === g._listeners.tick.length) {
                        for (; c && c._paused;) c = c._next;
                        c || g.sleep()
                    }
                }
            }, g.addEventListener("tick", C._updateRoot);
            var Y = function(a, b, c) {
                    var d, e, f = a._gsTweenID;
                    if (Q[f || (a._gsTweenID = f = "t" + R++)] || (Q[f] = {
                            target: a,
                            tweens: []
                        }), b && (d = Q[f].tweens, d[e = d.length] = b, c))
                        for (; --e > -1;) d[e] === b && d.splice(e, 1);
                    return Q[f].tweens
                },
                Z = function(a, b, c, d) {
                    var e, f, g = a.vars.onOverwrite;
                    return g && (e = g(a, b, c, d)), g = F.onOverwrite, g && (f = g(a, b, c, d)), e !== !1 && f !== !1
                },
                $ = function(a, b, c, d, e) {
                    var f, g, h, i;
                    if (1 === d || d >= 4) {
                        for (i = e.length, f = 0; i > f; f++)
                            if ((h = e[f]) !== b) h._gc || h._kill(null, a, b) && (g = !0);
                            else if (5 === d) break;
                        return g
                    }
                    var j, l = b._startTime + k,
                        m = [],
                        n = 0,
                        o = 0 === b._duration;
                    for (f = e.length; --f > -1;)(h = e[f]) === b || h._gc || h._paused || (h._timeline !== b._timeline ? (j = j || _(b, 0, o), 0 === _(h, j, o) && (m[n++] = h)) : h._startTime <= l && h._startTime + h.totalDuration() / h._timeScale > l && ((o || !h._initted) && l - h._startTime <= 2e-10 || (m[n++] = h)));
                    for (f = n; --f > -1;)
                        if (h = m[f], 2 === d && h._kill(c, a, b) && (g = !0), 2 !== d || !h._firstPT && h._initted) {
                            if (2 !== d && !Z(h, b)) continue;
                            h._enabled(!1, !1) && (g = !0)
                        }
                    return g
                },
                _ = function(a, b, c) {
                    for (var d = a._timeline, e = d._timeScale, f = a._startTime; d._timeline;) {
                        if (f += d._startTime, e *= d._timeScale, d._paused) return -100;
                        d = d._timeline
                    }
                    return f /= e, f > b ? f - b : c && f === b || !a._initted && 2 * k > f - b ? k : (f += a.totalDuration() / a._timeScale / e) > b + k ? 0 : f - b - k
                };
            f._init = function() {
                var a, b, c, d, e, f = this.vars,
                    g = this._overwrittenProps,
                    h = this._duration,
                    i = !!f.immediateRender,
                    j = f.ease;
                if (f.startAt) {
                    this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), e = {};
                    for (d in f.startAt) e[d] = f.startAt[d];
                    if (e.overwrite = !1, e.immediateRender = !0, e.lazy = i && f.lazy !== !1, e.startAt = e.delay = null, this._startAt = F.to(this.target, 0, e), i)
                        if (this._time > 0) this._startAt = null;
                        else if (0 !== h) return
                } else if (f.runBackwards && 0 !== h)
                    if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                    else {
                        0 !== this._time && (i = !1), c = {};
                        for (d in f) S[d] && "autoCSS" !== d || (c[d] = f[d]);
                        if (c.overwrite = 0, c.data = "isFromStart", c.lazy = i && f.lazy !== !1, c.immediateRender = i, this._startAt = F.to(this.target, 0, c), i) {
                            if (0 === this._time) return
                        } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                    }
                if (this._ease = j = j ? j instanceof u ? j : "function" == typeof j ? new u(j, f.easeParams) : v[j] || F.defaultEase : F.defaultEase, f.easeParams instanceof Array && j.config && (this._ease = j.config.apply(j, f.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                    for (a = this._targets.length; --a > -1;) this._initProps(this._targets[a], this._propLookup[a] = {}, this._siblings[a], g ? g[a] : null) && (b = !0);
                else b = this._initProps(this.target, this._propLookup, this._siblings, g);
                if (b && F._onPluginEvent("_onInitAllProps", this), g && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), f.runBackwards)
                    for (c = this._firstPT; c;) c.s += c.c, c.c = -c.c, c = c._next;
                this._onUpdate = f.onUpdate, this._initted = !0
            }, f._initProps = function(b, c, d, e) {
                var f, g, h, i, j, k;
                if (null == b) return !1;
                J[b._gsTweenID] && X(), this.vars.css || b.style && b !== a && b.nodeType && P.css && this.vars.autoCSS !== !1 && H(this.vars, b);
                for (f in this.vars)
                    if (k = this.vars[f], S[f]) k && (k instanceof Array || k.push && n(k)) && -1 !== k.join("").indexOf("{self}") && (this.vars[f] = k = this._swapSelfInParams(k, this));
                    else if (P[f] && (i = new P[f])._onInitTween(b, this.vars[f], this)) {
                    for (this._firstPT = j = {
                            _next: this._firstPT,
                            t: i,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 1,
                            n: f,
                            pg: 1,
                            pr: i._priority
                        }, g = i._overwriteProps.length; --g > -1;) c[i._overwriteProps[g]] = this._firstPT;
                    (i._priority || i._onInitAllProps) && (h = !0), (i._onDisable || i._onEnable) && (this._notifyPluginsOfEnabled = !0), j._next && (j._next._prev = j)
                } else c[f] = N.call(this, b, f, "get", k, f, 0, null, this.vars.stringFilter);
                return e && this._kill(e, b) ? this._initProps(b, c, d, e) : this._overwrite > 1 && this._firstPT && d.length > 1 && $(b, this, c, this._overwrite, d) ? (this._kill(c, b), this._initProps(b, c, d, e)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (J[b._gsTweenID] = !0), h)
            }, f.render = function(a, b, c) {
                var d, e, f, g, h = this._time,
                    i = this._duration,
                    j = this._rawPrevTime;
                if (a >= i - 1e-7) this._totalTime = this._time = i, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (d = !0, e = "onComplete", c = c || this._timeline.autoRemoveChildren), 0 === i && (this._initted || !this.vars.lazy || c) && (this._startTime === this._timeline._duration && (a = 0), (0 > j || 0 >= a && a >= -1e-7 || j === k && "isPause" !== this.data) && j !== a && (c = !0, j > k && (e = "onReverseComplete")), this._rawPrevTime = g = !b || a || j === a ? a : k);
                else if (1e-7 > a) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== h || 0 === i && j > 0) && (e = "onReverseComplete", d = this._reversed), 0 > a && (this._active = !1, 0 === i && (this._initted || !this.vars.lazy || c) && (j >= 0 && (j !== k || "isPause" !== this.data) && (c = !0), this._rawPrevTime = g = !b || a || j === a ? a : k)), this._initted || (c = !0);
                else if (this._totalTime = this._time = a, this._easeType) {
                    var l = a / i,
                        m = this._easeType,
                        n = this._easePower;
                    (1 === m || 3 === m && l >= .5) && (l = 1 - l), 3 === m && (l *= 2), 1 === n ? l *= l : 2 === n ? l *= l * l : 3 === n ? l *= l * l * l : 4 === n && (l *= l * l * l * l), 1 === m ? this.ratio = 1 - l : 2 === m ? this.ratio = l : .5 > a / i ? this.ratio = l / 2 : this.ratio = 1 - l / 2
                } else this.ratio = this._ease.getRatio(a / i);
                if (this._time !== h || c) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!c && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = h, this._rawPrevTime = j, I.push(this), void(this._lazy = [a, b]);
                        this._time && !d ? this.ratio = this._ease.getRatio(this._time / i) : d && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== h && a >= 0 && (this._active = !0), 0 === h && (this._startAt && (a >= 0 ? this._startAt.render(a, b, c) : e || (e = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === i) && (b || this._callback("onStart"))), f = this._firstPT; f;) f.f ? f.t[f.p](f.c * this.ratio + f.s) : f.t[f.p] = f.c * this.ratio + f.s, f = f._next;
                    this._onUpdate && (0 > a && this._startAt && a !== -1e-4 && this._startAt.render(a, b, c), b || (this._time !== h || d) && this._callback("onUpdate")), e && (!this._gc || c) && (0 > a && this._startAt && !this._onUpdate && a !== -1e-4 && this._startAt.render(a, b, c), d && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !b && this.vars[e] && this._callback(e), 0 === i && this._rawPrevTime === k && g !== k && (this._rawPrevTime = 0))
                }
            }, f._kill = function(a, b, c) {
                if ("all" === a && (a = null), null == a && (null == b || b === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                b = "string" != typeof b ? b || this._targets || this.target : F.selector(b) || b;
                var d, e, f, g, h, i, j, k, l, m = c && this._time && c._startTime === this._startTime && this._timeline === c._timeline;
                if ((n(b) || G(b)) && "number" != typeof b[0])
                    for (d = b.length; --d > -1;) this._kill(a, b[d], c) && (i = !0);
                else {
                    if (this._targets) {
                        for (d = this._targets.length; --d > -1;)
                            if (b === this._targets[d]) {
                                h = this._propLookup[d] || {}, this._overwrittenProps = this._overwrittenProps || [], e = this._overwrittenProps[d] = a ? this._overwrittenProps[d] || {} : "all";
                                break
                            }
                    } else {
                        if (b !== this.target) return !1;
                        h = this._propLookup, e = this._overwrittenProps = a ? this._overwrittenProps || {} : "all"
                    }
                    if (h) {
                        if (j = a || h, k = a !== e && "all" !== e && a !== h && ("object" != typeof a || !a._tempKill), c && (F.onOverwrite || this.vars.onOverwrite)) {
                            for (f in j) h[f] && (l || (l = []), l.push(f));
                            if ((l || !a) && !Z(this, c, b, l)) return !1
                        }
                        for (f in j)(g = h[f]) && (m && (g.f ? g.t[g.p](g.s) : g.t[g.p] = g.s, i = !0), g.pg && g.t._kill(j) && (i = !0), g.pg && 0 !== g.t._overwriteProps.length || (g._prev ? g._prev._next = g._next : g === this._firstPT && (this._firstPT = g._next), g._next && (g._next._prev = g._prev), g._next = g._prev = null), delete h[f]), k && (e[f] = 1);
                        !this._firstPT && this._initted && this._enabled(!1, !1)
                    }
                }
                return i
            }, f.invalidate = function() {
                return this._notifyPluginsOfEnabled && F._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], C.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -k, this.render(-this._delay)), this
            }, f._enabled = function(a, b) {
                if (h || g.wake(), a && this._gc) {
                    var c, d = this._targets;
                    if (d)
                        for (c = d.length; --c > -1;) this._siblings[c] = Y(d[c], this, !0);
                    else this._siblings = Y(this.target, this, !0)
                }
                return C.prototype._enabled.call(this, a, b), this._notifyPluginsOfEnabled && this._firstPT ? F._onPluginEvent(a ? "_onEnable" : "_onDisable", this) : !1
            }, F.to = function(a, b, c) {
                return new F(a, b, c)
            }, F.from = function(a, b, c) {
                return c.runBackwards = !0, c.immediateRender = 0 != c.immediateRender, new F(a, b, c)
            }, F.fromTo = function(a, b, c, d) {
                return d.startAt = c, d.immediateRender = 0 != d.immediateRender && 0 != c.immediateRender, new F(a, b, d)
            }, F.delayedCall = function(a, b, c, d, e) {
                return new F(b, 0, {
                    delay: a,
                    onComplete: b,
                    onCompleteParams: c,
                    callbackScope: d,
                    onReverseComplete: b,
                    onReverseCompleteParams: c,
                    immediateRender: !1,
                    lazy: !1,
                    useFrames: e,
                    overwrite: 0
                })
            }, F.set = function(a, b) {
                return new F(a, 0, b)
            }, F.getTweensOf = function(a, b) {
                if (null == a) return [];
                a = "string" != typeof a ? a : F.selector(a) || a;
                var c, d, e, f;
                if ((n(a) || G(a)) && "number" != typeof a[0]) {
                    for (c = a.length, d = []; --c > -1;) d = d.concat(F.getTweensOf(a[c], b));
                    for (c = d.length; --c > -1;)
                        for (f = d[c], e = c; --e > -1;) f === d[e] && d.splice(c, 1)
                } else
                    for (d = Y(a).concat(), c = d.length; --c > -1;)(d[c]._gc || b && !d[c].isActive()) && d.splice(c, 1);
                return d
            }, F.killTweensOf = F.killDelayedCallsTo = function(a, b, c) {
                "object" == typeof b && (c = b, b = !1);
                for (var d = F.getTweensOf(a, b), e = d.length; --e > -1;) d[e]._kill(c, a)
            };
            var aa = r("plugins.TweenPlugin", function(a, b) {
                this._overwriteProps = (a || "").split(","), this._propName = this._overwriteProps[0], this._priority = b || 0, this._super = aa.prototype
            }, !0);
            if (f = aa.prototype, aa.version = "1.18.0", aa.API = 2, f._firstPT = null, f._addTween = N, f.setRatio = L, f._kill = function(a) {
                    var b, c = this._overwriteProps,
                        d = this._firstPT;
                    if (null != a[this._propName]) this._overwriteProps = [];
                    else
                        for (b = c.length; --b > -1;) null != a[c[b]] && c.splice(b, 1);
                    for (; d;) null != a[d.n] && (d._next && (d._next._prev = d._prev), d._prev ? (d._prev._next = d._next, d._prev = null) : this._firstPT === d && (this._firstPT = d._next)), d = d._next;
                    return !1
                }, f._roundProps = function(a, b) {
                    for (var c = this._firstPT; c;)(a[this._propName] || null != c.n && a[c.n.split(this._propName + "_").join("")]) && (c.r = b), c = c._next
                }, F._onPluginEvent = function(a, b) {
                    var c, d, e, f, g, h = b._firstPT;
                    if ("_onInitAllProps" === a) {
                        for (; h;) {
                            for (g = h._next, d = e; d && d.pr > h.pr;) d = d._next;
                            (h._prev = d ? d._prev : f) ? h._prev._next = h: e = h, (h._next = d) ? d._prev = h : f = h, h = g
                        }
                        h = b._firstPT = e
                    }
                    for (; h;) h.pg && "function" == typeof h.t[a] && h.t[a]() && (c = !0), h = h._next;
                    return c
                }, aa.activate = function(a) {
                    for (var b = a.length; --b > -1;) a[b].API === aa.API && (P[(new a[b])._propName] = a[b]);
                    return !0
                }, q.plugin = function(a) {
                    if (!(a && a.propName && a.init && a.API)) throw "illegal plugin definition.";
                    var b, c = a.propName,
                        d = a.priority || 0,
                        e = a.overwriteProps,
                        f = {
                            init: "_onInitTween",
                            set: "setRatio",
                            kill: "_kill",
                            round: "_roundProps",
                            initAll: "_onInitAllProps"
                        },
                        g = r("plugins." + c.charAt(0).toUpperCase() + c.substr(1) + "Plugin", function() {
                            aa.call(this, c, d), this._overwriteProps = e || []
                        }, a.global === !0),
                        h = g.prototype = new aa(c);
                    h.constructor = g, g.API = a.API;
                    for (b in f) "function" == typeof a[b] && (h[f[b]] = a[b]);
                    return g.version = a.version, aa.activate([g]), g
                }, d = a._gsQueue) {
                for (e = 0; e < d.length; e++) d[e]();
                for (f in o) o[f].func || a.console.log("GSAP encountered missing dependency: com.greensock." + f)
            }
            h = !1
        }
    }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax");
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJncmVlbnNvY2svVHdlZW5NYXgubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBWRVJTSU9OOiAxLjE4LjJcclxuICogREFURTogMjAxNS0xMi0yMlxyXG4gKiBVUERBVEVTIEFORCBET0NTIEFUOiBodHRwOi8vZ3JlZW5zb2NrLmNvbVxyXG4gKiBcclxuICogSW5jbHVkZXMgYWxsIG9mIHRoZSBmb2xsb3dpbmc6IFR3ZWVuTGl0ZSwgVHdlZW5NYXgsIFRpbWVsaW5lTGl0ZSwgVGltZWxpbmVNYXgsIEVhc2VQYWNrLCBDU1NQbHVnaW4sIFJvdW5kUHJvcHNQbHVnaW4sIEJlemllclBsdWdpbiwgQXR0clBsdWdpbiwgRGlyZWN0aW9uYWxSb3RhdGlvblBsdWdpblxyXG4gKlxyXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxNiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBUaGlzIHdvcmsgaXMgc3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cDovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIHNvZnR3YXJlIGFncmVlbWVudCB0aGF0IHdhcyBpc3N1ZWQgd2l0aCB5b3VyIG1lbWJlcnNoaXAuXHJcbiAqIFxyXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cclxuICoqL1xyXG52YXIgX2dzU2NvcGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnRoaXN8fHdpbmRvdzsoX2dzU2NvcGUuX2dzUXVldWV8fChfZ3NTY29wZS5fZ3NRdWV1ZT1bXSkpLnB1c2goZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUd2Vlbk1heFwiLFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWZ1bmN0aW9uKGEpe3ZhciBiLGM9W10sZD1hLmxlbmd0aDtmb3IoYj0wO2IhPT1kO2MucHVzaChhW2IrK10pKTtyZXR1cm4gY30sZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPWEuY3ljbGU7Zm9yKGQgaW4gZillPWZbZF0sYVtkXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UuY2FsbChiW2NdLGMpOmVbYyVlLmxlbmd0aF07ZGVsZXRlIGEuY3ljbGV9LGY9ZnVuY3Rpb24oYSxiLGQpe2MuY2FsbCh0aGlzLGEsYixkKSx0aGlzLl9jeWNsZT0wLHRoaXMuX3lveW89dGhpcy52YXJzLnlveW89PT0hMCx0aGlzLl9yZXBlYXQ9dGhpcy52YXJzLnJlcGVhdHx8MCx0aGlzLl9yZXBlYXREZWxheT10aGlzLnZhcnMucmVwZWF0RGVsYXl8fDAsdGhpcy5fZGlydHk9ITAsdGhpcy5yZW5kZXI9Zi5wcm90b3R5cGUucmVuZGVyfSxnPTFlLTEwLGg9Yy5faW50ZXJuYWxzLGk9aC5pc1NlbGVjdG9yLGo9aC5pc0FycmF5LGs9Zi5wcm90b3R5cGU9Yy50byh7fSwuMSx7fSksbD1bXTtmLnZlcnNpb249XCIxLjE4LjJcIixrLmNvbnN0cnVjdG9yPWYsay5raWxsKCkuX2djPSExLGYua2lsbFR3ZWVuc09mPWYua2lsbERlbGF5ZWRDYWxsc1RvPWMua2lsbFR3ZWVuc09mLGYuZ2V0VHdlZW5zT2Y9Yy5nZXRUd2VlbnNPZixmLmxhZ1Ntb290aGluZz1jLmxhZ1Ntb290aGluZyxmLnRpY2tlcj1jLnRpY2tlcixmLnJlbmRlcj1jLnJlbmRlcixrLmludmFsaWRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5feW95bz10aGlzLnZhcnMueW95bz09PSEwLHRoaXMuX3JlcGVhdD10aGlzLnZhcnMucmVwZWF0fHwwLHRoaXMuX3JlcGVhdERlbGF5PXRoaXMudmFycy5yZXBlYXREZWxheXx8MCx0aGlzLl91bmNhY2hlKCEwKSxjLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyl9LGsudXBkYXRlVG89ZnVuY3Rpb24oYSxiKXt2YXIgZCxlPXRoaXMucmF0aW8sZj10aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyfHxhLmltbWVkaWF0ZVJlbmRlcjtiJiZ0aGlzLl9zdGFydFRpbWU8dGhpcy5fdGltZWxpbmUuX3RpbWUmJih0aGlzLl9zdGFydFRpbWU9dGhpcy5fdGltZWxpbmUuX3RpbWUsdGhpcy5fdW5jYWNoZSghMSksdGhpcy5fZ2M/dGhpcy5fZW5hYmxlZCghMCwhMSk6dGhpcy5fdGltZWxpbmUuaW5zZXJ0KHRoaXMsdGhpcy5fc3RhcnRUaW1lLXRoaXMuX2RlbGF5KSk7Zm9yKGQgaW4gYSl0aGlzLnZhcnNbZF09YVtkXTtpZih0aGlzLl9pbml0dGVkfHxmKWlmKGIpdGhpcy5faW5pdHRlZD0hMSxmJiZ0aGlzLnJlbmRlcigwLCEwLCEwKTtlbHNlIGlmKHRoaXMuX2djJiZ0aGlzLl9lbmFibGVkKCEwLCExKSx0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkJiZ0aGlzLl9maXJzdFBUJiZjLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLHRoaXMpLHRoaXMuX3RpbWUvdGhpcy5fZHVyYXRpb24+Ljk5OCl7dmFyIGc9dGhpcy5fdG90YWxUaW1lO3RoaXMucmVuZGVyKDAsITAsITEpLHRoaXMuX2luaXR0ZWQ9ITEsdGhpcy5yZW5kZXIoZywhMCwhMSl9ZWxzZSBpZih0aGlzLl9pbml0dGVkPSExLHRoaXMuX2luaXQoKSx0aGlzLl90aW1lPjB8fGYpZm9yKHZhciBoLGk9MS8oMS1lKSxqPXRoaXMuX2ZpcnN0UFQ7ajspaD1qLnMrai5jLGouYyo9aSxqLnM9aC1qLmMsaj1qLl9uZXh0O3JldHVybiB0aGlzfSxrLnJlbmRlcj1mdW5jdGlvbihhLGIsYyl7dGhpcy5faW5pdHRlZHx8MD09PXRoaXMuX2R1cmF0aW9uJiZ0aGlzLnZhcnMucmVwZWF0JiZ0aGlzLmludmFsaWRhdGUoKTt2YXIgZCxlLGYsaSxqLGssbCxtLG49dGhpcy5fZGlydHk/dGhpcy50b3RhbER1cmF0aW9uKCk6dGhpcy5fdG90YWxEdXJhdGlvbixvPXRoaXMuX3RpbWUscD10aGlzLl90b3RhbFRpbWUscT10aGlzLl9jeWNsZSxyPXRoaXMuX2R1cmF0aW9uLHM9dGhpcy5fcmF3UHJldlRpbWU7aWYoYT49bi0xZS03Pyh0aGlzLl90b3RhbFRpbWU9bix0aGlzLl9jeWNsZT10aGlzLl9yZXBlYXQsdGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT8odGhpcy5fdGltZT0wLHRoaXMucmF0aW89dGhpcy5fZWFzZS5fY2FsY0VuZD90aGlzLl9lYXNlLmdldFJhdGlvKDApOjApOih0aGlzLl90aW1lPXIsdGhpcy5yYXRpbz10aGlzLl9lYXNlLl9jYWxjRW5kP3RoaXMuX2Vhc2UuZ2V0UmF0aW8oMSk6MSksdGhpcy5fcmV2ZXJzZWR8fChkPSEwLGU9XCJvbkNvbXBsZXRlXCIsYz1jfHx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pLDA9PT1yJiYodGhpcy5faW5pdHRlZHx8IXRoaXMudmFycy5sYXp5fHxjKSYmKHRoaXMuX3N0YXJ0VGltZT09PXRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbiYmKGE9MCksKDA+c3x8MD49YSYmYT49LTFlLTd8fHM9PT1nJiZcImlzUGF1c2VcIiE9PXRoaXMuZGF0YSkmJnMhPT1hJiYoYz0hMCxzPmcmJihlPVwib25SZXZlcnNlQ29tcGxldGVcIikpLHRoaXMuX3Jhd1ByZXZUaW1lPW09IWJ8fGF8fHM9PT1hP2E6ZykpOjFlLTc+YT8odGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9dGhpcy5fY3ljbGU9MCx0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuX2NhbGNFbmQ/dGhpcy5fZWFzZS5nZXRSYXRpbygwKTowLCgwIT09cHx8MD09PXImJnM+MCkmJihlPVwib25SZXZlcnNlQ29tcGxldGVcIixkPXRoaXMuX3JldmVyc2VkKSwwPmEmJih0aGlzLl9hY3RpdmU9ITEsMD09PXImJih0aGlzLl9pbml0dGVkfHwhdGhpcy52YXJzLmxhenl8fGMpJiYocz49MCYmKGM9ITApLHRoaXMuX3Jhd1ByZXZUaW1lPW09IWJ8fGF8fHM9PT1hP2E6ZykpLHRoaXMuX2luaXR0ZWR8fChjPSEwKSk6KHRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPWEsMCE9PXRoaXMuX3JlcGVhdCYmKGk9cit0aGlzLl9yZXBlYXREZWxheSx0aGlzLl9jeWNsZT10aGlzLl90b3RhbFRpbWUvaT4+MCwwIT09dGhpcy5fY3ljbGUmJnRoaXMuX2N5Y2xlPT09dGhpcy5fdG90YWxUaW1lL2kmJnRoaXMuX2N5Y2xlLS0sdGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWUtdGhpcy5fY3ljbGUqaSx0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpJiYodGhpcy5fdGltZT1yLXRoaXMuX3RpbWUpLHRoaXMuX3RpbWU+cj90aGlzLl90aW1lPXI6dGhpcy5fdGltZTwwJiYodGhpcy5fdGltZT0wKSksdGhpcy5fZWFzZVR5cGU/KGo9dGhpcy5fdGltZS9yLGs9dGhpcy5fZWFzZVR5cGUsbD10aGlzLl9lYXNlUG93ZXIsKDE9PT1rfHwzPT09ayYmaj49LjUpJiYoaj0xLWopLDM9PT1rJiYoaio9MiksMT09PWw/aio9ajoyPT09bD9qKj1qKmo6Mz09PWw/aio9aipqKmo6ND09PWwmJihqKj1qKmoqaipqKSwxPT09az90aGlzLnJhdGlvPTEtajoyPT09az90aGlzLnJhdGlvPWo6dGhpcy5fdGltZS9yPC41P3RoaXMucmF0aW89ai8yOnRoaXMucmF0aW89MS1qLzIpOnRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbyh0aGlzLl90aW1lL3IpKSxvPT09dGhpcy5fdGltZSYmIWMmJnE9PT10aGlzLl9jeWNsZSlyZXR1cm4gdm9pZChwIT09dGhpcy5fdG90YWxUaW1lJiZ0aGlzLl9vblVwZGF0ZSYmKGJ8fHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpKTtpZighdGhpcy5faW5pdHRlZCl7aWYodGhpcy5faW5pdCgpLCF0aGlzLl9pbml0dGVkfHx0aGlzLl9nYylyZXR1cm47aWYoIWMmJnRoaXMuX2ZpcnN0UFQmJih0aGlzLnZhcnMubGF6eSE9PSExJiZ0aGlzLl9kdXJhdGlvbnx8dGhpcy52YXJzLmxhenkmJiF0aGlzLl9kdXJhdGlvbikpcmV0dXJuIHRoaXMuX3RpbWU9byx0aGlzLl90b3RhbFRpbWU9cCx0aGlzLl9yYXdQcmV2VGltZT1zLHRoaXMuX2N5Y2xlPXEsaC5sYXp5VHdlZW5zLnB1c2godGhpcyksdm9pZCh0aGlzLl9sYXp5PVthLGJdKTt0aGlzLl90aW1lJiYhZD90aGlzLnJhdGlvPXRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZS9yKTpkJiZ0aGlzLl9lYXNlLl9jYWxjRW5kJiYodGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKDA9PT10aGlzLl90aW1lPzA6MSkpfWZvcih0aGlzLl9sYXp5IT09ITEmJih0aGlzLl9sYXp5PSExKSx0aGlzLl9hY3RpdmV8fCF0aGlzLl9wYXVzZWQmJnRoaXMuX3RpbWUhPT1vJiZhPj0wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09cCYmKDI9PT10aGlzLl9pbml0dGVkJiZhPjAmJnRoaXMuX2luaXQoKSx0aGlzLl9zdGFydEF0JiYoYT49MD90aGlzLl9zdGFydEF0LnJlbmRlcihhLGIsYyk6ZXx8KGU9XCJfZHVtbXlHU1wiKSksdGhpcy52YXJzLm9uU3RhcnQmJigwIT09dGhpcy5fdG90YWxUaW1lfHwwPT09cikmJihifHx0aGlzLl9jYWxsYmFjayhcIm9uU3RhcnRcIikpKSxmPXRoaXMuX2ZpcnN0UFQ7ZjspZi5mP2YudFtmLnBdKGYuYyp0aGlzLnJhdGlvK2Yucyk6Zi50W2YucF09Zi5jKnRoaXMucmF0aW8rZi5zLGY9Zi5fbmV4dDt0aGlzLl9vblVwZGF0ZSYmKDA+YSYmdGhpcy5fc3RhcnRBdCYmdGhpcy5fc3RhcnRUaW1lJiZ0aGlzLl9zdGFydEF0LnJlbmRlcihhLGIsYyksYnx8KHRoaXMuX3RvdGFsVGltZSE9PXB8fGQpJiZ0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpKSx0aGlzLl9jeWNsZSE9PXEmJihifHx0aGlzLl9nY3x8dGhpcy52YXJzLm9uUmVwZWF0JiZ0aGlzLl9jYWxsYmFjayhcIm9uUmVwZWF0XCIpKSxlJiYoIXRoaXMuX2djfHxjKSYmKDA+YSYmdGhpcy5fc3RhcnRBdCYmIXRoaXMuX29uVXBkYXRlJiZ0aGlzLl9zdGFydFRpbWUmJnRoaXMuX3N0YXJ0QXQucmVuZGVyKGEsYixjKSxkJiYodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuJiZ0aGlzLl9lbmFibGVkKCExLCExKSx0aGlzLl9hY3RpdmU9ITEpLCFiJiZ0aGlzLnZhcnNbZV0mJnRoaXMuX2NhbGxiYWNrKGUpLDA9PT1yJiZ0aGlzLl9yYXdQcmV2VGltZT09PWcmJm0hPT1nJiYodGhpcy5fcmF3UHJldlRpbWU9MCkpfSxmLnRvPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IGYoYSxiLGMpfSxmLmZyb209ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjLnJ1bkJhY2t3YXJkcz0hMCxjLmltbWVkaWF0ZVJlbmRlcj0wIT1jLmltbWVkaWF0ZVJlbmRlcixuZXcgZihhLGIsYyl9LGYuZnJvbVRvPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBkLnN0YXJ0QXQ9YyxkLmltbWVkaWF0ZVJlbmRlcj0wIT1kLmltbWVkaWF0ZVJlbmRlciYmMCE9Yy5pbW1lZGlhdGVSZW5kZXIsbmV3IGYoYSxiLGQpfSxmLnN0YWdnZXJUbz1mLmFsbFRvPWZ1bmN0aW9uKGEsYixnLGgsayxtLG4pe2g9aHx8MDt2YXIgbyxwLHEscixzPTAsdD1bXSx1PWZ1bmN0aW9uKCl7Zy5vbkNvbXBsZXRlJiZnLm9uQ29tcGxldGUuYXBwbHkoZy5vbkNvbXBsZXRlU2NvcGV8fHRoaXMsYXJndW1lbnRzKSxrLmFwcGx5KG58fGcuY2FsbGJhY2tTY29wZXx8dGhpcyxtfHxsKX0sdj1nLmN5Y2xlLHc9Zy5zdGFydEF0JiZnLnN0YXJ0QXQuY3ljbGU7Zm9yKGooYSl8fChcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9Yy5zZWxlY3RvcihhKXx8YSksaShhKSYmKGE9ZChhKSkpLGE9YXx8W10sMD5oJiYoYT1kKGEpLGEucmV2ZXJzZSgpLGgqPS0xKSxvPWEubGVuZ3RoLTEscT0wO28+PXE7cSsrKXtwPXt9O2ZvcihyIGluIGcpcFtyXT1nW3JdO2lmKHYmJmUocCxhLHEpLHcpe3c9cC5zdGFydEF0PXt9O2ZvcihyIGluIGcuc3RhcnRBdCl3W3JdPWcuc3RhcnRBdFtyXTtlKHAuc3RhcnRBdCxhLHEpfXAuZGVsYXk9cysocC5kZWxheXx8MCkscT09PW8mJmsmJihwLm9uQ29tcGxldGU9dSksdFtxXT1uZXcgZihhW3FdLGIscCkscys9aH1yZXR1cm4gdH0sZi5zdGFnZ2VyRnJvbT1mLmFsbEZyb209ZnVuY3Rpb24oYSxiLGMsZCxlLGcsaCl7cmV0dXJuIGMucnVuQmFja3dhcmRzPSEwLGMuaW1tZWRpYXRlUmVuZGVyPTAhPWMuaW1tZWRpYXRlUmVuZGVyLGYuc3RhZ2dlclRvKGEsYixjLGQsZSxnLGgpfSxmLnN0YWdnZXJGcm9tVG89Zi5hbGxGcm9tVG89ZnVuY3Rpb24oYSxiLGMsZCxlLGcsaCxpKXtyZXR1cm4gZC5zdGFydEF0PWMsZC5pbW1lZGlhdGVSZW5kZXI9MCE9ZC5pbW1lZGlhdGVSZW5kZXImJjAhPWMuaW1tZWRpYXRlUmVuZGVyLGYuc3RhZ2dlclRvKGEsYixkLGUsZyxoLGkpfSxmLmRlbGF5ZWRDYWxsPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIG5ldyBmKGIsMCx7ZGVsYXk6YSxvbkNvbXBsZXRlOmIsb25Db21wbGV0ZVBhcmFtczpjLGNhbGxiYWNrU2NvcGU6ZCxvblJldmVyc2VDb21wbGV0ZTpiLG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOmMsaW1tZWRpYXRlUmVuZGVyOiExLHVzZUZyYW1lczplLG92ZXJ3cml0ZTowfSl9LGYuc2V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBmKGEsMCxiKX0sZi5pc1R3ZWVuaW5nPWZ1bmN0aW9uKGEpe3JldHVybiBjLmdldFR3ZWVuc09mKGEsITApLmxlbmd0aD4wfTt2YXIgbT1mdW5jdGlvbihhLGIpe2Zvcih2YXIgZD1bXSxlPTAsZj1hLl9maXJzdDtmOylmIGluc3RhbmNlb2YgYz9kW2UrK109ZjooYiYmKGRbZSsrXT1mKSxkPWQuY29uY2F0KG0oZixiKSksZT1kLmxlbmd0aCksZj1mLl9uZXh0O3JldHVybiBkfSxuPWYuZ2V0QWxsVHdlZW5zPWZ1bmN0aW9uKGIpe3JldHVybiBtKGEuX3Jvb3RUaW1lbGluZSxiKS5jb25jYXQobShhLl9yb290RnJhbWVzVGltZWxpbmUsYikpfTtmLmtpbGxBbGw9ZnVuY3Rpb24oYSxjLGQsZSl7bnVsbD09YyYmKGM9ITApLG51bGw9PWQmJihkPSEwKTt2YXIgZixnLGgsaT1uKDAhPWUpLGo9aS5sZW5ndGgsaz1jJiZkJiZlO2ZvcihoPTA7aj5oO2grKylnPWlbaF0sKGt8fGcgaW5zdGFuY2VvZiBifHwoZj1nLnRhcmdldD09PWcudmFycy5vbkNvbXBsZXRlKSYmZHx8YyYmIWYpJiYoYT9nLnRvdGFsVGltZShnLl9yZXZlcnNlZD8wOmcudG90YWxEdXJhdGlvbigpKTpnLl9lbmFibGVkKCExLCExKSl9LGYua2lsbENoaWxkVHdlZW5zT2Y9ZnVuY3Rpb24oYSxiKXtpZihudWxsIT1hKXt2YXIgZSxnLGssbCxtLG49aC50d2Vlbkxvb2t1cDtpZihcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9Yy5zZWxlY3RvcihhKXx8YSksaShhKSYmKGE9ZChhKSksaihhKSlmb3IobD1hLmxlbmd0aDstLWw+LTE7KWYua2lsbENoaWxkVHdlZW5zT2YoYVtsXSxiKTtlbHNle2U9W107Zm9yKGsgaW4gbilmb3IoZz1uW2tdLnRhcmdldC5wYXJlbnROb2RlO2c7KWc9PT1hJiYoZT1lLmNvbmNhdChuW2tdLnR3ZWVucykpLGc9Zy5wYXJlbnROb2RlO2ZvcihtPWUubGVuZ3RoLGw9MDttPmw7bCsrKWImJmVbbF0udG90YWxUaW1lKGVbbF0udG90YWxEdXJhdGlvbigpKSxlW2xdLl9lbmFibGVkKCExLCExKX19fTt2YXIgbz1mdW5jdGlvbihhLGMsZCxlKXtjPWMhPT0hMSxkPWQhPT0hMSxlPWUhPT0hMTtmb3IodmFyIGYsZyxoPW4oZSksaT1jJiZkJiZlLGo9aC5sZW5ndGg7LS1qPi0xOylnPWhbal0sKGl8fGcgaW5zdGFuY2VvZiBifHwoZj1nLnRhcmdldD09PWcudmFycy5vbkNvbXBsZXRlKSYmZHx8YyYmIWYpJiZnLnBhdXNlZChhKX07cmV0dXJuIGYucGF1c2VBbGw9ZnVuY3Rpb24oYSxiLGMpe28oITAsYSxiLGMpfSxmLnJlc3VtZUFsbD1mdW5jdGlvbihhLGIsYyl7byghMSxhLGIsYyl9LGYuZ2xvYmFsVGltZVNjYWxlPWZ1bmN0aW9uKGIpe3ZhciBkPWEuX3Jvb3RUaW1lbGluZSxlPWMudGlja2VyLnRpbWU7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGI9Ynx8ZyxkLl9zdGFydFRpbWU9ZS0oZS1kLl9zdGFydFRpbWUpKmQuX3RpbWVTY2FsZS9iLGQ9YS5fcm9vdEZyYW1lc1RpbWVsaW5lLGU9Yy50aWNrZXIuZnJhbWUsZC5fc3RhcnRUaW1lPWUtKGUtZC5fc3RhcnRUaW1lKSpkLl90aW1lU2NhbGUvYixkLl90aW1lU2NhbGU9YS5fcm9vdFRpbWVsaW5lLl90aW1lU2NhbGU9YixiKTpkLl90aW1lU2NhbGV9LGsucHJvZ3Jlc3M9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpKih0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpPzEtYTphKSt0aGlzLl9jeWNsZSoodGhpcy5fZHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpLCExKTp0aGlzLl90aW1lL3RoaXMuZHVyYXRpb24oKX0say50b3RhbFByb2dyZXNzPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpKmEsITEpOnRoaXMuX3RvdGFsVGltZS90aGlzLnRvdGFsRHVyYXRpb24oKX0say50aW1lPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKSxhPnRoaXMuX2R1cmF0aW9uJiYoYT10aGlzLl9kdXJhdGlvbiksdGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT9hPXRoaXMuX2R1cmF0aW9uLWErdGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KTowIT09dGhpcy5fcmVwZWF0JiYoYSs9dGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSksdGhpcy50b3RhbFRpbWUoYSxiKSk6dGhpcy5fdGltZX0say5kdXJhdGlvbj1mdW5jdGlvbihiKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD9hLnByb3RvdHlwZS5kdXJhdGlvbi5jYWxsKHRoaXMsYik6dGhpcy5fZHVyYXRpb259LGsudG90YWxEdXJhdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8tMT09PXRoaXMuX3JlcGVhdD90aGlzOnRoaXMuZHVyYXRpb24oKGEtdGhpcy5fcmVwZWF0KnRoaXMuX3JlcGVhdERlbGF5KS8odGhpcy5fcmVwZWF0KzEpKToodGhpcy5fZGlydHkmJih0aGlzLl90b3RhbER1cmF0aW9uPS0xPT09dGhpcy5fcmVwZWF0Pzk5OTk5OTk5OTk5OTp0aGlzLl9kdXJhdGlvbioodGhpcy5fcmVwZWF0KzEpK3RoaXMuX3JlcGVhdERlbGF5KnRoaXMuX3JlcGVhdCx0aGlzLl9kaXJ0eT0hMSksdGhpcy5fdG90YWxEdXJhdGlvbil9LGsucmVwZWF0PWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9yZXBlYXQ9YSx0aGlzLl91bmNhY2hlKCEwKSk6dGhpcy5fcmVwZWF0fSxrLnJlcGVhdERlbGF5PWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9yZXBlYXREZWxheT1hLHRoaXMuX3VuY2FjaGUoITApKTp0aGlzLl9yZXBlYXREZWxheX0say55b3lvPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl95b3lvPWEsdGhpcyk6dGhpcy5feW95b30sZn0sITApLF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTGl0ZVwiLFtcImNvcmUuQW5pbWF0aW9uXCIsXCJjb3JlLlNpbXBsZVRpbWVsaW5lXCIsXCJUd2VlbkxpdGVcIl0sZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWZ1bmN0aW9uKGEpe2IuY2FsbCh0aGlzLGEpLHRoaXMuX2xhYmVscz17fSx0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbj10aGlzLnZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuPT09ITAsdGhpcy5zbW9vdGhDaGlsZFRpbWluZz10aGlzLnZhcnMuc21vb3RoQ2hpbGRUaW1pbmc9PT0hMCx0aGlzLl9zb3J0Q2hpbGRyZW49ITAsdGhpcy5fb25VcGRhdGU9dGhpcy52YXJzLm9uVXBkYXRlO3ZhciBjLGQsZT10aGlzLnZhcnM7Zm9yKGQgaW4gZSljPWVbZF0saShjKSYmLTEhPT1jLmpvaW4oXCJcIikuaW5kZXhPZihcIntzZWxmfVwiKSYmKGVbZF09dGhpcy5fc3dhcFNlbGZJblBhcmFtcyhjKSk7aShlLnR3ZWVucykmJnRoaXMuYWRkKGUudHdlZW5zLDAsZS5hbGlnbixlLnN0YWdnZXIpfSxlPTFlLTEwLGY9Yy5faW50ZXJuYWxzLGc9ZC5faW50ZXJuYWxzPXt9LGg9Zi5pc1NlbGVjdG9yLGk9Zi5pc0FycmF5LGo9Zi5sYXp5VHdlZW5zLGs9Zi5sYXp5UmVuZGVyLGw9X2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsbT1mdW5jdGlvbihhKXt2YXIgYixjPXt9O2ZvcihiIGluIGEpY1tiXT1hW2JdO3JldHVybiBjfSxuPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9YS5jeWNsZTtmb3IoZCBpbiBmKWU9ZltkXSxhW2RdPVwiZnVuY3Rpb25cIj09dHlwZW9mIGU/ZS5jYWxsKGJbY10sYyk6ZVtjJWUubGVuZ3RoXTtkZWxldGUgYS5jeWNsZX0sbz1nLnBhdXNlQ2FsbGJhY2s9ZnVuY3Rpb24oKXt9LHA9ZnVuY3Rpb24oYSl7dmFyIGIsYz1bXSxkPWEubGVuZ3RoO2ZvcihiPTA7YiE9PWQ7Yy5wdXNoKGFbYisrXSkpO3JldHVybiBjfSxxPWQucHJvdG90eXBlPW5ldyBiO3JldHVybiBkLnZlcnNpb249XCIxLjE4LjJcIixxLmNvbnN0cnVjdG9yPWQscS5raWxsKCkuX2djPXEuX2ZvcmNpbmdQbGF5aGVhZD1xLl9oYXNQYXVzZT0hMSxxLnRvPWZ1bmN0aW9uKGEsYixkLGUpe3ZhciBmPWQucmVwZWF0JiZsLlR3ZWVuTWF4fHxjO3JldHVybiBiP3RoaXMuYWRkKG5ldyBmKGEsYixkKSxlKTp0aGlzLnNldChhLGQsZSl9LHEuZnJvbT1mdW5jdGlvbihhLGIsZCxlKXtyZXR1cm4gdGhpcy5hZGQoKGQucmVwZWF0JiZsLlR3ZWVuTWF4fHxjKS5mcm9tKGEsYixkKSxlKX0scS5mcm9tVG89ZnVuY3Rpb24oYSxiLGQsZSxmKXt2YXIgZz1lLnJlcGVhdCYmbC5Ud2Vlbk1heHx8YztyZXR1cm4gYj90aGlzLmFkZChnLmZyb21UbyhhLGIsZCxlKSxmKTp0aGlzLnNldChhLGUsZil9LHEuc3RhZ2dlclRvPWZ1bmN0aW9uKGEsYixlLGYsZyxpLGosayl7dmFyIGwsbyxxPW5ldyBkKHtvbkNvbXBsZXRlOmksb25Db21wbGV0ZVBhcmFtczpqLGNhbGxiYWNrU2NvcGU6ayxzbW9vdGhDaGlsZFRpbWluZzp0aGlzLnNtb290aENoaWxkVGltaW5nfSkscj1lLmN5Y2xlO2ZvcihcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9Yy5zZWxlY3RvcihhKXx8YSksYT1hfHxbXSxoKGEpJiYoYT1wKGEpKSxmPWZ8fDAsMD5mJiYoYT1wKGEpLGEucmV2ZXJzZSgpLGYqPS0xKSxvPTA7bzxhLmxlbmd0aDtvKyspbD1tKGUpLGwuc3RhcnRBdCYmKGwuc3RhcnRBdD1tKGwuc3RhcnRBdCksbC5zdGFydEF0LmN5Y2xlJiZuKGwuc3RhcnRBdCxhLG8pKSxyJiZuKGwsYSxvKSxxLnRvKGFbb10sYixsLG8qZik7cmV0dXJuIHRoaXMuYWRkKHEsZyl9LHEuc3RhZ2dlckZyb209ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoKXtyZXR1cm4gYy5pbW1lZGlhdGVSZW5kZXI9MCE9Yy5pbW1lZGlhdGVSZW5kZXIsYy5ydW5CYWNrd2FyZHM9ITAsdGhpcy5zdGFnZ2VyVG8oYSxiLGMsZCxlLGYsZyxoKX0scS5zdGFnZ2VyRnJvbVRvPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpKXtyZXR1cm4gZC5zdGFydEF0PWMsZC5pbW1lZGlhdGVSZW5kZXI9MCE9ZC5pbW1lZGlhdGVSZW5kZXImJjAhPWMuaW1tZWRpYXRlUmVuZGVyLHRoaXMuc3RhZ2dlclRvKGEsYixkLGUsZixnLGgsaSl9LHEuY2FsbD1mdW5jdGlvbihhLGIsZCxlKXtyZXR1cm4gdGhpcy5hZGQoYy5kZWxheWVkQ2FsbCgwLGEsYixkKSxlKX0scS5zZXQ9ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBkPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwoZCwwLCEwKSxudWxsPT1iLmltbWVkaWF0ZVJlbmRlciYmKGIuaW1tZWRpYXRlUmVuZGVyPWQ9PT10aGlzLl90aW1lJiYhdGhpcy5fcGF1c2VkKSx0aGlzLmFkZChuZXcgYyhhLDAsYiksZCl9LGQuZXhwb3J0Um9vdD1mdW5jdGlvbihhLGIpe2E9YXx8e30sbnVsbD09YS5zbW9vdGhDaGlsZFRpbWluZyYmKGEuc21vb3RoQ2hpbGRUaW1pbmc9ITApO3ZhciBlLGYsZz1uZXcgZChhKSxoPWcuX3RpbWVsaW5lO2ZvcihudWxsPT1iJiYoYj0hMCksaC5fcmVtb3ZlKGcsITApLGcuX3N0YXJ0VGltZT0wLGcuX3Jhd1ByZXZUaW1lPWcuX3RpbWU9Zy5fdG90YWxUaW1lPWguX3RpbWUsZT1oLl9maXJzdDtlOylmPWUuX25leHQsYiYmZSBpbnN0YW5jZW9mIGMmJmUudGFyZ2V0PT09ZS52YXJzLm9uQ29tcGxldGV8fGcuYWRkKGUsZS5fc3RhcnRUaW1lLWUuX2RlbGF5KSxlPWY7cmV0dXJuIGguYWRkKGcsMCksZ30scS5hZGQ9ZnVuY3Rpb24oZSxmLGcsaCl7dmFyIGosayxsLG0sbixvO2lmKFwibnVtYmVyXCIhPXR5cGVvZiBmJiYoZj10aGlzLl9wYXJzZVRpbWVPckxhYmVsKGYsMCwhMCxlKSksIShlIGluc3RhbmNlb2YgYSkpe2lmKGUgaW5zdGFuY2VvZiBBcnJheXx8ZSYmZS5wdXNoJiZpKGUpKXtmb3IoZz1nfHxcIm5vcm1hbFwiLGg9aHx8MCxqPWYsaz1lLmxlbmd0aCxsPTA7az5sO2wrKylpKG09ZVtsXSkmJihtPW5ldyBkKHt0d2VlbnM6bX0pKSx0aGlzLmFkZChtLGopLFwic3RyaW5nXCIhPXR5cGVvZiBtJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBtJiYoXCJzZXF1ZW5jZVwiPT09Zz9qPW0uX3N0YXJ0VGltZSttLnRvdGFsRHVyYXRpb24oKS9tLl90aW1lU2NhbGU6XCJzdGFydFwiPT09ZyYmKG0uX3N0YXJ0VGltZS09bS5kZWxheSgpKSksais9aDtyZXR1cm4gdGhpcy5fdW5jYWNoZSghMCl9aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIHRoaXMuYWRkTGFiZWwoZSxmKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93XCJDYW5ub3QgYWRkIFwiK2UrXCIgaW50byB0aGUgdGltZWxpbmU7IGl0IGlzIG5vdCBhIHR3ZWVuLCB0aW1lbGluZSwgZnVuY3Rpb24sIG9yIHN0cmluZy5cIjtlPWMuZGVsYXllZENhbGwoMCxlKX1pZihiLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLGUsZiksKHRoaXMuX2djfHx0aGlzLl90aW1lPT09dGhpcy5fZHVyYXRpb24pJiYhdGhpcy5fcGF1c2VkJiZ0aGlzLl9kdXJhdGlvbjx0aGlzLmR1cmF0aW9uKCkpZm9yKG49dGhpcyxvPW4ucmF3VGltZSgpPmUuX3N0YXJ0VGltZTtuLl90aW1lbGluZTspbyYmbi5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmc/bi50b3RhbFRpbWUobi5fdG90YWxUaW1lLCEwKTpuLl9nYyYmbi5fZW5hYmxlZCghMCwhMSksbj1uLl90aW1lbGluZTtyZXR1cm4gdGhpc30scS5yZW1vdmU9ZnVuY3Rpb24oYil7aWYoYiBpbnN0YW5jZW9mIGEpe3RoaXMuX3JlbW92ZShiLCExKTt2YXIgYz1iLl90aW1lbGluZT1iLnZhcnMudXNlRnJhbWVzP2EuX3Jvb3RGcmFtZXNUaW1lbGluZTphLl9yb290VGltZWxpbmU7cmV0dXJuIGIuX3N0YXJ0VGltZT0oYi5fcGF1c2VkP2IuX3BhdXNlVGltZTpjLl90aW1lKS0oYi5fcmV2ZXJzZWQ/Yi50b3RhbER1cmF0aW9uKCktYi5fdG90YWxUaW1lOmIuX3RvdGFsVGltZSkvYi5fdGltZVNjYWxlLHRoaXN9aWYoYiBpbnN0YW5jZW9mIEFycmF5fHxiJiZiLnB1c2gmJmkoYikpe2Zvcih2YXIgZD1iLmxlbmd0aDstLWQ+LTE7KXRoaXMucmVtb3ZlKGJbZF0pO3JldHVybiB0aGlzfXJldHVyblwic3RyaW5nXCI9PXR5cGVvZiBiP3RoaXMucmVtb3ZlTGFiZWwoYik6dGhpcy5raWxsKG51bGwsYil9LHEuX3JlbW92ZT1mdW5jdGlvbihhLGMpe2IucHJvdG90eXBlLl9yZW1vdmUuY2FsbCh0aGlzLGEsYyk7dmFyIGQ9dGhpcy5fbGFzdDtyZXR1cm4gZD90aGlzLl90aW1lPmQuX3N0YXJ0VGltZStkLl90b3RhbER1cmF0aW9uL2QuX3RpbWVTY2FsZSYmKHRoaXMuX3RpbWU9dGhpcy5kdXJhdGlvbigpLHRoaXMuX3RvdGFsVGltZT10aGlzLl90b3RhbER1cmF0aW9uKTp0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZT10aGlzLl9kdXJhdGlvbj10aGlzLl90b3RhbER1cmF0aW9uPTAsdGhpc30scS5hcHBlbmQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5hZGQoYSx0aGlzLl9wYXJzZVRpbWVPckxhYmVsKG51bGwsYiwhMCxhKSl9LHEuaW5zZXJ0PXEuaW5zZXJ0TXVsdGlwbGU9ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIHRoaXMuYWRkKGEsYnx8MCxjLGQpfSxxLmFwcGVuZE11bHRpcGxlPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLmFkZChhLHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCxiLCEwLGEpLGMsZCl9LHEuYWRkTGFiZWw9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5fbGFiZWxzW2FdPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwoYiksdGhpc30scS5hZGRQYXVzZT1mdW5jdGlvbihhLGIsZCxlKXt2YXIgZj1jLmRlbGF5ZWRDYWxsKDAsbyxkLGV8fHRoaXMpO3JldHVybiBmLnZhcnMub25Db21wbGV0ZT1mLnZhcnMub25SZXZlcnNlQ29tcGxldGU9YixmLmRhdGE9XCJpc1BhdXNlXCIsdGhpcy5faGFzUGF1c2U9ITAsdGhpcy5hZGQoZixhKX0scS5yZW1vdmVMYWJlbD1mdW5jdGlvbihhKXtyZXR1cm4gZGVsZXRlIHRoaXMuX2xhYmVsc1thXSx0aGlzfSxxLmdldExhYmVsVGltZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9dGhpcy5fbGFiZWxzW2FdP3RoaXMuX2xhYmVsc1thXTotMX0scS5fcGFyc2VUaW1lT3JMYWJlbD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZjtpZihlIGluc3RhbmNlb2YgYSYmZS50aW1lbGluZT09PXRoaXMpdGhpcy5yZW1vdmUoZSk7ZWxzZSBpZihlJiYoZSBpbnN0YW5jZW9mIEFycmF5fHxlLnB1c2gmJmkoZSkpKWZvcihmPWUubGVuZ3RoOy0tZj4tMTspZVtmXWluc3RhbmNlb2YgYSYmZVtmXS50aW1lbGluZT09PXRoaXMmJnRoaXMucmVtb3ZlKGVbZl0pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBjKXJldHVybiB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKGMsZCYmXCJudW1iZXJcIj09dHlwZW9mIGImJm51bGw9PXRoaXMuX2xhYmVsc1tjXT9iLXRoaXMuZHVyYXRpb24oKTowLGQpO2lmKGM9Y3x8MCxcInN0cmluZ1wiIT10eXBlb2YgYnx8IWlzTmFOKGIpJiZudWxsPT10aGlzLl9sYWJlbHNbYl0pbnVsbD09YiYmKGI9dGhpcy5kdXJhdGlvbigpKTtlbHNle2lmKGY9Yi5pbmRleE9mKFwiPVwiKSwtMT09PWYpcmV0dXJuIG51bGw9PXRoaXMuX2xhYmVsc1tiXT9kP3RoaXMuX2xhYmVsc1tiXT10aGlzLmR1cmF0aW9uKCkrYzpjOnRoaXMuX2xhYmVsc1tiXStjO2M9cGFyc2VJbnQoYi5jaGFyQXQoZi0xKStcIjFcIiwxMCkqTnVtYmVyKGIuc3Vic3RyKGYrMSkpLGI9Zj4xP3RoaXMuX3BhcnNlVGltZU9yTGFiZWwoYi5zdWJzdHIoMCxmLTEpLDAsZCk6dGhpcy5kdXJhdGlvbigpfXJldHVybiBOdW1iZXIoYikrY30scS5zZWVrPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMudG90YWxUaW1lKFwibnVtYmVyXCI9PXR5cGVvZiBhP2E6dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChhKSxiIT09ITEpfSxxLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXVzZWQoITApfSxxLmdvdG9BbmRQbGF5PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMucGxheShhLGIpfSxxLmdvdG9BbmRTdG9wPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMucGF1c2UoYSxiKX0scS5yZW5kZXI9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuX2djJiZ0aGlzLl9lbmFibGVkKCEwLCExKTt2YXIgZCxmLGcsaCxpLGwsbSxuPXRoaXMuX2RpcnR5P3RoaXMudG90YWxEdXJhdGlvbigpOnRoaXMuX3RvdGFsRHVyYXRpb24sbz10aGlzLl90aW1lLHA9dGhpcy5fc3RhcnRUaW1lLHE9dGhpcy5fdGltZVNjYWxlLHI9dGhpcy5fcGF1c2VkO2lmKGE+PW4tMWUtNyl0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT1uLHRoaXMuX3JldmVyc2VkfHx0aGlzLl9oYXNQYXVzZWRDaGlsZCgpfHwoZj0hMCxoPVwib25Db21wbGV0ZVwiLGk9ISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4sMD09PXRoaXMuX2R1cmF0aW9uJiYoMD49YSYmYT49LTFlLTd8fHRoaXMuX3Jhd1ByZXZUaW1lPDB8fHRoaXMuX3Jhd1ByZXZUaW1lPT09ZSkmJnRoaXMuX3Jhd1ByZXZUaW1lIT09YSYmdGhpcy5fZmlyc3QmJihpPSEwLHRoaXMuX3Jhd1ByZXZUaW1lPmUmJihoPVwib25SZXZlcnNlQ29tcGxldGVcIikpKSx0aGlzLl9yYXdQcmV2VGltZT10aGlzLl9kdXJhdGlvbnx8IWJ8fGF8fHRoaXMuX3Jhd1ByZXZUaW1lPT09YT9hOmUsYT1uKzFlLTQ7ZWxzZSBpZigxZS03PmEpaWYodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9MCwoMCE9PW98fDA9PT10aGlzLl9kdXJhdGlvbiYmdGhpcy5fcmF3UHJldlRpbWUhPT1lJiYodGhpcy5fcmF3UHJldlRpbWU+MHx8MD5hJiZ0aGlzLl9yYXdQcmV2VGltZT49MCkpJiYoaD1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIsZj10aGlzLl9yZXZlcnNlZCksMD5hKXRoaXMuX2FjdGl2ZT0hMSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX3JldmVyc2VkPyhpPWY9ITAsaD1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIpOnRoaXMuX3Jhd1ByZXZUaW1lPj0wJiZ0aGlzLl9maXJzdCYmKGk9ITApLHRoaXMuX3Jhd1ByZXZUaW1lPWE7ZWxzZXtpZih0aGlzLl9yYXdQcmV2VGltZT10aGlzLl9kdXJhdGlvbnx8IWJ8fGF8fHRoaXMuX3Jhd1ByZXZUaW1lPT09YT9hOmUsMD09PWEmJmYpZm9yKGQ9dGhpcy5fZmlyc3Q7ZCYmMD09PWQuX3N0YXJ0VGltZTspZC5fZHVyYXRpb258fChmPSExKSxkPWQuX25leHQ7YT0wLHRoaXMuX2luaXR0ZWR8fChpPSEwKX1lbHNle2lmKHRoaXMuX2hhc1BhdXNlJiYhdGhpcy5fZm9yY2luZ1BsYXloZWFkJiYhYil7aWYoYT49bylmb3IoZD10aGlzLl9maXJzdDtkJiZkLl9zdGFydFRpbWU8PWEmJiFsOylkLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCIhPT1kLmRhdGF8fGQucmF0aW98fDA9PT1kLl9zdGFydFRpbWUmJjA9PT10aGlzLl9yYXdQcmV2VGltZXx8KGw9ZCksZD1kLl9uZXh0O2Vsc2UgZm9yKGQ9dGhpcy5fbGFzdDtkJiZkLl9zdGFydFRpbWU+PWEmJiFsOylkLl9kdXJhdGlvbnx8XCJpc1BhdXNlXCI9PT1kLmRhdGEmJmQuX3Jhd1ByZXZUaW1lPjAmJihsPWQpLGQ9ZC5fcHJldjtsJiYodGhpcy5fdGltZT1hPWwuX3N0YXJ0VGltZSx0aGlzLl90b3RhbFRpbWU9YSt0aGlzLl9jeWNsZSoodGhpcy5fdG90YWxEdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSkpfXRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPXRoaXMuX3Jhd1ByZXZUaW1lPWF9aWYodGhpcy5fdGltZSE9PW8mJnRoaXMuX2ZpcnN0fHxjfHxpfHxsKXtpZih0aGlzLl9pbml0dGVkfHwodGhpcy5faW5pdHRlZD0hMCksdGhpcy5fYWN0aXZlfHwhdGhpcy5fcGF1c2VkJiZ0aGlzLl90aW1lIT09byYmYT4wJiYodGhpcy5fYWN0aXZlPSEwKSwwPT09byYmdGhpcy52YXJzLm9uU3RhcnQmJjAhPT10aGlzLl90aW1lJiYoYnx8dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpKSxtPXRoaXMuX3RpbWUsbT49bylmb3IoZD10aGlzLl9maXJzdDtkJiYoZz1kLl9uZXh0LG09PT10aGlzLl90aW1lJiYoIXRoaXMuX3BhdXNlZHx8cikpOykoZC5fYWN0aXZlfHxkLl9zdGFydFRpbWU8PW0mJiFkLl9wYXVzZWQmJiFkLl9nYykmJihsPT09ZCYmdGhpcy5wYXVzZSgpLGQuX3JldmVyc2VkP2QucmVuZGVyKChkLl9kaXJ0eT9kLnRvdGFsRHVyYXRpb24oKTpkLl90b3RhbER1cmF0aW9uKS0oYS1kLl9zdGFydFRpbWUpKmQuX3RpbWVTY2FsZSxiLGMpOmQucmVuZGVyKChhLWQuX3N0YXJ0VGltZSkqZC5fdGltZVNjYWxlLGIsYykpLGQ9ZztlbHNlIGZvcihkPXRoaXMuX2xhc3Q7ZCYmKGc9ZC5fcHJldixtPT09dGhpcy5fdGltZSYmKCF0aGlzLl9wYXVzZWR8fHIpKTspe2lmKGQuX2FjdGl2ZXx8ZC5fc3RhcnRUaW1lPD1vJiYhZC5fcGF1c2VkJiYhZC5fZ2Mpe2lmKGw9PT1kKXtmb3IobD1kLl9wcmV2O2wmJmwuZW5kVGltZSgpPnRoaXMuX3RpbWU7KWwucmVuZGVyKGwuX3JldmVyc2VkP2wudG90YWxEdXJhdGlvbigpLShhLWwuX3N0YXJ0VGltZSkqbC5fdGltZVNjYWxlOihhLWwuX3N0YXJ0VGltZSkqbC5fdGltZVNjYWxlLGIsYyksbD1sLl9wcmV2O2w9bnVsbCx0aGlzLnBhdXNlKCl9ZC5fcmV2ZXJzZWQ/ZC5yZW5kZXIoKGQuX2RpcnR5P2QudG90YWxEdXJhdGlvbigpOmQuX3RvdGFsRHVyYXRpb24pLShhLWQuX3N0YXJ0VGltZSkqZC5fdGltZVNjYWxlLGIsYyk6ZC5yZW5kZXIoKGEtZC5fc3RhcnRUaW1lKSpkLl90aW1lU2NhbGUsYixjKX1kPWd9dGhpcy5fb25VcGRhdGUmJihifHwoai5sZW5ndGgmJmsoKSx0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpKSksaCYmKHRoaXMuX2djfHwocD09PXRoaXMuX3N0YXJ0VGltZXx8cSE9PXRoaXMuX3RpbWVTY2FsZSkmJigwPT09dGhpcy5fdGltZXx8bj49dGhpcy50b3RhbER1cmF0aW9uKCkpJiYoZiYmKGoubGVuZ3RoJiZrKCksdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuJiZ0aGlzLl9lbmFibGVkKCExLCExKSx0aGlzLl9hY3RpdmU9ITEpLCFiJiZ0aGlzLnZhcnNbaF0mJnRoaXMuX2NhbGxiYWNrKGgpKSl9fSxxLl9oYXNQYXVzZWRDaGlsZD1mdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLl9maXJzdDthOyl7aWYoYS5fcGF1c2VkfHxhIGluc3RhbmNlb2YgZCYmYS5faGFzUGF1c2VkQ2hpbGQoKSlyZXR1cm4hMDthPWEuX25leHR9cmV0dXJuITF9LHEuZ2V0Q2hpbGRyZW49ZnVuY3Rpb24oYSxiLGQsZSl7ZT1lfHwtOTk5OTk5OTk5OTtmb3IodmFyIGY9W10sZz10aGlzLl9maXJzdCxoPTA7ZzspZy5fc3RhcnRUaW1lPGV8fChnIGluc3RhbmNlb2YgYz9iIT09ITEmJihmW2grK109Zyk6KGQhPT0hMSYmKGZbaCsrXT1nKSxhIT09ITEmJihmPWYuY29uY2F0KGcuZ2V0Q2hpbGRyZW4oITAsYixkKSksaD1mLmxlbmd0aCkpKSxnPWcuX25leHQ7cmV0dXJuIGZ9LHEuZ2V0VHdlZW5zT2Y9ZnVuY3Rpb24oYSxiKXt2YXIgZCxlLGY9dGhpcy5fZ2MsZz1bXSxoPTA7Zm9yKGYmJnRoaXMuX2VuYWJsZWQoITAsITApLGQ9Yy5nZXRUd2VlbnNPZihhKSxlPWQubGVuZ3RoOy0tZT4tMTspKGRbZV0udGltZWxpbmU9PT10aGlzfHxiJiZ0aGlzLl9jb250YWlucyhkW2VdKSkmJihnW2grK109ZFtlXSk7cmV0dXJuIGYmJnRoaXMuX2VuYWJsZWQoITEsITApLGd9LHEucmVjZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlY2VudH0scS5fY29udGFpbnM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEudGltZWxpbmU7Yjspe2lmKGI9PT10aGlzKXJldHVybiEwO2I9Yi50aW1lbGluZX1yZXR1cm4hMX0scS5zaGlmdENoaWxkcmVuPWZ1bmN0aW9uKGEsYixjKXtjPWN8fDA7Zm9yKHZhciBkLGU9dGhpcy5fZmlyc3QsZj10aGlzLl9sYWJlbHM7ZTspZS5fc3RhcnRUaW1lPj1jJiYoZS5fc3RhcnRUaW1lKz1hKSxlPWUuX25leHQ7aWYoYilmb3IoZCBpbiBmKWZbZF0+PWMmJihmW2RdKz1hKTtyZXR1cm4gdGhpcy5fdW5jYWNoZSghMCl9LHEuX2tpbGw9ZnVuY3Rpb24oYSxiKXtpZighYSYmIWIpcmV0dXJuIHRoaXMuX2VuYWJsZWQoITEsITEpO2Zvcih2YXIgYz1iP3RoaXMuZ2V0VHdlZW5zT2YoYik6dGhpcy5nZXRDaGlsZHJlbighMCwhMCwhMSksZD1jLmxlbmd0aCxlPSExOy0tZD4tMTspY1tkXS5fa2lsbChhLGIpJiYoZT0hMCk7cmV0dXJuIGV9LHEuY2xlYXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5nZXRDaGlsZHJlbighMSwhMCwhMCksYz1iLmxlbmd0aDtmb3IodGhpcy5fdGltZT10aGlzLl90b3RhbFRpbWU9MDstLWM+LTE7KWJbY10uX2VuYWJsZWQoITEsITEpO3JldHVybiBhIT09ITEmJih0aGlzLl9sYWJlbHM9e30pLHRoaXMuX3VuY2FjaGUoITApfSxxLmludmFsaWRhdGU9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5fZmlyc3Q7YjspYi5pbnZhbGlkYXRlKCksYj1iLl9uZXh0O3JldHVybiBhLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyl9LHEuX2VuYWJsZWQ9ZnVuY3Rpb24oYSxjKXtpZihhPT09dGhpcy5fZ2MpZm9yKHZhciBkPXRoaXMuX2ZpcnN0O2Q7KWQuX2VuYWJsZWQoYSwhMCksZD1kLl9uZXh0O3JldHVybiBiLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsYSxjKX0scS50b3RhbFRpbWU9ZnVuY3Rpb24oYixjLGQpe3RoaXMuX2ZvcmNpbmdQbGF5aGVhZD0hMDt2YXIgZT1hLnByb3RvdHlwZS50b3RhbFRpbWUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB0aGlzLl9mb3JjaW5nUGxheWhlYWQ9ITEsZX0scS5kdXJhdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oMCE9PXRoaXMuZHVyYXRpb24oKSYmMCE9PWEmJnRoaXMudGltZVNjYWxlKHRoaXMuX2R1cmF0aW9uL2EpLHRoaXMpOih0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCksdGhpcy5fZHVyYXRpb24pfSxxLnRvdGFsRHVyYXRpb249ZnVuY3Rpb24oYSl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpe2lmKHRoaXMuX2RpcnR5KXtmb3IodmFyIGIsYyxkPTAsZT10aGlzLl9sYXN0LGY9OTk5OTk5OTk5OTk5O2U7KWI9ZS5fcHJldixlLl9kaXJ0eSYmZS50b3RhbER1cmF0aW9uKCksZS5fc3RhcnRUaW1lPmYmJnRoaXMuX3NvcnRDaGlsZHJlbiYmIWUuX3BhdXNlZD90aGlzLmFkZChlLGUuX3N0YXJ0VGltZS1lLl9kZWxheSk6Zj1lLl9zdGFydFRpbWUsZS5fc3RhcnRUaW1lPDAmJiFlLl9wYXVzZWQmJihkLT1lLl9zdGFydFRpbWUsdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcmJih0aGlzLl9zdGFydFRpbWUrPWUuX3N0YXJ0VGltZS90aGlzLl90aW1lU2NhbGUpLHRoaXMuc2hpZnRDaGlsZHJlbigtZS5fc3RhcnRUaW1lLCExLC05OTk5OTk5OTk5KSxmPTApLGM9ZS5fc3RhcnRUaW1lK2UuX3RvdGFsRHVyYXRpb24vZS5fdGltZVNjYWxlLGM+ZCYmKGQ9YyksZT1iO3RoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249ZCx0aGlzLl9kaXJ0eT0hMX1yZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbn1yZXR1cm4gYSYmdGhpcy50b3RhbER1cmF0aW9uKCk/dGhpcy50aW1lU2NhbGUodGhpcy5fdG90YWxEdXJhdGlvbi9hKTp0aGlzfSxxLnBhdXNlZD1mdW5jdGlvbihiKXtpZighYilmb3IodmFyIGM9dGhpcy5fZmlyc3QsZD10aGlzLl90aW1lO2M7KWMuX3N0YXJ0VGltZT09PWQmJlwiaXNQYXVzZVwiPT09Yy5kYXRhJiYoYy5fcmF3UHJldlRpbWU9MCksYz1jLl9uZXh0O3JldHVybiBhLnByb3RvdHlwZS5wYXVzZWQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxxLnVzZXNGcmFtZXM9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5fdGltZWxpbmU7Yi5fdGltZWxpbmU7KWI9Yi5fdGltZWxpbmU7cmV0dXJuIGI9PT1hLl9yb290RnJhbWVzVGltZWxpbmV9LHEucmF3VGltZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXVzZWQ/dGhpcy5fdG90YWxUaW1lOih0aGlzLl90aW1lbGluZS5yYXdUaW1lKCktdGhpcy5fc3RhcnRUaW1lKSp0aGlzLl90aW1lU2NhbGV9LGR9LCEwKSxfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZU1heFwiLFtcIlRpbWVsaW5lTGl0ZVwiLFwiVHdlZW5MaXRlXCIsXCJlYXNpbmcuRWFzZVwiXSxmdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZnVuY3Rpb24oYil7YS5jYWxsKHRoaXMsYiksdGhpcy5fcmVwZWF0PXRoaXMudmFycy5yZXBlYXR8fDAsdGhpcy5fcmVwZWF0RGVsYXk9dGhpcy52YXJzLnJlcGVhdERlbGF5fHwwLHRoaXMuX2N5Y2xlPTAsdGhpcy5feW95bz10aGlzLnZhcnMueW95bz09PSEwLHRoaXMuX2RpcnR5PSEwfSxlPTFlLTEwLGY9Yi5faW50ZXJuYWxzLGc9Zi5sYXp5VHdlZW5zLGg9Zi5sYXp5UmVuZGVyLGk9bmV3IGMobnVsbCxudWxsLDEsMCksaj1kLnByb3RvdHlwZT1uZXcgYTtyZXR1cm4gai5jb25zdHJ1Y3Rvcj1kLGoua2lsbCgpLl9nYz0hMSxkLnZlcnNpb249XCIxLjE4LjJcIixqLmludmFsaWRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5feW95bz10aGlzLnZhcnMueW95bz09PSEwLHRoaXMuX3JlcGVhdD10aGlzLnZhcnMucmVwZWF0fHwwLHRoaXMuX3JlcGVhdERlbGF5PXRoaXMudmFycy5yZXBlYXREZWxheXx8MCx0aGlzLl91bmNhY2hlKCEwKSxhLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyl9LGouYWRkQ2FsbGJhY2s9ZnVuY3Rpb24oYSxjLGQsZSl7cmV0dXJuIHRoaXMuYWRkKGIuZGVsYXllZENhbGwoMCxhLGQsZSksYyl9LGoucmVtb3ZlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiKXtpZihhKWlmKG51bGw9PWIpdGhpcy5fa2lsbChudWxsLGEpO2Vsc2UgZm9yKHZhciBjPXRoaXMuZ2V0VHdlZW5zT2YoYSwhMSksZD1jLmxlbmd0aCxlPXRoaXMuX3BhcnNlVGltZU9yTGFiZWwoYik7LS1kPi0xOyljW2RdLl9zdGFydFRpbWU9PT1lJiZjW2RdLl9lbmFibGVkKCExLCExKTtyZXR1cm4gdGhpc30sai5yZW1vdmVQYXVzZT1mdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5yZW1vdmVDYWxsYmFjayhhLl9pbnRlcm5hbHMucGF1c2VDYWxsYmFjayxiKX0sai50d2VlblRvPWZ1bmN0aW9uKGEsYyl7Yz1jfHx7fTt2YXIgZCxlLGYsZz17ZWFzZTppLHVzZUZyYW1lczp0aGlzLnVzZXNGcmFtZXMoKSxpbW1lZGlhdGVSZW5kZXI6ITF9O2ZvcihlIGluIGMpZ1tlXT1jW2VdO3JldHVybiBnLnRpbWU9dGhpcy5fcGFyc2VUaW1lT3JMYWJlbChhKSxkPU1hdGguYWJzKE51bWJlcihnLnRpbWUpLXRoaXMuX3RpbWUpL3RoaXMuX3RpbWVTY2FsZXx8LjAwMSxmPW5ldyBiKHRoaXMsZCxnKSxnLm9uU3RhcnQ9ZnVuY3Rpb24oKXtmLnRhcmdldC5wYXVzZWQoITApLGYudmFycy50aW1lIT09Zi50YXJnZXQudGltZSgpJiZkPT09Zi5kdXJhdGlvbigpJiZmLmR1cmF0aW9uKE1hdGguYWJzKGYudmFycy50aW1lLWYudGFyZ2V0LnRpbWUoKSkvZi50YXJnZXQuX3RpbWVTY2FsZSksYy5vblN0YXJ0JiZmLl9jYWxsYmFjayhcIm9uU3RhcnRcIil9LGZ9LGoudHdlZW5Gcm9tVG89ZnVuY3Rpb24oYSxiLGMpe2M9Y3x8e30sYT10aGlzLl9wYXJzZVRpbWVPckxhYmVsKGEpLGMuc3RhcnRBdD17b25Db21wbGV0ZTp0aGlzLnNlZWssb25Db21wbGV0ZVBhcmFtczpbYV0sY2FsbGJhY2tTY29wZTp0aGlzfSxjLmltbWVkaWF0ZVJlbmRlcj1jLmltbWVkaWF0ZVJlbmRlciE9PSExO3ZhciBkPXRoaXMudHdlZW5UbyhiLGMpO3JldHVybiBkLmR1cmF0aW9uKE1hdGguYWJzKGQudmFycy50aW1lLWEpL3RoaXMuX3RpbWVTY2FsZXx8LjAwMSl9LGoucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXt0aGlzLl9nYyYmdGhpcy5fZW5hYmxlZCghMCwhMSk7dmFyIGQsZixpLGosayxsLG0sbixvPXRoaXMuX2RpcnR5P3RoaXMudG90YWxEdXJhdGlvbigpOnRoaXMuX3RvdGFsRHVyYXRpb24scD10aGlzLl9kdXJhdGlvbixxPXRoaXMuX3RpbWUscj10aGlzLl90b3RhbFRpbWUscz10aGlzLl9zdGFydFRpbWUsdD10aGlzLl90aW1lU2NhbGUsdT10aGlzLl9yYXdQcmV2VGltZSx2PXRoaXMuX3BhdXNlZCx3PXRoaXMuX2N5Y2xlO2lmKGE+PW8tMWUtNyl0aGlzLl9sb2NrZWR8fCh0aGlzLl90b3RhbFRpbWU9byx0aGlzLl9jeWNsZT10aGlzLl9yZXBlYXQpLHRoaXMuX3JldmVyc2VkfHx0aGlzLl9oYXNQYXVzZWRDaGlsZCgpfHwoZj0hMCxqPVwib25Db21wbGV0ZVwiLGs9ISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4sMD09PXRoaXMuX2R1cmF0aW9uJiYoMD49YSYmYT49LTFlLTd8fDA+dXx8dT09PWUpJiZ1IT09YSYmdGhpcy5fZmlyc3QmJihrPSEwLHU+ZSYmKGo9XCJvblJldmVyc2VDb21wbGV0ZVwiKSkpLHRoaXMuX3Jhd1ByZXZUaW1lPXRoaXMuX2R1cmF0aW9ufHwhYnx8YXx8dGhpcy5fcmF3UHJldlRpbWU9PT1hP2E6ZSx0aGlzLl95b3lvJiYwIT09KDEmdGhpcy5fY3ljbGUpP3RoaXMuX3RpbWU9YT0wOih0aGlzLl90aW1lPXAsYT1wKzFlLTQpO2Vsc2UgaWYoMWUtNz5hKWlmKHRoaXMuX2xvY2tlZHx8KHRoaXMuX3RvdGFsVGltZT10aGlzLl9jeWNsZT0wKSx0aGlzLl90aW1lPTAsKDAhPT1xfHwwPT09cCYmdSE9PWUmJih1PjB8fDA+YSYmdT49MCkmJiF0aGlzLl9sb2NrZWQpJiYoaj1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIsZj10aGlzLl9yZXZlcnNlZCksMD5hKXRoaXMuX2FjdGl2ZT0hMSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX3JldmVyc2VkPyhrPWY9ITAsaj1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIpOnU+PTAmJnRoaXMuX2ZpcnN0JiYoaz0hMCksdGhpcy5fcmF3UHJldlRpbWU9YTtlbHNle2lmKHRoaXMuX3Jhd1ByZXZUaW1lPXB8fCFifHxhfHx0aGlzLl9yYXdQcmV2VGltZT09PWE/YTplLDA9PT1hJiZmKWZvcihkPXRoaXMuX2ZpcnN0O2QmJjA9PT1kLl9zdGFydFRpbWU7KWQuX2R1cmF0aW9ufHwoZj0hMSksZD1kLl9uZXh0O2E9MCx0aGlzLl9pbml0dGVkfHwoaz0hMCl9ZWxzZSBpZigwPT09cCYmMD51JiYoaz0hMCksdGhpcy5fdGltZT10aGlzLl9yYXdQcmV2VGltZT1hLHRoaXMuX2xvY2tlZHx8KHRoaXMuX3RvdGFsVGltZT1hLDAhPT10aGlzLl9yZXBlYXQmJihsPXArdGhpcy5fcmVwZWF0RGVsYXksdGhpcy5fY3ljbGU9dGhpcy5fdG90YWxUaW1lL2w+PjAsMCE9PXRoaXMuX2N5Y2xlJiZ0aGlzLl9jeWNsZT09PXRoaXMuX3RvdGFsVGltZS9sJiZ0aGlzLl9jeWNsZS0tLHRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lLXRoaXMuX2N5Y2xlKmwsdGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKSYmKHRoaXMuX3RpbWU9cC10aGlzLl90aW1lKSx0aGlzLl90aW1lPnA/KHRoaXMuX3RpbWU9cCxhPXArMWUtNCk6dGhpcy5fdGltZTwwP3RoaXMuX3RpbWU9YT0wOmE9dGhpcy5fdGltZSkpLHRoaXMuX2hhc1BhdXNlJiYhdGhpcy5fZm9yY2luZ1BsYXloZWFkJiYhYil7aWYoYT10aGlzLl90aW1lLGE+PXEpZm9yKGQ9dGhpcy5fZmlyc3Q7ZCYmZC5fc3RhcnRUaW1lPD1hJiYhbTspZC5fZHVyYXRpb258fFwiaXNQYXVzZVwiIT09ZC5kYXRhfHxkLnJhdGlvfHwwPT09ZC5fc3RhcnRUaW1lJiYwPT09dGhpcy5fcmF3UHJldlRpbWV8fChtPWQpLGQ9ZC5fbmV4dDtlbHNlIGZvcihkPXRoaXMuX2xhc3Q7ZCYmZC5fc3RhcnRUaW1lPj1hJiYhbTspZC5fZHVyYXRpb258fFwiaXNQYXVzZVwiPT09ZC5kYXRhJiZkLl9yYXdQcmV2VGltZT4wJiYobT1kKSxkPWQuX3ByZXY7bSYmKHRoaXMuX3RpbWU9YT1tLl9zdGFydFRpbWUsdGhpcy5fdG90YWxUaW1lPWErdGhpcy5fY3ljbGUqKHRoaXMuX3RvdGFsRHVyYXRpb24rdGhpcy5fcmVwZWF0RGVsYXkpKX1pZih0aGlzLl9jeWNsZSE9PXcmJiF0aGlzLl9sb2NrZWQpe3ZhciB4PXRoaXMuX3lveW8mJjAhPT0oMSZ3KSx5PXg9PT0odGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKSksej10aGlzLl90b3RhbFRpbWUsQT10aGlzLl9jeWNsZSxCPXRoaXMuX3Jhd1ByZXZUaW1lLEM9dGhpcy5fdGltZTtpZih0aGlzLl90b3RhbFRpbWU9dypwLHRoaXMuX2N5Y2xlPHc/eD0heDp0aGlzLl90b3RhbFRpbWUrPXAsdGhpcy5fdGltZT1xLHRoaXMuX3Jhd1ByZXZUaW1lPTA9PT1wP3UtMWUtNDp1LHRoaXMuX2N5Y2xlPXcsdGhpcy5fbG9ja2VkPSEwLHE9eD8wOnAsdGhpcy5yZW5kZXIocSxiLDA9PT1wKSxifHx0aGlzLl9nY3x8dGhpcy52YXJzLm9uUmVwZWF0JiZ0aGlzLl9jYWxsYmFjayhcIm9uUmVwZWF0XCIpLHEhPT10aGlzLl90aW1lKXJldHVybjtpZih5JiYocT14P3ArMWUtNDotMWUtNCx0aGlzLnJlbmRlcihxLCEwLCExKSksdGhpcy5fbG9ja2VkPSExLHRoaXMuX3BhdXNlZCYmIXYpcmV0dXJuO3RoaXMuX3RpbWU9Qyx0aGlzLl90b3RhbFRpbWU9eix0aGlzLl9jeWNsZT1BLHRoaXMuX3Jhd1ByZXZUaW1lPUJ9aWYoISh0aGlzLl90aW1lIT09cSYmdGhpcy5fZmlyc3R8fGN8fGt8fG0pKXJldHVybiB2b2lkKHIhPT10aGlzLl90b3RhbFRpbWUmJnRoaXMuX29uVXBkYXRlJiYoYnx8dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKSkpO2lmKHRoaXMuX2luaXR0ZWR8fCh0aGlzLl9pbml0dGVkPSEwKSx0aGlzLl9hY3RpdmV8fCF0aGlzLl9wYXVzZWQmJnRoaXMuX3RvdGFsVGltZSE9PXImJmE+MCYmKHRoaXMuX2FjdGl2ZT0hMCksMD09PXImJnRoaXMudmFycy5vblN0YXJ0JiYwIT09dGhpcy5fdG90YWxUaW1lJiYoYnx8dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpKSxuPXRoaXMuX3RpbWUsbj49cSlmb3IoZD10aGlzLl9maXJzdDtkJiYoaT1kLl9uZXh0LG49PT10aGlzLl90aW1lJiYoIXRoaXMuX3BhdXNlZHx8dikpOykoZC5fYWN0aXZlfHxkLl9zdGFydFRpbWU8PXRoaXMuX3RpbWUmJiFkLl9wYXVzZWQmJiFkLl9nYykmJihtPT09ZCYmdGhpcy5wYXVzZSgpLGQuX3JldmVyc2VkP2QucmVuZGVyKChkLl9kaXJ0eT9kLnRvdGFsRHVyYXRpb24oKTpkLl90b3RhbER1cmF0aW9uKS0oYS1kLl9zdGFydFRpbWUpKmQuX3RpbWVTY2FsZSxiLGMpOmQucmVuZGVyKChhLWQuX3N0YXJ0VGltZSkqZC5fdGltZVNjYWxlLGIsYykpLGQ9aTtlbHNlIGZvcihkPXRoaXMuX2xhc3Q7ZCYmKGk9ZC5fcHJldixuPT09dGhpcy5fdGltZSYmKCF0aGlzLl9wYXVzZWR8fHYpKTspe2lmKGQuX2FjdGl2ZXx8ZC5fc3RhcnRUaW1lPD1xJiYhZC5fcGF1c2VkJiYhZC5fZ2Mpe2lmKG09PT1kKXtmb3IobT1kLl9wcmV2O20mJm0uZW5kVGltZSgpPnRoaXMuX3RpbWU7KW0ucmVuZGVyKG0uX3JldmVyc2VkP20udG90YWxEdXJhdGlvbigpLShhLW0uX3N0YXJ0VGltZSkqbS5fdGltZVNjYWxlOihhLW0uX3N0YXJ0VGltZSkqbS5fdGltZVNjYWxlLGIsYyksbT1tLl9wcmV2O209bnVsbCx0aGlzLnBhdXNlKCl9ZC5fcmV2ZXJzZWQ/ZC5yZW5kZXIoKGQuX2RpcnR5P2QudG90YWxEdXJhdGlvbigpOmQuX3RvdGFsRHVyYXRpb24pLShhLWQuX3N0YXJ0VGltZSkqZC5fdGltZVNjYWxlLGIsYyk6ZC5yZW5kZXIoKGEtZC5fc3RhcnRUaW1lKSpkLl90aW1lU2NhbGUsYixjKX1kPWl9dGhpcy5fb25VcGRhdGUmJihifHwoZy5sZW5ndGgmJmgoKSx0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpKSksaiYmKHRoaXMuX2xvY2tlZHx8dGhpcy5fZ2N8fChzPT09dGhpcy5fc3RhcnRUaW1lfHx0IT09dGhpcy5fdGltZVNjYWxlKSYmKDA9PT10aGlzLl90aW1lfHxvPj10aGlzLnRvdGFsRHVyYXRpb24oKSkmJihmJiYoZy5sZW5ndGgmJmgoKSx0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWImJnRoaXMudmFyc1tqXSYmdGhpcy5fY2FsbGJhY2soaikpKX0sai5nZXRBY3RpdmU9ZnVuY3Rpb24oYSxiLGMpe251bGw9PWEmJihhPSEwKSxudWxsPT1iJiYoYj0hMCksbnVsbD09YyYmKGM9ITEpO3ZhciBkLGUsZj1bXSxnPXRoaXMuZ2V0Q2hpbGRyZW4oYSxiLGMpLGg9MCxpPWcubGVuZ3RoO2ZvcihkPTA7aT5kO2QrKyllPWdbZF0sZS5pc0FjdGl2ZSgpJiYoZltoKytdPWUpO3JldHVybiBmfSxqLmdldExhYmVsQWZ0ZXI9ZnVuY3Rpb24oYSl7YXx8MCE9PWEmJihhPXRoaXMuX3RpbWUpO3ZhciBiLGM9dGhpcy5nZXRMYWJlbHNBcnJheSgpLGQ9Yy5sZW5ndGg7Zm9yKGI9MDtkPmI7YisrKWlmKGNbYl0udGltZT5hKXJldHVybiBjW2JdLm5hbWU7cmV0dXJuIG51bGx9LGouZ2V0TGFiZWxCZWZvcmU9ZnVuY3Rpb24oYSl7bnVsbD09YSYmKGE9dGhpcy5fdGltZSk7Zm9yKHZhciBiPXRoaXMuZ2V0TGFiZWxzQXJyYXkoKSxjPWIubGVuZ3RoOy0tYz4tMTspaWYoYltjXS50aW1lPGEpcmV0dXJuIGJbY10ubmFtZTtyZXR1cm4gbnVsbH0sai5nZXRMYWJlbHNBcnJheT1mdW5jdGlvbigpe3ZhciBhLGI9W10sYz0wO2ZvcihhIGluIHRoaXMuX2xhYmVscyliW2MrK109e3RpbWU6dGhpcy5fbGFiZWxzW2FdLG5hbWU6YX07cmV0dXJuIGIuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLnRpbWUtYi50aW1lfSksYn0sai5wcm9ncmVzcz1mdW5jdGlvbihhLGIpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMudG90YWxUaW1lKHRoaXMuZHVyYXRpb24oKSoodGhpcy5feW95byYmMCE9PSgxJnRoaXMuX2N5Y2xlKT8xLWE6YSkrdGhpcy5fY3ljbGUqKHRoaXMuX2R1cmF0aW9uK3RoaXMuX3JlcGVhdERlbGF5KSxiKTp0aGlzLl90aW1lL3RoaXMuZHVyYXRpb24oKX0sai50b3RhbFByb2dyZXNzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy50b3RhbFRpbWUodGhpcy50b3RhbER1cmF0aW9uKCkqYSxiKTp0aGlzLl90b3RhbFRpbWUvdGhpcy50b3RhbER1cmF0aW9uKCl9LGoudG90YWxEdXJhdGlvbj1mdW5jdGlvbihiKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8tMSE9PXRoaXMuX3JlcGVhdCYmYj90aGlzLnRpbWVTY2FsZSh0aGlzLnRvdGFsRHVyYXRpb24oKS9iKTp0aGlzOih0aGlzLl9kaXJ0eSYmKGEucHJvdG90eXBlLnRvdGFsRHVyYXRpb24uY2FsbCh0aGlzKSx0aGlzLl90b3RhbER1cmF0aW9uPS0xPT09dGhpcy5fcmVwZWF0Pzk5OTk5OTk5OTk5OTp0aGlzLl9kdXJhdGlvbioodGhpcy5fcmVwZWF0KzEpK3RoaXMuX3JlcGVhdERlbGF5KnRoaXMuX3JlcGVhdCksdGhpcy5fdG90YWxEdXJhdGlvbil9LGoudGltZT1mdW5jdGlvbihhLGIpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9kaXJ0eSYmdGhpcy50b3RhbER1cmF0aW9uKCksYT50aGlzLl9kdXJhdGlvbiYmKGE9dGhpcy5fZHVyYXRpb24pLHRoaXMuX3lveW8mJjAhPT0oMSZ0aGlzLl9jeWNsZSk/YT10aGlzLl9kdXJhdGlvbi1hK3RoaXMuX2N5Y2xlKih0aGlzLl9kdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSk6MCE9PXRoaXMuX3JlcGVhdCYmKGErPXRoaXMuX2N5Y2xlKih0aGlzLl9kdXJhdGlvbit0aGlzLl9yZXBlYXREZWxheSkpLHRoaXMudG90YWxUaW1lKGEsYikpOnRoaXMuX3RpbWV9LGoucmVwZWF0PWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9yZXBlYXQ9YSx0aGlzLl91bmNhY2hlKCEwKSk6dGhpcy5fcmVwZWF0fSxqLnJlcGVhdERlbGF5PWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9yZXBlYXREZWxheT1hLHRoaXMuX3VuY2FjaGUoITApKTp0aGlzLl9yZXBlYXREZWxheX0sai55b3lvPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyh0aGlzLl95b3lvPWEsdGhpcyk6dGhpcy5feW95b30sai5jdXJyZW50TGFiZWw9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/dGhpcy5zZWVrKGEsITApOnRoaXMuZ2V0TGFiZWxCZWZvcmUodGhpcy5fdGltZSsxZS04KX0sZH0sITApLGZ1bmN0aW9uKCl7dmFyIGE9MTgwL01hdGguUEksYj1bXSxjPVtdLGQ9W10sZT17fSxmPV9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLGc9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5hPWEsdGhpcy5iPWIsdGhpcy5jPWMsdGhpcy5kPWQsdGhpcy5kYT1kLWEsdGhpcy5jYT1jLWEsdGhpcy5iYT1iLWF9LGg9XCIseCx5LHosbGVmdCx0b3AscmlnaHQsYm90dG9tLG1hcmdpblRvcCxtYXJnaW5MZWZ0LG1hcmdpblJpZ2h0LG1hcmdpbkJvdHRvbSxwYWRkaW5nTGVmdCxwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLGJhY2tncm91bmRQb3NpdGlvbixiYWNrZ3JvdW5kUG9zaXRpb25feSxcIixpPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXthOmF9LGY9e30sZz17fSxoPXtjOmR9LGk9KGErYikvMixqPShiK2MpLzIsaz0oYytkKS8yLGw9KGkraikvMixtPShqK2spLzIsbj0obS1sKS84O3JldHVybiBlLmI9aSsoYS1pKS80LGYuYj1sK24sZS5jPWYuYT0oZS5iK2YuYikvMixmLmM9Zy5hPShsK20pLzIsZy5iPW0tbixoLmI9aysoZC1rKS80LGcuYz1oLmE9KGcuYitoLmIpLzIsW2UsZixnLGhdfSxqPWZ1bmN0aW9uKGEsZSxmLGcsaCl7dmFyIGosayxsLG0sbixvLHAscSxyLHMsdCx1LHYsdz1hLmxlbmd0aC0xLHg9MCx5PWFbMF0uYTtmb3Ioaj0wO3c+ajtqKyspbj1hW3hdLGs9bi5hLGw9bi5kLG09YVt4KzFdLmQsaD8odD1iW2pdLHU9Y1tqXSx2PSh1K3QpKmUqLjI1LyhnPy41OmRbal18fC41KSxvPWwtKGwtaykqKGc/LjUqZTowIT09dD92L3Q6MCkscD1sKyhtLWwpKihnPy41KmU6MCE9PXU/di91OjApLHE9bC0obysoKHAtbykqKDMqdC8odCt1KSsuNSkvNHx8MCkpKToobz1sLShsLWspKmUqLjUscD1sKyhtLWwpKmUqLjUscT1sLShvK3ApLzIpLG8rPXEscCs9cSxuLmM9cj1vLDAhPT1qP24uYj15Om4uYj15PW4uYSsuNioobi5jLW4uYSksbi5kYT1sLWssbi5jYT1yLWssbi5iYT15LWssZj8ocz1pKGsseSxyLGwpLGEuc3BsaWNlKHgsMSxzWzBdLHNbMV0sc1syXSxzWzNdKSx4Kz00KTp4KysseT1wO249YVt4XSxuLmI9eSxuLmM9eSsuNCoobi5kLXkpLG4uZGE9bi5kLW4uYSxuLmNhPW4uYy1uLmEsbi5iYT15LW4uYSxmJiYocz1pKG4uYSx5LG4uYyxuLmQpLGEuc3BsaWNlKHgsMSxzWzBdLHNbMV0sc1syXSxzWzNdKSl9LGs9ZnVuY3Rpb24oYSxkLGUsZil7dmFyIGgsaSxqLGssbCxtLG49W107aWYoZilmb3IoYT1bZl0uY29uY2F0KGEpLGk9YS5sZW5ndGg7LS1pPi0xOylcInN0cmluZ1wiPT10eXBlb2YobT1hW2ldW2RdKSYmXCI9XCI9PT1tLmNoYXJBdCgxKSYmKGFbaV1bZF09ZltkXStOdW1iZXIobS5jaGFyQXQoMCkrbS5zdWJzdHIoMikpKTtpZihoPWEubGVuZ3RoLTIsMD5oKXJldHVybiBuWzBdPW5ldyBnKGFbMF1bZF0sMCwwLGFbLTE+aD8wOjFdW2RdKSxuO2ZvcihpPTA7aD5pO2krKylqPWFbaV1bZF0saz1hW2krMV1bZF0sbltpXT1uZXcgZyhqLDAsMCxrKSxlJiYobD1hW2krMl1bZF0sYltpXT0oYltpXXx8MCkrKGstaikqKGstaiksY1tpXT0oY1tpXXx8MCkrKGwtaykqKGwtaykpO3JldHVybiBuW2ldPW5ldyBnKGFbaV1bZF0sMCwwLGFbaSsxXVtkXSksbn0sbD1mdW5jdGlvbihhLGYsZyxpLGwsbSl7dmFyIG4sbyxwLHEscixzLHQsdSx2PXt9LHc9W10seD1tfHxhWzBdO2w9XCJzdHJpbmdcIj09dHlwZW9mIGw/XCIsXCIrbCtcIixcIjpoLG51bGw9PWYmJihmPTEpO2ZvcihvIGluIGFbMF0pdy5wdXNoKG8pO2lmKGEubGVuZ3RoPjEpe2Zvcih1PWFbYS5sZW5ndGgtMV0sdD0hMCxuPXcubGVuZ3RoOy0tbj4tMTspaWYobz13W25dLE1hdGguYWJzKHhbb10tdVtvXSk+LjA1KXt0PSExO2JyZWFrfXQmJihhPWEuY29uY2F0KCksbSYmYS51bnNoaWZ0KG0pLGEucHVzaChhWzFdKSxtPWFbYS5sZW5ndGgtM10pfWZvcihiLmxlbmd0aD1jLmxlbmd0aD1kLmxlbmd0aD0wLG49dy5sZW5ndGg7LS1uPi0xOylvPXdbbl0sZVtvXT0tMSE9PWwuaW5kZXhPZihcIixcIitvK1wiLFwiKSx2W29dPWsoYSxvLGVbb10sbSk7Zm9yKG49Yi5sZW5ndGg7LS1uPi0xOyliW25dPU1hdGguc3FydChiW25dKSxjW25dPU1hdGguc3FydChjW25dKTtpZighaSl7Zm9yKG49dy5sZW5ndGg7LS1uPi0xOylpZihlW29dKWZvcihwPXZbd1tuXV0scz1wLmxlbmd0aC0xLHE9MDtzPnE7cSsrKXI9cFtxKzFdLmRhL2NbcV0rcFtxXS5kYS9iW3FdLGRbcV09KGRbcV18fDApK3Iqcjtmb3Iobj1kLmxlbmd0aDstLW4+LTE7KWRbbl09TWF0aC5zcXJ0KGRbbl0pfWZvcihuPXcubGVuZ3RoLHE9Zz80OjE7LS1uPi0xOylvPXdbbl0scD12W29dLGoocCxmLGcsaSxlW29dKSx0JiYocC5zcGxpY2UoMCxxKSxwLnNwbGljZShwLmxlbmd0aC1xLHEpKTtyZXR1cm4gdn0sbT1mdW5jdGlvbihhLGIsYyl7Yj1ifHxcInNvZnRcIjt2YXIgZCxlLGYsaCxpLGosayxsLG0sbixvLHA9e30scT1cImN1YmljXCI9PT1iPzM6MixyPVwic29mdFwiPT09YixzPVtdO2lmKHImJmMmJihhPVtjXS5jb25jYXQoYSkpLG51bGw9PWF8fGEubGVuZ3RoPHErMSl0aHJvd1wiaW52YWxpZCBCZXppZXIgZGF0YVwiO2ZvcihtIGluIGFbMF0pcy5wdXNoKG0pO2ZvcihqPXMubGVuZ3RoOy0taj4tMTspe2ZvcihtPXNbal0scFttXT1pPVtdLG49MCxsPWEubGVuZ3RoLGs9MDtsPms7aysrKWQ9bnVsbD09Yz9hW2tdW21dOlwic3RyaW5nXCI9PXR5cGVvZihvPWFba11bbV0pJiZcIj1cIj09PW8uY2hhckF0KDEpP2NbbV0rTnVtYmVyKG8uY2hhckF0KDApK28uc3Vic3RyKDIpKTpOdW1iZXIobyksciYmaz4xJiZsLTE+ayYmKGlbbisrXT0oZCtpW24tMl0pLzIpLGlbbisrXT1kO2ZvcihsPW4tcSsxLG49MCxrPTA7bD5rO2srPXEpZD1pW2tdLGU9aVtrKzFdLGY9aVtrKzJdLGg9Mj09PXE/MDppW2srM10saVtuKytdPW89Mz09PXE/bmV3IGcoZCxlLGYsaCk6bmV3IGcoZCwoMiplK2QpLzMsKDIqZStmKS8zLGYpO2kubGVuZ3RoPW59cmV0dXJuIHB9LG49ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZCxlLGYsZyxoLGksaixrLGwsbSxuLG89MS9jLHA9YS5sZW5ndGg7LS1wPi0xOylmb3IobT1hW3BdLGY9bS5hLGc9bS5kLWYsaD1tLmMtZixpPW0uYi1mLGQ9ZT0wLGs9MTtjPj1rO2srKylqPW8qayxsPTEtaixkPWUtKGU9KGoqaipnKzMqbCooaipoK2wqaSkpKmopLG49cCpjK2stMSxiW25dPShiW25dfHwwKStkKmR9LG89ZnVuY3Rpb24oYSxiKXtiPWI+PjB8fDY7dmFyIGMsZCxlLGYsZz1bXSxoPVtdLGk9MCxqPTAsaz1iLTEsbD1bXSxtPVtdO2ZvcihjIGluIGEpbihhW2NdLGcsYik7Zm9yKGU9Zy5sZW5ndGgsZD0wO2U+ZDtkKyspaSs9TWF0aC5zcXJ0KGdbZF0pLGY9ZCViLG1bZl09aSxmPT09ayYmKGorPWksZj1kL2I+PjAsbFtmXT1tLGhbZl09aixpPTAsbT1bXSk7cmV0dXJue2xlbmd0aDpqLGxlbmd0aHM6aCxzZWdtZW50czpsfX0scD1fZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtwcm9wTmFtZTpcImJlemllclwiLHByaW9yaXR5Oi0xLHZlcnNpb246XCIxLjMuNFwiLEFQSToyLGdsb2JhbDohMCxpbml0OmZ1bmN0aW9uKGEsYixjKXt0aGlzLl90YXJnZXQ9YSxiIGluc3RhbmNlb2YgQXJyYXkmJihiPXt2YWx1ZXM6Yn0pLHRoaXMuX2Z1bmM9e30sdGhpcy5fcm91bmQ9e30sdGhpcy5fcHJvcHM9W10sdGhpcy5fdGltZVJlcz1udWxsPT1iLnRpbWVSZXNvbHV0aW9uPzY6cGFyc2VJbnQoYi50aW1lUmVzb2x1dGlvbiwxMCk7XHJcbnZhciBkLGUsZixnLGgsaT1iLnZhbHVlc3x8W10saj17fSxrPWlbMF0sbj1iLmF1dG9Sb3RhdGV8fGMudmFycy5vcmllbnRUb0Jlemllcjt0aGlzLl9hdXRvUm90YXRlPW4/biBpbnN0YW5jZW9mIEFycmF5P246W1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsbj09PSEwPzA6TnVtYmVyKG4pfHwwXV06bnVsbDtmb3IoZCBpbiBrKXRoaXMuX3Byb3BzLnB1c2goZCk7Zm9yKGY9dGhpcy5fcHJvcHMubGVuZ3RoOy0tZj4tMTspZD10aGlzLl9wcm9wc1tmXSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKGQpLGU9dGhpcy5fZnVuY1tkXT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhW2RdLGpbZF09ZT9hW2QuaW5kZXhPZihcInNldFwiKXx8XCJmdW5jdGlvblwiIT10eXBlb2YgYVtcImdldFwiK2Quc3Vic3RyKDMpXT9kOlwiZ2V0XCIrZC5zdWJzdHIoMyldKCk6cGFyc2VGbG9hdChhW2RdKSxofHxqW2RdIT09aVswXVtkXSYmKGg9aik7aWYodGhpcy5fYmV6aWVycz1cImN1YmljXCIhPT1iLnR5cGUmJlwicXVhZHJhdGljXCIhPT1iLnR5cGUmJlwic29mdFwiIT09Yi50eXBlP2woaSxpc05hTihiLmN1cnZpbmVzcyk/MTpiLmN1cnZpbmVzcywhMSxcInRocnVCYXNpY1wiPT09Yi50eXBlLGIuY29ycmVsYXRlLGgpOm0oaSxiLnR5cGUsaiksdGhpcy5fc2VnQ291bnQ9dGhpcy5fYmV6aWVyc1tkXS5sZW5ndGgsdGhpcy5fdGltZVJlcyl7dmFyIHA9byh0aGlzLl9iZXppZXJzLHRoaXMuX3RpbWVSZXMpO3RoaXMuX2xlbmd0aD1wLmxlbmd0aCx0aGlzLl9sZW5ndGhzPXAubGVuZ3Rocyx0aGlzLl9zZWdtZW50cz1wLnNlZ21lbnRzLHRoaXMuX2wxPXRoaXMuX2xpPXRoaXMuX3MxPXRoaXMuX3NpPTAsdGhpcy5fbDI9dGhpcy5fbGVuZ3Roc1swXSx0aGlzLl9jdXJTZWc9dGhpcy5fc2VnbWVudHNbMF0sdGhpcy5fczI9dGhpcy5fY3VyU2VnWzBdLHRoaXMuX3ByZWM9MS90aGlzLl9jdXJTZWcubGVuZ3RofWlmKG49dGhpcy5fYXV0b1JvdGF0ZSlmb3IodGhpcy5faW5pdGlhbFJvdGF0aW9ucz1bXSxuWzBdaW5zdGFuY2VvZiBBcnJheXx8KHRoaXMuX2F1dG9Sb3RhdGU9bj1bbl0pLGY9bi5sZW5ndGg7LS1mPi0xOyl7Zm9yKGc9MDszPmc7ZysrKWQ9bltmXVtnXSx0aGlzLl9mdW5jW2RdPVwiZnVuY3Rpb25cIj09dHlwZW9mIGFbZF0/YVtkLmluZGV4T2YoXCJzZXRcIil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGFbXCJnZXRcIitkLnN1YnN0cigzKV0/ZDpcImdldFwiK2Quc3Vic3RyKDMpXTohMTtkPW5bZl1bMl0sdGhpcy5faW5pdGlhbFJvdGF0aW9uc1tmXT10aGlzLl9mdW5jW2RdP3RoaXMuX2Z1bmNbZF0uY2FsbCh0aGlzLl90YXJnZXQpOnRoaXMuX3RhcmdldFtkXX1yZXR1cm4gdGhpcy5fc3RhcnRSYXRpbz1jLnZhcnMucnVuQmFja3dhcmRzPzE6MCwhMH0sc2V0OmZ1bmN0aW9uKGIpe3ZhciBjLGQsZSxmLGcsaCxpLGosayxsLG09dGhpcy5fc2VnQ291bnQsbj10aGlzLl9mdW5jLG89dGhpcy5fdGFyZ2V0LHA9YiE9PXRoaXMuX3N0YXJ0UmF0aW87aWYodGhpcy5fdGltZVJlcyl7aWYoaz10aGlzLl9sZW5ndGhzLGw9dGhpcy5fY3VyU2VnLGIqPXRoaXMuX2xlbmd0aCxlPXRoaXMuX2xpLGI+dGhpcy5fbDImJm0tMT5lKXtmb3Ioaj1tLTE7aj5lJiYodGhpcy5fbDI9a1srK2VdKTw9YjspO3RoaXMuX2wxPWtbZS0xXSx0aGlzLl9saT1lLHRoaXMuX2N1clNlZz1sPXRoaXMuX3NlZ21lbnRzW2VdLHRoaXMuX3MyPWxbdGhpcy5fczE9dGhpcy5fc2k9MF19ZWxzZSBpZihiPHRoaXMuX2wxJiZlPjApe2Zvcig7ZT4wJiYodGhpcy5fbDE9a1stLWVdKT49YjspOzA9PT1lJiZiPHRoaXMuX2wxP3RoaXMuX2wxPTA6ZSsrLHRoaXMuX2wyPWtbZV0sdGhpcy5fbGk9ZSx0aGlzLl9jdXJTZWc9bD10aGlzLl9zZWdtZW50c1tlXSx0aGlzLl9zMT1sWyh0aGlzLl9zaT1sLmxlbmd0aC0xKS0xXXx8MCx0aGlzLl9zMj1sW3RoaXMuX3NpXX1pZihjPWUsYi09dGhpcy5fbDEsZT10aGlzLl9zaSxiPnRoaXMuX3MyJiZlPGwubGVuZ3RoLTEpe2ZvcihqPWwubGVuZ3RoLTE7aj5lJiYodGhpcy5fczI9bFsrK2VdKTw9YjspO3RoaXMuX3MxPWxbZS0xXSx0aGlzLl9zaT1lfWVsc2UgaWYoYjx0aGlzLl9zMSYmZT4wKXtmb3IoO2U+MCYmKHRoaXMuX3MxPWxbLS1lXSk+PWI7KTswPT09ZSYmYjx0aGlzLl9zMT90aGlzLl9zMT0wOmUrKyx0aGlzLl9zMj1sW2VdLHRoaXMuX3NpPWV9aD0oZSsoYi10aGlzLl9zMSkvKHRoaXMuX3MyLXRoaXMuX3MxKSkqdGhpcy5fcHJlY31lbHNlIGM9MD5iPzA6Yj49MT9tLTE6bSpiPj4wLGg9KGItYyooMS9tKSkqbTtmb3IoZD0xLWgsZT10aGlzLl9wcm9wcy5sZW5ndGg7LS1lPi0xOylmPXRoaXMuX3Byb3BzW2VdLGc9dGhpcy5fYmV6aWVyc1tmXVtjXSxpPShoKmgqZy5kYSszKmQqKGgqZy5jYStkKmcuYmEpKSpoK2cuYSx0aGlzLl9yb3VuZFtmXSYmKGk9TWF0aC5yb3VuZChpKSksbltmXT9vW2ZdKGkpOm9bZl09aTtpZih0aGlzLl9hdXRvUm90YXRlKXt2YXIgcSxyLHMsdCx1LHYsdyx4PXRoaXMuX2F1dG9Sb3RhdGU7Zm9yKGU9eC5sZW5ndGg7LS1lPi0xOylmPXhbZV1bMl0sdj14W2VdWzNdfHwwLHc9eFtlXVs0XT09PSEwPzE6YSxnPXRoaXMuX2JlemllcnNbeFtlXVswXV0scT10aGlzLl9iZXppZXJzW3hbZV1bMV1dLGcmJnEmJihnPWdbY10scT1xW2NdLHI9Zy5hKyhnLmItZy5hKSpoLHQ9Zy5iKyhnLmMtZy5iKSpoLHIrPSh0LXIpKmgsdCs9KGcuYysoZy5kLWcuYykqaC10KSpoLHM9cS5hKyhxLmItcS5hKSpoLHU9cS5iKyhxLmMtcS5iKSpoLHMrPSh1LXMpKmgsdSs9KHEuYysocS5kLXEuYykqaC11KSpoLGk9cD9NYXRoLmF0YW4yKHUtcyx0LXIpKncrdjp0aGlzLl9pbml0aWFsUm90YXRpb25zW2VdLG5bZl0/b1tmXShpKTpvW2ZdPWkpfX19KSxxPXAucHJvdG90eXBlO3AuYmV6aWVyVGhyb3VnaD1sLHAuY3ViaWNUb1F1YWRyYXRpYz1pLHAuX2F1dG9DU1M9ITAscC5xdWFkcmF0aWNUb0N1YmljPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IGcoYSwoMipiK2EpLzMsKDIqYitjKS8zLGMpfSxwLl9jc3NSZWdpc3Rlcj1mdW5jdGlvbigpe3ZhciBhPWYuQ1NTUGx1Z2luO2lmKGEpe3ZhciBiPWEuX2ludGVybmFscyxjPWIuX3BhcnNlVG9Qcm94eSxkPWIuX3NldFBsdWdpblJhdGlvLGU9Yi5DU1NQcm9wVHdlZW47Yi5fcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiZXppZXJcIix7cGFyc2VyOmZ1bmN0aW9uKGEsYixmLGcsaCxpKXtiIGluc3RhbmNlb2YgQXJyYXkmJihiPXt2YWx1ZXM6Yn0pLGk9bmV3IHA7dmFyIGosayxsLG09Yi52YWx1ZXMsbj1tLmxlbmd0aC0xLG89W10scT17fTtpZigwPm4pcmV0dXJuIGg7Zm9yKGo9MDtuPj1qO2orKylsPWMoYSxtW2pdLGcsaCxpLG4hPT1qKSxvW2pdPWwuZW5kO2ZvcihrIGluIGIpcVtrXT1iW2tdO3JldHVybiBxLnZhbHVlcz1vLGg9bmV3IGUoYSxcImJlemllclwiLDAsMCxsLnB0LDIpLGguZGF0YT1sLGgucGx1Z2luPWksaC5zZXRSYXRpbz1kLDA9PT1xLmF1dG9Sb3RhdGUmJihxLmF1dG9Sb3RhdGU9ITApLCFxLmF1dG9Sb3RhdGV8fHEuYXV0b1JvdGF0ZSBpbnN0YW5jZW9mIEFycmF5fHwoaj1xLmF1dG9Sb3RhdGU9PT0hMD8wOk51bWJlcihxLmF1dG9Sb3RhdGUpLHEuYXV0b1JvdGF0ZT1udWxsIT1sLmVuZC5sZWZ0P1tbXCJsZWZ0XCIsXCJ0b3BcIixcInJvdGF0aW9uXCIsaiwhMV1dOm51bGwhPWwuZW5kLng/W1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsaiwhMV1dOiExKSxxLmF1dG9Sb3RhdGUmJihnLl90cmFuc2Zvcm18fGcuX2VuYWJsZVRyYW5zZm9ybXMoITEpLGwuYXV0b1JvdGF0ZT1nLl90YXJnZXQuX2dzVHJhbnNmb3JtKSxpLl9vbkluaXRUd2VlbihsLnByb3h5LHEsZy5fdHdlZW4pLGh9fSl9fSxxLl9yb3VuZFByb3BzPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuX292ZXJ3cml0ZVByb3BzLGQ9Yy5sZW5ndGg7LS1kPi0xOykoYVtjW2RdXXx8YS5iZXppZXJ8fGEuYmV6aWVyVGhyb3VnaCkmJih0aGlzLl9yb3VuZFtjW2RdXT1iKX0scS5fa2lsbD1mdW5jdGlvbihhKXt2YXIgYixjLGQ9dGhpcy5fcHJvcHM7Zm9yKGIgaW4gdGhpcy5fYmV6aWVycylpZihiIGluIGEpZm9yKGRlbGV0ZSB0aGlzLl9iZXppZXJzW2JdLGRlbGV0ZSB0aGlzLl9mdW5jW2JdLGM9ZC5sZW5ndGg7LS1jPi0xOylkW2NdPT09YiYmZC5zcGxpY2UoYywxKTtyZXR1cm4gdGhpcy5fc3VwZXIuX2tpbGwuY2FsbCh0aGlzLGEpfX0oKSxfZ3NTY29wZS5fZ3NEZWZpbmUoXCJwbHVnaW5zLkNTU1BsdWdpblwiLFtcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcIlR3ZWVuTGl0ZVwiXSxmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGc9ZnVuY3Rpb24oKXthLmNhbGwodGhpcyxcImNzc1wiKSx0aGlzLl9vdmVyd3JpdGVQcm9wcy5sZW5ndGg9MCx0aGlzLnNldFJhdGlvPWcucHJvdG90eXBlLnNldFJhdGlvfSxoPV9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLGk9e30saj1nLnByb3RvdHlwZT1uZXcgYShcImNzc1wiKTtqLmNvbnN0cnVjdG9yPWcsZy52ZXJzaW9uPVwiMS4xOC4yXCIsZy5BUEk9MixnLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZT0wLGcuZGVmYXVsdFNrZXdUeXBlPVwiY29tcGVuc2F0ZWRcIixnLmRlZmF1bHRTbW9vdGhPcmlnaW49ITAsaj1cInB4XCIsZy5zdWZmaXhNYXA9e3RvcDpqLHJpZ2h0OmosYm90dG9tOmosbGVmdDpqLHdpZHRoOmosaGVpZ2h0OmosZm9udFNpemU6aixwYWRkaW5nOmosbWFyZ2luOmoscGVyc3BlY3RpdmU6aixsaW5lSGVpZ2h0OlwiXCJ9O3ZhciBrLGwsbSxuLG8scCxxPS8oPzpcXGR8XFwtXFxkfFxcLlxcZHxcXC1cXC5cXGQpKy9nLHI9Lyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZHxcXCs9XFxkfFxcLT1cXGR8XFwrPS5cXGR8XFwtPVxcLlxcZCkrL2cscz0vKD86XFwrPXxcXC09fFxcLXxcXGIpW1xcZFxcLVxcLl0rW2EtekEtWjAtOV0qKD86JXxcXGIpL2dpLHQ9Lyg/IVsrLV0/XFxkKlxcLj9cXGQrfFsrLV18ZVsrLV1cXGQrKVteMC05XS9nLHU9Lyg/OlxcZHxcXC18XFwrfD18I3xcXC4pKi9nLHY9L29wYWNpdHkgKj0gKihbXildKikvaSx3PS9vcGFjaXR5OihbXjtdKikvaSx4PS9hbHBoYVxcKG9wYWNpdHkgKj0uKz9cXCkvaSx5PS9eKHJnYnxoc2wpLyx6PS8oW0EtWl0pL2csQT0vLShbYS16XSkvZ2ksQj0vKF4oPzp1cmxcXChcXFwifHVybFxcKCkpfCg/OihcXFwiXFwpKSR8XFwpJCkvZ2ksQz1mdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9LEQ9Lyg/OkxlZnR8UmlnaHR8V2lkdGgpL2ksRT0vKE0xMXxNMTJ8TTIxfE0yMik9W1xcZFxcLVxcLmVdKy9naSxGPS9wcm9naWRcXDpEWEltYWdlVHJhbnNmb3JtXFwuTWljcm9zb2Z0XFwuTWF0cml4XFwoLis/XFwpL2ksRz0vLCg/PVteXFwpXSooPzpcXCh8JCkpL2dpLEg9TWF0aC5QSS8xODAsST0xODAvTWF0aC5QSSxKPXt9LEs9ZG9jdW1lbnQsTD1mdW5jdGlvbihhKXtyZXR1cm4gSy5jcmVhdGVFbGVtZW50TlM/Sy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsYSk6Sy5jcmVhdGVFbGVtZW50KGEpfSxNPUwoXCJkaXZcIiksTj1MKFwiaW1nXCIpLE89Zy5faW50ZXJuYWxzPXtfc3BlY2lhbFByb3BzOml9LFA9bmF2aWdhdG9yLnVzZXJBZ2VudCxRPWZ1bmN0aW9uKCl7dmFyIGE9UC5pbmRleE9mKFwiQW5kcm9pZFwiKSxiPUwoXCJhXCIpO3JldHVybiBtPS0xIT09UC5pbmRleE9mKFwiU2FmYXJpXCIpJiYtMT09PVAuaW5kZXhPZihcIkNocm9tZVwiKSYmKC0xPT09YXx8TnVtYmVyKFAuc3Vic3RyKGErOCwxKSk+Myksbz1tJiZOdW1iZXIoUC5zdWJzdHIoUC5pbmRleE9mKFwiVmVyc2lvbi9cIikrOCwxKSk8NixuPS0xIT09UC5pbmRleE9mKFwiRmlyZWZveFwiKSwoL01TSUUgKFswLTldezEsfVtcXC4wLTldezAsfSkvLmV4ZWMoUCl8fC9UcmlkZW50XFwvLipydjooWzAtOV17MSx9W1xcLjAtOV17MCx9KS8uZXhlYyhQKSkmJihwPXBhcnNlRmxvYXQoUmVnRXhwLiQxKSksYj8oYi5zdHlsZS5jc3NUZXh0PVwidG9wOjFweDtvcGFjaXR5Oi41NTtcIiwvXjAuNTUvLnRlc3QoYi5zdHlsZS5vcGFjaXR5KSk6ITF9KCksUj1mdW5jdGlvbihhKXtyZXR1cm4gdi50ZXN0KFwic3RyaW5nXCI9PXR5cGVvZiBhP2E6KGEuY3VycmVudFN0eWxlP2EuY3VycmVudFN0eWxlLmZpbHRlcjphLnN0eWxlLmZpbHRlcil8fFwiXCIpP3BhcnNlRmxvYXQoUmVnRXhwLiQxKS8xMDA6MX0sUz1mdW5jdGlvbihhKXt3aW5kb3cuY29uc29sZSYmY29uc29sZS5sb2coYSl9LFQ9XCJcIixVPVwiXCIsVj1mdW5jdGlvbihhLGIpe2I9Ynx8TTt2YXIgYyxkLGU9Yi5zdHlsZTtpZih2b2lkIDAhPT1lW2FdKXJldHVybiBhO2ZvcihhPWEuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHIoMSksYz1bXCJPXCIsXCJNb3pcIixcIm1zXCIsXCJNc1wiLFwiV2Via2l0XCJdLGQ9NTstLWQ+LTEmJnZvaWQgMD09PWVbY1tkXSthXTspO3JldHVybiBkPj0wPyhVPTM9PT1kP1wibXNcIjpjW2RdLFQ9XCItXCIrVS50b0xvd2VyQ2FzZSgpK1wiLVwiLFUrYSk6bnVsbH0sVz1LLmRlZmF1bHRWaWV3P0suZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZTpmdW5jdGlvbigpe30sWD1nLmdldFN0eWxlPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY7cmV0dXJuIFF8fFwib3BhY2l0eVwiIT09Yj8oIWQmJmEuc3R5bGVbYl0/Zj1hLnN0eWxlW2JdOihjPWN8fFcoYSkpP2Y9Y1tiXXx8Yy5nZXRQcm9wZXJ0eVZhbHVlKGIpfHxjLmdldFByb3BlcnR5VmFsdWUoYi5yZXBsYWNlKHosXCItJDFcIikudG9Mb3dlckNhc2UoKSk6YS5jdXJyZW50U3R5bGUmJihmPWEuY3VycmVudFN0eWxlW2JdKSxudWxsPT1lfHxmJiZcIm5vbmVcIiE9PWYmJlwiYXV0b1wiIT09ZiYmXCJhdXRvIGF1dG9cIiE9PWY/ZjplKTpSKGEpfSxZPU8uY29udmVydFRvUGl4ZWxzPWZ1bmN0aW9uKGEsYyxkLGUsZil7aWYoXCJweFwiPT09ZXx8IWUpcmV0dXJuIGQ7aWYoXCJhdXRvXCI9PT1lfHwhZClyZXR1cm4gMDt2YXIgaCxpLGosaz1ELnRlc3QoYyksbD1hLG09TS5zdHlsZSxuPTA+ZDtpZihuJiYoZD0tZCksXCIlXCI9PT1lJiYtMSE9PWMuaW5kZXhPZihcImJvcmRlclwiKSloPWQvMTAwKihrP2EuY2xpZW50V2lkdGg6YS5jbGllbnRIZWlnaHQpO2Vsc2V7aWYobS5jc3NUZXh0PVwiYm9yZGVyOjAgc29saWQgcmVkO3Bvc2l0aW9uOlwiK1goYSxcInBvc2l0aW9uXCIpK1wiO2xpbmUtaGVpZ2h0OjA7XCIsXCIlXCIhPT1lJiZsLmFwcGVuZENoaWxkJiZcInZcIiE9PWUuY2hhckF0KDApJiZcInJlbVwiIT09ZSltW2s/XCJib3JkZXJMZWZ0V2lkdGhcIjpcImJvcmRlclRvcFdpZHRoXCJdPWQrZTtlbHNle2lmKGw9YS5wYXJlbnROb2RlfHxLLmJvZHksaT1sLl9nc0NhY2hlLGo9Yi50aWNrZXIuZnJhbWUsaSYmayYmaS50aW1lPT09ailyZXR1cm4gaS53aWR0aCpkLzEwMDttW2s/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJdPWQrZX1sLmFwcGVuZENoaWxkKE0pLGg9cGFyc2VGbG9hdChNW2s/XCJvZmZzZXRXaWR0aFwiOlwib2Zmc2V0SGVpZ2h0XCJdKSxsLnJlbW92ZUNoaWxkKE0pLGsmJlwiJVwiPT09ZSYmZy5jYWNoZVdpZHRocyE9PSExJiYoaT1sLl9nc0NhY2hlPWwuX2dzQ2FjaGV8fHt9LGkudGltZT1qLGkud2lkdGg9aC9kKjEwMCksMCE9PWh8fGZ8fChoPVkoYSxjLGQsZSwhMCkpfXJldHVybiBuPy1oOmh9LFo9Ty5jYWxjdWxhdGVPZmZzZXQ9ZnVuY3Rpb24oYSxiLGMpe2lmKFwiYWJzb2x1dGVcIiE9PVgoYSxcInBvc2l0aW9uXCIsYykpcmV0dXJuIDA7dmFyIGQ9XCJsZWZ0XCI9PT1iP1wiTGVmdFwiOlwiVG9wXCIsZT1YKGEsXCJtYXJnaW5cIitkLGMpO3JldHVybiBhW1wib2Zmc2V0XCIrZF0tKFkoYSxiLHBhcnNlRmxvYXQoZSksZS5yZXBsYWNlKHUsXCJcIikpfHwwKX0sJD1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPXt9O2lmKGI9Ynx8VyhhLG51bGwpKWlmKGM9Yi5sZW5ndGgpZm9yKDstLWM+LTE7KWU9YltjXSwoLTE9PT1lLmluZGV4T2YoXCItdHJhbnNmb3JtXCIpfHx6YT09PWUpJiYoZltlLnJlcGxhY2UoQSxDKV09Yi5nZXRQcm9wZXJ0eVZhbHVlKGUpKTtlbHNlIGZvcihjIGluIGIpKC0xPT09Yy5pbmRleE9mKFwiVHJhbnNmb3JtXCIpfHx5YT09PWMpJiYoZltjXT1iW2NdKTtlbHNlIGlmKGI9YS5jdXJyZW50U3R5bGV8fGEuc3R5bGUpZm9yKGMgaW4gYilcInN0cmluZ1wiPT10eXBlb2YgYyYmdm9pZCAwPT09ZltjXSYmKGZbYy5yZXBsYWNlKEEsQyldPWJbY10pO3JldHVybiBRfHwoZi5vcGFjaXR5PVIoYSkpLGQ9TGEoYSxiLCExKSxmLnJvdGF0aW9uPWQucm90YXRpb24sZi5za2V3WD1kLnNrZXdYLGYuc2NhbGVYPWQuc2NhbGVYLGYuc2NhbGVZPWQuc2NhbGVZLGYueD1kLngsZi55PWQueSxCYSYmKGYuej1kLnosZi5yb3RhdGlvblg9ZC5yb3RhdGlvblgsZi5yb3RhdGlvblk9ZC5yb3RhdGlvblksZi5zY2FsZVo9ZC5zY2FsZVopLGYuZmlsdGVycyYmZGVsZXRlIGYuZmlsdGVycyxmfSxfPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGYsZyxoLGk9e30saj1hLnN0eWxlO2ZvcihnIGluIGMpXCJjc3NUZXh0XCIhPT1nJiZcImxlbmd0aFwiIT09ZyYmaXNOYU4oZykmJihiW2ddIT09KGY9Y1tnXSl8fGUmJmVbZ10pJiYtMT09PWcuaW5kZXhPZihcIk9yaWdpblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBmfHxcInN0cmluZ1wiPT10eXBlb2YgZikmJihpW2ddPVwiYXV0b1wiIT09Znx8XCJsZWZ0XCIhPT1nJiZcInRvcFwiIT09Zz9cIlwiIT09ZiYmXCJhdXRvXCIhPT1mJiZcIm5vbmVcIiE9PWZ8fFwic3RyaW5nXCIhPXR5cGVvZiBiW2ddfHxcIlwiPT09YltnXS5yZXBsYWNlKHQsXCJcIik/ZjowOlooYSxnKSx2b2lkIDAhPT1qW2ddJiYoaD1uZXcgb2EoaixnLGpbZ10saCkpKTtpZihkKWZvcihnIGluIGQpXCJjbGFzc05hbWVcIiE9PWcmJihpW2ddPWRbZ10pO3JldHVybntkaWZzOmksZmlyc3RNUFQ6aH19LGFhPXt3aWR0aDpbXCJMZWZ0XCIsXCJSaWdodFwiXSxoZWlnaHQ6W1wiVG9wXCIsXCJCb3R0b21cIl19LGJhPVtcIm1hcmdpbkxlZnRcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Ub3BcIixcIm1hcmdpbkJvdHRvbVwiXSxjYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9cGFyc2VGbG9hdChcIndpZHRoXCI9PT1iP2Eub2Zmc2V0V2lkdGg6YS5vZmZzZXRIZWlnaHQpLGU9YWFbYl0sZj1lLmxlbmd0aDtmb3IoYz1jfHxXKGEsbnVsbCk7LS1mPi0xOylkLT1wYXJzZUZsb2F0KFgoYSxcInBhZGRpbmdcIitlW2ZdLGMsITApKXx8MCxkLT1wYXJzZUZsb2F0KFgoYSxcImJvcmRlclwiK2VbZl0rXCJXaWR0aFwiLGMsITApKXx8MDtyZXR1cm4gZH0sZGE9ZnVuY3Rpb24oYSxiKXtpZihcImNvbnRhaW5cIj09PWF8fFwiYXV0b1wiPT09YXx8XCJhdXRvIGF1dG9cIj09PWEpcmV0dXJuIGErXCIgXCI7KG51bGw9PWF8fFwiXCI9PT1hKSYmKGE9XCIwIDBcIik7dmFyIGM9YS5zcGxpdChcIiBcIiksZD0tMSE9PWEuaW5kZXhPZihcImxlZnRcIik/XCIwJVwiOi0xIT09YS5pbmRleE9mKFwicmlnaHRcIik/XCIxMDAlXCI6Y1swXSxlPS0xIT09YS5pbmRleE9mKFwidG9wXCIpP1wiMCVcIjotMSE9PWEuaW5kZXhPZihcImJvdHRvbVwiKT9cIjEwMCVcIjpjWzFdO3JldHVybiBudWxsPT1lP2U9XCJjZW50ZXJcIj09PWQ/XCI1MCVcIjpcIjBcIjpcImNlbnRlclwiPT09ZSYmKGU9XCI1MCVcIiksKFwiY2VudGVyXCI9PT1kfHxpc05hTihwYXJzZUZsb2F0KGQpKSYmLTE9PT0oZCtcIlwiKS5pbmRleE9mKFwiPVwiKSkmJihkPVwiNTAlXCIpLGE9ZCtcIiBcIitlKyhjLmxlbmd0aD4yP1wiIFwiK2NbMl06XCJcIiksYiYmKGIub3hwPS0xIT09ZC5pbmRleE9mKFwiJVwiKSxiLm95cD0tMSE9PWUuaW5kZXhPZihcIiVcIiksYi5veHI9XCI9XCI9PT1kLmNoYXJBdCgxKSxiLm95cj1cIj1cIj09PWUuY2hhckF0KDEpLGIub3g9cGFyc2VGbG9hdChkLnJlcGxhY2UodCxcIlwiKSksYi5veT1wYXJzZUZsb2F0KGUucmVwbGFjZSh0LFwiXCIpKSxiLnY9YSksYnx8YX0sZWE9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYSYmXCI9XCI9PT1hLmNoYXJBdCgxKT9wYXJzZUludChhLmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChhLnN1YnN0cigyKSk6cGFyc2VGbG9hdChhKS1wYXJzZUZsb2F0KGIpfSxmYT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsPT1hP2I6XCJzdHJpbmdcIj09dHlwZW9mIGEmJlwiPVwiPT09YS5jaGFyQXQoMSk/cGFyc2VJbnQoYS5jaGFyQXQoMCkrXCIxXCIsMTApKnBhcnNlRmxvYXQoYS5zdWJzdHIoMikpK2I6cGFyc2VGbG9hdChhKX0sZ2E9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnLGgsaSxqPTFlLTY7cmV0dXJuIG51bGw9PWE/aD1iOlwibnVtYmVyXCI9PXR5cGVvZiBhP2g9YTooZT0zNjAsZj1hLnNwbGl0KFwiX1wiKSxpPVwiPVwiPT09YS5jaGFyQXQoMSksZz0oaT9wYXJzZUludChhLmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChmWzBdLnN1YnN0cigyKSk6cGFyc2VGbG9hdChmWzBdKSkqKC0xPT09YS5pbmRleE9mKFwicmFkXCIpPzE6SSktKGk/MDpiKSxmLmxlbmd0aCYmKGQmJihkW2NdPWIrZyksLTEhPT1hLmluZGV4T2YoXCJzaG9ydFwiKSYmKGclPWUsZyE9PWclKGUvMikmJihnPTA+Zz9nK2U6Zy1lKSksLTEhPT1hLmluZGV4T2YoXCJfY3dcIikmJjA+Zz9nPShnKzk5OTk5OTk5OTkqZSklZS0oZy9lfDApKmU6LTEhPT1hLmluZGV4T2YoXCJjY3dcIikmJmc+MCYmKGc9KGctOTk5OTk5OTk5OSplKSVlLShnL2V8MCkqZSkpLGg9YitnKSxqPmgmJmg+LWomJihoPTApLGh9LGhhPXthcXVhOlswLDI1NSwyNTVdLGxpbWU6WzAsMjU1LDBdLHNpbHZlcjpbMTkyLDE5MiwxOTJdLGJsYWNrOlswLDAsMF0sbWFyb29uOlsxMjgsMCwwXSx0ZWFsOlswLDEyOCwxMjhdLGJsdWU6WzAsMCwyNTVdLG5hdnk6WzAsMCwxMjhdLHdoaXRlOlsyNTUsMjU1LDI1NV0sZnVjaHNpYTpbMjU1LDAsMjU1XSxvbGl2ZTpbMTI4LDEyOCwwXSx5ZWxsb3c6WzI1NSwyNTUsMF0sb3JhbmdlOlsyNTUsMTY1LDBdLGdyYXk6WzEyOCwxMjgsMTI4XSxwdXJwbGU6WzEyOCwwLDEyOF0sZ3JlZW46WzAsMTI4LDBdLHJlZDpbMjU1LDAsMF0scGluazpbMjU1LDE5MiwyMDNdLGN5YW46WzAsMjU1LDI1NV0sdHJhbnNwYXJlbnQ6WzI1NSwyNTUsMjU1LDBdfSxpYT1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGE9MD5hP2ErMTphPjE/YS0xOmEsMjU1KigxPjYqYT9iKyhjLWIpKmEqNjouNT5hP2M6Mj4zKmE/YisoYy1iKSooMi8zLWEpKjY6YikrLjV8MH0samE9Zy5wYXJzZUNvbG9yPWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZyxoLGksaixrLGwsbTtpZihhKWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhKWM9W2E+PjE2LGE+PjgmMjU1LDI1NSZhXTtlbHNle2lmKFwiLFwiPT09YS5jaGFyQXQoYS5sZW5ndGgtMSkmJihhPWEuc3Vic3RyKDAsYS5sZW5ndGgtMSkpLGhhW2FdKWM9aGFbYV07ZWxzZSBpZihcIiNcIj09PWEuY2hhckF0KDApKTQ9PT1hLmxlbmd0aCYmKGQ9YS5jaGFyQXQoMSksZT1hLmNoYXJBdCgyKSxmPWEuY2hhckF0KDMpLGE9XCIjXCIrZCtkK2UrZStmK2YpLGE9cGFyc2VJbnQoYS5zdWJzdHIoMSksMTYpLGM9W2E+PjE2LGE+PjgmMjU1LDI1NSZhXTtlbHNlIGlmKFwiaHNsXCI9PT1hLnN1YnN0cigwLDMpKWlmKGM9bT1hLm1hdGNoKHEpLGIpe2lmKC0xIT09YS5pbmRleE9mKFwiPVwiKSlyZXR1cm4gYS5tYXRjaChyKX1lbHNlIGc9TnVtYmVyKGNbMF0pJTM2MC8zNjAsaD1OdW1iZXIoY1sxXSkvMTAwLGk9TnVtYmVyKGNbMl0pLzEwMCxlPS41Pj1pP2kqKGgrMSk6aStoLWkqaCxkPTIqaS1lLGMubGVuZ3RoPjMmJihjWzNdPU51bWJlcihhWzNdKSksY1swXT1pYShnKzEvMyxkLGUpLGNbMV09aWEoZyxkLGUpLGNbMl09aWEoZy0xLzMsZCxlKTtlbHNlIGM9YS5tYXRjaChxKXx8aGEudHJhbnNwYXJlbnQ7Y1swXT1OdW1iZXIoY1swXSksY1sxXT1OdW1iZXIoY1sxXSksY1syXT1OdW1iZXIoY1syXSksYy5sZW5ndGg+MyYmKGNbM109TnVtYmVyKGNbM10pKX1lbHNlIGM9aGEuYmxhY2s7cmV0dXJuIGImJiFtJiYoZD1jWzBdLzI1NSxlPWNbMV0vMjU1LGY9Y1syXS8yNTUsaj1NYXRoLm1heChkLGUsZiksaz1NYXRoLm1pbihkLGUsZiksaT0oaitrKS8yLGo9PT1rP2c9aD0wOihsPWotayxoPWk+LjU/bC8oMi1qLWspOmwvKGorayksZz1qPT09ZD8oZS1mKS9sKyhmPmU/NjowKTpqPT09ZT8oZi1kKS9sKzI6KGQtZSkvbCs0LGcqPTYwKSxjWzBdPWcrLjV8MCxjWzFdPTEwMCpoKy41fDAsY1syXT0xMDAqaSsuNXwwKSxjfSxrYT1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPWEubWF0Y2gobGEpfHxbXSxnPTAsaD1mLmxlbmd0aD9cIlwiOmE7Zm9yKGM9MDtjPGYubGVuZ3RoO2MrKylkPWZbY10sZT1hLnN1YnN0cihnLGEuaW5kZXhPZihkLGcpLWcpLGcrPWUubGVuZ3RoK2QubGVuZ3RoLGQ9amEoZCxiKSwzPT09ZC5sZW5ndGgmJmQucHVzaCgxKSxoKz1lKyhiP1wiaHNsYShcIitkWzBdK1wiLFwiK2RbMV0rXCIlLFwiK2RbMl0rXCIlLFwiK2RbM106XCJyZ2JhKFwiK2Quam9pbihcIixcIikpK1wiKVwiO3JldHVybiBofSxsYT1cIig/OlxcXFxiKD86KD86cmdifHJnYmF8aHNsfGhzbGEpXFxcXCguKz9cXFxcKSl8XFxcXEIjKD86WzAtOWEtZl17M30pezEsMn1cXFxcYlwiO2ZvcihqIGluIGhhKWxhKz1cInxcIitqK1wiXFxcXGJcIjtsYT1uZXcgUmVnRXhwKGxhK1wiKVwiLFwiZ2lcIiksZy5jb2xvclN0cmluZ0ZpbHRlcj1mdW5jdGlvbihhKXt2YXIgYixjPWFbMF0rYVsxXTtsYS5sYXN0SW5kZXg9MCxsYS50ZXN0KGMpJiYoYj0tMSE9PWMuaW5kZXhPZihcImhzbChcIil8fC0xIT09Yy5pbmRleE9mKFwiaHNsYShcIiksYVswXT1rYShhWzBdLGIpLGFbMV09a2EoYVsxXSxiKSl9LGIuZGVmYXVsdFN0cmluZ0ZpbHRlcnx8KGIuZGVmYXVsdFN0cmluZ0ZpbHRlcj1nLmNvbG9yU3RyaW5nRmlsdGVyKTt2YXIgbWE9ZnVuY3Rpb24oYSxiLGMsZCl7aWYobnVsbD09YSlyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIGF9O3ZhciBlLGY9Yj8oYS5tYXRjaChsYSl8fFtcIlwiXSlbMF06XCJcIixnPWEuc3BsaXQoZikuam9pbihcIlwiKS5tYXRjaChzKXx8W10saD1hLnN1YnN0cigwLGEuaW5kZXhPZihnWzBdKSksaT1cIilcIj09PWEuY2hhckF0KGEubGVuZ3RoLTEpP1wiKVwiOlwiXCIsaj0tMSE9PWEuaW5kZXhPZihcIiBcIik/XCIgXCI6XCIsXCIsaz1nLmxlbmd0aCxsPWs+MD9nWzBdLnJlcGxhY2UocSxcIlwiKTpcIlwiO3JldHVybiBrP2U9Yj9mdW5jdGlvbihhKXt2YXIgYixtLG4sbztpZihcIm51bWJlclwiPT10eXBlb2YgYSlhKz1sO2Vsc2UgaWYoZCYmRy50ZXN0KGEpKXtmb3Iobz1hLnJlcGxhY2UoRyxcInxcIikuc3BsaXQoXCJ8XCIpLG49MDtuPG8ubGVuZ3RoO24rKylvW25dPWUob1tuXSk7cmV0dXJuIG8uam9pbihcIixcIil9aWYoYj0oYS5tYXRjaChsYSl8fFtmXSlbMF0sbT1hLnNwbGl0KGIpLmpvaW4oXCJcIikubWF0Y2gocyl8fFtdLG49bS5sZW5ndGgsaz5uLS0pZm9yKDsrK248azspbVtuXT1jP21bKG4tMSkvMnwwXTpnW25dO3JldHVybiBoK20uam9pbihqKStqK2IraSsoLTEhPT1hLmluZGV4T2YoXCJpbnNldFwiKT9cIiBpbnNldFwiOlwiXCIpfTpmdW5jdGlvbihhKXt2YXIgYixmLG07aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpYSs9bDtlbHNlIGlmKGQmJkcudGVzdChhKSl7Zm9yKGY9YS5yZXBsYWNlKEcsXCJ8XCIpLnNwbGl0KFwifFwiKSxtPTA7bTxmLmxlbmd0aDttKyspZlttXT1lKGZbbV0pO3JldHVybiBmLmpvaW4oXCIsXCIpfWlmKGI9YS5tYXRjaChzKXx8W10sbT1iLmxlbmd0aCxrPm0tLSlmb3IoOysrbTxrOyliW21dPWM/YlsobS0xKS8yfDBdOmdbbV07cmV0dXJuIGgrYi5qb2luKGopK2l9OmZ1bmN0aW9uKGEpe3JldHVybiBhfX0sbmE9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9YS5zcGxpdChcIixcIiksZnVuY3Rpb24oYixjLGQsZSxmLGcsaCl7dmFyIGksaj0oYytcIlwiKS5zcGxpdChcIiBcIik7Zm9yKGg9e30saT0wOzQ+aTtpKyspaFthW2ldXT1qW2ldPWpbaV18fGpbKGktMSkvMj4+MF07cmV0dXJuIGUucGFyc2UoYixoLGYsZyl9fSxvYT0oTy5fc2V0UGx1Z2luUmF0aW89ZnVuY3Rpb24oYSl7dGhpcy5wbHVnaW4uc2V0UmF0aW8oYSk7Zm9yKHZhciBiLGMsZCxlLGYsZz10aGlzLmRhdGEsaD1nLnByb3h5LGk9Zy5maXJzdE1QVCxqPTFlLTY7aTspYj1oW2kudl0saS5yP2I9TWF0aC5yb3VuZChiKTpqPmImJmI+LWomJihiPTApLGkudFtpLnBdPWIsaT1pLl9uZXh0O2lmKGcuYXV0b1JvdGF0ZSYmKGcuYXV0b1JvdGF0ZS5yb3RhdGlvbj1oLnJvdGF0aW9uKSwxPT09YXx8MD09PWEpZm9yKGk9Zy5maXJzdE1QVCxmPTE9PT1hP1wiZVwiOlwiYlwiO2k7KXtpZihjPWkudCxjLnR5cGUpe2lmKDE9PT1jLnR5cGUpe2ZvcihlPWMueHMwK2MucytjLnhzMSxkPTE7ZDxjLmw7ZCsrKWUrPWNbXCJ4blwiK2RdK2NbXCJ4c1wiKyhkKzEpXTtjW2ZdPWV9fWVsc2UgY1tmXT1jLnMrYy54czA7aT1pLl9uZXh0fX0sZnVuY3Rpb24oYSxiLGMsZCxlKXt0aGlzLnQ9YSx0aGlzLnA9Yix0aGlzLnY9Yyx0aGlzLnI9ZSxkJiYoZC5fcHJldj10aGlzLHRoaXMuX25leHQ9ZCl9KSxwYT0oTy5fcGFyc2VUb1Byb3h5PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgZyxoLGksaixrLGw9ZCxtPXt9LG49e30sbz1jLl90cmFuc2Zvcm0scD1KO2ZvcihjLl90cmFuc2Zvcm09bnVsbCxKPWIsZD1rPWMucGFyc2UoYSxiLGQsZSksSj1wLGYmJihjLl90cmFuc2Zvcm09byxsJiYobC5fcHJldj1udWxsLGwuX3ByZXYmJihsLl9wcmV2Ll9uZXh0PW51bGwpKSk7ZCYmZCE9PWw7KXtpZihkLnR5cGU8PTEmJihoPWQucCxuW2hdPWQucytkLmMsbVtoXT1kLnMsZnx8KGo9bmV3IG9hKGQsXCJzXCIsaCxqLGQuciksZC5jPTApLDE9PT1kLnR5cGUpKWZvcihnPWQubDstLWc+MDspaT1cInhuXCIrZyxoPWQucCtcIl9cIitpLG5baF09ZC5kYXRhW2ldLG1baF09ZFtpXSxmfHwoaj1uZXcgb2EoZCxpLGgsaixkLnJ4cFtpXSkpO2Q9ZC5fbmV4dH1yZXR1cm57cHJveHk6bSxlbmQ6bixmaXJzdE1QVDpqLHB0Omt9fSxPLkNTU1Byb3BUd2Vlbj1mdW5jdGlvbihhLGIsZCxlLGcsaCxpLGosayxsLG0pe3RoaXMudD1hLHRoaXMucD1iLHRoaXMucz1kLHRoaXMuYz1lLHRoaXMubj1pfHxiLGEgaW5zdGFuY2VvZiBwYXx8Zi5wdXNoKHRoaXMubiksdGhpcy5yPWosdGhpcy50eXBlPWh8fDAsayYmKHRoaXMucHI9ayxjPSEwKSx0aGlzLmI9dm9pZCAwPT09bD9kOmwsdGhpcy5lPXZvaWQgMD09PW0/ZCtlOm0sZyYmKHRoaXMuX25leHQ9ZyxnLl9wcmV2PXRoaXMpfSkscWE9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPW5ldyBwYShhLGIsYyxkLWMsZSwtMSxmKTtyZXR1cm4gZy5iPWMsZy5lPWcueHMwPWQsZ30scmE9Zy5wYXJzZUNvbXBsZXg9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGksail7Yz1jfHxmfHxcIlwiLGc9bmV3IHBhKGEsYiwwLDAsZyxqPzI6MSxudWxsLCExLGgsYyxkKSxkKz1cIlwiO3ZhciBsLG0sbixvLHAscyx0LHUsdix3LHgseSx6LEE9Yy5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiIFwiKSxCPWQuc3BsaXQoXCIsIFwiKS5qb2luKFwiLFwiKS5zcGxpdChcIiBcIiksQz1BLmxlbmd0aCxEPWshPT0hMTtmb3IoKC0xIT09ZC5pbmRleE9mKFwiLFwiKXx8LTEhPT1jLmluZGV4T2YoXCIsXCIpKSYmKEE9QS5qb2luKFwiIFwiKS5yZXBsYWNlKEcsXCIsIFwiKS5zcGxpdChcIiBcIiksQj1CLmpvaW4oXCIgXCIpLnJlcGxhY2UoRyxcIiwgXCIpLnNwbGl0KFwiIFwiKSxDPUEubGVuZ3RoKSxDIT09Qi5sZW5ndGgmJihBPShmfHxcIlwiKS5zcGxpdChcIiBcIiksQz1BLmxlbmd0aCksZy5wbHVnaW49aSxnLnNldFJhdGlvPWosbGEubGFzdEluZGV4PTAsbD0wO0M+bDtsKyspaWYobz1BW2xdLHA9QltsXSx1PXBhcnNlRmxvYXQobyksdXx8MD09PXUpZy5hcHBlbmRYdHJhKFwiXCIsdSxlYShwLHUpLHAucmVwbGFjZShyLFwiXCIpLEQmJi0xIT09cC5pbmRleE9mKFwicHhcIiksITApO2Vsc2UgaWYoZSYmbGEudGVzdChvKSl5PVwiLFwiPT09cC5jaGFyQXQocC5sZW5ndGgtMSk/XCIpLFwiOlwiKVwiLHo9LTEhPT1wLmluZGV4T2YoXCJoc2xcIikmJlEsbz1qYShvLHopLHA9amEocCx6KSx2PW8ubGVuZ3RoK3AubGVuZ3RoPjYsdiYmIVEmJjA9PT1wWzNdPyhnW1wieHNcIitnLmxdKz1nLmw/XCIgdHJhbnNwYXJlbnRcIjpcInRyYW5zcGFyZW50XCIsZy5lPWcuZS5zcGxpdChCW2xdKS5qb2luKFwidHJhbnNwYXJlbnRcIikpOihRfHwodj0hMSksej9nLmFwcGVuZFh0cmEodj9cImhzbGEoXCI6XCJoc2woXCIsb1swXSxlYShwWzBdLG9bMF0pLFwiLFwiLCExLCEwKS5hcHBlbmRYdHJhKFwiXCIsb1sxXSxlYShwWzFdLG9bMV0pLFwiJSxcIiwhMSkuYXBwZW5kWHRyYShcIlwiLG9bMl0sZWEocFsyXSxvWzJdKSx2P1wiJSxcIjpcIiVcIit5LCExKTpnLmFwcGVuZFh0cmEodj9cInJnYmEoXCI6XCJyZ2IoXCIsb1swXSxwWzBdLW9bMF0sXCIsXCIsITAsITApLmFwcGVuZFh0cmEoXCJcIixvWzFdLHBbMV0tb1sxXSxcIixcIiwhMCkuYXBwZW5kWHRyYShcIlwiLG9bMl0scFsyXS1vWzJdLHY/XCIsXCI6eSwhMCksdiYmKG89by5sZW5ndGg8ND8xOm9bM10sZy5hcHBlbmRYdHJhKFwiXCIsbywocC5sZW5ndGg8ND8xOnBbM10pLW8seSwhMSkpKSxsYS5sYXN0SW5kZXg9MDtlbHNlIGlmKHM9by5tYXRjaChxKSl7aWYodD1wLm1hdGNoKHIpLCF0fHx0Lmxlbmd0aCE9PXMubGVuZ3RoKXJldHVybiBnO2ZvcihuPTAsbT0wO208cy5sZW5ndGg7bSsrKXg9c1ttXSx3PW8uaW5kZXhPZih4LG4pLGcuYXBwZW5kWHRyYShvLnN1YnN0cihuLHctbiksTnVtYmVyKHgpLGVhKHRbbV0seCksXCJcIixEJiZcInB4XCI9PT1vLnN1YnN0cih3K3gubGVuZ3RoLDIpLDA9PT1tKSxuPXcreC5sZW5ndGg7Z1tcInhzXCIrZy5sXSs9by5zdWJzdHIobil9ZWxzZSBnW1wieHNcIitnLmxdKz1nLmw/XCIgXCIrcDpwO2lmKC0xIT09ZC5pbmRleE9mKFwiPVwiKSYmZy5kYXRhKXtmb3IoeT1nLnhzMCtnLmRhdGEucyxsPTE7bDxnLmw7bCsrKXkrPWdbXCJ4c1wiK2xdK2cuZGF0YVtcInhuXCIrbF07Zy5lPXkrZ1tcInhzXCIrbF19cmV0dXJuIGcubHx8KGcudHlwZT0tMSxnLnhzMD1nLmUpLGcueGZpcnN0fHxnfSxzYT05O2ZvcihqPXBhLnByb3RvdHlwZSxqLmw9ai5wcj0wOy0tc2E+MDspaltcInhuXCIrc2FdPTAsaltcInhzXCIrc2FdPVwiXCI7ai54czA9XCJcIixqLl9uZXh0PWouX3ByZXY9ai54Zmlyc3Q9ai5kYXRhPWoucGx1Z2luPWouc2V0UmF0aW89ai5yeHA9bnVsbCxqLmFwcGVuZFh0cmE9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPXRoaXMsaD1nLmw7cmV0dXJuIGdbXCJ4c1wiK2hdKz1mJiZoP1wiIFwiK2E6YXx8XCJcIixjfHwwPT09aHx8Zy5wbHVnaW4/KGcubCsrLGcudHlwZT1nLnNldFJhdGlvPzI6MSxnW1wieHNcIitnLmxdPWR8fFwiXCIsaD4wPyhnLmRhdGFbXCJ4blwiK2hdPWIrYyxnLnJ4cFtcInhuXCIraF09ZSxnW1wieG5cIitoXT1iLGcucGx1Z2lufHwoZy54Zmlyc3Q9bmV3IHBhKGcsXCJ4blwiK2gsYixjLGcueGZpcnN0fHxnLDAsZy5uLGUsZy5wciksZy54Zmlyc3QueHMwPTApLGcpOihnLmRhdGE9e3M6YitjfSxnLnJ4cD17fSxnLnM9YixnLmM9YyxnLnI9ZSxnKSk6KGdbXCJ4c1wiK2hdKz1iKyhkfHxcIlwiKSxnKX07dmFyIHRhPWZ1bmN0aW9uKGEsYil7Yj1ifHx7fSx0aGlzLnA9Yi5wcmVmaXg/VihhKXx8YTphLGlbYV09aVt0aGlzLnBdPXRoaXMsdGhpcy5mb3JtYXQ9Yi5mb3JtYXR0ZXJ8fG1hKGIuZGVmYXVsdFZhbHVlLGIuY29sb3IsYi5jb2xsYXBzaWJsZSxiLm11bHRpKSxiLnBhcnNlciYmKHRoaXMucGFyc2U9Yi5wYXJzZXIpLHRoaXMuY2xycz1iLmNvbG9yLHRoaXMubXVsdGk9Yi5tdWx0aSx0aGlzLmtleXdvcmQ9Yi5rZXl3b3JkLHRoaXMuZGZsdD1iLmRlZmF1bHRWYWx1ZSx0aGlzLnByPWIucHJpb3JpdHl8fDB9LHVhPU8uX3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wPWZ1bmN0aW9uKGEsYixjKXtcIm9iamVjdFwiIT10eXBlb2YgYiYmKGI9e3BhcnNlcjpjfSk7dmFyIGQsZSxmPWEuc3BsaXQoXCIsXCIpLGc9Yi5kZWZhdWx0VmFsdWU7Zm9yKGM9Y3x8W2ddLGQ9MDtkPGYubGVuZ3RoO2QrKyliLnByZWZpeD0wPT09ZCYmYi5wcmVmaXgsYi5kZWZhdWx0VmFsdWU9Y1tkXXx8ZyxlPW5ldyB0YShmW2RdLGIpfSx2YT1mdW5jdGlvbihhKXtpZighaVthXSl7dmFyIGI9YS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cigxKStcIlBsdWdpblwiO3VhKGEse3BhcnNlcjpmdW5jdGlvbihhLGMsZCxlLGYsZyxqKXt2YXIgaz1oLmNvbS5ncmVlbnNvY2sucGx1Z2luc1tiXTtyZXR1cm4gaz8oay5fY3NzUmVnaXN0ZXIoKSxpW2RdLnBhcnNlKGEsYyxkLGUsZixnLGopKTooUyhcIkVycm9yOiBcIitiK1wiIGpzIGZpbGUgbm90IGxvYWRlZC5cIiksZil9fSl9fTtqPXRhLnByb3RvdHlwZSxqLnBhcnNlQ29tcGxleD1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGcsaCxpLGosayxsLG09dGhpcy5rZXl3b3JkO2lmKHRoaXMubXVsdGkmJihHLnRlc3QoYyl8fEcudGVzdChiKT8oaD1iLnJlcGxhY2UoRyxcInxcIikuc3BsaXQoXCJ8XCIpLGk9Yy5yZXBsYWNlKEcsXCJ8XCIpLnNwbGl0KFwifFwiKSk6bSYmKGg9W2JdLGk9W2NdKSksaSl7Zm9yKGo9aS5sZW5ndGg+aC5sZW5ndGg/aS5sZW5ndGg6aC5sZW5ndGgsZz0wO2o+ZztnKyspYj1oW2ddPWhbZ118fHRoaXMuZGZsdCxjPWlbZ109aVtnXXx8dGhpcy5kZmx0LG0mJihrPWIuaW5kZXhPZihtKSxsPWMuaW5kZXhPZihtKSxrIT09bCYmKC0xPT09bD9oW2ddPWhbZ10uc3BsaXQobSkuam9pbihcIlwiKTotMT09PWsmJihoW2ddKz1cIiBcIittKSkpO2I9aC5qb2luKFwiLCBcIiksYz1pLmpvaW4oXCIsIFwiKX1yZXR1cm4gcmEoYSx0aGlzLnAsYixjLHRoaXMuY2xycyx0aGlzLmRmbHQsZCx0aGlzLnByLGUsZil9LGoucGFyc2U9ZnVuY3Rpb24oYSxiLGMsZCxmLGcsaCl7cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KGEuc3R5bGUsdGhpcy5mb3JtYXQoWChhLHRoaXMucCxlLCExLHRoaXMuZGZsdCkpLHRoaXMuZm9ybWF0KGIpLGYsZyl9LGcucmVnaXN0ZXJTcGVjaWFsUHJvcD1mdW5jdGlvbihhLGIsYyl7dWEoYSx7cGFyc2VyOmZ1bmN0aW9uKGEsZCxlLGYsZyxoLGkpe3ZhciBqPW5ldyBwYShhLGUsMCwwLGcsMixlLCExLGMpO3JldHVybiBqLnBsdWdpbj1oLGouc2V0UmF0aW89YihhLGQsZi5fdHdlZW4sZSksan0scHJpb3JpdHk6Y30pfSxnLnVzZVNWR1RyYW5zZm9ybUF0dHI9bXx8bjt2YXIgd2EseGE9XCJzY2FsZVgsc2NhbGVZLHNjYWxlWix4LHkseixza2V3WCxza2V3WSxyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHBlcnNwZWN0aXZlLHhQZXJjZW50LHlQZXJjZW50XCIuc3BsaXQoXCIsXCIpLHlhPVYoXCJ0cmFuc2Zvcm1cIiksemE9VCtcInRyYW5zZm9ybVwiLEFhPVYoXCJ0cmFuc2Zvcm1PcmlnaW5cIiksQmE9bnVsbCE9PVYoXCJwZXJzcGVjdGl2ZVwiKSxDYT1PLlRyYW5zZm9ybT1mdW5jdGlvbigpe3RoaXMucGVyc3BlY3RpdmU9cGFyc2VGbG9hdChnLmRlZmF1bHRUcmFuc2Zvcm1QZXJzcGVjdGl2ZSl8fDAsdGhpcy5mb3JjZTNEPWcuZGVmYXVsdEZvcmNlM0QhPT0hMSYmQmE/Zy5kZWZhdWx0Rm9yY2UzRHx8XCJhdXRvXCI6ITF9LERhPXdpbmRvdy5TVkdFbGVtZW50LEVhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPUsuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixhKSxmPS8oW2Etel0pKFtBLVpdKS9nO2ZvcihkIGluIGMpZS5zZXRBdHRyaWJ1dGVOUyhudWxsLGQucmVwbGFjZShmLFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKSxjW2RdKTtyZXR1cm4gYi5hcHBlbmRDaGlsZChlKSxlfSxGYT1LLmRvY3VtZW50RWxlbWVudCxHYT1mdW5jdGlvbigpe3ZhciBhLGIsYyxkPXB8fC9BbmRyb2lkL2kudGVzdChQKSYmIXdpbmRvdy5jaHJvbWU7cmV0dXJuIEsuY3JlYXRlRWxlbWVudE5TJiYhZCYmKGE9RWEoXCJzdmdcIixGYSksYj1FYShcInJlY3RcIixhLHt3aWR0aDoxMDAsaGVpZ2h0OjUwLHg6MTAwfSksYz1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLGIuc3R5bGVbQWFdPVwiNTAlIDUwJVwiLGIuc3R5bGVbeWFdPVwic2NhbGVYKDAuNSlcIixkPWM9PT1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoJiYhKG4mJkJhKSxGYS5yZW1vdmVDaGlsZChhKSksZH0oKSxIYT1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGgsaSxqLGssbCxtLG4sbyxwLHEscixzLHQsdT1hLl9nc1RyYW5zZm9ybSx2PUthKGEsITApO3UmJihzPXUueE9yaWdpbix0PXUueU9yaWdpbiksKCFkfHwoZj1kLnNwbGl0KFwiIFwiKSkubGVuZ3RoPDIpJiYobT1hLmdldEJCb3goKSxiPWRhKGIpLnNwbGl0KFwiIFwiKSxmPVsoLTEhPT1iWzBdLmluZGV4T2YoXCIlXCIpP3BhcnNlRmxvYXQoYlswXSkvMTAwKm0ud2lkdGg6cGFyc2VGbG9hdChiWzBdKSkrbS54LCgtMSE9PWJbMV0uaW5kZXhPZihcIiVcIik/cGFyc2VGbG9hdChiWzFdKS8xMDAqbS5oZWlnaHQ6cGFyc2VGbG9hdChiWzFdKSkrbS55XSksYy54T3JpZ2luPWo9cGFyc2VGbG9hdChmWzBdKSxjLnlPcmlnaW49az1wYXJzZUZsb2F0KGZbMV0pLGQmJnYhPT1KYSYmKGw9dlswXSxtPXZbMV0sbj12WzJdLG89dlszXSxwPXZbNF0scT12WzVdLHI9bCpvLW0qbixoPWoqKG8vcikrayooLW4vcikrKG4qcS1vKnApL3IsaT1qKigtbS9yKStrKihsL3IpLShsKnEtbSpwKS9yLGo9Yy54T3JpZ2luPWZbMF09aCxrPWMueU9yaWdpbj1mWzFdPWkpLHUmJihlfHxlIT09ITEmJmcuZGVmYXVsdFNtb290aE9yaWdpbiE9PSExPyhoPWotcyxpPWstdCx1LnhPZmZzZXQrPWgqdlswXStpKnZbMl0taCx1LnlPZmZzZXQrPWgqdlsxXStpKnZbM10taSk6dS54T2Zmc2V0PXUueU9mZnNldD0wKSxhLnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLGYuam9pbihcIiBcIikpfSxJYT1mdW5jdGlvbihhKXtyZXR1cm4hIShEYSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5nZXRCQm94JiZhLmdldENUTSYmKCFhLnBhcmVudE5vZGV8fGEucGFyZW50Tm9kZS5nZXRCQm94JiZhLnBhcmVudE5vZGUuZ2V0Q1RNKSl9LEphPVsxLDAsMCwxLDAsMF0sS2E9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnLGg9YS5fZ3NUcmFuc2Zvcm18fG5ldyBDYSxpPTFlNTtpZih5YT9kPVgoYSx6YSxudWxsLCEwKTphLmN1cnJlbnRTdHlsZSYmKGQ9YS5jdXJyZW50U3R5bGUuZmlsdGVyLm1hdGNoKEUpLGQ9ZCYmND09PWQubGVuZ3RoP1tkWzBdLnN1YnN0cig0KSxOdW1iZXIoZFsyXS5zdWJzdHIoNCkpLE51bWJlcihkWzFdLnN1YnN0cig0KSksZFszXS5zdWJzdHIoNCksaC54fHwwLGgueXx8MF0uam9pbihcIixcIik6XCJcIiksYz0hZHx8XCJub25lXCI9PT1kfHxcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiPT09ZCwoaC5zdmd8fGEuZ2V0QkJveCYmSWEoYSkpJiYoYyYmLTEhPT0oYS5zdHlsZVt5YV0rXCJcIikuaW5kZXhPZihcIm1hdHJpeFwiKSYmKGQ9YS5zdHlsZVt5YV0sYz0wKSxlPWEuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpLGMmJmUmJigtMSE9PWUuaW5kZXhPZihcIm1hdHJpeFwiKT8oZD1lLGM9MCk6LTEhPT1lLmluZGV4T2YoXCJ0cmFuc2xhdGVcIikmJihkPVwibWF0cml4KDEsMCwwLDEsXCIrZS5tYXRjaCgvKD86XFwtfFxcYilbXFxkXFwtXFwuZV0rXFxiL2dpKS5qb2luKFwiLFwiKStcIilcIixjPTApKSksYylyZXR1cm4gSmE7Zm9yKGU9KGR8fFwiXCIpLm1hdGNoKC8oPzpcXC18XFxiKVtcXGRcXC1cXC5lXStcXGIvZ2kpfHxbXSxzYT1lLmxlbmd0aDstLXNhPi0xOylmPU51bWJlcihlW3NhXSksZVtzYV09KGc9Zi0oZnw9MCkpPyhnKmkrKDA+Zz8tLjU6LjUpfDApL2krZjpmO3JldHVybiBiJiZlLmxlbmd0aD42P1tlWzBdLGVbMV0sZVs0XSxlWzVdLGVbMTJdLGVbMTNdXTplfSxMYT1PLmdldFRyYW5zZm9ybT1mdW5jdGlvbihhLGMsZCxmKXtpZihhLl9nc1RyYW5zZm9ybSYmZCYmIWYpcmV0dXJuIGEuX2dzVHJhbnNmb3JtO3ZhciBoLGksaixrLGwsbSxuPWQ/YS5fZ3NUcmFuc2Zvcm18fG5ldyBDYTpuZXcgQ2Esbz1uLnNjYWxlWDwwLHA9MmUtNSxxPTFlNSxyPUJhP3BhcnNlRmxvYXQoWChhLEFhLGMsITEsXCIwIDAgMFwiKS5zcGxpdChcIiBcIilbMl0pfHxuLnpPcmlnaW58fDA6MCxzPXBhcnNlRmxvYXQoZy5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUpfHwwO2lmKG4uc3ZnPSEoIWEuZ2V0QkJveHx8IUlhKGEpKSxuLnN2ZyYmKEhhKGEsWChhLEFhLGUsITEsXCI1MCUgNTAlXCIpK1wiXCIsbixhLmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKSksd2E9Zy51c2VTVkdUcmFuc2Zvcm1BdHRyfHxHYSksaD1LYShhKSxoIT09SmEpe2lmKDE2PT09aC5sZW5ndGgpe3ZhciB0LHUsdix3LHgseT1oWzBdLHo9aFsxXSxBPWhbMl0sQj1oWzNdLEM9aFs0XSxEPWhbNV0sRT1oWzZdLEY9aFs3XSxHPWhbOF0sSD1oWzldLEo9aFsxMF0sSz1oWzEyXSxMPWhbMTNdLE09aFsxNF0sTj1oWzExXSxPPU1hdGguYXRhbjIoRSxKKTtuLnpPcmlnaW4mJihNPS1uLnpPcmlnaW4sSz1HKk0taFsxMl0sTD1IKk0taFsxM10sTT1KKk0rbi56T3JpZ2luLWhbMTRdKSxuLnJvdGF0aW9uWD1PKkksTyYmKHc9TWF0aC5jb3MoLU8pLHg9TWF0aC5zaW4oLU8pLHQ9Qyp3K0cqeCx1PUQqdytIKngsdj1FKncrSip4LEc9QyoteCtHKncsSD1EKi14K0gqdyxKPUUqLXgrSip3LE49RioteCtOKncsQz10LEQ9dSxFPXYpLE89TWF0aC5hdGFuMigtQSxKKSxuLnJvdGF0aW9uWT1PKkksTyYmKHc9TWF0aC5jb3MoLU8pLHg9TWF0aC5zaW4oLU8pLHQ9eSp3LUcqeCx1PXoqdy1IKngsdj1BKnctSip4LEg9eip4K0gqdyxKPUEqeCtKKncsTj1CKngrTip3LHk9dCx6PXUsQT12KSxPPU1hdGguYXRhbjIoeix5KSxuLnJvdGF0aW9uPU8qSSxPJiYodz1NYXRoLmNvcygtTykseD1NYXRoLnNpbigtTykseT15KncrQyp4LHU9eip3K0QqeCxEPXoqLXgrRCp3LEU9QSoteCtFKncsej11KSxuLnJvdGF0aW9uWCYmTWF0aC5hYnMobi5yb3RhdGlvblgpK01hdGguYWJzKG4ucm90YXRpb24pPjM1OS45JiYobi5yb3RhdGlvblg9bi5yb3RhdGlvbj0wLG4ucm90YXRpb25ZPTE4MC1uLnJvdGF0aW9uWSksbi5zY2FsZVg9KE1hdGguc3FydCh5Knkreip6KSpxKy41fDApL3Esbi5zY2FsZVk9KE1hdGguc3FydChEKkQrSCpIKSpxKy41fDApL3Esbi5zY2FsZVo9KE1hdGguc3FydChFKkUrSipKKSpxKy41fDApL3Esbi5za2V3WD0wLG4ucGVyc3BlY3RpdmU9Tj8xLygwPk4/LU46Tik6MCxuLng9SyxuLnk9TCxuLno9TSxuLnN2ZyYmKG4ueC09bi54T3JpZ2luLShuLnhPcmlnaW4qeS1uLnlPcmlnaW4qQyksbi55LT1uLnlPcmlnaW4tKG4ueU9yaWdpbip6LW4ueE9yaWdpbipEKSl9ZWxzZSBpZigoIUJhfHxmfHwhaC5sZW5ndGh8fG4ueCE9PWhbNF18fG4ueSE9PWhbNV18fCFuLnJvdGF0aW9uWCYmIW4ucm90YXRpb25ZKSYmKHZvaWQgMD09PW4ueHx8XCJub25lXCIhPT1YKGEsXCJkaXNwbGF5XCIsYykpKXt2YXIgUD1oLmxlbmd0aD49NixRPVA/aFswXToxLFI9aFsxXXx8MCxTPWhbMl18fDAsVD1QP2hbM106MTtuLng9aFs0XXx8MCxuLnk9aFs1XXx8MCxqPU1hdGguc3FydChRKlErUipSKSxrPU1hdGguc3FydChUKlQrUypTKSxsPVF8fFI/TWF0aC5hdGFuMihSLFEpKkk6bi5yb3RhdGlvbnx8MCxtPVN8fFQ/TWF0aC5hdGFuMihTLFQpKkkrbDpuLnNrZXdYfHwwLE1hdGguYWJzKG0pPjkwJiZNYXRoLmFicyhtKTwyNzAmJihvPyhqKj0tMSxtKz0wPj1sPzE4MDotMTgwLGwrPTA+PWw/MTgwOi0xODApOihrKj0tMSxtKz0wPj1tPzE4MDotMTgwKSksbi5zY2FsZVg9aixuLnNjYWxlWT1rLG4ucm90YXRpb249bCxuLnNrZXdYPW0sQmEmJihuLnJvdGF0aW9uWD1uLnJvdGF0aW9uWT1uLno9MCxuLnBlcnNwZWN0aXZlPXMsbi5zY2FsZVo9MSksbi5zdmcmJihuLngtPW4ueE9yaWdpbi0obi54T3JpZ2luKlErbi55T3JpZ2luKlMpLG4ueS09bi55T3JpZ2luLShuLnhPcmlnaW4qUituLnlPcmlnaW4qVCkpfW4uek9yaWdpbj1yO2ZvcihpIGluIG4pbltpXTxwJiZuW2ldPi1wJiYobltpXT0wKX1yZXR1cm4gZCYmKGEuX2dzVHJhbnNmb3JtPW4sbi5zdmcmJih3YSYmYS5zdHlsZVt5YV0/Yi5kZWxheWVkQ2FsbCguMDAxLGZ1bmN0aW9uKCl7UGEoYS5zdHlsZSx5YSl9KTohd2EmJmEuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpJiZiLmRlbGF5ZWRDYWxsKC4wMDEsZnVuY3Rpb24oKXthLnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKX0pKSksbn0sTWE9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkPXRoaXMuZGF0YSxlPS1kLnJvdGF0aW9uKkgsZj1lK2Quc2tld1gqSCxnPTFlNSxoPShNYXRoLmNvcyhlKSpkLnNjYWxlWCpnfDApL2csaT0oTWF0aC5zaW4oZSkqZC5zY2FsZVgqZ3wwKS9nLGo9KE1hdGguc2luKGYpKi1kLnNjYWxlWSpnfDApL2csaz0oTWF0aC5jb3MoZikqZC5zY2FsZVkqZ3wwKS9nLGw9dGhpcy50LnN0eWxlLG09dGhpcy50LmN1cnJlbnRTdHlsZTtpZihtKXtjPWksaT0taixqPS1jLGI9bS5maWx0ZXIsbC5maWx0ZXI9XCJcIjt2YXIgbixvLHE9dGhpcy50Lm9mZnNldFdpZHRoLHI9dGhpcy50Lm9mZnNldEhlaWdodCxzPVwiYWJzb2x1dGVcIiE9PW0ucG9zaXRpb24sdD1cInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoTTExPVwiK2grXCIsIE0xMj1cIitpK1wiLCBNMjE9XCIraitcIiwgTTIyPVwiK2ssdz1kLngrcSpkLnhQZXJjZW50LzEwMCx4PWQueStyKmQueVBlcmNlbnQvMTAwO2lmKG51bGwhPWQub3gmJihuPShkLm94cD9xKmQub3gqLjAxOmQub3gpLXEvMixvPShkLm95cD9yKmQub3kqLjAxOmQub3kpLXIvMix3Kz1uLShuKmgrbyppKSx4Kz1vLShuKmorbyprKSkscz8obj1xLzIsbz1yLzIsdCs9XCIsIER4PVwiKyhuLShuKmgrbyppKSt3KStcIiwgRHk9XCIrKG8tKG4qaitvKmspK3gpK1wiKVwiKTp0Kz1cIiwgc2l6aW5nTWV0aG9kPSdhdXRvIGV4cGFuZCcpXCIsLTEhPT1iLmluZGV4T2YoXCJEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoXCIpP2wuZmlsdGVyPWIucmVwbGFjZShGLHQpOmwuZmlsdGVyPXQrXCIgXCIrYiwoMD09PWF8fDE9PT1hKSYmMT09PWgmJjA9PT1pJiYwPT09aiYmMT09PWsmJihzJiYtMT09PXQuaW5kZXhPZihcIkR4PTAsIER5PTBcIil8fHYudGVzdChiKSYmMTAwIT09cGFyc2VGbG9hdChSZWdFeHAuJDEpfHwtMT09PWIuaW5kZXhPZihiLmluZGV4T2YoXCJBbHBoYVwiKSkmJmwucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpKSwhcyl7dmFyIHkseixBLEI9OD5wPzE6LTE7Zm9yKG49ZC5pZU9mZnNldFh8fDAsbz1kLmllT2Zmc2V0WXx8MCxkLmllT2Zmc2V0WD1NYXRoLnJvdW5kKChxLSgoMD5oPy1oOmgpKnErKDA+aT8taTppKSpyKSkvMit3KSxkLmllT2Zmc2V0WT1NYXRoLnJvdW5kKChyLSgoMD5rPy1rOmspKnIrKDA+aj8tajpqKSpxKSkvMit4KSxzYT0wOzQ+c2E7c2ErKyl6PWJhW3NhXSx5PW1bel0sYz0tMSE9PXkuaW5kZXhPZihcInB4XCIpP3BhcnNlRmxvYXQoeSk6WSh0aGlzLnQseixwYXJzZUZsb2F0KHkpLHkucmVwbGFjZSh1LFwiXCIpKXx8MCxBPWMhPT1kW3pdPzI+c2E/LWQuaWVPZmZzZXRYOi1kLmllT2Zmc2V0WToyPnNhP24tZC5pZU9mZnNldFg6by1kLmllT2Zmc2V0WSxsW3pdPShkW3pdPU1hdGgucm91bmQoYy1BKigwPT09c2F8fDI9PT1zYT8xOkIpKSkrXCJweFwifX19LE5hPU8uc2V0M0RUcmFuc2Zvcm1SYXRpbz1PLnNldFRyYW5zZm9ybVJhdGlvPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxvLHAscSxyLHMsdCx1LHYsdyx4LHksej10aGlzLmRhdGEsQT10aGlzLnQuc3R5bGUsQj16LnJvdGF0aW9uLEM9ei5yb3RhdGlvblgsRD16LnJvdGF0aW9uWSxFPXouc2NhbGVYLEY9ei5zY2FsZVksRz16LnNjYWxlWixJPXoueCxKPXoueSxLPXoueixMPXouc3ZnLE09ei5wZXJzcGVjdGl2ZSxOPXouZm9yY2UzRDtpZigoKDE9PT1hfHwwPT09YSkmJlwiYXV0b1wiPT09TiYmKHRoaXMudHdlZW4uX3RvdGFsVGltZT09PXRoaXMudHdlZW4uX3RvdGFsRHVyYXRpb258fCF0aGlzLnR3ZWVuLl90b3RhbFRpbWUpfHwhTikmJiFLJiYhTSYmIUQmJiFDJiYxPT09R3x8d2EmJkx8fCFCYSlyZXR1cm4gdm9pZChCfHx6LnNrZXdYfHxMPyhCKj1ILHg9ei5za2V3WCpILHk9MWU1LGI9TWF0aC5jb3MoQikqRSxlPU1hdGguc2luKEIpKkUsYz1NYXRoLnNpbihCLXgpKi1GLGY9TWF0aC5jb3MoQi14KSpGLHgmJlwic2ltcGxlXCI9PT16LnNrZXdUeXBlJiYocz1NYXRoLnRhbih4KSxzPU1hdGguc3FydCgxK3MqcyksYyo9cyxmKj1zLHouc2tld1kmJihiKj1zLGUqPXMpKSxMJiYoSSs9ei54T3JpZ2luLSh6LnhPcmlnaW4qYit6LnlPcmlnaW4qYykrei54T2Zmc2V0LEorPXoueU9yaWdpbi0oei54T3JpZ2luKmUrei55T3JpZ2luKmYpK3oueU9mZnNldCx3YSYmKHoueFBlcmNlbnR8fHoueVBlcmNlbnQpJiYocD10aGlzLnQuZ2V0QkJveCgpLEkrPS4wMSp6LnhQZXJjZW50KnAud2lkdGgsSis9LjAxKnoueVBlcmNlbnQqcC5oZWlnaHQpLHA9MWUtNixwPkkmJkk+LXAmJihJPTApLHA+SiYmSj4tcCYmKEo9MCkpLHU9KGIqeXwwKS95K1wiLFwiKyhlKnl8MCkveStcIixcIisoYyp5fDApL3krXCIsXCIrKGYqeXwwKS95K1wiLFwiK0krXCIsXCIrSitcIilcIixMJiZ3YT90aGlzLnQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsXCJtYXRyaXgoXCIrdSk6QVt5YV09KHoueFBlcmNlbnR8fHoueVBlcmNlbnQ/XCJ0cmFuc2xhdGUoXCIrei54UGVyY2VudCtcIiUsXCIrei55UGVyY2VudCtcIiUpIG1hdHJpeChcIjpcIm1hdHJpeChcIikrdSk6QVt5YV09KHoueFBlcmNlbnR8fHoueVBlcmNlbnQ/XCJ0cmFuc2xhdGUoXCIrei54UGVyY2VudCtcIiUsXCIrei55UGVyY2VudCtcIiUpIG1hdHJpeChcIjpcIm1hdHJpeChcIikrRStcIiwwLDAsXCIrRitcIixcIitJK1wiLFwiK0orXCIpXCIpO2lmKG4mJihwPTFlLTQscD5FJiZFPi1wJiYoRT1HPTJlLTUpLHA+RiYmRj4tcCYmKEY9Rz0yZS01KSwhTXx8ei56fHx6LnJvdGF0aW9uWHx8ei5yb3RhdGlvbll8fChNPTApKSxCfHx6LnNrZXdYKUIqPUgscT1iPU1hdGguY29zKEIpLHI9ZT1NYXRoLnNpbihCKSx6LnNrZXdYJiYoQi09ei5za2V3WCpILHE9TWF0aC5jb3MoQikscj1NYXRoLnNpbihCKSxcInNpbXBsZVwiPT09ei5za2V3VHlwZSYmKHM9TWF0aC50YW4oei5za2V3WCpIKSxzPU1hdGguc3FydCgxK3MqcykscSo9cyxyKj1zLHouc2tld1kmJihiKj1zLGUqPXMpKSksYz0tcixmPXE7ZWxzZXtpZighKER8fEN8fDEhPT1HfHxNfHxMKSlyZXR1cm4gdm9pZChBW3lhXT0oei54UGVyY2VudHx8ei55UGVyY2VudD9cInRyYW5zbGF0ZShcIit6LnhQZXJjZW50K1wiJSxcIit6LnlQZXJjZW50K1wiJSkgdHJhbnNsYXRlM2QoXCI6XCJ0cmFuc2xhdGUzZChcIikrSStcInB4LFwiK0orXCJweCxcIitLK1wicHgpXCIrKDEhPT1FfHwxIT09Rj9cIiBzY2FsZShcIitFK1wiLFwiK0YrXCIpXCI6XCJcIikpO2I9Zj0xLGM9ZT0wfWo9MSxkPWc9aD1pPWs9bD0wLG09TT8tMS9NOjAsbz16LnpPcmlnaW4scD0xZS02LHY9XCIsXCIsdz1cIjBcIixCPUQqSCxCJiYocT1NYXRoLmNvcyhCKSxyPU1hdGguc2luKEIpLGg9LXIsaz1tKi1yLGQ9YipyLGc9ZSpyLGo9cSxtKj1xLGIqPXEsZSo9cSksQj1DKkgsQiYmKHE9TWF0aC5jb3MoQikscj1NYXRoLnNpbihCKSxzPWMqcStkKnIsdD1mKnErZypyLGk9aipyLGw9bSpyLGQ9YyotcitkKnEsZz1mKi1yK2cqcSxqKj1xLG0qPXEsYz1zLGY9dCksMSE9PUcmJihkKj1HLGcqPUcsaio9RyxtKj1HKSwxIT09RiYmKGMqPUYsZio9RixpKj1GLGwqPUYpLDEhPT1FJiYoYio9RSxlKj1FLGgqPUUsayo9RSksKG98fEwpJiYobyYmKEkrPWQqLW8sSis9ZyotbyxLKz1qKi1vK28pLEwmJihJKz16LnhPcmlnaW4tKHoueE9yaWdpbipiK3oueU9yaWdpbipjKSt6LnhPZmZzZXQsSis9ei55T3JpZ2luLSh6LnhPcmlnaW4qZSt6LnlPcmlnaW4qZikrei55T2Zmc2V0KSxwPkkmJkk+LXAmJihJPXcpLHA+SiYmSj4tcCYmKEo9dykscD5LJiZLPi1wJiYoSz0wKSksdT16LnhQZXJjZW50fHx6LnlQZXJjZW50P1widHJhbnNsYXRlKFwiK3oueFBlcmNlbnQrXCIlLFwiK3oueVBlcmNlbnQrXCIlKSBtYXRyaXgzZChcIjpcIm1hdHJpeDNkKFwiLHUrPShwPmImJmI+LXA/dzpiKSt2KyhwPmUmJmU+LXA/dzplKSt2KyhwPmgmJmg+LXA/dzpoKSx1Kz12KyhwPmsmJms+LXA/dzprKSt2KyhwPmMmJmM+LXA/dzpjKSt2KyhwPmYmJmY+LXA/dzpmKSxDfHxEfHwxIT09Rz8odSs9disocD5pJiZpPi1wP3c6aSkrdisocD5sJiZsPi1wP3c6bCkrdisocD5kJiZkPi1wP3c6ZCksdSs9disocD5nJiZnPi1wP3c6ZykrdisocD5qJiZqPi1wP3c6aikrdisocD5tJiZtPi1wP3c6bSkrdik6dSs9XCIsMCwwLDAsMCwxLDAsXCIsdSs9SSt2K0orditLK3YrKE0/MSstSy9NOjEpK1wiKVwiLEFbeWFdPXV9O2o9Q2EucHJvdG90eXBlLGoueD1qLnk9ai56PWouc2tld1g9ai5za2V3WT1qLnJvdGF0aW9uPWoucm90YXRpb25YPWoucm90YXRpb25ZPWouek9yaWdpbj1qLnhQZXJjZW50PWoueVBlcmNlbnQ9ai54T2Zmc2V0PWoueU9mZnNldD0wLGouc2NhbGVYPWouc2NhbGVZPWouc2NhbGVaPTEsdWEoXCJ0cmFuc2Zvcm0sc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHoscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxyb3RhdGlvblosc2tld1gsc2tld1ksc2hvcnRSb3RhdGlvbixzaG9ydFJvdGF0aW9uWCxzaG9ydFJvdGF0aW9uWSxzaG9ydFJvdGF0aW9uWix0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlLGRpcmVjdGlvbmFsUm90YXRpb24scGFyc2VUcmFuc2Zvcm0sZm9yY2UzRCxza2V3VHlwZSx4UGVyY2VudCx5UGVyY2VudCxzbW9vdGhPcmlnaW5cIix7cGFyc2VyOmZ1bmN0aW9uKGEsYixjLGQsZixoLGkpe2lmKGQuX2xhc3RQYXJzZWRUcmFuc2Zvcm09PT1pKXJldHVybiBmO2QuX2xhc3RQYXJzZWRUcmFuc2Zvcm09aTt2YXIgaixrLGwsbSxuLG8scCxxLHIscyx0PWEuX2dzVHJhbnNmb3JtLHU9YS5zdHlsZSx2PTFlLTYsdz14YS5sZW5ndGgseD1pLHk9e30sej1cInRyYW5zZm9ybU9yaWdpblwiO2lmKGkuZGlzcGxheT8obT1YKGEsXCJkaXNwbGF5XCIpLHUuZGlzcGxheT1cImJsb2NrXCIsaj1MYShhLGUsITAsaS5wYXJzZVRyYW5zZm9ybSksdS5kaXNwbGF5PW0pOmo9TGEoYSxlLCEwLGkucGFyc2VUcmFuc2Zvcm0pLGQuX3RyYW5zZm9ybT1qLFwic3RyaW5nXCI9PXR5cGVvZiB4LnRyYW5zZm9ybSYmeWEpbT1NLnN0eWxlLG1beWFdPXgudHJhbnNmb3JtLG0uZGlzcGxheT1cImJsb2NrXCIsbS5wb3NpdGlvbj1cImFic29sdXRlXCIsSy5ib2R5LmFwcGVuZENoaWxkKE0pLGs9TGEoTSxudWxsLCExKSxLLmJvZHkucmVtb3ZlQ2hpbGQoTSksay5wZXJzcGVjdGl2ZXx8KGsucGVyc3BlY3RpdmU9ai5wZXJzcGVjdGl2ZSksbnVsbCE9eC54UGVyY2VudCYmKGsueFBlcmNlbnQ9ZmEoeC54UGVyY2VudCxqLnhQZXJjZW50KSksbnVsbCE9eC55UGVyY2VudCYmKGsueVBlcmNlbnQ9ZmEoeC55UGVyY2VudCxqLnlQZXJjZW50KSk7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgeCl7aWYoaz17c2NhbGVYOmZhKG51bGwhPXguc2NhbGVYP3guc2NhbGVYOnguc2NhbGUsai5zY2FsZVgpLHNjYWxlWTpmYShudWxsIT14LnNjYWxlWT94LnNjYWxlWTp4LnNjYWxlLGouc2NhbGVZKSxzY2FsZVo6ZmEoeC5zY2FsZVosai5zY2FsZVopLHg6ZmEoeC54LGoueCkseTpmYSh4Lnksai55KSx6OmZhKHgueixqLnopLHhQZXJjZW50OmZhKHgueFBlcmNlbnQsai54UGVyY2VudCkseVBlcmNlbnQ6ZmEoeC55UGVyY2VudCxqLnlQZXJjZW50KSxwZXJzcGVjdGl2ZTpmYSh4LnRyYW5zZm9ybVBlcnNwZWN0aXZlLGoucGVyc3BlY3RpdmUpfSxxPXguZGlyZWN0aW9uYWxSb3RhdGlvbixudWxsIT1xKWlmKFwib2JqZWN0XCI9PXR5cGVvZiBxKWZvcihtIGluIHEpeFttXT1xW21dO2Vsc2UgeC5yb3RhdGlvbj1xO1wic3RyaW5nXCI9PXR5cGVvZiB4LngmJi0xIT09eC54LmluZGV4T2YoXCIlXCIpJiYoay54PTAsay54UGVyY2VudD1mYSh4Lngsai54UGVyY2VudCkpLFwic3RyaW5nXCI9PXR5cGVvZiB4LnkmJi0xIT09eC55LmluZGV4T2YoXCIlXCIpJiYoay55PTAsay55UGVyY2VudD1mYSh4Lnksai55UGVyY2VudCkpLGsucm90YXRpb249Z2EoXCJyb3RhdGlvblwiaW4geD94LnJvdGF0aW9uOlwic2hvcnRSb3RhdGlvblwiaW4geD94LnNob3J0Um90YXRpb24rXCJfc2hvcnRcIjpcInJvdGF0aW9uWlwiaW4geD94LnJvdGF0aW9uWjpqLnJvdGF0aW9uLGoucm90YXRpb24sXCJyb3RhdGlvblwiLHkpLEJhJiYoay5yb3RhdGlvblg9Z2EoXCJyb3RhdGlvblhcImluIHg/eC5yb3RhdGlvblg6XCJzaG9ydFJvdGF0aW9uWFwiaW4geD94LnNob3J0Um90YXRpb25YK1wiX3Nob3J0XCI6ai5yb3RhdGlvblh8fDAsai5yb3RhdGlvblgsXCJyb3RhdGlvblhcIix5KSxrLnJvdGF0aW9uWT1nYShcInJvdGF0aW9uWVwiaW4geD94LnJvdGF0aW9uWTpcInNob3J0Um90YXRpb25ZXCJpbiB4P3guc2hvcnRSb3RhdGlvblkrXCJfc2hvcnRcIjpqLnJvdGF0aW9uWXx8MCxqLnJvdGF0aW9uWSxcInJvdGF0aW9uWVwiLHkpKSxrLnNrZXdYPW51bGw9PXguc2tld1g/ai5za2V3WDpnYSh4LnNrZXdYLGouc2tld1gpLGsuc2tld1k9bnVsbD09eC5za2V3WT9qLnNrZXdZOmdhKHguc2tld1ksai5za2V3WSksKGw9ay5za2V3WS1qLnNrZXdZKSYmKGsuc2tld1grPWwsay5yb3RhdGlvbis9bCl9Zm9yKEJhJiZudWxsIT14LmZvcmNlM0QmJihqLmZvcmNlM0Q9eC5mb3JjZTNELHA9ITApLGouc2tld1R5cGU9eC5za2V3VHlwZXx8ai5za2V3VHlwZXx8Zy5kZWZhdWx0U2tld1R5cGUsbz1qLmZvcmNlM0R8fGouenx8ai5yb3RhdGlvblh8fGoucm90YXRpb25ZfHxrLnp8fGsucm90YXRpb25YfHxrLnJvdGF0aW9uWXx8ay5wZXJzcGVjdGl2ZSxvfHxudWxsPT14LnNjYWxlfHwoay5zY2FsZVo9MSk7LS13Pi0xOyljPXhhW3ddLG49a1tjXS1qW2NdLChuPnZ8fC12Pm58fG51bGwhPXhbY118fG51bGwhPUpbY10pJiYocD0hMCxmPW5ldyBwYShqLGMsaltjXSxuLGYpLGMgaW4geSYmKGYuZT15W2NdKSxmLnhzMD0wLGYucGx1Z2luPWgsZC5fb3ZlcndyaXRlUHJvcHMucHVzaChmLm4pKTtyZXR1cm4gbj14LnRyYW5zZm9ybU9yaWdpbixqLnN2ZyYmKG58fHguc3ZnT3JpZ2luKSYmKHI9ai54T2Zmc2V0LHM9ai55T2Zmc2V0LEhhKGEsZGEobiksayx4LnN2Z09yaWdpbix4LnNtb290aE9yaWdpbiksZj1xYShqLFwieE9yaWdpblwiLCh0P2o6aykueE9yaWdpbixrLnhPcmlnaW4sZix6KSxmPXFhKGosXCJ5T3JpZ2luXCIsKHQ/ajprKS55T3JpZ2luLGsueU9yaWdpbixmLHopLChyIT09ai54T2Zmc2V0fHxzIT09ai55T2Zmc2V0KSYmKGY9cWEoaixcInhPZmZzZXRcIix0P3I6ai54T2Zmc2V0LGoueE9mZnNldCxmLHopLGY9cWEoaixcInlPZmZzZXRcIix0P3M6ai55T2Zmc2V0LGoueU9mZnNldCxmLHopKSxuPXdhP251bGw6XCIwcHggMHB4XCIpLChufHxCYSYmbyYmai56T3JpZ2luKSYmKHlhPyhwPSEwLGM9QWEsbj0obnx8WChhLGMsZSwhMSxcIjUwJSA1MCVcIikpK1wiXCIsZj1uZXcgcGEodSxjLDAsMCxmLC0xLHopLGYuYj11W2NdLGYucGx1Z2luPWgsQmE/KG09ai56T3JpZ2luLG49bi5zcGxpdChcIiBcIiksai56T3JpZ2luPShuLmxlbmd0aD4yJiYoMD09PW18fFwiMHB4XCIhPT1uWzJdKT9wYXJzZUZsb2F0KG5bMl0pOm0pfHwwLGYueHMwPWYuZT1uWzBdK1wiIFwiKyhuWzFdfHxcIjUwJVwiKStcIiAwcHhcIixmPW5ldyBwYShqLFwiek9yaWdpblwiLDAsMCxmLC0xLGYubiksZi5iPW0sZi54czA9Zi5lPWouek9yaWdpbik6Zi54czA9Zi5lPW4pOmRhKG4rXCJcIixqKSkscCYmKGQuX3RyYW5zZm9ybVR5cGU9ai5zdmcmJndhfHwhbyYmMyE9PXRoaXMuX3RyYW5zZm9ybVR5cGU/MjozKSxmfSxwcmVmaXg6ITB9KSx1YShcImJveFNoYWRvd1wiLHtkZWZhdWx0VmFsdWU6XCIwcHggMHB4IDBweCAwcHggIzk5OVwiLHByZWZpeDohMCxjb2xvcjohMCxtdWx0aTohMCxrZXl3b3JkOlwiaW5zZXRcIn0pLHVhKFwiYm9yZGVyUmFkaXVzXCIse2RlZmF1bHRWYWx1ZTpcIjBweFwiLHBhcnNlcjpmdW5jdGlvbihhLGIsYyxmLGcsaCl7Yj10aGlzLmZvcm1hdChiKTt2YXIgaSxqLGssbCxtLG4sbyxwLHEscixzLHQsdSx2LHcseCx5PVtcImJvcmRlclRvcExlZnRSYWRpdXNcIixcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiXSx6PWEuc3R5bGU7Zm9yKHE9cGFyc2VGbG9hdChhLm9mZnNldFdpZHRoKSxyPXBhcnNlRmxvYXQoYS5vZmZzZXRIZWlnaHQpLGk9Yi5zcGxpdChcIiBcIiksaj0wO2o8eS5sZW5ndGg7aisrKXRoaXMucC5pbmRleE9mKFwiYm9yZGVyXCIpJiYoeVtqXT1WKHlbal0pKSxtPWw9WChhLHlbal0sZSwhMSxcIjBweFwiKSwtMSE9PW0uaW5kZXhPZihcIiBcIikmJihsPW0uc3BsaXQoXCIgXCIpLG09bFswXSxsPWxbMV0pLG49az1pW2pdLG89cGFyc2VGbG9hdChtKSx0PW0uc3Vic3RyKChvK1wiXCIpLmxlbmd0aCksdT1cIj1cIj09PW4uY2hhckF0KDEpLHU/KHA9cGFyc2VJbnQobi5jaGFyQXQoMCkrXCIxXCIsMTApLG49bi5zdWJzdHIoMikscCo9cGFyc2VGbG9hdChuKSxzPW4uc3Vic3RyKChwK1wiXCIpLmxlbmd0aC0oMD5wPzE6MCkpfHxcIlwiKToocD1wYXJzZUZsb2F0KG4pLHM9bi5zdWJzdHIoKHArXCJcIikubGVuZ3RoKSksXCJcIj09PXMmJihzPWRbY118fHQpLHMhPT10JiYodj1ZKGEsXCJib3JkZXJMZWZ0XCIsbyx0KSx3PVkoYSxcImJvcmRlclRvcFwiLG8sdCksXCIlXCI9PT1zPyhtPXYvcSoxMDArXCIlXCIsbD13L3IqMTAwK1wiJVwiKTpcImVtXCI9PT1zPyh4PVkoYSxcImJvcmRlckxlZnRcIiwxLFwiZW1cIiksbT12L3grXCJlbVwiLGw9dy94K1wiZW1cIik6KG09ditcInB4XCIsbD13K1wicHhcIiksdSYmKG49cGFyc2VGbG9hdChtKStwK3Msaz1wYXJzZUZsb2F0KGwpK3ArcykpLGc9cmEoeix5W2pdLG0rXCIgXCIrbCxuK1wiIFwiK2ssITEsXCIwcHhcIixnKTtyZXR1cm4gZ30scHJlZml4OiEwLGZvcm1hdHRlcjptYShcIjBweCAwcHggMHB4IDBweFwiLCExLCEwKX0pLHVhKFwiYmFja2dyb3VuZFBvc2l0aW9uXCIse1xyXG5kZWZhdWx0VmFsdWU6XCIwIDBcIixwYXJzZXI6ZnVuY3Rpb24oYSxiLGMsZCxmLGcpe3ZhciBoLGksaixrLGwsbSxuPVwiYmFja2dyb3VuZC1wb3NpdGlvblwiLG89ZXx8VyhhLG51bGwpLHE9dGhpcy5mb3JtYXQoKG8/cD9vLmdldFByb3BlcnR5VmFsdWUobitcIi14XCIpK1wiIFwiK28uZ2V0UHJvcGVydHlWYWx1ZShuK1wiLXlcIik6by5nZXRQcm9wZXJ0eVZhbHVlKG4pOmEuY3VycmVudFN0eWxlLmJhY2tncm91bmRQb3NpdGlvblgrXCIgXCIrYS5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWSl8fFwiMCAwXCIpLHI9dGhpcy5mb3JtYXQoYik7aWYoLTEhPT1xLmluZGV4T2YoXCIlXCIpIT0oLTEhPT1yLmluZGV4T2YoXCIlXCIpKSYmKG09WChhLFwiYmFja2dyb3VuZEltYWdlXCIpLnJlcGxhY2UoQixcIlwiKSxtJiZcIm5vbmVcIiE9PW0pKXtmb3IoaD1xLnNwbGl0KFwiIFwiKSxpPXIuc3BsaXQoXCIgXCIpLE4uc2V0QXR0cmlidXRlKFwic3JjXCIsbSksaj0yOy0taj4tMTspcT1oW2pdLGs9LTEhPT1xLmluZGV4T2YoXCIlXCIpLGshPT0oLTEhPT1pW2pdLmluZGV4T2YoXCIlXCIpKSYmKGw9MD09PWo/YS5vZmZzZXRXaWR0aC1OLndpZHRoOmEub2Zmc2V0SGVpZ2h0LU4uaGVpZ2h0LGhbal09az9wYXJzZUZsb2F0KHEpLzEwMCpsK1wicHhcIjpwYXJzZUZsb2F0KHEpL2wqMTAwK1wiJVwiKTtxPWguam9pbihcIiBcIil9cmV0dXJuIHRoaXMucGFyc2VDb21wbGV4KGEuc3R5bGUscSxyLGYsZyl9LGZvcm1hdHRlcjpkYX0pLHVhKFwiYmFja2dyb3VuZFNpemVcIix7ZGVmYXVsdFZhbHVlOlwiMCAwXCIsZm9ybWF0dGVyOmRhfSksdWEoXCJwZXJzcGVjdGl2ZVwiLHtkZWZhdWx0VmFsdWU6XCIwcHhcIixwcmVmaXg6ITB9KSx1YShcInBlcnNwZWN0aXZlT3JpZ2luXCIse2RlZmF1bHRWYWx1ZTpcIjUwJSA1MCVcIixwcmVmaXg6ITB9KSx1YShcInRyYW5zZm9ybVN0eWxlXCIse3ByZWZpeDohMH0pLHVhKFwiYmFja2ZhY2VWaXNpYmlsaXR5XCIse3ByZWZpeDohMH0pLHVhKFwidXNlclNlbGVjdFwiLHtwcmVmaXg6ITB9KSx1YShcIm1hcmdpblwiLHtwYXJzZXI6bmEoXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIil9KSx1YShcInBhZGRpbmdcIix7cGFyc2VyOm5hKFwicGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxwYWRkaW5nTGVmdFwiKX0pLHVhKFwiY2xpcFwiLHtkZWZhdWx0VmFsdWU6XCJyZWN0KDBweCwwcHgsMHB4LDBweClcIixwYXJzZXI6ZnVuY3Rpb24oYSxiLGMsZCxmLGcpe3ZhciBoLGksajtyZXR1cm4gOT5wPyhpPWEuY3VycmVudFN0eWxlLGo9OD5wP1wiIFwiOlwiLFwiLGg9XCJyZWN0KFwiK2kuY2xpcFRvcCtqK2kuY2xpcFJpZ2h0K2oraS5jbGlwQm90dG9tK2oraS5jbGlwTGVmdCtcIilcIixiPXRoaXMuZm9ybWF0KGIpLnNwbGl0KFwiLFwiKS5qb2luKGopKTooaD10aGlzLmZvcm1hdChYKGEsdGhpcy5wLGUsITEsdGhpcy5kZmx0KSksYj10aGlzLmZvcm1hdChiKSksdGhpcy5wYXJzZUNvbXBsZXgoYS5zdHlsZSxoLGIsZixnKX19KSx1YShcInRleHRTaGFkb3dcIix7ZGVmYXVsdFZhbHVlOlwiMHB4IDBweCAwcHggIzk5OVwiLGNvbG9yOiEwLG11bHRpOiEwfSksdWEoXCJhdXRvUm91bmQsc3RyaWN0VW5pdHNcIix7cGFyc2VyOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIGV9fSksdWEoXCJib3JkZXJcIix7ZGVmYXVsdFZhbHVlOlwiMHB4IHNvbGlkICMwMDBcIixwYXJzZXI6ZnVuY3Rpb24oYSxiLGMsZCxmLGcpe3JldHVybiB0aGlzLnBhcnNlQ29tcGxleChhLnN0eWxlLHRoaXMuZm9ybWF0KFgoYSxcImJvcmRlclRvcFdpZHRoXCIsZSwhMSxcIjBweFwiKStcIiBcIitYKGEsXCJib3JkZXJUb3BTdHlsZVwiLGUsITEsXCJzb2xpZFwiKStcIiBcIitYKGEsXCJib3JkZXJUb3BDb2xvclwiLGUsITEsXCIjMDAwXCIpKSx0aGlzLmZvcm1hdChiKSxmLGcpfSxjb2xvcjohMCxmb3JtYXR0ZXI6ZnVuY3Rpb24oYSl7dmFyIGI9YS5zcGxpdChcIiBcIik7cmV0dXJuIGJbMF0rXCIgXCIrKGJbMV18fFwic29saWRcIikrXCIgXCIrKGEubWF0Y2gobGEpfHxbXCIjMDAwXCJdKVswXX19KSx1YShcImJvcmRlcldpZHRoXCIse3BhcnNlcjpuYShcImJvcmRlclRvcFdpZHRoLGJvcmRlclJpZ2h0V2lkdGgsYm9yZGVyQm90dG9tV2lkdGgsYm9yZGVyTGVmdFdpZHRoXCIpfSksdWEoXCJmbG9hdCxjc3NGbG9hdCxzdHlsZUZsb2F0XCIse3BhcnNlcjpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGc9YS5zdHlsZSxoPVwiY3NzRmxvYXRcImluIGc/XCJjc3NGbG9hdFwiOlwic3R5bGVGbG9hdFwiO3JldHVybiBuZXcgcGEoZyxoLDAsMCxlLC0xLGMsITEsMCxnW2hdLGIpfX0pO3ZhciBPYT1mdW5jdGlvbihhKXt2YXIgYixjPXRoaXMudCxkPWMuZmlsdGVyfHxYKHRoaXMuZGF0YSxcImZpbHRlclwiKXx8XCJcIixlPXRoaXMucyt0aGlzLmMqYXwwOzEwMD09PWUmJigtMT09PWQuaW5kZXhPZihcImF0cml4KFwiKSYmLTE9PT1kLmluZGV4T2YoXCJyYWRpZW50KFwiKSYmLTE9PT1kLmluZGV4T2YoXCJvYWRlcihcIik/KGMucmVtb3ZlQXR0cmlidXRlKFwiZmlsdGVyXCIpLGI9IVgodGhpcy5kYXRhLFwiZmlsdGVyXCIpKTooYy5maWx0ZXI9ZC5yZXBsYWNlKHgsXCJcIiksYj0hMCkpLGJ8fCh0aGlzLnhuMSYmKGMuZmlsdGVyPWQ9ZHx8XCJhbHBoYShvcGFjaXR5PVwiK2UrXCIpXCIpLC0xPT09ZC5pbmRleE9mKFwicGFjaXR5XCIpPzA9PT1lJiZ0aGlzLnhuMXx8KGMuZmlsdGVyPWQrXCIgYWxwaGEob3BhY2l0eT1cIitlK1wiKVwiKTpjLmZpbHRlcj1kLnJlcGxhY2UodixcIm9wYWNpdHk9XCIrZSkpfTt1YShcIm9wYWNpdHksYWxwaGEsYXV0b0FscGhhXCIse2RlZmF1bHRWYWx1ZTpcIjFcIixwYXJzZXI6ZnVuY3Rpb24oYSxiLGMsZCxmLGcpe3ZhciBoPXBhcnNlRmxvYXQoWChhLFwib3BhY2l0eVwiLGUsITEsXCIxXCIpKSxpPWEuc3R5bGUsaj1cImF1dG9BbHBoYVwiPT09YztyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYiYmXCI9XCI9PT1iLmNoYXJBdCgxKSYmKGI9KFwiLVwiPT09Yi5jaGFyQXQoMCk/LTE6MSkqcGFyc2VGbG9hdChiLnN1YnN0cigyKSkraCksaiYmMT09PWgmJlwiaGlkZGVuXCI9PT1YKGEsXCJ2aXNpYmlsaXR5XCIsZSkmJjAhPT1iJiYoaD0wKSxRP2Y9bmV3IHBhKGksXCJvcGFjaXR5XCIsaCxiLWgsZik6KGY9bmV3IHBhKGksXCJvcGFjaXR5XCIsMTAwKmgsMTAwKihiLWgpLGYpLGYueG4xPWo/MTowLGkuem9vbT0xLGYudHlwZT0yLGYuYj1cImFscGhhKG9wYWNpdHk9XCIrZi5zK1wiKVwiLGYuZT1cImFscGhhKG9wYWNpdHk9XCIrKGYucytmLmMpK1wiKVwiLGYuZGF0YT1hLGYucGx1Z2luPWcsZi5zZXRSYXRpbz1PYSksaiYmKGY9bmV3IHBhKGksXCJ2aXNpYmlsaXR5XCIsMCwwLGYsLTEsbnVsbCwhMSwwLDAhPT1oP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCIsMD09PWI/XCJoaWRkZW5cIjpcImluaGVyaXRcIiksZi54czA9XCJpbmhlcml0XCIsZC5fb3ZlcndyaXRlUHJvcHMucHVzaChmLm4pLGQuX292ZXJ3cml0ZVByb3BzLnB1c2goYykpLGZ9fSk7dmFyIFBhPWZ1bmN0aW9uKGEsYil7YiYmKGEucmVtb3ZlUHJvcGVydHk/KChcIm1zXCI9PT1iLnN1YnN0cigwLDIpfHxcIndlYmtpdFwiPT09Yi5zdWJzdHIoMCw2KSkmJihiPVwiLVwiK2IpLGEucmVtb3ZlUHJvcGVydHkoYi5yZXBsYWNlKHosXCItJDFcIikudG9Mb3dlckNhc2UoKSkpOmEucmVtb3ZlQXR0cmlidXRlKGIpKX0sUWE9ZnVuY3Rpb24oYSl7aWYodGhpcy50Ll9nc0NsYXNzUFQ9dGhpcywxPT09YXx8MD09PWEpe3RoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLDA9PT1hP3RoaXMuYjp0aGlzLmUpO2Zvcih2YXIgYj10aGlzLmRhdGEsYz10aGlzLnQuc3R5bGU7YjspYi52P2NbYi5wXT1iLnY6UGEoYyxiLnApLGI9Yi5fbmV4dDsxPT09YSYmdGhpcy50Ll9nc0NsYXNzUFQ9PT10aGlzJiYodGhpcy50Ll9nc0NsYXNzUFQ9bnVsbCl9ZWxzZSB0aGlzLnQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikhPT10aGlzLmUmJnRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLHRoaXMuZSl9O3VhKFwiY2xhc3NOYW1lXCIse3BhcnNlcjpmdW5jdGlvbihhLGIsZCxmLGcsaCxpKXt2YXIgaixrLGwsbSxuLG89YS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIixwPWEuc3R5bGUuY3NzVGV4dDtpZihnPWYuX2NsYXNzTmFtZVBUPW5ldyBwYShhLGQsMCwwLGcsMiksZy5zZXRSYXRpbz1RYSxnLnByPS0xMSxjPSEwLGcuYj1vLGs9JChhLGUpLGw9YS5fZ3NDbGFzc1BUKXtmb3IobT17fSxuPWwuZGF0YTtuOyltW24ucF09MSxuPW4uX25leHQ7bC5zZXRSYXRpbygxKX1yZXR1cm4gYS5fZ3NDbGFzc1BUPWcsZy5lPVwiPVwiIT09Yi5jaGFyQXQoMSk/YjpvLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxzKlxcXFxiXCIrYi5zdWJzdHIoMikrXCJcXFxcYlwiKSxcIlwiKSsoXCIrXCI9PT1iLmNoYXJBdCgwKT9cIiBcIitiLnN1YnN0cigyKTpcIlwiKSxhLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsZy5lKSxqPV8oYSxrLCQoYSksaSxtKSxhLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsbyksZy5kYXRhPWouZmlyc3RNUFQsYS5zdHlsZS5jc3NUZXh0PXAsZz1nLnhmaXJzdD1mLnBhcnNlKGEsai5kaWZzLGcsaCl9fSk7dmFyIFJhPWZ1bmN0aW9uKGEpe2lmKCgxPT09YXx8MD09PWEpJiZ0aGlzLmRhdGEuX3RvdGFsVGltZT09PXRoaXMuZGF0YS5fdG90YWxEdXJhdGlvbiYmXCJpc0Zyb21TdGFydFwiIT09dGhpcy5kYXRhLmRhdGEpe3ZhciBiLGMsZCxlLGYsZz10aGlzLnQuc3R5bGUsaD1pLnRyYW5zZm9ybS5wYXJzZTtpZihcImFsbFwiPT09dGhpcy5lKWcuY3NzVGV4dD1cIlwiLGU9ITA7ZWxzZSBmb3IoYj10aGlzLmUuc3BsaXQoXCIgXCIpLmpvaW4oXCJcIikuc3BsaXQoXCIsXCIpLGQ9Yi5sZW5ndGg7LS1kPi0xOyljPWJbZF0saVtjXSYmKGlbY10ucGFyc2U9PT1oP2U9ITA6Yz1cInRyYW5zZm9ybU9yaWdpblwiPT09Yz9BYTppW2NdLnApLFBhKGcsYyk7ZSYmKFBhKGcseWEpLGY9dGhpcy50Ll9nc1RyYW5zZm9ybSxmJiYoZi5zdmcmJih0aGlzLnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpLHRoaXMudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpLGRlbGV0ZSB0aGlzLnQuX2dzVHJhbnNmb3JtKSl9fTtmb3IodWEoXCJjbGVhclByb3BzXCIse3BhcnNlcjpmdW5jdGlvbihhLGIsZCxlLGYpe3JldHVybiBmPW5ldyBwYShhLGQsMCwwLGYsMiksZi5zZXRSYXRpbz1SYSxmLmU9YixmLnByPS0xMCxmLmRhdGE9ZS5fdHdlZW4sYz0hMCxmfX0pLGo9XCJiZXppZXIsdGhyb3dQcm9wcyxwaHlzaWNzUHJvcHMscGh5c2ljczJEXCIuc3BsaXQoXCIsXCIpLHNhPWoubGVuZ3RoO3NhLS07KXZhKGpbc2FdKTtqPWcucHJvdG90eXBlLGouX2ZpcnN0UFQ9ai5fbGFzdFBhcnNlZFRyYW5zZm9ybT1qLl90cmFuc2Zvcm09bnVsbCxqLl9vbkluaXRUd2Vlbj1mdW5jdGlvbihhLGIsaCl7aWYoIWEubm9kZVR5cGUpcmV0dXJuITE7dGhpcy5fdGFyZ2V0PWEsdGhpcy5fdHdlZW49aCx0aGlzLl92YXJzPWIsaz1iLmF1dG9Sb3VuZCxjPSExLGQ9Yi5zdWZmaXhNYXB8fGcuc3VmZml4TWFwLGU9VyhhLFwiXCIpLGY9dGhpcy5fb3ZlcndyaXRlUHJvcHM7dmFyIGosbixwLHEscixzLHQsdSx2LHg9YS5zdHlsZTtpZihsJiZcIlwiPT09eC56SW5kZXgmJihqPVgoYSxcInpJbmRleFwiLGUpLChcImF1dG9cIj09PWp8fFwiXCI9PT1qKSYmdGhpcy5fYWRkTGF6eVNldCh4LFwiekluZGV4XCIsMCkpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiYocT14LmNzc1RleHQsaj0kKGEsZSkseC5jc3NUZXh0PXErXCI7XCIrYixqPV8oYSxqLCQoYSkpLmRpZnMsIVEmJncudGVzdChiKSYmKGoub3BhY2l0eT1wYXJzZUZsb2F0KFJlZ0V4cC4kMSkpLGI9aix4LmNzc1RleHQ9cSksYi5jbGFzc05hbWU/dGhpcy5fZmlyc3RQVD1uPWkuY2xhc3NOYW1lLnBhcnNlKGEsYi5jbGFzc05hbWUsXCJjbGFzc05hbWVcIix0aGlzLG51bGwsbnVsbCxiKTp0aGlzLl9maXJzdFBUPW49dGhpcy5wYXJzZShhLGIsbnVsbCksdGhpcy5fdHJhbnNmb3JtVHlwZSl7Zm9yKHY9Mz09PXRoaXMuX3RyYW5zZm9ybVR5cGUseWE/bSYmKGw9ITAsXCJcIj09PXguekluZGV4JiYodD1YKGEsXCJ6SW5kZXhcIixlKSwoXCJhdXRvXCI9PT10fHxcIlwiPT09dCkmJnRoaXMuX2FkZExhenlTZXQoeCxcInpJbmRleFwiLDApKSxvJiZ0aGlzLl9hZGRMYXp5U2V0KHgsXCJXZWJraXRCYWNrZmFjZVZpc2liaWxpdHlcIix0aGlzLl92YXJzLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eXx8KHY/XCJ2aXNpYmxlXCI6XCJoaWRkZW5cIikpKTp4Lnpvb209MSxwPW47cCYmcC5fbmV4dDspcD1wLl9uZXh0O3U9bmV3IHBhKGEsXCJ0cmFuc2Zvcm1cIiwwLDAsbnVsbCwyKSx0aGlzLl9saW5rQ1NTUCh1LG51bGwscCksdS5zZXRSYXRpbz15YT9OYTpNYSx1LmRhdGE9dGhpcy5fdHJhbnNmb3JtfHxMYShhLGUsITApLHUudHdlZW49aCx1LnByPS0xLGYucG9wKCl9aWYoYyl7Zm9yKDtuOyl7Zm9yKHM9bi5fbmV4dCxwPXE7cCYmcC5wcj5uLnByOylwPXAuX25leHQ7KG4uX3ByZXY9cD9wLl9wcmV2OnIpP24uX3ByZXYuX25leHQ9bjpxPW4sKG4uX25leHQ9cCk/cC5fcHJldj1uOnI9bixuPXN9dGhpcy5fZmlyc3RQVD1xfXJldHVybiEwfSxqLnBhcnNlPWZ1bmN0aW9uKGEsYixjLGYpe3ZhciBnLGgsaixsLG0sbixvLHAscSxyLHM9YS5zdHlsZTtmb3IoZyBpbiBiKW49YltnXSxoPWlbZ10saD9jPWgucGFyc2UoYSxuLGcsdGhpcyxjLGYsYik6KG09WChhLGcsZSkrXCJcIixxPVwic3RyaW5nXCI9PXR5cGVvZiBuLFwiY29sb3JcIj09PWd8fFwiZmlsbFwiPT09Z3x8XCJzdHJva2VcIj09PWd8fC0xIT09Zy5pbmRleE9mKFwiQ29sb3JcIil8fHEmJnkudGVzdChuKT8ocXx8KG49amEobiksbj0obi5sZW5ndGg+Mz9cInJnYmEoXCI6XCJyZ2IoXCIpK24uam9pbihcIixcIikrXCIpXCIpLGM9cmEocyxnLG0sbiwhMCxcInRyYW5zcGFyZW50XCIsYywwLGYpKTohcXx8LTE9PT1uLmluZGV4T2YoXCIgXCIpJiYtMT09PW4uaW5kZXhPZihcIixcIik/KGo9cGFyc2VGbG9hdChtKSxvPWp8fDA9PT1qP20uc3Vic3RyKChqK1wiXCIpLmxlbmd0aCk6XCJcIiwoXCJcIj09PW18fFwiYXV0b1wiPT09bSkmJihcIndpZHRoXCI9PT1nfHxcImhlaWdodFwiPT09Zz8oaj1jYShhLGcsZSksbz1cInB4XCIpOlwibGVmdFwiPT09Z3x8XCJ0b3BcIj09PWc/KGo9WihhLGcsZSksbz1cInB4XCIpOihqPVwib3BhY2l0eVwiIT09Zz8wOjEsbz1cIlwiKSkscj1xJiZcIj1cIj09PW4uY2hhckF0KDEpLHI/KGw9cGFyc2VJbnQobi5jaGFyQXQoMCkrXCIxXCIsMTApLG49bi5zdWJzdHIoMiksbCo9cGFyc2VGbG9hdChuKSxwPW4ucmVwbGFjZSh1LFwiXCIpKToobD1wYXJzZUZsb2F0KG4pLHA9cT9uLnJlcGxhY2UodSxcIlwiKTpcIlwiKSxcIlwiPT09cCYmKHA9ZyBpbiBkP2RbZ106byksbj1sfHwwPT09bD8ocj9sK2o6bCkrcDpiW2ddLG8hPT1wJiZcIlwiIT09cCYmKGx8fDA9PT1sKSYmaiYmKGo9WShhLGcsaixvKSxcIiVcIj09PXA/KGovPVkoYSxnLDEwMCxcIiVcIikvMTAwLGIuc3RyaWN0VW5pdHMhPT0hMCYmKG09aitcIiVcIikpOlwiZW1cIj09PXB8fFwicmVtXCI9PT1wfHxcInZ3XCI9PT1wfHxcInZoXCI9PT1wP2ovPVkoYSxnLDEscCk6XCJweFwiIT09cCYmKGw9WShhLGcsbCxwKSxwPVwicHhcIiksciYmKGx8fDA9PT1sKSYmKG49bCtqK3ApKSxyJiYobCs9aiksIWomJjAhPT1qfHwhbCYmMCE9PWw/dm9pZCAwIT09c1tnXSYmKG58fG4rXCJcIiE9XCJOYU5cIiYmbnVsbCE9bik/KGM9bmV3IHBhKHMsZyxsfHxqfHwwLDAsYywtMSxnLCExLDAsbSxuKSxjLnhzMD1cIm5vbmVcIiE9PW58fFwiZGlzcGxheVwiIT09ZyYmLTE9PT1nLmluZGV4T2YoXCJTdHlsZVwiKT9uOm0pOlMoXCJpbnZhbGlkIFwiK2crXCIgdHdlZW4gdmFsdWU6IFwiK2JbZ10pOihjPW5ldyBwYShzLGcsaixsLWosYywwLGcsayE9PSExJiYoXCJweFwiPT09cHx8XCJ6SW5kZXhcIj09PWcpLDAsbSxuKSxjLnhzMD1wKSk6Yz1yYShzLGcsbSxuLCEwLG51bGwsYywwLGYpKSxmJiZjJiYhYy5wbHVnaW4mJihjLnBsdWdpbj1mKTtyZXR1cm4gY30sai5zZXRSYXRpbz1mdW5jdGlvbihhKXt2YXIgYixjLGQsZT10aGlzLl9maXJzdFBULGY9MWUtNjtpZigxIT09YXx8dGhpcy5fdHdlZW4uX3RpbWUhPT10aGlzLl90d2Vlbi5fZHVyYXRpb24mJjAhPT10aGlzLl90d2Vlbi5fdGltZSlpZihhfHx0aGlzLl90d2Vlbi5fdGltZSE9PXRoaXMuX3R3ZWVuLl9kdXJhdGlvbiYmMCE9PXRoaXMuX3R3ZWVuLl90aW1lfHx0aGlzLl90d2Vlbi5fcmF3UHJldlRpbWU9PT0tMWUtNilmb3IoO2U7KXtpZihiPWUuYyphK2UucyxlLnI/Yj1NYXRoLnJvdW5kKGIpOmY+YiYmYj4tZiYmKGI9MCksZS50eXBlKWlmKDE9PT1lLnR5cGUpaWYoZD1lLmwsMj09PWQpZS50W2UucF09ZS54czArYitlLnhzMStlLnhuMStlLnhzMjtlbHNlIGlmKDM9PT1kKWUudFtlLnBdPWUueHMwK2IrZS54czErZS54bjErZS54czIrZS54bjIrZS54czM7ZWxzZSBpZig0PT09ZCllLnRbZS5wXT1lLnhzMCtiK2UueHMxK2UueG4xK2UueHMyK2UueG4yK2UueHMzK2UueG4zK2UueHM0O2Vsc2UgaWYoNT09PWQpZS50W2UucF09ZS54czArYitlLnhzMStlLnhuMStlLnhzMitlLnhuMitlLnhzMytlLnhuMytlLnhzNCtlLnhuNCtlLnhzNTtlbHNle2ZvcihjPWUueHMwK2IrZS54czEsZD0xO2Q8ZS5sO2QrKyljKz1lW1wieG5cIitkXStlW1wieHNcIisoZCsxKV07ZS50W2UucF09Y31lbHNlLTE9PT1lLnR5cGU/ZS50W2UucF09ZS54czA6ZS5zZXRSYXRpbyYmZS5zZXRSYXRpbyhhKTtlbHNlIGUudFtlLnBdPWIrZS54czA7ZT1lLl9uZXh0fWVsc2UgZm9yKDtlOykyIT09ZS50eXBlP2UudFtlLnBdPWUuYjplLnNldFJhdGlvKGEpLGU9ZS5fbmV4dDtlbHNlIGZvcig7ZTspe2lmKDIhPT1lLnR5cGUpaWYoZS5yJiYtMSE9PWUudHlwZSlpZihiPU1hdGgucm91bmQoZS5zK2UuYyksZS50eXBlKXtpZigxPT09ZS50eXBlKXtmb3IoZD1lLmwsYz1lLnhzMCtiK2UueHMxLGQ9MTtkPGUubDtkKyspYys9ZVtcInhuXCIrZF0rZVtcInhzXCIrKGQrMSldO2UudFtlLnBdPWN9fWVsc2UgZS50W2UucF09YitlLnhzMDtlbHNlIGUudFtlLnBdPWUuZTtlbHNlIGUuc2V0UmF0aW8oYSk7ZT1lLl9uZXh0fX0sai5fZW5hYmxlVHJhbnNmb3Jtcz1mdW5jdGlvbihhKXt0aGlzLl90cmFuc2Zvcm09dGhpcy5fdHJhbnNmb3JtfHxMYSh0aGlzLl90YXJnZXQsZSwhMCksdGhpcy5fdHJhbnNmb3JtVHlwZT10aGlzLl90cmFuc2Zvcm0uc3ZnJiZ3YXx8IWEmJjMhPT10aGlzLl90cmFuc2Zvcm1UeXBlPzI6M307dmFyIFNhPWZ1bmN0aW9uKGEpe3RoaXMudFt0aGlzLnBdPXRoaXMuZSx0aGlzLmRhdGEuX2xpbmtDU1NQKHRoaXMsdGhpcy5fbmV4dCxudWxsLCEwKX07ai5fYWRkTGF6eVNldD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5fZmlyc3RQVD1uZXcgcGEoYSxiLDAsMCx0aGlzLl9maXJzdFBULDIpO2QuZT1jLGQuc2V0UmF0aW89U2EsZC5kYXRhPXRoaXN9LGouX2xpbmtDU1NQPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBhJiYoYiYmKGIuX3ByZXY9YSksYS5fbmV4dCYmKGEuX25leHQuX3ByZXY9YS5fcHJldiksYS5fcHJldj9hLl9wcmV2Ll9uZXh0PWEuX25leHQ6dGhpcy5fZmlyc3RQVD09PWEmJih0aGlzLl9maXJzdFBUPWEuX25leHQsZD0hMCksYz9jLl9uZXh0PWE6ZHx8bnVsbCE9PXRoaXMuX2ZpcnN0UFR8fCh0aGlzLl9maXJzdFBUPWEpLGEuX25leHQ9YixhLl9wcmV2PWMpLGF9LGouX2tpbGw9ZnVuY3Rpb24oYil7dmFyIGMsZCxlLGY9YjtpZihiLmF1dG9BbHBoYXx8Yi5hbHBoYSl7Zj17fTtmb3IoZCBpbiBiKWZbZF09YltkXTtmLm9wYWNpdHk9MSxmLmF1dG9BbHBoYSYmKGYudmlzaWJpbGl0eT0xKX1yZXR1cm4gYi5jbGFzc05hbWUmJihjPXRoaXMuX2NsYXNzTmFtZVBUKSYmKGU9Yy54Zmlyc3QsZSYmZS5fcHJldj90aGlzLl9saW5rQ1NTUChlLl9wcmV2LGMuX25leHQsZS5fcHJldi5fcHJldik6ZT09PXRoaXMuX2ZpcnN0UFQmJih0aGlzLl9maXJzdFBUPWMuX25leHQpLGMuX25leHQmJnRoaXMuX2xpbmtDU1NQKGMuX25leHQsYy5fbmV4dC5fbmV4dCxlLl9wcmV2KSx0aGlzLl9jbGFzc05hbWVQVD1udWxsKSxhLnByb3RvdHlwZS5fa2lsbC5jYWxsKHRoaXMsZil9O3ZhciBUYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGc7aWYoYS5zbGljZSlmb3IoZT1hLmxlbmd0aDstLWU+LTE7KVRhKGFbZV0sYixjKTtlbHNlIGZvcihkPWEuY2hpbGROb2RlcyxlPWQubGVuZ3RoOy0tZT4tMTspZj1kW2VdLGc9Zi50eXBlLGYuc3R5bGUmJihiLnB1c2goJChmKSksYyYmYy5wdXNoKGYpKSwxIT09ZyYmOSE9PWcmJjExIT09Z3x8IWYuY2hpbGROb2Rlcy5sZW5ndGh8fFRhKGYsYixjKX07cmV0dXJuIGcuY2FzY2FkZVRvPWZ1bmN0aW9uKGEsYyxkKXt2YXIgZSxmLGcsaCxpPWIudG8oYSxjLGQpLGo9W2ldLGs9W10sbD1bXSxtPVtdLG49Yi5faW50ZXJuYWxzLnJlc2VydmVkUHJvcHM7Zm9yKGE9aS5fdGFyZ2V0c3x8aS50YXJnZXQsVGEoYSxrLG0pLGkucmVuZGVyKGMsITAsITApLFRhKGEsbCksaS5yZW5kZXIoMCwhMCwhMCksaS5fZW5hYmxlZCghMCksZT1tLmxlbmd0aDstLWU+LTE7KWlmKGY9XyhtW2VdLGtbZV0sbFtlXSksZi5maXJzdE1QVCl7Zj1mLmRpZnM7Zm9yKGcgaW4gZCluW2ddJiYoZltnXT1kW2ddKTtoPXt9O2ZvcihnIGluIGYpaFtnXT1rW2VdW2ddO2oucHVzaChiLmZyb21UbyhtW2VdLGMsaCxmKSl9cmV0dXJuIGp9LGEuYWN0aXZhdGUoW2ddKSxnfSwhMCksZnVuY3Rpb24oKXt2YXIgYT1fZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtwcm9wTmFtZTpcInJvdW5kUHJvcHNcIix2ZXJzaW9uOlwiMS41XCIscHJpb3JpdHk6LTEsQVBJOjIsaW5pdDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuX3R3ZWVuPWMsITB9fSksYj1mdW5jdGlvbihhKXtmb3IoO2E7KWEuZnx8YS5ibG9ifHwoYS5yPTEpLGE9YS5fbmV4dH0sYz1hLnByb3RvdHlwZTtjLl9vbkluaXRBbGxQcm9wcz1mdW5jdGlvbigpe2Zvcih2YXIgYSxjLGQsZT10aGlzLl90d2VlbixmPWUudmFycy5yb3VuZFByb3BzLmpvaW4/ZS52YXJzLnJvdW5kUHJvcHM6ZS52YXJzLnJvdW5kUHJvcHMuc3BsaXQoXCIsXCIpLGc9Zi5sZW5ndGgsaD17fSxpPWUuX3Byb3BMb29rdXAucm91bmRQcm9wczstLWc+LTE7KWhbZltnXV09MTtmb3IoZz1mLmxlbmd0aDstLWc+LTE7KWZvcihhPWZbZ10sYz1lLl9maXJzdFBUO2M7KWQ9Yy5fbmV4dCxjLnBnP2MudC5fcm91bmRQcm9wcyhoLCEwKTpjLm49PT1hJiYoMj09PWMuZiYmYy50P2IoYy50Ll9maXJzdFBUKToodGhpcy5fYWRkKGMudCxhLGMucyxjLmMpLGQmJihkLl9wcmV2PWMuX3ByZXYpLGMuX3ByZXY/Yy5fcHJldi5fbmV4dD1kOmUuX2ZpcnN0UFQ9PT1jJiYoZS5fZmlyc3RQVD1kKSxjLl9uZXh0PWMuX3ByZXY9bnVsbCxlLl9wcm9wTG9va3VwW2FdPWkpKSxjPWQ7cmV0dXJuITF9LGMuX2FkZD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLl9hZGRUd2VlbihhLGIsYyxjK2QsYiwhMCksdGhpcy5fb3ZlcndyaXRlUHJvcHMucHVzaChiKX19KCksZnVuY3Rpb24oKXtfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtwcm9wTmFtZTpcImF0dHJcIixBUEk6Mix2ZXJzaW9uOlwiMC41LjBcIixpbml0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZDtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBhLnNldEF0dHJpYnV0ZSlyZXR1cm4hMTtmb3IoZCBpbiBiKXRoaXMuX2FkZFR3ZWVuKGEsXCJzZXRBdHRyaWJ1dGVcIixhLmdldEF0dHJpYnV0ZShkKStcIlwiLGJbZF0rXCJcIixkLCExLGQpLHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2goZCk7cmV0dXJuITB9fSl9KCksX2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7cHJvcE5hbWU6XCJkaXJlY3Rpb25hbFJvdGF0aW9uXCIsdmVyc2lvbjpcIjAuMi4xXCIsQVBJOjIsaW5pdDpmdW5jdGlvbihhLGIsYyl7XCJvYmplY3RcIiE9dHlwZW9mIGImJihiPXtyb3RhdGlvbjpifSksdGhpcy5maW5hbHM9e307dmFyIGQsZSxmLGcsaCxpLGo9Yi51c2VSYWRpYW5zPT09ITA/MipNYXRoLlBJOjM2MCxrPTFlLTY7Zm9yKGQgaW4gYilcInVzZVJhZGlhbnNcIiE9PWQmJihpPShiW2RdK1wiXCIpLnNwbGl0KFwiX1wiKSxlPWlbMF0sZj1wYXJzZUZsb2F0KFwiZnVuY3Rpb25cIiE9dHlwZW9mIGFbZF0/YVtkXTphW2QuaW5kZXhPZihcInNldFwiKXx8XCJmdW5jdGlvblwiIT10eXBlb2YgYVtcImdldFwiK2Quc3Vic3RyKDMpXT9kOlwiZ2V0XCIrZC5zdWJzdHIoMyldKCkpLGc9dGhpcy5maW5hbHNbZF09XCJzdHJpbmdcIj09dHlwZW9mIGUmJlwiPVwiPT09ZS5jaGFyQXQoMSk/ZitwYXJzZUludChlLmNoYXJBdCgwKStcIjFcIiwxMCkqTnVtYmVyKGUuc3Vic3RyKDIpKTpOdW1iZXIoZSl8fDAsaD1nLWYsaS5sZW5ndGgmJihlPWkuam9pbihcIl9cIiksLTEhPT1lLmluZGV4T2YoXCJzaG9ydFwiKSYmKGglPWosaCE9PWglKGovMikmJihoPTA+aD9oK2o6aC1qKSksLTEhPT1lLmluZGV4T2YoXCJfY3dcIikmJjA+aD9oPShoKzk5OTk5OTk5OTkqaiklai0oaC9qfDApKmo6LTEhPT1lLmluZGV4T2YoXCJjY3dcIikmJmg+MCYmKGg9KGgtOTk5OTk5OTk5OSpqKSVqLShoL2p8MCkqaikpLChoPmt8fC1rPmgpJiYodGhpcy5fYWRkVHdlZW4oYSxkLGYsZitoLGQpLHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2goZCkpKTtyZXR1cm4hMH0sc2V0OmZ1bmN0aW9uKGEpe3ZhciBiO2lmKDEhPT1hKXRoaXMuX3N1cGVyLnNldFJhdGlvLmNhbGwodGhpcyxhKTtlbHNlIGZvcihiPXRoaXMuX2ZpcnN0UFQ7YjspYi5mP2IudFtiLnBdKHRoaXMuZmluYWxzW2IucF0pOmIudFtiLnBdPXRoaXMuZmluYWxzW2IucF0sYj1iLl9uZXh0fX0pLl9hdXRvQ1NTPSEwLF9nc1Njb3BlLl9nc0RlZmluZShcImVhc2luZy5CYWNrXCIsW1wiZWFzaW5nLkVhc2VcIl0sZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU9X2dzU2NvcGUuR3JlZW5Tb2NrR2xvYmFsc3x8X2dzU2NvcGUsZj1lLmNvbS5ncmVlbnNvY2ssZz0yKk1hdGguUEksaD1NYXRoLlBJLzIsaT1mLl9jbGFzcyxqPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9aShcImVhc2luZy5cIitiLGZ1bmN0aW9uKCl7fSwhMCksZT1kLnByb3RvdHlwZT1uZXcgYTtyZXR1cm4gZS5jb25zdHJ1Y3Rvcj1kLGUuZ2V0UmF0aW89YyxkfSxrPWEucmVnaXN0ZXJ8fGZ1bmN0aW9uKCl7fSxsPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9aShcImVhc2luZy5cIithLHtlYXNlT3V0Om5ldyBiLGVhc2VJbjpuZXcgYyxlYXNlSW5PdXQ6bmV3IGR9LCEwKTtyZXR1cm4gayhmLGEpLGZ9LG09ZnVuY3Rpb24oYSxiLGMpe3RoaXMudD1hLHRoaXMudj1iLGMmJih0aGlzLm5leHQ9YyxjLnByZXY9dGhpcyx0aGlzLmM9Yy52LWIsdGhpcy5nYXA9Yy50LWEpfSxuPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9aShcImVhc2luZy5cIitiLGZ1bmN0aW9uKGEpe3RoaXMuX3AxPWF8fDA9PT1hP2E6MS43MDE1OCx0aGlzLl9wMj0xLjUyNSp0aGlzLl9wMX0sITApLGU9ZC5wcm90b3R5cGU9bmV3IGE7cmV0dXJuIGUuY29uc3RydWN0b3I9ZCxlLmdldFJhdGlvPWMsZS5jb25maWc9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBkKGEpfSxkfSxvPWwoXCJCYWNrXCIsbihcIkJhY2tPdXRcIixmdW5jdGlvbihhKXtyZXR1cm4oYS09MSkqYSooKHRoaXMuX3AxKzEpKmErdGhpcy5fcDEpKzF9KSxuKFwiQmFja0luXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEqYSooKHRoaXMuX3AxKzEpKmEtdGhpcy5fcDEpfSksbihcIkJhY2tJbk91dFwiLGZ1bmN0aW9uKGEpe3JldHVybihhKj0yKTwxPy41KmEqYSooKHRoaXMuX3AyKzEpKmEtdGhpcy5fcDIpOi41KigoYS09MikqYSooKHRoaXMuX3AyKzEpKmErdGhpcy5fcDIpKzIpfSkpLHA9aShcImVhc2luZy5TbG93TW9cIixmdW5jdGlvbihhLGIsYyl7Yj1ifHwwPT09Yj9iOi43LG51bGw9PWE/YT0uNzphPjEmJihhPTEpLHRoaXMuX3A9MSE9PWE/YjowLHRoaXMuX3AxPSgxLWEpLzIsdGhpcy5fcDI9YSx0aGlzLl9wMz10aGlzLl9wMSt0aGlzLl9wMix0aGlzLl9jYWxjRW5kPWM9PT0hMH0sITApLHE9cC5wcm90b3R5cGU9bmV3IGE7cmV0dXJuIHEuY29uc3RydWN0b3I9cCxxLmdldFJhdGlvPWZ1bmN0aW9uKGEpe3ZhciBiPWErKC41LWEpKnRoaXMuX3A7cmV0dXJuIGE8dGhpcy5fcDE/dGhpcy5fY2FsY0VuZD8xLShhPTEtYS90aGlzLl9wMSkqYTpiLShhPTEtYS90aGlzLl9wMSkqYSphKmEqYjphPnRoaXMuX3AzP3RoaXMuX2NhbGNFbmQ/MS0oYT0oYS10aGlzLl9wMykvdGhpcy5fcDEpKmE6YisoYS1iKSooYT0oYS10aGlzLl9wMykvdGhpcy5fcDEpKmEqYSphOnRoaXMuX2NhbGNFbmQ/MTpifSxwLmVhc2U9bmV3IHAoLjcsLjcpLHEuY29uZmlnPXAuY29uZmlnPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IHAoYSxiLGMpfSxiPWkoXCJlYXNpbmcuU3RlcHBlZEVhc2VcIixmdW5jdGlvbihhKXthPWF8fDEsdGhpcy5fcDE9MS9hLHRoaXMuX3AyPWErMX0sITApLHE9Yi5wcm90b3R5cGU9bmV3IGEscS5jb25zdHJ1Y3Rvcj1iLHEuZ2V0UmF0aW89ZnVuY3Rpb24oYSl7cmV0dXJuIDA+YT9hPTA6YT49MSYmKGE9Ljk5OTk5OTk5OSksKHRoaXMuX3AyKmE+PjApKnRoaXMuX3AxfSxxLmNvbmZpZz1iLmNvbmZpZz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGIoYSl9LGM9aShcImVhc2luZy5Sb3VnaEVhc2VcIixmdW5jdGlvbihiKXtiPWJ8fHt9O2Zvcih2YXIgYyxkLGUsZixnLGgsaT1iLnRhcGVyfHxcIm5vbmVcIixqPVtdLGs9MCxsPTB8KGIucG9pbnRzfHwyMCksbj1sLG89Yi5yYW5kb21pemUhPT0hMSxwPWIuY2xhbXA9PT0hMCxxPWIudGVtcGxhdGUgaW5zdGFuY2VvZiBhP2IudGVtcGxhdGU6bnVsbCxyPVwibnVtYmVyXCI9PXR5cGVvZiBiLnN0cmVuZ3RoPy40KmIuc3RyZW5ndGg6LjQ7LS1uPi0xOyljPW8/TWF0aC5yYW5kb20oKToxL2wqbixkPXE/cS5nZXRSYXRpbyhjKTpjLFwibm9uZVwiPT09aT9lPXI6XCJvdXRcIj09PWk/KGY9MS1jLGU9ZipmKnIpOlwiaW5cIj09PWk/ZT1jKmMqcjouNT5jPyhmPTIqYyxlPWYqZiouNSpyKTooZj0yKigxLWMpLGU9ZipmKi41KnIpLG8/ZCs9TWF0aC5yYW5kb20oKSplLS41KmU6biUyP2QrPS41KmU6ZC09LjUqZSxwJiYoZD4xP2Q9MTowPmQmJihkPTApKSxqW2srK109e3g6Yyx5OmR9O2ZvcihqLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS54LWIueH0pLGg9bmV3IG0oMSwxLG51bGwpLG49bDstLW4+LTE7KWc9altuXSxoPW5ldyBtKGcueCxnLnksaCk7dGhpcy5fcHJldj1uZXcgbSgwLDAsMCE9PWgudD9oOmgubmV4dCl9LCEwKSxxPWMucHJvdG90eXBlPW5ldyBhLHEuY29uc3RydWN0b3I9YyxxLmdldFJhdGlvPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuX3ByZXY7aWYoYT5iLnQpe2Zvcig7Yi5uZXh0JiZhPj1iLnQ7KWI9Yi5uZXh0O2I9Yi5wcmV2fWVsc2UgZm9yKDtiLnByZXYmJmE8PWIudDspYj1iLnByZXY7cmV0dXJuIHRoaXMuX3ByZXY9YixiLnYrKGEtYi50KS9iLmdhcCpiLmN9LHEuY29uZmlnPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhKX0sYy5lYXNlPW5ldyBjLGwoXCJCb3VuY2VcIixqKFwiQm91bmNlT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIDEvMi43NT5hPzcuNTYyNSphKmE6Mi8yLjc1PmE/Ny41NjI1KihhLT0xLjUvMi43NSkqYSsuNzU6Mi41LzIuNzU+YT83LjU2MjUqKGEtPTIuMjUvMi43NSkqYSsuOTM3NTo3LjU2MjUqKGEtPTIuNjI1LzIuNzUpKmErLjk4NDM3NX0pLGooXCJCb3VuY2VJblwiLGZ1bmN0aW9uKGEpe3JldHVybihhPTEtYSk8MS8yLjc1PzEtNy41NjI1KmEqYToyLzIuNzU+YT8xLSg3LjU2MjUqKGEtPTEuNS8yLjc1KSphKy43NSk6Mi41LzIuNzU+YT8xLSg3LjU2MjUqKGEtPTIuMjUvMi43NSkqYSsuOTM3NSk6MS0oNy41NjI1KihhLT0yLjYyNS8yLjc1KSphKy45ODQzNzUpfSksaihcIkJvdW5jZUluT3V0XCIsZnVuY3Rpb24oYSl7dmFyIGI9LjU+YTtyZXR1cm4gYT1iPzEtMiphOjIqYS0xLGE9MS8yLjc1PmE/Ny41NjI1KmEqYToyLzIuNzU+YT83LjU2MjUqKGEtPTEuNS8yLjc1KSphKy43NToyLjUvMi43NT5hPzcuNTYyNSooYS09Mi4yNS8yLjc1KSphKy45Mzc1OjcuNTYyNSooYS09Mi42MjUvMi43NSkqYSsuOTg0Mzc1LGI/LjUqKDEtYSk6LjUqYSsuNX0pKSxsKFwiQ2lyY1wiLGooXCJDaXJjT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGguc3FydCgxLShhLT0xKSphKX0pLGooXCJDaXJjSW5cIixmdW5jdGlvbihhKXtyZXR1cm4tKE1hdGguc3FydCgxLWEqYSktMSl9KSxqKFwiQ2lyY0luT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuKGEqPTIpPDE/LS41KihNYXRoLnNxcnQoMS1hKmEpLTEpOi41KihNYXRoLnNxcnQoMS0oYS09MikqYSkrMSl9KSksZD1mdW5jdGlvbihiLGMsZCl7dmFyIGU9aShcImVhc2luZy5cIitiLGZ1bmN0aW9uKGEsYil7dGhpcy5fcDE9YT49MT9hOjEsdGhpcy5fcDI9KGJ8fGQpLygxPmE/YToxKSx0aGlzLl9wMz10aGlzLl9wMi9nKihNYXRoLmFzaW4oMS90aGlzLl9wMSl8fDApLHRoaXMuX3AyPWcvdGhpcy5fcDJ9LCEwKSxmPWUucHJvdG90eXBlPW5ldyBhO3JldHVybiBmLmNvbnN0cnVjdG9yPWUsZi5nZXRSYXRpbz1jLGYuY29uZmlnPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBlKGEsYil9LGV9LGwoXCJFbGFzdGljXCIsZChcIkVsYXN0aWNPdXRcIixmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fcDEqTWF0aC5wb3coMiwtMTAqYSkqTWF0aC5zaW4oKGEtdGhpcy5fcDMpKnRoaXMuX3AyKSsxfSwuMyksZChcIkVsYXN0aWNJblwiLGZ1bmN0aW9uKGEpe3JldHVybi0odGhpcy5fcDEqTWF0aC5wb3coMiwxMCooYS09MSkpKk1hdGguc2luKChhLXRoaXMuX3AzKSp0aGlzLl9wMikpfSwuMyksZChcIkVsYXN0aWNJbk91dFwiLGZ1bmN0aW9uKGEpe3JldHVybihhKj0yKTwxPy0uNSoodGhpcy5fcDEqTWF0aC5wb3coMiwxMCooYS09MSkpKk1hdGguc2luKChhLXRoaXMuX3AzKSp0aGlzLl9wMikpOnRoaXMuX3AxKk1hdGgucG93KDIsLTEwKihhLT0xKSkqTWF0aC5zaW4oKGEtdGhpcy5fcDMpKnRoaXMuX3AyKSouNSsxfSwuNDUpKSxsKFwiRXhwb1wiLGooXCJFeHBvT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIDEtTWF0aC5wb3coMiwtMTAqYSl9KSxqKFwiRXhwb0luXCIsZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucG93KDIsMTAqKGEtMSkpLS4wMDF9KSxqKFwiRXhwb0luT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuKGEqPTIpPDE/LjUqTWF0aC5wb3coMiwxMCooYS0xKSk6LjUqKDItTWF0aC5wb3coMiwtMTAqKGEtMSkpKX0pKSxsKFwiU2luZVwiLGooXCJTaW5lT3V0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGguc2luKGEqaCl9KSxqKFwiU2luZUluXCIsZnVuY3Rpb24oYSl7cmV0dXJuLU1hdGguY29zKGEqaCkrMX0pLGooXCJTaW5lSW5PdXRcIixmdW5jdGlvbihhKXtyZXR1cm4tLjUqKE1hdGguY29zKE1hdGguUEkqYSktMSl9KSksaShcImVhc2luZy5FYXNlTG9va3VwXCIse2ZpbmQ6ZnVuY3Rpb24oYil7cmV0dXJuIGEubWFwW2JdfX0sITApLGsoZS5TbG93TW8sXCJTbG93TW9cIixcImVhc2UsXCIpLGsoYyxcIlJvdWdoRWFzZVwiLFwiZWFzZSxcIiksayhiLFwiU3RlcHBlZEVhc2VcIixcImVhc2UsXCIpLG99LCEwKX0pLF9nc1Njb3BlLl9nc0RlZmluZSYmX2dzU2NvcGUuX2dzUXVldWUucG9wKCkoKSxmdW5jdGlvbihhLGIpe1widXNlIHN0cmljdFwiO3ZhciBjPWEuR3JlZW5Tb2NrR2xvYmFscz1hLkdyZWVuU29ja0dsb2JhbHN8fGE7aWYoIWMuVHdlZW5MaXRlKXt2YXIgZCxlLGYsZyxoLGk9ZnVuY3Rpb24oYSl7dmFyIGIsZD1hLnNwbGl0KFwiLlwiKSxlPWM7Zm9yKGI9MDtiPGQubGVuZ3RoO2IrKyllW2RbYl1dPWU9ZVtkW2JdXXx8e307cmV0dXJuIGV9LGo9aShcImNvbS5ncmVlbnNvY2tcIiksaz0xZS0xMCxsPWZ1bmN0aW9uKGEpe3ZhciBiLGM9W10sZD1hLmxlbmd0aDtmb3IoYj0wO2IhPT1kO2MucHVzaChhW2IrK10pKTtyZXR1cm4gY30sbT1mdW5jdGlvbigpe30sbj1mdW5jdGlvbigpe3ZhciBhPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsYj1hLmNhbGwoW10pO3JldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gbnVsbCE9YyYmKGMgaW5zdGFuY2VvZiBBcnJheXx8XCJvYmplY3RcIj09dHlwZW9mIGMmJiEhYy5wdXNoJiZhLmNhbGwoYyk9PT1iKX19KCksbz17fSxwPWZ1bmN0aW9uKGQsZSxmLGcpe3RoaXMuc2M9b1tkXT9vW2RdLnNjOltdLG9bZF09dGhpcyx0aGlzLmdzQ2xhc3M9bnVsbCx0aGlzLmZ1bmM9Zjt2YXIgaD1bXTt0aGlzLmNoZWNrPWZ1bmN0aW9uKGope2Zvcih2YXIgayxsLG0sbixxLHI9ZS5sZW5ndGgscz1yOy0tcj4tMTspKGs9b1tlW3JdXXx8bmV3IHAoZVtyXSxbXSkpLmdzQ2xhc3M/KGhbcl09ay5nc0NsYXNzLHMtLSk6aiYmay5zYy5wdXNoKHRoaXMpO2lmKDA9PT1zJiZmKWZvcihsPShcImNvbS5ncmVlbnNvY2suXCIrZCkuc3BsaXQoXCIuXCIpLG09bC5wb3AoKSxuPWkobC5qb2luKFwiLlwiKSlbbV09dGhpcy5nc0NsYXNzPWYuYXBwbHkoZixoKSxnJiYoY1ttXT1uLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMsIXEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoKGEuR3JlZW5Tb2NrQU1EUGF0aD9hLkdyZWVuU29ja0FNRFBhdGgrXCIvXCI6XCJcIikrZC5zcGxpdChcIi5cIikucG9wKCksW10sZnVuY3Rpb24oKXtyZXR1cm4gbn0pOmQ9PT1iJiZxJiYobW9kdWxlLmV4cG9ydHM9bikpLHI9MDtyPHRoaXMuc2MubGVuZ3RoO3IrKyl0aGlzLnNjW3JdLmNoZWNrKCl9LHRoaXMuY2hlY2soITApfSxxPWEuX2dzRGVmaW5lPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBuZXcgcChhLGIsYyxkKX0scj1qLl9jbGFzcz1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGI9Ynx8ZnVuY3Rpb24oKXt9LHEoYSxbXSxmdW5jdGlvbigpe3JldHVybiBifSxjKSxifTtxLmdsb2JhbHM9Yzt2YXIgcz1bMCwwLDEsMV0sdD1bXSx1PXIoXCJlYXNpbmcuRWFzZVwiLGZ1bmN0aW9uKGEsYixjLGQpe3RoaXMuX2Z1bmM9YSx0aGlzLl90eXBlPWN8fDAsdGhpcy5fcG93ZXI9ZHx8MCx0aGlzLl9wYXJhbXM9Yj9zLmNvbmNhdChiKTpzfSwhMCksdj11Lm1hcD17fSx3PXUucmVnaXN0ZXI9ZnVuY3Rpb24oYSxiLGMsZCl7Zm9yKHZhciBlLGYsZyxoLGk9Yi5zcGxpdChcIixcIiksaz1pLmxlbmd0aCxsPShjfHxcImVhc2VJbixlYXNlT3V0LGVhc2VJbk91dFwiKS5zcGxpdChcIixcIik7LS1rPi0xOylmb3IoZj1pW2tdLGU9ZD9yKFwiZWFzaW5nLlwiK2YsbnVsbCwhMCk6ai5lYXNpbmdbZl18fHt9LGc9bC5sZW5ndGg7LS1nPi0xOyloPWxbZ10sdltmK1wiLlwiK2hdPXZbaCtmXT1lW2hdPWEuZ2V0UmF0aW8/YTphW2hdfHxuZXcgYX07Zm9yKGY9dS5wcm90b3R5cGUsZi5fY2FsY0VuZD0hMSxmLmdldFJhdGlvPWZ1bmN0aW9uKGEpe2lmKHRoaXMuX2Z1bmMpcmV0dXJuIHRoaXMuX3BhcmFtc1swXT1hLHRoaXMuX2Z1bmMuYXBwbHkobnVsbCx0aGlzLl9wYXJhbXMpO3ZhciBiPXRoaXMuX3R5cGUsYz10aGlzLl9wb3dlcixkPTE9PT1iPzEtYToyPT09Yj9hOi41PmE/MiphOjIqKDEtYSk7cmV0dXJuIDE9PT1jP2QqPWQ6Mj09PWM/ZCo9ZCpkOjM9PT1jP2QqPWQqZCpkOjQ9PT1jJiYoZCo9ZCpkKmQqZCksMT09PWI/MS1kOjI9PT1iP2Q6LjU+YT9kLzI6MS1kLzJ9LGQ9W1wiTGluZWFyXCIsXCJRdWFkXCIsXCJDdWJpY1wiLFwiUXVhcnRcIixcIlF1aW50LFN0cm9uZ1wiXSxlPWQubGVuZ3RoOy0tZT4tMTspZj1kW2VdK1wiLFBvd2VyXCIrZSx3KG5ldyB1KG51bGwsbnVsbCwxLGUpLGYsXCJlYXNlT3V0XCIsITApLHcobmV3IHUobnVsbCxudWxsLDIsZSksZixcImVhc2VJblwiKygwPT09ZT9cIixlYXNlTm9uZVwiOlwiXCIpKSx3KG5ldyB1KG51bGwsbnVsbCwzLGUpLGYsXCJlYXNlSW5PdXRcIik7di5saW5lYXI9ai5lYXNpbmcuTGluZWFyLmVhc2VJbix2LnN3aW5nPWouZWFzaW5nLlF1YWQuZWFzZUluT3V0O3ZhciB4PXIoXCJldmVudHMuRXZlbnREaXNwYXRjaGVyXCIsZnVuY3Rpb24oYSl7dGhpcy5fbGlzdGVuZXJzPXt9LHRoaXMuX2V2ZW50VGFyZ2V0PWF8fHRoaXN9KTtmPXgucHJvdG90eXBlLGYuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyxkLGUpe2U9ZXx8MDt2YXIgZixpLGo9dGhpcy5fbGlzdGVuZXJzW2FdLGs9MDtmb3IobnVsbD09aiYmKHRoaXMuX2xpc3RlbmVyc1thXT1qPVtdKSxpPWoubGVuZ3RoOy0taT4tMTspZj1qW2ldLGYuYz09PWImJmYucz09PWM/ai5zcGxpY2UoaSwxKTowPT09ayYmZi5wcjxlJiYoaz1pKzEpO2ouc3BsaWNlKGssMCx7YzpiLHM6Yyx1cDpkLHByOmV9KSx0aGlzIT09Z3x8aHx8Zy53YWtlKCl9LGYucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9dGhpcy5fbGlzdGVuZXJzW2FdO2lmKGQpZm9yKGM9ZC5sZW5ndGg7LS1jPi0xOylpZihkW2NdLmM9PT1iKXJldHVybiB2b2lkIGQuc3BsaWNlKGMsMSl9LGYuZGlzcGF0Y2hFdmVudD1mdW5jdGlvbihhKXt2YXIgYixjLGQsZT10aGlzLl9saXN0ZW5lcnNbYV07aWYoZSlmb3IoYj1lLmxlbmd0aCxjPXRoaXMuX2V2ZW50VGFyZ2V0Oy0tYj4tMTspZD1lW2JdLGQmJihkLnVwP2QuYy5jYWxsKGQuc3x8Yyx7dHlwZTphLHRhcmdldDpjfSk6ZC5jLmNhbGwoZC5zfHxjKSl9O3ZhciB5PWEucmVxdWVzdEFuaW1hdGlvbkZyYW1lLHo9YS5jYW5jZWxBbmltYXRpb25GcmFtZSxBPURhdGUubm93fHxmdW5jdGlvbigpe3JldHVybihuZXcgRGF0ZSkuZ2V0VGltZSgpfSxCPUEoKTtmb3IoZD1bXCJtc1wiLFwibW96XCIsXCJ3ZWJraXRcIixcIm9cIl0sZT1kLmxlbmd0aDstLWU+LTEmJiF5Oyl5PWFbZFtlXStcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXSx6PWFbZFtlXStcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdfHxhW2RbZV0rXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07cihcIlRpY2tlclwiLGZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsaSxqPXRoaXMsbD1BKCksbj1iIT09ITEmJnk/XCJhdXRvXCI6ITEsbz01MDAscD0zMyxxPVwidGlja1wiLHI9ZnVuY3Rpb24oYSl7dmFyIGIsZyxoPUEoKS1CO2g+byYmKGwrPWgtcCksQis9aCxqLnRpbWU9KEItbCkvMWUzLGI9ai50aW1lLWksKCFjfHxiPjB8fGE9PT0hMCkmJihqLmZyYW1lKyssaSs9YisoYj49Zj8uMDA0OmYtYiksZz0hMCksYSE9PSEwJiYoZT1kKHIpKSxnJiZqLmRpc3BhdGNoRXZlbnQocSl9O3guY2FsbChqKSxqLnRpbWU9ai5mcmFtZT0wLGoudGljaz1mdW5jdGlvbigpe3IoITApfSxqLmxhZ1Ntb290aGluZz1mdW5jdGlvbihhLGIpe289YXx8MS9rLHA9TWF0aC5taW4oYixvLDApfSxqLnNsZWVwPWZ1bmN0aW9uKCl7bnVsbCE9ZSYmKG4mJno/eihlKTpjbGVhclRpbWVvdXQoZSksZD1tLGU9bnVsbCxqPT09ZyYmKGg9ITEpKX0sai53YWtlPWZ1bmN0aW9uKGEpe251bGwhPT1lP2ouc2xlZXAoKTphP2wrPS1CKyhCPUEoKSk6ai5mcmFtZT4xMCYmKEI9QSgpLW8rNSksZD0wPT09Yz9tOm4mJnk/eTpmdW5jdGlvbihhKXtyZXR1cm4gc2V0VGltZW91dChhLDFlMyooaS1qLnRpbWUpKzF8MCl9LGo9PT1nJiYoaD0hMCkscigyKX0sai5mcHM9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KGM9YSxmPTEvKGN8fDYwKSxpPXRoaXMudGltZStmLHZvaWQgai53YWtlKCkpOmN9LGoudXNlUkFGPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhqLnNsZWVwKCksbj1hLHZvaWQgai5mcHMoYykpOm59LGouZnBzKGEpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcImF1dG9cIj09PW4mJmouZnJhbWU8NSYmXCJoaWRkZW5cIiE9PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSYmai51c2VSQUYoITEpfSwxNTAwKX0pLGY9ai5UaWNrZXIucHJvdG90eXBlPW5ldyBqLmV2ZW50cy5FdmVudERpc3BhdGNoZXIsZi5jb25zdHJ1Y3Rvcj1qLlRpY2tlcjt2YXIgQz1yKFwiY29yZS5BbmltYXRpb25cIixmdW5jdGlvbihhLGIpe2lmKHRoaXMudmFycz1iPWJ8fHt9LHRoaXMuX2R1cmF0aW9uPXRoaXMuX3RvdGFsRHVyYXRpb249YXx8MCx0aGlzLl9kZWxheT1OdW1iZXIoYi5kZWxheSl8fDAsdGhpcy5fdGltZVNjYWxlPTEsdGhpcy5fYWN0aXZlPWIuaW1tZWRpYXRlUmVuZGVyPT09ITAsdGhpcy5kYXRhPWIuZGF0YSx0aGlzLl9yZXZlcnNlZD1iLnJldmVyc2VkPT09ITAsVil7aHx8Zy53YWtlKCk7dmFyIGM9dGhpcy52YXJzLnVzZUZyYW1lcz9VOlY7Yy5hZGQodGhpcyxjLl90aW1lKSx0aGlzLnZhcnMucGF1c2VkJiZ0aGlzLnBhdXNlZCghMCl9fSk7Zz1DLnRpY2tlcj1uZXcgai5UaWNrZXIsZj1DLnByb3RvdHlwZSxmLl9kaXJ0eT1mLl9nYz1mLl9pbml0dGVkPWYuX3BhdXNlZD0hMSxmLl90b3RhbFRpbWU9Zi5fdGltZT0wLGYuX3Jhd1ByZXZUaW1lPS0xLGYuX25leHQ9Zi5fbGFzdD1mLl9vblVwZGF0ZT1mLl90aW1lbGluZT1mLnRpbWVsaW5lPW51bGwsZi5fcGF1c2VkPSExO3ZhciBEPWZ1bmN0aW9uKCl7aCYmQSgpLUI+MmUzJiZnLndha2UoKSxzZXRUaW1lb3V0KEQsMmUzKX07RCgpLGYucGxheT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hJiZ0aGlzLnNlZWsoYSxiKSx0aGlzLnJldmVyc2VkKCExKS5wYXVzZWQoITEpfSxmLnBhdXNlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG51bGwhPWEmJnRoaXMuc2VlayhhLGIpLHRoaXMucGF1c2VkKCEwKX0sZi5yZXN1bWU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbCE9YSYmdGhpcy5zZWVrKGEsYiksdGhpcy5wYXVzZWQoITEpfSxmLnNlZWs9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy50b3RhbFRpbWUoTnVtYmVyKGEpLGIhPT0hMSl9LGYucmVzdGFydD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnJldmVyc2VkKCExKS5wYXVzZWQoITEpLnRvdGFsVGltZShhPy10aGlzLl9kZWxheTowLGIhPT0hMSwhMCl9LGYucmV2ZXJzZT1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hJiZ0aGlzLnNlZWsoYXx8dGhpcy50b3RhbER1cmF0aW9uKCksYiksdGhpcy5yZXZlcnNlZCghMCkucGF1c2VkKCExKX0sZi5yZW5kZXI9ZnVuY3Rpb24oYSxiLGMpe30sZi5pbnZhbGlkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RpbWU9dGhpcy5fdG90YWxUaW1lPTAsdGhpcy5faW5pdHRlZD10aGlzLl9nYz0hMSx0aGlzLl9yYXdQcmV2VGltZT0tMSwodGhpcy5fZ2N8fCF0aGlzLnRpbWVsaW5lKSYmdGhpcy5fZW5hYmxlZCghMCksdGhpc30sZi5pc0FjdGl2ZT1mdW5jdGlvbigpe3ZhciBhLGI9dGhpcy5fdGltZWxpbmUsYz10aGlzLl9zdGFydFRpbWU7cmV0dXJuIWJ8fCF0aGlzLl9nYyYmIXRoaXMuX3BhdXNlZCYmYi5pc0FjdGl2ZSgpJiYoYT1iLnJhd1RpbWUoKSk+PWMmJmE8Yyt0aGlzLnRvdGFsRHVyYXRpb24oKS90aGlzLl90aW1lU2NhbGV9LGYuX2VuYWJsZWQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gaHx8Zy53YWtlKCksdGhpcy5fZ2M9IWEsdGhpcy5fYWN0aXZlPXRoaXMuaXNBY3RpdmUoKSxiIT09ITAmJihhJiYhdGhpcy50aW1lbGluZT90aGlzLl90aW1lbGluZS5hZGQodGhpcyx0aGlzLl9zdGFydFRpbWUtdGhpcy5fZGVsYXkpOiFhJiZ0aGlzLnRpbWVsaW5lJiZ0aGlzLl90aW1lbGluZS5fcmVtb3ZlKHRoaXMsITApKSwhMX0sZi5fa2lsbD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLl9lbmFibGVkKCExLCExKX0sZi5raWxsPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuX2tpbGwoYSxiKSx0aGlzfSxmLl91bmNhY2hlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hP3RoaXM6dGhpcy50aW1lbGluZTtiOyliLl9kaXJ0eT0hMCxiPWIudGltZWxpbmU7cmV0dXJuIHRoaXN9LGYuX3N3YXBTZWxmSW5QYXJhbXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEubGVuZ3RoLGM9YS5jb25jYXQoKTstLWI+LTE7KVwie3NlbGZ9XCI9PT1hW2JdJiYoY1tiXT10aGlzKTtyZXR1cm4gY30sZi5fY2FsbGJhY2s9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy52YXJzO2JbYV0uYXBwbHkoYlthK1wiU2NvcGVcIl18fGIuY2FsbGJhY2tTY29wZXx8dGhpcyxiW2ErXCJQYXJhbXNcIl18fHQpfSxmLmV2ZW50Q2FsbGJhY2s9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoXCJvblwiPT09KGF8fFwiXCIpLnN1YnN0cigwLDIpKXt2YXIgZT10aGlzLnZhcnM7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGVbYV07bnVsbD09Yj9kZWxldGUgZVthXTooZVthXT1iLGVbYStcIlBhcmFtc1wiXT1uKGMpJiYtMSE9PWMuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpP3RoaXMuX3N3YXBTZWxmSW5QYXJhbXMoYyk6YyxlW2ErXCJTY29wZVwiXT1kKSxcIm9uVXBkYXRlXCI9PT1hJiYodGhpcy5fb25VcGRhdGU9Yil9cmV0dXJuIHRoaXN9LGYuZGVsYXk9ZnVuY3Rpb24oYSl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg/KHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nJiZ0aGlzLnN0YXJ0VGltZSh0aGlzLl9zdGFydFRpbWUrYS10aGlzLl9kZWxheSksdGhpcy5fZGVsYXk9YSx0aGlzKTp0aGlzLl9kZWxheX0sZi5kdXJhdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZHVyYXRpb249dGhpcy5fdG90YWxEdXJhdGlvbj1hLHRoaXMuX3VuY2FjaGUoITApLHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nJiZ0aGlzLl90aW1lPjAmJnRoaXMuX3RpbWU8dGhpcy5fZHVyYXRpb24mJjAhPT1hJiZ0aGlzLnRvdGFsVGltZSh0aGlzLl90b3RhbFRpbWUqKGEvdGhpcy5fZHVyYXRpb24pLCEwKSx0aGlzKToodGhpcy5fZGlydHk9ITEsdGhpcy5fZHVyYXRpb24pfSxmLnRvdGFsRHVyYXRpb249ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX2RpcnR5PSExLGFyZ3VtZW50cy5sZW5ndGg/dGhpcy5kdXJhdGlvbihhKTp0aGlzLl90b3RhbER1cmF0aW9ufSxmLnRpbWU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZGlydHkmJnRoaXMudG90YWxEdXJhdGlvbigpLHRoaXMudG90YWxUaW1lKGE+dGhpcy5fZHVyYXRpb24/dGhpcy5fZHVyYXRpb246YSxiKSk6dGhpcy5fdGltZX0sZi50b3RhbFRpbWU9ZnVuY3Rpb24oYSxiLGMpe2lmKGh8fGcud2FrZSgpLCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl90b3RhbFRpbWU7aWYodGhpcy5fdGltZWxpbmUpe2lmKDA+YSYmIWMmJihhKz10aGlzLnRvdGFsRHVyYXRpb24oKSksdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpe3RoaXMuX2RpcnR5JiZ0aGlzLnRvdGFsRHVyYXRpb24oKTt2YXIgZD10aGlzLl90b3RhbER1cmF0aW9uLGU9dGhpcy5fdGltZWxpbmU7aWYoYT5kJiYhYyYmKGE9ZCksdGhpcy5fc3RhcnRUaW1lPSh0aGlzLl9wYXVzZWQ/dGhpcy5fcGF1c2VUaW1lOmUuX3RpbWUpLSh0aGlzLl9yZXZlcnNlZD9kLWE6YSkvdGhpcy5fdGltZVNjYWxlLGUuX2RpcnR5fHx0aGlzLl91bmNhY2hlKCExKSxlLl90aW1lbGluZSlmb3IoO2UuX3RpbWVsaW5lOyllLl90aW1lbGluZS5fdGltZSE9PShlLl9zdGFydFRpbWUrZS5fdG90YWxUaW1lKS9lLl90aW1lU2NhbGUmJmUudG90YWxUaW1lKGUuX3RvdGFsVGltZSwhMCksZT1lLl90aW1lbGluZX10aGlzLl9nYyYmdGhpcy5fZW5hYmxlZCghMCwhMSksKHRoaXMuX3RvdGFsVGltZSE9PWF8fDA9PT10aGlzLl9kdXJhdGlvbikmJihJLmxlbmd0aCYmWCgpLHRoaXMucmVuZGVyKGEsYiwhMSksSS5sZW5ndGgmJlgoKSl9cmV0dXJuIHRoaXN9LGYucHJvZ3Jlc3M9Zi50b3RhbFByb2dyZXNzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5kdXJhdGlvbigpO3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMudG90YWxUaW1lKGMqYSxiKTpjP3RoaXMuX3RpbWUvYzp0aGlzLnJhdGlvfSxmLnN0YXJ0VGltZT1mdW5jdGlvbihhKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD8oYSE9PXRoaXMuX3N0YXJ0VGltZSYmKHRoaXMuX3N0YXJ0VGltZT1hLHRoaXMudGltZWxpbmUmJnRoaXMudGltZWxpbmUuX3NvcnRDaGlsZHJlbiYmdGhpcy50aW1lbGluZS5hZGQodGhpcyxhLXRoaXMuX2RlbGF5KSksdGhpcyk6dGhpcy5fc3RhcnRUaW1lfSxmLmVuZFRpbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX3N0YXJ0VGltZSsoMCE9YT90aGlzLnRvdGFsRHVyYXRpb24oKTp0aGlzLmR1cmF0aW9uKCkpL3RoaXMuX3RpbWVTY2FsZX0sZi50aW1lU2NhbGU9ZnVuY3Rpb24oYSl7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtpZihhPWF8fGssdGhpcy5fdGltZWxpbmUmJnRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKXt2YXIgYj10aGlzLl9wYXVzZVRpbWUsYz1ifHwwPT09Yj9iOnRoaXMuX3RpbWVsaW5lLnRvdGFsVGltZSgpO3RoaXMuX3N0YXJ0VGltZT1jLShjLXRoaXMuX3N0YXJ0VGltZSkqdGhpcy5fdGltZVNjYWxlL2F9cmV0dXJuIHRoaXMuX3RpbWVTY2FsZT1hLHRoaXMuX3VuY2FjaGUoITEpfSxmLnJldmVyc2VkPWZ1bmN0aW9uKGEpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPyhhIT10aGlzLl9yZXZlcnNlZCYmKHRoaXMuX3JldmVyc2VkPWEsdGhpcy50b3RhbFRpbWUodGhpcy5fdGltZWxpbmUmJiF0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZz90aGlzLnRvdGFsRHVyYXRpb24oKS10aGlzLl90b3RhbFRpbWU6dGhpcy5fdG90YWxUaW1lLCEwKSksdGhpcyk6dGhpcy5fcmV2ZXJzZWR9LGYucGF1c2VkPWZ1bmN0aW9uKGEpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9wYXVzZWQ7dmFyIGIsYyxkPXRoaXMuX3RpbWVsaW5lO3JldHVybiBhIT10aGlzLl9wYXVzZWQmJmQmJihofHxhfHxnLndha2UoKSxiPWQucmF3VGltZSgpLGM9Yi10aGlzLl9wYXVzZVRpbWUsIWEmJmQuc21vb3RoQ2hpbGRUaW1pbmcmJih0aGlzLl9zdGFydFRpbWUrPWMsdGhpcy5fdW5jYWNoZSghMSkpLHRoaXMuX3BhdXNlVGltZT1hP2I6bnVsbCx0aGlzLl9wYXVzZWQ9YSx0aGlzLl9hY3RpdmU9dGhpcy5pc0FjdGl2ZSgpLCFhJiYwIT09YyYmdGhpcy5faW5pdHRlZCYmdGhpcy5kdXJhdGlvbigpJiYoYj1kLnNtb290aENoaWxkVGltaW5nP3RoaXMuX3RvdGFsVGltZTooYi10aGlzLl9zdGFydFRpbWUpL3RoaXMuX3RpbWVTY2FsZSx0aGlzLnJlbmRlcihiLGI9PT10aGlzLl90b3RhbFRpbWUsITApKSksdGhpcy5fZ2MmJiFhJiZ0aGlzLl9lbmFibGVkKCEwLCExKSx0aGlzfTt2YXIgRT1yKFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLGZ1bmN0aW9uKGEpe0MuY2FsbCh0aGlzLDAsYSksdGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW49dGhpcy5zbW9vdGhDaGlsZFRpbWluZz0hMH0pO2Y9RS5wcm90b3R5cGU9bmV3IEMsZi5jb25zdHJ1Y3Rvcj1FLGYua2lsbCgpLl9nYz0hMSxmLl9maXJzdD1mLl9sYXN0PWYuX3JlY2VudD1udWxsLGYuX3NvcnRDaGlsZHJlbj0hMSxmLmFkZD1mLmluc2VydD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmO2lmKGEuX3N0YXJ0VGltZT1OdW1iZXIoYnx8MCkrYS5fZGVsYXksYS5fcGF1c2VkJiZ0aGlzIT09YS5fdGltZWxpbmUmJihhLl9wYXVzZVRpbWU9YS5fc3RhcnRUaW1lKyh0aGlzLnJhd1RpbWUoKS1hLl9zdGFydFRpbWUpL2EuX3RpbWVTY2FsZSksYS50aW1lbGluZSYmYS50aW1lbGluZS5fcmVtb3ZlKGEsITApLGEudGltZWxpbmU9YS5fdGltZWxpbmU9dGhpcyxhLl9nYyYmYS5fZW5hYmxlZCghMCwhMCksZT10aGlzLl9sYXN0LHRoaXMuX3NvcnRDaGlsZHJlbilmb3IoZj1hLl9zdGFydFRpbWU7ZSYmZS5fc3RhcnRUaW1lPmY7KWU9ZS5fcHJldjtyZXR1cm4gZT8oYS5fbmV4dD1lLl9uZXh0LGUuX25leHQ9YSk6KGEuX25leHQ9dGhpcy5fZmlyc3QsdGhpcy5fZmlyc3Q9YSksYS5fbmV4dD9hLl9uZXh0Ll9wcmV2PWE6dGhpcy5fbGFzdD1hLGEuX3ByZXY9ZSx0aGlzLl9yZWNlbnQ9YSx0aGlzLl90aW1lbGluZSYmdGhpcy5fdW5jYWNoZSghMCksdGhpc30sZi5fcmVtb3ZlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEudGltZWxpbmU9PT10aGlzJiYoYnx8YS5fZW5hYmxlZCghMSwhMCksYS5fcHJldj9hLl9wcmV2Ll9uZXh0PWEuX25leHQ6dGhpcy5fZmlyc3Q9PT1hJiYodGhpcy5fZmlyc3Q9YS5fbmV4dCksYS5fbmV4dD9hLl9uZXh0Ll9wcmV2PWEuX3ByZXY6dGhpcy5fbGFzdD09PWEmJih0aGlzLl9sYXN0PWEuX3ByZXYpLGEuX25leHQ9YS5fcHJldj1hLnRpbWVsaW5lPW51bGwsYT09PXRoaXMuX3JlY2VudCYmKHRoaXMuX3JlY2VudD10aGlzLl9sYXN0KSx0aGlzLl90aW1lbGluZSYmdGhpcy5fdW5jYWNoZSghMCkpLHRoaXN9LGYucmVuZGVyPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPXRoaXMuX2ZpcnN0O2Zvcih0aGlzLl90b3RhbFRpbWU9dGhpcy5fdGltZT10aGlzLl9yYXdQcmV2VGltZT1hO2U7KWQ9ZS5fbmV4dCwoZS5fYWN0aXZlfHxhPj1lLl9zdGFydFRpbWUmJiFlLl9wYXVzZWQpJiYoZS5fcmV2ZXJzZWQ/ZS5yZW5kZXIoKGUuX2RpcnR5P2UudG90YWxEdXJhdGlvbigpOmUuX3RvdGFsRHVyYXRpb24pLShhLWUuX3N0YXJ0VGltZSkqZS5fdGltZVNjYWxlLGIsYyk6ZS5yZW5kZXIoKGEtZS5fc3RhcnRUaW1lKSplLl90aW1lU2NhbGUsYixjKSksZT1kfSxmLnJhd1RpbWU9ZnVuY3Rpb24oKXtyZXR1cm4gaHx8Zy53YWtlKCksdGhpcy5fdG90YWxUaW1lfTt2YXIgRj1yKFwiVHdlZW5MaXRlXCIsZnVuY3Rpb24oYixjLGQpe2lmKEMuY2FsbCh0aGlzLGMsZCksdGhpcy5yZW5kZXI9Ri5wcm90b3R5cGUucmVuZGVyLG51bGw9PWIpdGhyb3dcIkNhbm5vdCB0d2VlbiBhIG51bGwgdGFyZ2V0LlwiO3RoaXMudGFyZ2V0PWI9XCJzdHJpbmdcIiE9dHlwZW9mIGI/YjpGLnNlbGVjdG9yKGIpfHxiO3ZhciBlLGYsZyxoPWIuanF1ZXJ5fHxiLmxlbmd0aCYmYiE9PWEmJmJbMF0mJihiWzBdPT09YXx8YlswXS5ub2RlVHlwZSYmYlswXS5zdHlsZSYmIWIubm9kZVR5cGUpLGk9dGhpcy52YXJzLm92ZXJ3cml0ZTtpZih0aGlzLl9vdmVyd3JpdGU9aT1udWxsPT1pP1RbRi5kZWZhdWx0T3ZlcndyaXRlXTpcIm51bWJlclwiPT10eXBlb2YgaT9pPj4wOlRbaV0sKGh8fGIgaW5zdGFuY2VvZiBBcnJheXx8Yi5wdXNoJiZuKGIpKSYmXCJudW1iZXJcIiE9dHlwZW9mIGJbMF0pZm9yKHRoaXMuX3RhcmdldHM9Zz1sKGIpLHRoaXMuX3Byb3BMb29rdXA9W10sdGhpcy5fc2libGluZ3M9W10sZT0wO2U8Zy5sZW5ndGg7ZSsrKWY9Z1tlXSxmP1wic3RyaW5nXCIhPXR5cGVvZiBmP2YubGVuZ3RoJiZmIT09YSYmZlswXSYmKGZbMF09PT1hfHxmWzBdLm5vZGVUeXBlJiZmWzBdLnN0eWxlJiYhZi5ub2RlVHlwZSk/KGcuc3BsaWNlKGUtLSwxKSx0aGlzLl90YXJnZXRzPWc9Zy5jb25jYXQobChmKSkpOih0aGlzLl9zaWJsaW5nc1tlXT1ZKGYsdGhpcywhMSksMT09PWkmJnRoaXMuX3NpYmxpbmdzW2VdLmxlbmd0aD4xJiYkKGYsdGhpcyxudWxsLDEsdGhpcy5fc2libGluZ3NbZV0pKTooZj1nW2UtLV09Ri5zZWxlY3RvcihmKSxcInN0cmluZ1wiPT10eXBlb2YgZiYmZy5zcGxpY2UoZSsxLDEpKTpnLnNwbGljZShlLS0sMSk7ZWxzZSB0aGlzLl9wcm9wTG9va3VwPXt9LHRoaXMuX3NpYmxpbmdzPVkoYix0aGlzLCExKSwxPT09aSYmdGhpcy5fc2libGluZ3MubGVuZ3RoPjEmJiQoYix0aGlzLG51bGwsMSx0aGlzLl9zaWJsaW5ncyk7KHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXJ8fDA9PT1jJiYwPT09dGhpcy5fZGVsYXkmJnRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIhPT0hMSkmJih0aGlzLl90aW1lPS1rLHRoaXMucmVuZGVyKC10aGlzLl9kZWxheSkpfSwhMCksRz1mdW5jdGlvbihiKXtyZXR1cm4gYiYmYi5sZW5ndGgmJmIhPT1hJiZiWzBdJiYoYlswXT09PWF8fGJbMF0ubm9kZVR5cGUmJmJbMF0uc3R5bGUmJiFiLm5vZGVUeXBlKX0sSD1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9e307Zm9yKGMgaW4gYSlTW2NdfHxjIGluIGImJlwidHJhbnNmb3JtXCIhPT1jJiZcInhcIiE9PWMmJlwieVwiIT09YyYmXCJ3aWR0aFwiIT09YyYmXCJoZWlnaHRcIiE9PWMmJlwiY2xhc3NOYW1lXCIhPT1jJiZcImJvcmRlclwiIT09Y3x8ISghUFtjXXx8UFtjXSYmUFtjXS5fYXV0b0NTUyl8fChkW2NdPWFbY10sZGVsZXRlIGFbY10pO2EuY3NzPWR9O2Y9Ri5wcm90b3R5cGU9bmV3IEMsZi5jb25zdHJ1Y3Rvcj1GLGYua2lsbCgpLl9nYz0hMSxmLnJhdGlvPTAsZi5fZmlyc3RQVD1mLl90YXJnZXRzPWYuX292ZXJ3cml0dGVuUHJvcHM9Zi5fc3RhcnRBdD1udWxsLGYuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQ9Zi5fbGF6eT0hMSxGLnZlcnNpb249XCIxLjE4LjJcIixGLmRlZmF1bHRFYXNlPWYuX2Vhc2U9bmV3IHUobnVsbCxudWxsLDEsMSksRi5kZWZhdWx0T3ZlcndyaXRlPVwiYXV0b1wiLEYudGlja2VyPWcsRi5hdXRvU2xlZXA9MTIwLEYubGFnU21vb3RoaW5nPWZ1bmN0aW9uKGEsYil7Zy5sYWdTbW9vdGhpbmcoYSxiKX0sRi5zZWxlY3Rvcj1hLiR8fGEualF1ZXJ5fHxmdW5jdGlvbihiKXt2YXIgYz1hLiR8fGEualF1ZXJ5O3JldHVybiBjPyhGLnNlbGVjdG9yPWMsYyhiKSk6XCJ1bmRlZmluZWRcIj09dHlwZW9mIGRvY3VtZW50P2I6ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbD9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGIpOmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiI1wiPT09Yi5jaGFyQXQoMCk/Yi5zdWJzdHIoMSk6Yil9O3ZhciBJPVtdLEo9e30sSz0vKD86KC18LT18XFwrPSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vZ2ksTD1mdW5jdGlvbihhKXtmb3IodmFyIGIsYz10aGlzLl9maXJzdFBULGQ9MWUtNjtjOyliPWMuYmxvYj9hP3RoaXMuam9pbihcIlwiKTp0aGlzLnN0YXJ0OmMuYyphK2MucyxjLnI/Yj1NYXRoLnJvdW5kKGIpOmQ+YiYmYj4tZCYmKGI9MCksYy5mP2MuZnA/Yy50W2MucF0oYy5mcCxiKTpjLnRbYy5wXShiKTpjLnRbYy5wXT1iLGM9Yy5fbmV4dH0sTT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGcsaCxpLGosayxsPVthLGJdLG09MCxuPVwiXCIsbz0wO2ZvcihsLnN0YXJ0PWEsYyYmKGMobCksYT1sWzBdLGI9bFsxXSksbC5sZW5ndGg9MCxlPWEubWF0Y2goSyl8fFtdLGY9Yi5tYXRjaChLKXx8W10sZCYmKGQuX25leHQ9bnVsbCxkLmJsb2I9MSxsLl9maXJzdFBUPWQpLGk9Zi5sZW5ndGgsaD0wO2k+aDtoKyspaz1mW2hdLGo9Yi5zdWJzdHIobSxiLmluZGV4T2YoayxtKS1tKSxuKz1qfHwhaD9qOlwiLFwiLG0rPWoubGVuZ3RoLG8/bz0obysxKSU1OlwicmdiYShcIj09PWouc3Vic3RyKC01KSYmKG89MSksaz09PWVbaF18fGUubGVuZ3RoPD1oP24rPWs6KG4mJihsLnB1c2gobiksbj1cIlwiKSxnPXBhcnNlRmxvYXQoZVtoXSksbC5wdXNoKGcpLGwuX2ZpcnN0UFQ9e19uZXh0OmwuX2ZpcnN0UFQsdDpsLHA6bC5sZW5ndGgtMSxzOmcsYzooXCI9XCI9PT1rLmNoYXJBdCgxKT9wYXJzZUludChrLmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChrLnN1YnN0cigyKSk6cGFyc2VGbG9hdChrKS1nKXx8MCxmOjAscjpvJiY0Pm99KSxtKz1rLmxlbmd0aDtyZXR1cm4gbis9Yi5zdWJzdHIobSksbiYmbC5wdXNoKG4pLGwuc2V0UmF0aW89TCxsfSxOPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCl7dmFyIGksaixrPVwiZ2V0XCI9PT1jP2FbYl06YyxsPXR5cGVvZiBhW2JdLG09XCJzdHJpbmdcIj09dHlwZW9mIGQmJlwiPVwiPT09ZC5jaGFyQXQoMSksbj17dDphLHA6YixzOmssZjpcImZ1bmN0aW9uXCI9PT1sLHBnOjAsbjplfHxiLHI6ZixwcjowLGM6bT9wYXJzZUludChkLmNoYXJBdCgwKStcIjFcIiwxMCkqcGFyc2VGbG9hdChkLnN1YnN0cigyKSk6cGFyc2VGbG9hdChkKS1rfHwwfTtyZXR1cm5cIm51bWJlclwiIT09bCYmKFwiZnVuY3Rpb25cIj09PWwmJlwiZ2V0XCI9PT1jJiYoaj1iLmluZGV4T2YoXCJzZXRcIil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGFbXCJnZXRcIitiLnN1YnN0cigzKV0/YjpcImdldFwiK2Iuc3Vic3RyKDMpLG4ucz1rPWc/YVtqXShnKTphW2pdKCkpLFwic3RyaW5nXCI9PXR5cGVvZiBrJiYoZ3x8aXNOYU4oaykpPyhuLmZwPWcsaT1NKGssZCxofHxGLmRlZmF1bHRTdHJpbmdGaWx0ZXIsbiksbj17dDppLHA6XCJzZXRSYXRpb1wiLHM6MCxjOjEsZjoyLHBnOjAsbjplfHxiLHByOjB9KTptfHwobi5zPXBhcnNlRmxvYXQoayksbi5jPXBhcnNlRmxvYXQoZCktbi5zfHwwKSksbi5jPygobi5fbmV4dD10aGlzLl9maXJzdFBUKSYmKG4uX25leHQuX3ByZXY9biksdGhpcy5fZmlyc3RQVD1uLG4pOnZvaWQgMH0sTz1GLl9pbnRlcm5hbHM9e2lzQXJyYXk6bixpc1NlbGVjdG9yOkcsbGF6eVR3ZWVuczpJLGJsb2JEaWY6TX0sUD1GLl9wbHVnaW5zPXt9LFE9Ty50d2Vlbkxvb2t1cD17fSxSPTAsUz1PLnJlc2VydmVkUHJvcHM9e2Vhc2U6MSxkZWxheToxLG92ZXJ3cml0ZToxLG9uQ29tcGxldGU6MSxvbkNvbXBsZXRlUGFyYW1zOjEsb25Db21wbGV0ZVNjb3BlOjEsdXNlRnJhbWVzOjEscnVuQmFja3dhcmRzOjEsc3RhcnRBdDoxLG9uVXBkYXRlOjEsb25VcGRhdGVQYXJhbXM6MSxvblVwZGF0ZVNjb3BlOjEsb25TdGFydDoxLG9uU3RhcnRQYXJhbXM6MSxvblN0YXJ0U2NvcGU6MSxvblJldmVyc2VDb21wbGV0ZToxLG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOjEsb25SZXZlcnNlQ29tcGxldGVTY29wZToxLG9uUmVwZWF0OjEsb25SZXBlYXRQYXJhbXM6MSxvblJlcGVhdFNjb3BlOjEsZWFzZVBhcmFtczoxLHlveW86MSxpbW1lZGlhdGVSZW5kZXI6MSxyZXBlYXQ6MSxyZXBlYXREZWxheToxLGRhdGE6MSxwYXVzZWQ6MSxyZXZlcnNlZDoxLGF1dG9DU1M6MSxsYXp5OjEsb25PdmVyd3JpdGU6MSxjYWxsYmFja1Njb3BlOjEsc3RyaW5nRmlsdGVyOjF9LFQ9e25vbmU6MCxhbGw6MSxhdXRvOjIsY29uY3VycmVudDozLGFsbE9uU3RhcnQ6NCxwcmVleGlzdGluZzo1LFwidHJ1ZVwiOjEsXCJmYWxzZVwiOjB9LFU9Qy5fcm9vdEZyYW1lc1RpbWVsaW5lPW5ldyBFLFY9Qy5fcm9vdFRpbWVsaW5lPW5ldyBFLFc9MzAsWD1PLmxhenlSZW5kZXI9ZnVuY3Rpb24oKXtcclxudmFyIGEsYj1JLmxlbmd0aDtmb3IoSj17fTstLWI+LTE7KWE9SVtiXSxhJiZhLl9sYXp5IT09ITEmJihhLnJlbmRlcihhLl9sYXp5WzBdLGEuX2xhenlbMV0sITApLGEuX2xhenk9ITEpO0kubGVuZ3RoPTB9O1YuX3N0YXJ0VGltZT1nLnRpbWUsVS5fc3RhcnRUaW1lPWcuZnJhbWUsVi5fYWN0aXZlPVUuX2FjdGl2ZT0hMCxzZXRUaW1lb3V0KFgsMSksQy5fdXBkYXRlUm9vdD1GLnJlbmRlcj1mdW5jdGlvbigpe3ZhciBhLGIsYztpZihJLmxlbmd0aCYmWCgpLFYucmVuZGVyKChnLnRpbWUtVi5fc3RhcnRUaW1lKSpWLl90aW1lU2NhbGUsITEsITEpLFUucmVuZGVyKChnLmZyYW1lLVUuX3N0YXJ0VGltZSkqVS5fdGltZVNjYWxlLCExLCExKSxJLmxlbmd0aCYmWCgpLGcuZnJhbWU+PVcpe1c9Zy5mcmFtZSsocGFyc2VJbnQoRi5hdXRvU2xlZXAsMTApfHwxMjApO2ZvcihjIGluIFEpe2ZvcihiPVFbY10udHdlZW5zLGE9Yi5sZW5ndGg7LS1hPi0xOyliW2FdLl9nYyYmYi5zcGxpY2UoYSwxKTswPT09Yi5sZW5ndGgmJmRlbGV0ZSBRW2NdfWlmKGM9Vi5fZmlyc3QsKCFjfHxjLl9wYXVzZWQpJiZGLmF1dG9TbGVlcCYmIVUuX2ZpcnN0JiYxPT09Zy5fbGlzdGVuZXJzLnRpY2subGVuZ3RoKXtmb3IoO2MmJmMuX3BhdXNlZDspYz1jLl9uZXh0O2N8fGcuc2xlZXAoKX19fSxnLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsQy5fdXBkYXRlUm9vdCk7dmFyIFk9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZj1hLl9nc1R3ZWVuSUQ7aWYoUVtmfHwoYS5fZ3NUd2VlbklEPWY9XCJ0XCIrUisrKV18fChRW2ZdPXt0YXJnZXQ6YSx0d2VlbnM6W119KSxiJiYoZD1RW2ZdLnR3ZWVucyxkW2U9ZC5sZW5ndGhdPWIsYykpZm9yKDstLWU+LTE7KWRbZV09PT1iJiZkLnNwbGljZShlLDEpO3JldHVybiBRW2ZdLnR3ZWVuc30sWj1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGc9YS52YXJzLm9uT3ZlcndyaXRlO3JldHVybiBnJiYoZT1nKGEsYixjLGQpKSxnPUYub25PdmVyd3JpdGUsZyYmKGY9ZyhhLGIsYyxkKSksZSE9PSExJiZmIT09ITF9LCQ9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZixnLGgsaTtpZigxPT09ZHx8ZD49NCl7Zm9yKGk9ZS5sZW5ndGgsZj0wO2k+ZjtmKyspaWYoKGg9ZVtmXSkhPT1iKWguX2djfHxoLl9raWxsKG51bGwsYSxiKSYmKGc9ITApO2Vsc2UgaWYoNT09PWQpYnJlYWs7cmV0dXJuIGd9dmFyIGosbD1iLl9zdGFydFRpbWUrayxtPVtdLG49MCxvPTA9PT1iLl9kdXJhdGlvbjtmb3IoZj1lLmxlbmd0aDstLWY+LTE7KShoPWVbZl0pPT09Ynx8aC5fZ2N8fGguX3BhdXNlZHx8KGguX3RpbWVsaW5lIT09Yi5fdGltZWxpbmU/KGo9anx8XyhiLDAsbyksMD09PV8oaCxqLG8pJiYobVtuKytdPWgpKTpoLl9zdGFydFRpbWU8PWwmJmguX3N0YXJ0VGltZStoLnRvdGFsRHVyYXRpb24oKS9oLl90aW1lU2NhbGU+bCYmKChvfHwhaC5faW5pdHRlZCkmJmwtaC5fc3RhcnRUaW1lPD0yZS0xMHx8KG1bbisrXT1oKSkpO2ZvcihmPW47LS1mPi0xOylpZihoPW1bZl0sMj09PWQmJmguX2tpbGwoYyxhLGIpJiYoZz0hMCksMiE9PWR8fCFoLl9maXJzdFBUJiZoLl9pbml0dGVkKXtpZigyIT09ZCYmIVooaCxiKSljb250aW51ZTtoLl9lbmFibGVkKCExLCExKSYmKGc9ITApfXJldHVybiBnfSxfPWZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5fdGltZWxpbmUsZT1kLl90aW1lU2NhbGUsZj1hLl9zdGFydFRpbWU7ZC5fdGltZWxpbmU7KXtpZihmKz1kLl9zdGFydFRpbWUsZSo9ZC5fdGltZVNjYWxlLGQuX3BhdXNlZClyZXR1cm4tMTAwO2Q9ZC5fdGltZWxpbmV9cmV0dXJuIGYvPWUsZj5iP2YtYjpjJiZmPT09Ynx8IWEuX2luaXR0ZWQmJjIqaz5mLWI/azooZis9YS50b3RhbER1cmF0aW9uKCkvYS5fdGltZVNjYWxlL2UpPmIraz8wOmYtYi1rfTtmLl9pbml0PWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZSxmPXRoaXMudmFycyxnPXRoaXMuX292ZXJ3cml0dGVuUHJvcHMsaD10aGlzLl9kdXJhdGlvbixpPSEhZi5pbW1lZGlhdGVSZW5kZXIsaj1mLmVhc2U7aWYoZi5zdGFydEF0KXt0aGlzLl9zdGFydEF0JiYodGhpcy5fc3RhcnRBdC5yZW5kZXIoLTEsITApLHRoaXMuX3N0YXJ0QXQua2lsbCgpKSxlPXt9O2ZvcihkIGluIGYuc3RhcnRBdCllW2RdPWYuc3RhcnRBdFtkXTtpZihlLm92ZXJ3cml0ZT0hMSxlLmltbWVkaWF0ZVJlbmRlcj0hMCxlLmxhenk9aSYmZi5sYXp5IT09ITEsZS5zdGFydEF0PWUuZGVsYXk9bnVsbCx0aGlzLl9zdGFydEF0PUYudG8odGhpcy50YXJnZXQsMCxlKSxpKWlmKHRoaXMuX3RpbWU+MCl0aGlzLl9zdGFydEF0PW51bGw7ZWxzZSBpZigwIT09aClyZXR1cm59ZWxzZSBpZihmLnJ1bkJhY2t3YXJkcyYmMCE9PWgpaWYodGhpcy5fc3RhcnRBdCl0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwhMCksdGhpcy5fc3RhcnRBdC5raWxsKCksdGhpcy5fc3RhcnRBdD1udWxsO2Vsc2V7MCE9PXRoaXMuX3RpbWUmJihpPSExKSxjPXt9O2ZvcihkIGluIGYpU1tkXSYmXCJhdXRvQ1NTXCIhPT1kfHwoY1tkXT1mW2RdKTtpZihjLm92ZXJ3cml0ZT0wLGMuZGF0YT1cImlzRnJvbVN0YXJ0XCIsYy5sYXp5PWkmJmYubGF6eSE9PSExLGMuaW1tZWRpYXRlUmVuZGVyPWksdGhpcy5fc3RhcnRBdD1GLnRvKHRoaXMudGFyZ2V0LDAsYyksaSl7aWYoMD09PXRoaXMuX3RpbWUpcmV0dXJufWVsc2UgdGhpcy5fc3RhcnRBdC5faW5pdCgpLHRoaXMuX3N0YXJ0QXQuX2VuYWJsZWQoITEpLHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXImJih0aGlzLl9zdGFydEF0PW51bGwpfWlmKHRoaXMuX2Vhc2U9aj1qP2ogaW5zdGFuY2VvZiB1P2o6XCJmdW5jdGlvblwiPT10eXBlb2Ygaj9uZXcgdShqLGYuZWFzZVBhcmFtcyk6dltqXXx8Ri5kZWZhdWx0RWFzZTpGLmRlZmF1bHRFYXNlLGYuZWFzZVBhcmFtcyBpbnN0YW5jZW9mIEFycmF5JiZqLmNvbmZpZyYmKHRoaXMuX2Vhc2U9ai5jb25maWcuYXBwbHkoaixmLmVhc2VQYXJhbXMpKSx0aGlzLl9lYXNlVHlwZT10aGlzLl9lYXNlLl90eXBlLHRoaXMuX2Vhc2VQb3dlcj10aGlzLl9lYXNlLl9wb3dlcix0aGlzLl9maXJzdFBUPW51bGwsdGhpcy5fdGFyZ2V0cylmb3IoYT10aGlzLl90YXJnZXRzLmxlbmd0aDstLWE+LTE7KXRoaXMuX2luaXRQcm9wcyh0aGlzLl90YXJnZXRzW2FdLHRoaXMuX3Byb3BMb29rdXBbYV09e30sdGhpcy5fc2libGluZ3NbYV0sZz9nW2FdOm51bGwpJiYoYj0hMCk7ZWxzZSBiPXRoaXMuX2luaXRQcm9wcyh0aGlzLnRhcmdldCx0aGlzLl9wcm9wTG9va3VwLHRoaXMuX3NpYmxpbmdzLGcpO2lmKGImJkYuX29uUGx1Z2luRXZlbnQoXCJfb25Jbml0QWxsUHJvcHNcIix0aGlzKSxnJiYodGhpcy5fZmlyc3RQVHx8XCJmdW5jdGlvblwiIT10eXBlb2YgdGhpcy50YXJnZXQmJnRoaXMuX2VuYWJsZWQoITEsITEpKSxmLnJ1bkJhY2t3YXJkcylmb3IoYz10aGlzLl9maXJzdFBUO2M7KWMucys9Yy5jLGMuYz0tYy5jLGM9Yy5fbmV4dDt0aGlzLl9vblVwZGF0ZT1mLm9uVXBkYXRlLHRoaXMuX2luaXR0ZWQ9ITB9LGYuX2luaXRQcm9wcz1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZixnLGgsaSxqLGs7aWYobnVsbD09YilyZXR1cm4hMTtKW2IuX2dzVHdlZW5JRF0mJlgoKSx0aGlzLnZhcnMuY3NzfHxiLnN0eWxlJiZiIT09YSYmYi5ub2RlVHlwZSYmUC5jc3MmJnRoaXMudmFycy5hdXRvQ1NTIT09ITEmJkgodGhpcy52YXJzLGIpO2ZvcihmIGluIHRoaXMudmFycylpZihrPXRoaXMudmFyc1tmXSxTW2ZdKWsmJihrIGluc3RhbmNlb2YgQXJyYXl8fGsucHVzaCYmbihrKSkmJi0xIT09ay5qb2luKFwiXCIpLmluZGV4T2YoXCJ7c2VsZn1cIikmJih0aGlzLnZhcnNbZl09az10aGlzLl9zd2FwU2VsZkluUGFyYW1zKGssdGhpcykpO2Vsc2UgaWYoUFtmXSYmKGk9bmV3IFBbZl0pLl9vbkluaXRUd2VlbihiLHRoaXMudmFyc1tmXSx0aGlzKSl7Zm9yKHRoaXMuX2ZpcnN0UFQ9aj17X25leHQ6dGhpcy5fZmlyc3RQVCx0OmkscDpcInNldFJhdGlvXCIsczowLGM6MSxmOjEsbjpmLHBnOjEscHI6aS5fcHJpb3JpdHl9LGc9aS5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoOy0tZz4tMTspY1tpLl9vdmVyd3JpdGVQcm9wc1tnXV09dGhpcy5fZmlyc3RQVDsoaS5fcHJpb3JpdHl8fGkuX29uSW5pdEFsbFByb3BzKSYmKGg9ITApLChpLl9vbkRpc2FibGV8fGkuX29uRW5hYmxlKSYmKHRoaXMuX25vdGlmeVBsdWdpbnNPZkVuYWJsZWQ9ITApLGouX25leHQmJihqLl9uZXh0Ll9wcmV2PWopfWVsc2UgY1tmXT1OLmNhbGwodGhpcyxiLGYsXCJnZXRcIixrLGYsMCxudWxsLHRoaXMudmFycy5zdHJpbmdGaWx0ZXIpO3JldHVybiBlJiZ0aGlzLl9raWxsKGUsYik/dGhpcy5faW5pdFByb3BzKGIsYyxkLGUpOnRoaXMuX292ZXJ3cml0ZT4xJiZ0aGlzLl9maXJzdFBUJiZkLmxlbmd0aD4xJiYkKGIsdGhpcyxjLHRoaXMuX292ZXJ3cml0ZSxkKT8odGhpcy5fa2lsbChjLGIpLHRoaXMuX2luaXRQcm9wcyhiLGMsZCxlKSk6KHRoaXMuX2ZpcnN0UFQmJih0aGlzLnZhcnMubGF6eSE9PSExJiZ0aGlzLl9kdXJhdGlvbnx8dGhpcy52YXJzLmxhenkmJiF0aGlzLl9kdXJhdGlvbikmJihKW2IuX2dzVHdlZW5JRF09ITApLGgpfSxmLnJlbmRlcj1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaD10aGlzLl90aW1lLGk9dGhpcy5fZHVyYXRpb24saj10aGlzLl9yYXdQcmV2VGltZTtpZihhPj1pLTFlLTcpdGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9aSx0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuX2NhbGNFbmQ/dGhpcy5fZWFzZS5nZXRSYXRpbygxKToxLHRoaXMuX3JldmVyc2VkfHwoZD0hMCxlPVwib25Db21wbGV0ZVwiLGM9Y3x8dGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSwwPT09aSYmKHRoaXMuX2luaXR0ZWR8fCF0aGlzLnZhcnMubGF6eXx8YykmJih0aGlzLl9zdGFydFRpbWU9PT10aGlzLl90aW1lbGluZS5fZHVyYXRpb24mJihhPTApLCgwPmp8fDA+PWEmJmE+PS0xZS03fHxqPT09ayYmXCJpc1BhdXNlXCIhPT10aGlzLmRhdGEpJiZqIT09YSYmKGM9ITAsaj5rJiYoZT1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIpKSx0aGlzLl9yYXdQcmV2VGltZT1nPSFifHxhfHxqPT09YT9hOmspO2Vsc2UgaWYoMWUtNz5hKXRoaXMuX3RvdGFsVGltZT10aGlzLl90aW1lPTAsdGhpcy5yYXRpbz10aGlzLl9lYXNlLl9jYWxjRW5kP3RoaXMuX2Vhc2UuZ2V0UmF0aW8oMCk6MCwoMCE9PWh8fDA9PT1pJiZqPjApJiYoZT1cIm9uUmV2ZXJzZUNvbXBsZXRlXCIsZD10aGlzLl9yZXZlcnNlZCksMD5hJiYodGhpcy5fYWN0aXZlPSExLDA9PT1pJiYodGhpcy5faW5pdHRlZHx8IXRoaXMudmFycy5sYXp5fHxjKSYmKGo+PTAmJihqIT09a3x8XCJpc1BhdXNlXCIhPT10aGlzLmRhdGEpJiYoYz0hMCksdGhpcy5fcmF3UHJldlRpbWU9Zz0hYnx8YXx8aj09PWE/YTprKSksdGhpcy5faW5pdHRlZHx8KGM9ITApO2Vsc2UgaWYodGhpcy5fdG90YWxUaW1lPXRoaXMuX3RpbWU9YSx0aGlzLl9lYXNlVHlwZSl7dmFyIGw9YS9pLG09dGhpcy5fZWFzZVR5cGUsbj10aGlzLl9lYXNlUG93ZXI7KDE9PT1tfHwzPT09bSYmbD49LjUpJiYobD0xLWwpLDM9PT1tJiYobCo9MiksMT09PW4/bCo9bDoyPT09bj9sKj1sKmw6Mz09PW4/bCo9bCpsKmw6ND09PW4mJihsKj1sKmwqbCpsKSwxPT09bT90aGlzLnJhdGlvPTEtbDoyPT09bT90aGlzLnJhdGlvPWw6LjU+YS9pP3RoaXMucmF0aW89bC8yOnRoaXMucmF0aW89MS1sLzJ9ZWxzZSB0aGlzLnJhdGlvPXRoaXMuX2Vhc2UuZ2V0UmF0aW8oYS9pKTtpZih0aGlzLl90aW1lIT09aHx8Yyl7aWYoIXRoaXMuX2luaXR0ZWQpe2lmKHRoaXMuX2luaXQoKSwhdGhpcy5faW5pdHRlZHx8dGhpcy5fZ2MpcmV0dXJuO2lmKCFjJiZ0aGlzLl9maXJzdFBUJiYodGhpcy52YXJzLmxhenkhPT0hMSYmdGhpcy5fZHVyYXRpb258fHRoaXMudmFycy5sYXp5JiYhdGhpcy5fZHVyYXRpb24pKXJldHVybiB0aGlzLl90aW1lPXRoaXMuX3RvdGFsVGltZT1oLHRoaXMuX3Jhd1ByZXZUaW1lPWosSS5wdXNoKHRoaXMpLHZvaWQodGhpcy5fbGF6eT1bYSxiXSk7dGhpcy5fdGltZSYmIWQ/dGhpcy5yYXRpbz10aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUvaSk6ZCYmdGhpcy5fZWFzZS5fY2FsY0VuZCYmKHRoaXMucmF0aW89dGhpcy5fZWFzZS5nZXRSYXRpbygwPT09dGhpcy5fdGltZT8wOjEpKX1mb3IodGhpcy5fbGF6eSE9PSExJiYodGhpcy5fbGF6eT0hMSksdGhpcy5fYWN0aXZlfHwhdGhpcy5fcGF1c2VkJiZ0aGlzLl90aW1lIT09aCYmYT49MCYmKHRoaXMuX2FjdGl2ZT0hMCksMD09PWgmJih0aGlzLl9zdGFydEF0JiYoYT49MD90aGlzLl9zdGFydEF0LnJlbmRlcihhLGIsYyk6ZXx8KGU9XCJfZHVtbXlHU1wiKSksdGhpcy52YXJzLm9uU3RhcnQmJigwIT09dGhpcy5fdGltZXx8MD09PWkpJiYoYnx8dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpKSksZj10aGlzLl9maXJzdFBUO2Y7KWYuZj9mLnRbZi5wXShmLmMqdGhpcy5yYXRpbytmLnMpOmYudFtmLnBdPWYuYyp0aGlzLnJhdGlvK2YucyxmPWYuX25leHQ7dGhpcy5fb25VcGRhdGUmJigwPmEmJnRoaXMuX3N0YXJ0QXQmJmEhPT0tMWUtNCYmdGhpcy5fc3RhcnRBdC5yZW5kZXIoYSxiLGMpLGJ8fCh0aGlzLl90aW1lIT09aHx8ZCkmJnRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIikpLGUmJighdGhpcy5fZ2N8fGMpJiYoMD5hJiZ0aGlzLl9zdGFydEF0JiYhdGhpcy5fb25VcGRhdGUmJmEhPT0tMWUtNCYmdGhpcy5fc3RhcnRBdC5yZW5kZXIoYSxiLGMpLGQmJih0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4mJnRoaXMuX2VuYWJsZWQoITEsITEpLHRoaXMuX2FjdGl2ZT0hMSksIWImJnRoaXMudmFyc1tlXSYmdGhpcy5fY2FsbGJhY2soZSksMD09PWkmJnRoaXMuX3Jhd1ByZXZUaW1lPT09ayYmZyE9PWsmJih0aGlzLl9yYXdQcmV2VGltZT0wKSl9fSxmLl9raWxsPWZ1bmN0aW9uKGEsYixjKXtpZihcImFsbFwiPT09YSYmKGE9bnVsbCksbnVsbD09YSYmKG51bGw9PWJ8fGI9PT10aGlzLnRhcmdldCkpcmV0dXJuIHRoaXMuX2xhenk9ITEsdGhpcy5fZW5hYmxlZCghMSwhMSk7Yj1cInN0cmluZ1wiIT10eXBlb2YgYj9ifHx0aGlzLl90YXJnZXRzfHx0aGlzLnRhcmdldDpGLnNlbGVjdG9yKGIpfHxiO3ZhciBkLGUsZixnLGgsaSxqLGssbCxtPWMmJnRoaXMuX3RpbWUmJmMuX3N0YXJ0VGltZT09PXRoaXMuX3N0YXJ0VGltZSYmdGhpcy5fdGltZWxpbmU9PT1jLl90aW1lbGluZTtpZigobihiKXx8RyhiKSkmJlwibnVtYmVyXCIhPXR5cGVvZiBiWzBdKWZvcihkPWIubGVuZ3RoOy0tZD4tMTspdGhpcy5fa2lsbChhLGJbZF0sYykmJihpPSEwKTtlbHNle2lmKHRoaXMuX3RhcmdldHMpe2ZvcihkPXRoaXMuX3RhcmdldHMubGVuZ3RoOy0tZD4tMTspaWYoYj09PXRoaXMuX3RhcmdldHNbZF0pe2g9dGhpcy5fcHJvcExvb2t1cFtkXXx8e30sdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcz10aGlzLl9vdmVyd3JpdHRlblByb3BzfHxbXSxlPXRoaXMuX292ZXJ3cml0dGVuUHJvcHNbZF09YT90aGlzLl9vdmVyd3JpdHRlblByb3BzW2RdfHx7fTpcImFsbFwiO2JyZWFrfX1lbHNle2lmKGIhPT10aGlzLnRhcmdldClyZXR1cm4hMTtoPXRoaXMuX3Byb3BMb29rdXAsZT10aGlzLl9vdmVyd3JpdHRlblByb3BzPWE/dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc3x8e306XCJhbGxcIn1pZihoKXtpZihqPWF8fGgsaz1hIT09ZSYmXCJhbGxcIiE9PWUmJmEhPT1oJiYoXCJvYmplY3RcIiE9dHlwZW9mIGF8fCFhLl90ZW1wS2lsbCksYyYmKEYub25PdmVyd3JpdGV8fHRoaXMudmFycy5vbk92ZXJ3cml0ZSkpe2ZvcihmIGluIGopaFtmXSYmKGx8fChsPVtdKSxsLnB1c2goZikpO2lmKChsfHwhYSkmJiFaKHRoaXMsYyxiLGwpKXJldHVybiExfWZvcihmIGluIGopKGc9aFtmXSkmJihtJiYoZy5mP2cudFtnLnBdKGcucyk6Zy50W2cucF09Zy5zLGk9ITApLGcucGcmJmcudC5fa2lsbChqKSYmKGk9ITApLGcucGcmJjAhPT1nLnQuX292ZXJ3cml0ZVByb3BzLmxlbmd0aHx8KGcuX3ByZXY/Zy5fcHJldi5fbmV4dD1nLl9uZXh0Omc9PT10aGlzLl9maXJzdFBUJiYodGhpcy5fZmlyc3RQVD1nLl9uZXh0KSxnLl9uZXh0JiYoZy5fbmV4dC5fcHJldj1nLl9wcmV2KSxnLl9uZXh0PWcuX3ByZXY9bnVsbCksZGVsZXRlIGhbZl0pLGsmJihlW2ZdPTEpOyF0aGlzLl9maXJzdFBUJiZ0aGlzLl9pbml0dGVkJiZ0aGlzLl9lbmFibGVkKCExLCExKX19cmV0dXJuIGl9LGYuaW52YWxpZGF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkJiZGLl9vblBsdWdpbkV2ZW50KFwiX29uRGlzYWJsZVwiLHRoaXMpLHRoaXMuX2ZpcnN0UFQ9dGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcz10aGlzLl9zdGFydEF0PXRoaXMuX29uVXBkYXRlPW51bGwsdGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZD10aGlzLl9hY3RpdmU9dGhpcy5fbGF6eT0hMSx0aGlzLl9wcm9wTG9va3VwPXRoaXMuX3RhcmdldHM/e306W10sQy5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpLHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXImJih0aGlzLl90aW1lPS1rLHRoaXMucmVuZGVyKC10aGlzLl9kZWxheSkpLHRoaXN9LGYuX2VuYWJsZWQ9ZnVuY3Rpb24oYSxiKXtpZihofHxnLndha2UoKSxhJiZ0aGlzLl9nYyl7dmFyIGMsZD10aGlzLl90YXJnZXRzO2lmKGQpZm9yKGM9ZC5sZW5ndGg7LS1jPi0xOyl0aGlzLl9zaWJsaW5nc1tjXT1ZKGRbY10sdGhpcywhMCk7ZWxzZSB0aGlzLl9zaWJsaW5ncz1ZKHRoaXMudGFyZ2V0LHRoaXMsITApfXJldHVybiBDLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsYSxiKSx0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkJiZ0aGlzLl9maXJzdFBUP0YuX29uUGx1Z2luRXZlbnQoYT9cIl9vbkVuYWJsZVwiOlwiX29uRGlzYWJsZVwiLHRoaXMpOiExfSxGLnRvPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IEYoYSxiLGMpfSxGLmZyb209ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjLnJ1bkJhY2t3YXJkcz0hMCxjLmltbWVkaWF0ZVJlbmRlcj0wIT1jLmltbWVkaWF0ZVJlbmRlcixuZXcgRihhLGIsYyl9LEYuZnJvbVRvPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBkLnN0YXJ0QXQ9YyxkLmltbWVkaWF0ZVJlbmRlcj0wIT1kLmltbWVkaWF0ZVJlbmRlciYmMCE9Yy5pbW1lZGlhdGVSZW5kZXIsbmV3IEYoYSxiLGQpfSxGLmRlbGF5ZWRDYWxsPWZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIG5ldyBGKGIsMCx7ZGVsYXk6YSxvbkNvbXBsZXRlOmIsb25Db21wbGV0ZVBhcmFtczpjLGNhbGxiYWNrU2NvcGU6ZCxvblJldmVyc2VDb21wbGV0ZTpiLG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOmMsaW1tZWRpYXRlUmVuZGVyOiExLGxhenk6ITEsdXNlRnJhbWVzOmUsb3ZlcndyaXRlOjB9KX0sRi5zZXQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IEYoYSwwLGIpfSxGLmdldFR3ZWVuc09mPWZ1bmN0aW9uKGEsYil7aWYobnVsbD09YSlyZXR1cm5bXTthPVwic3RyaW5nXCIhPXR5cGVvZiBhP2E6Ri5zZWxlY3RvcihhKXx8YTt2YXIgYyxkLGUsZjtpZigobihhKXx8RyhhKSkmJlwibnVtYmVyXCIhPXR5cGVvZiBhWzBdKXtmb3IoYz1hLmxlbmd0aCxkPVtdOy0tYz4tMTspZD1kLmNvbmNhdChGLmdldFR3ZWVuc09mKGFbY10sYikpO2ZvcihjPWQubGVuZ3RoOy0tYz4tMTspZm9yKGY9ZFtjXSxlPWM7LS1lPi0xOylmPT09ZFtlXSYmZC5zcGxpY2UoYywxKX1lbHNlIGZvcihkPVkoYSkuY29uY2F0KCksYz1kLmxlbmd0aDstLWM+LTE7KShkW2NdLl9nY3x8YiYmIWRbY10uaXNBY3RpdmUoKSkmJmQuc3BsaWNlKGMsMSk7cmV0dXJuIGR9LEYua2lsbFR3ZWVuc09mPUYua2lsbERlbGF5ZWRDYWxsc1RvPWZ1bmN0aW9uKGEsYixjKXtcIm9iamVjdFwiPT10eXBlb2YgYiYmKGM9YixiPSExKTtmb3IodmFyIGQ9Ri5nZXRUd2VlbnNPZihhLGIpLGU9ZC5sZW5ndGg7LS1lPi0xOylkW2VdLl9raWxsKGMsYSl9O3ZhciBhYT1yKFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLGZ1bmN0aW9uKGEsYil7dGhpcy5fb3ZlcndyaXRlUHJvcHM9KGF8fFwiXCIpLnNwbGl0KFwiLFwiKSx0aGlzLl9wcm9wTmFtZT10aGlzLl9vdmVyd3JpdGVQcm9wc1swXSx0aGlzLl9wcmlvcml0eT1ifHwwLHRoaXMuX3N1cGVyPWFhLnByb3RvdHlwZX0sITApO2lmKGY9YWEucHJvdG90eXBlLGFhLnZlcnNpb249XCIxLjE4LjBcIixhYS5BUEk9MixmLl9maXJzdFBUPW51bGwsZi5fYWRkVHdlZW49TixmLnNldFJhdGlvPUwsZi5fa2lsbD1mdW5jdGlvbihhKXt2YXIgYixjPXRoaXMuX292ZXJ3cml0ZVByb3BzLGQ9dGhpcy5fZmlyc3RQVDtpZihudWxsIT1hW3RoaXMuX3Byb3BOYW1lXSl0aGlzLl9vdmVyd3JpdGVQcm9wcz1bXTtlbHNlIGZvcihiPWMubGVuZ3RoOy0tYj4tMTspbnVsbCE9YVtjW2JdXSYmYy5zcGxpY2UoYiwxKTtmb3IoO2Q7KW51bGwhPWFbZC5uXSYmKGQuX25leHQmJihkLl9uZXh0Ll9wcmV2PWQuX3ByZXYpLGQuX3ByZXY/KGQuX3ByZXYuX25leHQ9ZC5fbmV4dCxkLl9wcmV2PW51bGwpOnRoaXMuX2ZpcnN0UFQ9PT1kJiYodGhpcy5fZmlyc3RQVD1kLl9uZXh0KSksZD1kLl9uZXh0O3JldHVybiExfSxmLl9yb3VuZFByb3BzPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPXRoaXMuX2ZpcnN0UFQ7YzspKGFbdGhpcy5fcHJvcE5hbWVdfHxudWxsIT1jLm4mJmFbYy5uLnNwbGl0KHRoaXMuX3Byb3BOYW1lK1wiX1wiKS5qb2luKFwiXCIpXSkmJihjLnI9YiksYz1jLl9uZXh0fSxGLl9vblBsdWdpbkV2ZW50PWZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZyxoPWIuX2ZpcnN0UFQ7aWYoXCJfb25Jbml0QWxsUHJvcHNcIj09PWEpe2Zvcig7aDspe2ZvcihnPWguX25leHQsZD1lO2QmJmQucHI+aC5wcjspZD1kLl9uZXh0OyhoLl9wcmV2PWQ/ZC5fcHJldjpmKT9oLl9wcmV2Ll9uZXh0PWg6ZT1oLChoLl9uZXh0PWQpP2QuX3ByZXY9aDpmPWgsaD1nfWg9Yi5fZmlyc3RQVD1lfWZvcig7aDspaC5wZyYmXCJmdW5jdGlvblwiPT10eXBlb2YgaC50W2FdJiZoLnRbYV0oKSYmKGM9ITApLGg9aC5fbmV4dDtyZXR1cm4gY30sYWEuYWN0aXZhdGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEubGVuZ3RoOy0tYj4tMTspYVtiXS5BUEk9PT1hYS5BUEkmJihQWyhuZXcgYVtiXSkuX3Byb3BOYW1lXT1hW2JdKTtyZXR1cm4hMH0scS5wbHVnaW49ZnVuY3Rpb24oYSl7aWYoIShhJiZhLnByb3BOYW1lJiZhLmluaXQmJmEuQVBJKSl0aHJvd1wiaWxsZWdhbCBwbHVnaW4gZGVmaW5pdGlvbi5cIjt2YXIgYixjPWEucHJvcE5hbWUsZD1hLnByaW9yaXR5fHwwLGU9YS5vdmVyd3JpdGVQcm9wcyxmPXtpbml0OlwiX29uSW5pdFR3ZWVuXCIsc2V0Olwic2V0UmF0aW9cIixraWxsOlwiX2tpbGxcIixyb3VuZDpcIl9yb3VuZFByb3BzXCIsaW5pdEFsbDpcIl9vbkluaXRBbGxQcm9wc1wifSxnPXIoXCJwbHVnaW5zLlwiK2MuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrYy5zdWJzdHIoMSkrXCJQbHVnaW5cIixmdW5jdGlvbigpe2FhLmNhbGwodGhpcyxjLGQpLHRoaXMuX292ZXJ3cml0ZVByb3BzPWV8fFtdfSxhLmdsb2JhbD09PSEwKSxoPWcucHJvdG90eXBlPW5ldyBhYShjKTtoLmNvbnN0cnVjdG9yPWcsZy5BUEk9YS5BUEk7Zm9yKGIgaW4gZilcImZ1bmN0aW9uXCI9PXR5cGVvZiBhW2JdJiYoaFtmW2JdXT1hW2JdKTtyZXR1cm4gZy52ZXJzaW9uPWEudmVyc2lvbixhYS5hY3RpdmF0ZShbZ10pLGd9LGQ9YS5fZ3NRdWV1ZSl7Zm9yKGU9MDtlPGQubGVuZ3RoO2UrKylkW2VdKCk7Zm9yKGYgaW4gbylvW2ZdLmZ1bmN8fGEuY29uc29sZS5sb2coXCJHU0FQIGVuY291bnRlcmVkIG1pc3NpbmcgZGVwZW5kZW5jeTogY29tLmdyZWVuc29jay5cIitmKX1oPSExfX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOnRoaXN8fHdpbmRvdyxcIlR3ZWVuTWF4XCIpOyJdLCJmaWxlIjoiZ3JlZW5zb2NrL1R3ZWVuTWF4Lm1pbi5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9

/*!

 handlebars v4.0.5

Copyright (C) 2011-2015 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else if (typeof exports === 'object')
        exports["Handlebars"] = factory();
    else
        root["Handlebars"] = factory();
})(this, function() {
    return /******/ (function(modules) { // webpackBootstrap
            /******/ // The module cache
            /******/
            var installedModules = {};

            /******/ // The require function
            /******/
            function __webpack_require__(moduleId) {

                /******/ // Check if module is in cache
                /******/
                if (installedModules[moduleId])
                /******/
                    return installedModules[moduleId].exports;

                /******/ // Create a new module (and put it into the cache)
                /******/
                var module = installedModules[moduleId] = {
                    /******/
                    exports: {},
                    /******/
                    id: moduleId,
                    /******/
                    loaded: false
                        /******/
                };

                /******/ // Execute the module function
                /******/
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

                /******/ // Flag the module as loaded
                /******/
                module.loaded = true;

                /******/ // Return the exports of the module
                /******/
                return module.exports;
                /******/
            }


            /******/ // expose the modules object (__webpack_modules__)
            /******/
            __webpack_require__.m = modules;

            /******/ // expose the module cache
            /******/
            __webpack_require__.c = installedModules;

            /******/ // __webpack_public_path__
            /******/
            __webpack_require__.p = "";

            /******/ // Load entry module and return exports
            /******/
            return __webpack_require__(0);
            /******/
        })
        /************************************************************************/
        /******/
        ([
            /* 0 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;

                var _handlebarsRuntime = __webpack_require__(2);

                var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

                // Compiler imports

                var _handlebarsCompilerAst = __webpack_require__(21);

                var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

                var _handlebarsCompilerBase = __webpack_require__(22);

                var _handlebarsCompilerCompiler = __webpack_require__(27);

                var _handlebarsCompilerJavascriptCompiler = __webpack_require__(28);

                var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

                var _handlebarsCompilerVisitor = __webpack_require__(25);

                var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

                var _handlebarsNoConflict = __webpack_require__(20);

                var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

                var _create = _handlebarsRuntime2['default'].create;

                function create() {
                    var hb = _create();

                    hb.compile = function(input, options) {
                        return _handlebarsCompilerCompiler.compile(input, options, hb);
                    };
                    hb.precompile = function(input, options) {
                        return _handlebarsCompilerCompiler.precompile(input, options, hb);
                    };

                    hb.AST = _handlebarsCompilerAst2['default'];
                    hb.Compiler = _handlebarsCompilerCompiler.Compiler;
                    hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
                    hb.Parser = _handlebarsCompilerBase.parser;
                    hb.parse = _handlebarsCompilerBase.parse;

                    return hb;
                }

                var inst = create();
                inst.create = create;

                _handlebarsNoConflict2['default'](inst);

                inst.Visitor = _handlebarsCompilerVisitor2['default'];

                inst['default'] = inst;

                exports['default'] = inst;
                module.exports = exports['default'];

                /***/
            },
            /* 1 */
            /***/
            function(module, exports) {

                "use strict";

                exports["default"] = function(obj) {
                    return obj && obj.__esModule ? obj : {
                        "default": obj
                    };
                };

                exports.__esModule = true;

                /***/
            },
            /* 2 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireWildcard = __webpack_require__(3)['default'];

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;

                var _handlebarsBase = __webpack_require__(4);

                var base = _interopRequireWildcard(_handlebarsBase);

                // Each of these augment the Handlebars object. No need to setup here.
                // (This is done to easily share code between commonjs and browse envs)

                var _handlebarsSafeString = __webpack_require__(18);

                var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

                var _handlebarsException = __webpack_require__(6);

                var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

                var _handlebarsUtils = __webpack_require__(5);

                var Utils = _interopRequireWildcard(_handlebarsUtils);

                var _handlebarsRuntime = __webpack_require__(19);

                var runtime = _interopRequireWildcard(_handlebarsRuntime);

                var _handlebarsNoConflict = __webpack_require__(20);

                var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

                // For compatibility and usage outside of module systems, make the Handlebars object a namespace
                function create() {
                    var hb = new base.HandlebarsEnvironment();

                    Utils.extend(hb, base);
                    hb.SafeString = _handlebarsSafeString2['default'];
                    hb.Exception = _handlebarsException2['default'];
                    hb.Utils = Utils;
                    hb.escapeExpression = Utils.escapeExpression;

                    hb.VM = runtime;
                    hb.template = function(spec) {
                        return runtime.template(spec, hb);
                    };

                    return hb;
                }

                var inst = create();
                inst.create = create;

                _handlebarsNoConflict2['default'](inst);

                inst['default'] = inst;

                exports['default'] = inst;
                module.exports = exports['default'];

                /***/
            },
            /* 3 */
            /***/
            function(module, exports) {

                "use strict";

                exports["default"] = function(obj) {
                    if (obj && obj.__esModule) {
                        return obj;
                    } else {
                        var newObj = {};

                        if (obj != null) {
                            for (var key in obj) {
                                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                            }
                        }

                        newObj["default"] = obj;
                        return newObj;
                    }
                };

                exports.__esModule = true;

                /***/
            },
            /* 4 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;
                exports.HandlebarsEnvironment = HandlebarsEnvironment;

                var _utils = __webpack_require__(5);

                var _exception = __webpack_require__(6);

                var _exception2 = _interopRequireDefault(_exception);

                var _helpers = __webpack_require__(7);

                var _decorators = __webpack_require__(15);

                var _logger = __webpack_require__(17);

                var _logger2 = _interopRequireDefault(_logger);

                var VERSION = '4.0.5';
                exports.VERSION = VERSION;
                var COMPILER_REVISION = 7;

                exports.COMPILER_REVISION = COMPILER_REVISION;
                var REVISION_CHANGES = {
                    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
                    2: '== 1.0.0-rc.3',
                    3: '== 1.0.0-rc.4',
                    4: '== 1.x.x',
                    5: '== 2.0.0-alpha.x',
                    6: '>= 2.0.0-beta.1',
                    7: '>= 4.0.0'
                };

                exports.REVISION_CHANGES = REVISION_CHANGES;
                var objectType = '[object Object]';

                function HandlebarsEnvironment(helpers, partials, decorators) {
                    this.helpers = helpers || {};
                    this.partials = partials || {};
                    this.decorators = decorators || {};

                    _helpers.registerDefaultHelpers(this);
                    _decorators.registerDefaultDecorators(this);
                }

                HandlebarsEnvironment.prototype = {
                    constructor: HandlebarsEnvironment,

                    logger: _logger2['default'],
                    log: _logger2['default'].log,

                    registerHelper: function registerHelper(name, fn) {
                        if (_utils.toString.call(name) === objectType) {
                            if (fn) {
                                throw new _exception2['default']('Arg not supported with multiple helpers');
                            }
                            _utils.extend(this.helpers, name);
                        } else {
                            this.helpers[name] = fn;
                        }
                    },
                    unregisterHelper: function unregisterHelper(name) {
                        delete this.helpers[name];
                    },

                    registerPartial: function registerPartial(name, partial) {
                        if (_utils.toString.call(name) === objectType) {
                            _utils.extend(this.partials, name);
                        } else {
                            if (typeof partial === 'undefined') {
                                throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
                            }
                            this.partials[name] = partial;
                        }
                    },
                    unregisterPartial: function unregisterPartial(name) {
                        delete this.partials[name];
                    },

                    registerDecorator: function registerDecorator(name, fn) {
                        if (_utils.toString.call(name) === objectType) {
                            if (fn) {
                                throw new _exception2['default']('Arg not supported with multiple decorators');
                            }
                            _utils.extend(this.decorators, name);
                        } else {
                            this.decorators[name] = fn;
                        }
                    },
                    unregisterDecorator: function unregisterDecorator(name) {
                        delete this.decorators[name];
                    }
                };

                var log = _logger2['default'].log;

                exports.log = log;
                exports.createFrame = _utils.createFrame;
                exports.logger = _logger2['default'];

                /***/
            },
            /* 5 */
            /***/
            function(module, exports) {

                'use strict';

                exports.__esModule = true;
                exports.extend = extend;
                exports.indexOf = indexOf;
                exports.escapeExpression = escapeExpression;
                exports.isEmpty = isEmpty;
                exports.createFrame = createFrame;
                exports.blockParams = blockParams;
                exports.appendContextPath = appendContextPath;
                var escape = {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#x27;',
                    '`': '&#x60;',
                    '=': '&#x3D;'
                };

                var badChars = /[&<>"'`=]/g,
                    possible = /[&<>"'`=]/;

                function escapeChar(chr) {
                    return escape[chr];
                }

                function extend(obj /* , ...source */ ) {
                    for (var i = 1; i < arguments.length; i++) {
                        for (var key in arguments[i]) {
                            if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                                obj[key] = arguments[i][key];
                            }
                        }
                    }

                    return obj;
                }

                var toString = Object.prototype.toString;

                exports.toString = toString;
                // Sourced from lodash
                // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
                /* eslint-disable func-style */
                var isFunction = function isFunction(value) {
                    return typeof value === 'function';
                };
                // fallback for older versions of Chrome and Safari
                /* istanbul ignore next */
                if (isFunction(/x/)) {
                    exports.isFunction = isFunction = function(value) {
                        return typeof value === 'function' && toString.call(value) === '[object Function]';
                    };
                }
                exports.isFunction = isFunction;

                /* eslint-enable func-style */

                /* istanbul ignore next */
                var isArray = Array.isArray || function(value) {
                    return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
                };

                exports.isArray = isArray;
                // Older IE versions do not directly support indexOf so we must implement our own, sadly.

                function indexOf(array, value) {
                    for (var i = 0, len = array.length; i < len; i++) {
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                }

                function escapeExpression(string) {
                    if (typeof string !== 'string') {
                        // don't escape SafeStrings, since they're already safe
                        if (string && string.toHTML) {
                            return string.toHTML();
                        } else if (string == null) {
                            return '';
                        } else if (!string) {
                            return string + '';
                        }

                        // Force a string conversion as this will be done by the append regardless and
                        // the regex test will do this transparently behind the scenes, causing issues if
                        // an object's to string has escaped characters in it.
                        string = '' + string;
                    }

                    if (!possible.test(string)) {
                        return string;
                    }
                    return string.replace(badChars, escapeChar);
                }

                function isEmpty(value) {
                    if (!value && value !== 0) {
                        return true;
                    } else if (isArray(value) && value.length === 0) {
                        return true;
                    } else {
                        return false;
                    }
                }

                function createFrame(object) {
                    var frame = extend({}, object);
                    frame._parent = object;
                    return frame;
                }

                function blockParams(params, ids) {
                    params.path = ids;
                    return params;
                }

                function appendContextPath(contextPath, id) {
                    return (contextPath ? contextPath + '.' : '') + id;
                }

                /***/
            },
            /* 6 */
            /***/
            function(module, exports) {

                'use strict';

                exports.__esModule = true;

                var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

                function Exception(message, node) {
                    var loc = node && node.loc,
                        line = undefined,
                        column = undefined;
                    if (loc) {
                        line = loc.start.line;
                        column = loc.start.column;

                        message += ' - ' + line + ':' + column;
                    }

                    var tmp = Error.prototype.constructor.call(this, message);

                    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
                    for (var idx = 0; idx < errorProps.length; idx++) {
                        this[errorProps[idx]] = tmp[errorProps[idx]];
                    }

                    /* istanbul ignore else */
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, Exception);
                    }

                    if (loc) {
                        this.lineNumber = line;
                        this.column = column;
                    }
                }

                Exception.prototype = new Error();

                exports['default'] = Exception;
                module.exports = exports['default'];

                /***/
            },
            /* 7 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;
                exports.registerDefaultHelpers = registerDefaultHelpers;

                var _helpersBlockHelperMissing = __webpack_require__(8);

                var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

                var _helpersEach = __webpack_require__(9);

                var _helpersEach2 = _interopRequireDefault(_helpersEach);

                var _helpersHelperMissing = __webpack_require__(10);

                var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

                var _helpersIf = __webpack_require__(11);

                var _helpersIf2 = _interopRequireDefault(_helpersIf);

                var _helpersLog = __webpack_require__(12);

                var _helpersLog2 = _interopRequireDefault(_helpersLog);

                var _helpersLookup = __webpack_require__(13);

                var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

                var _helpersWith = __webpack_require__(14);

                var _helpersWith2 = _interopRequireDefault(_helpersWith);

                function registerDefaultHelpers(instance) {
                    _helpersBlockHelperMissing2['default'](instance);
                    _helpersEach2['default'](instance);
                    _helpersHelperMissing2['default'](instance);
                    _helpersIf2['default'](instance);
                    _helpersLog2['default'](instance);
                    _helpersLookup2['default'](instance);
                    _helpersWith2['default'](instance);
                }

                /***/
            },
            /* 8 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                exports.__esModule = true;

                var _utils = __webpack_require__(5);

                exports['default'] = function(instance) {
                    instance.registerHelper('blockHelperMissing', function(context, options) {
                        var inverse = options.inverse,
                            fn = options.fn;

                        if (context === true) {
                            return fn(this);
                        } else if (context === false || context == null) {
                            return inverse(this);
                        } else if (_utils.isArray(context)) {
                            if (context.length > 0) {
                                if (options.ids) {
                                    options.ids = [options.name];
                                }

                                return instance.helpers.each(context, options);
                            } else {
                                return inverse(this);
                            }
                        } else {
                            if (options.data && options.ids) {
                                var data = _utils.createFrame(options.data);
                                data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
                                options = {
                                    data: data
                                };
                            }

                            return fn(context, options);
                        }
                    });
                };

                module.exports = exports['default'];

                /***/
            },
            /* 9 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;

                var _utils = __webpack_require__(5);

                var _exception = __webpack_require__(6);

                var _exception2 = _interopRequireDefault(_exception);

                exports['default'] = function(instance) {
                    instance.registerHelper('each', function(context, options) {
                        if (!options) {
                            throw new _exception2['default']('Must pass iterator to #each');
                        }

                        var fn = options.fn,
                            inverse = options.inverse,
                            i = 0,
                            ret = '',
                            data = undefined,
                            contextPath = undefined;

                        if (options.data && options.ids) {
                            contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
                        }

                        if (_utils.isFunction(context)) {
                            context = context.call(this);
                        }

                        if (options.data) {
                            data = _utils.createFrame(options.data);
                        }

                        function execIteration(field, index, last) {
                            if (data) {
                                data.key = field;
                                data.index = index;
                                data.first = index === 0;
                                data.last = !!last;

                                if (contextPath) {
                                    data.contextPath = contextPath + field;
                                }
                            }

                            ret = ret + fn(context[field], {
                                data: data,
                                blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
                            });
                        }

                        if (context && typeof context === 'object') {
                            if (_utils.isArray(context)) {
                                for (var j = context.length; i < j; i++) {
                                    if (i in context) {
                                        execIteration(i, i, i === context.length - 1);
                                    }
                                }
                            } else {
                                var priorKey = undefined;

                                for (var key in context) {
                                    if (context.hasOwnProperty(key)) {
                                        // We're running the iterations one step out of sync so we can detect
                                        // the last iteration without have to scan the object twice and create
                                        // an itermediate keys array.
                                        if (priorKey !== undefined) {
                                            execIteration(priorKey, i - 1);
                                        }
                                        priorKey = key;
                                        i++;
                                    }
                                }
                                if (priorKey !== undefined) {
                                    execIteration(priorKey, i - 1, true);
                                }
                            }
                        }

                        if (i === 0) {
                            ret = inverse(this);
                        }

                        return ret;
                    });
                };

                module.exports = exports['default'];

                /***/
            },
            /* 10 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;

                var _exception = __webpack_require__(6);

                var _exception2 = _interopRequireDefault(_exception);

                exports['default'] = function(instance) {
                    instance.registerHelper('helperMissing', function() /* [args, ]options */ {
                        if (arguments.length === 1) {
                            // A missing field in a {{foo}} construct.
                            return undefined;
                        } else {
                            // Someone is actually trying to call something, blow up.
                            throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                        }
                    });
                };

                module.exports = exports['default'];

                /***/
            },
            /* 11 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                exports.__esModule = true;

                var _utils = __webpack_require__(5);

                exports['default'] = function(instance) {
                    instance.registerHelper('if', function(conditional, options) {
                        if (_utils.isFunction(conditional)) {
                            conditional = conditional.call(this);
                        }

                        // Default behavior is to render the positive path if the value is truthy and not empty.
                        // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                        // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                        if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
                            return options.inverse(this);
                        } else {
                            return options.fn(this);
                        }
                    });

                    instance.registerHelper('unless', function(conditional, options) {
                        return instance.helpers['if'].call(this, conditional, {
                            fn: options.inverse,
                            inverse: options.fn,
                            hash: options.hash
                        });
                    });
                };

                module.exports = exports['default'];

                /***/
            },
            /* 12 */
            /***/
            function(module, exports) {

                'use strict';

                exports.__esModule = true;

                exports['default'] = function(instance) {
                    instance.registerHelper('log', function() /* message, options */ {
                        var args = [undefined],
                            options = arguments[arguments.length - 1];
                        for (var i = 0; i < arguments.length - 1; i++) {
                            args.push(arguments[i]);
                        }

                        var level = 1;
                        if (options.hash.level != null) {
                            level = options.hash.level;
                        } else if (options.data && options.data.level != null) {
                            level = options.data.level;
                        }
                        args[0] = level;

                        instance.log.apply(instance, args);
                    });
                };

                module.exports = exports['default'];

                /***/
            },
            /* 13 */
            /***/
            function(module, exports) {

                'use strict';

                exports.__esModule = true;

                exports['default'] = function(instance) {
                    instance.registerHelper('lookup', function(obj, field) {
                        return obj && obj[field];
                    });
                };

                module.exports = exports['default'];

                /***/
            },
            /* 14 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                exports.__esModule = true;

                var _utils = __webpack_require__(5);

                exports['default'] = function(instance) {
                    instance.registerHelper('with', function(context, options) {
                        if (_utils.isFunction(context)) {
                            context = context.call(this);
                        }

                        var fn = options.fn;

                        if (!_utils.isEmpty(context)) {
                            var data = options.data;
                            if (options.data && options.ids) {
                                data = _utils.createFrame(options.data);
                                data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
                            }

                            return fn(context, {
                                data: data,
                                blockParams: _utils.blockParams([context], [data && data.contextPath])
                            });
                        } else {
                            return options.inverse(this);
                        }
                    });
                };

                module.exports = exports['default'];

                /***/
            },
            /* 15 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;
                exports.registerDefaultDecorators = registerDefaultDecorators;

                var _decoratorsInline = __webpack_require__(16);

                var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

                function registerDefaultDecorators(instance) {
                    _decoratorsInline2['default'](instance);
                }

                /***/
            },
            /* 16 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                exports.__esModule = true;

                var _utils = __webpack_require__(5);

                exports['default'] = function(instance) {
                    instance.registerDecorator('inline', function(fn, props, container, options) {
                        var ret = fn;
                        if (!props.partials) {
                            props.partials = {};
                            ret = function(context, options) {
                                // Create a new partials stack frame prior to exec.
                                var original = container.partials;
                                container.partials = _utils.extend({}, original, props.partials);
                                var ret = fn(context, options);
                                container.partials = original;
                                return ret;
                            };
                        }

                        props.partials[options.args[0]] = options.fn;

                        return ret;
                    });
                };

                module.exports = exports['default'];

                /***/
            },
            /* 17 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                exports.__esModule = true;

                var _utils = __webpack_require__(5);

                var logger = {
                    methodMap: ['debug', 'info', 'warn', 'error'],
                    level: 'info',

                    // Maps a given level value to the `methodMap` indexes above.
                    lookupLevel: function lookupLevel(level) {
                        if (typeof level === 'string') {
                            var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
                            if (levelMap >= 0) {
                                level = levelMap;
                            } else {
                                level = parseInt(level, 10);
                            }
                        }

                        return level;
                    },

                    // Can be overridden in the host environment
                    log: function log(level) {
                        level = logger.lookupLevel(level);

                        if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
                            var method = logger.methodMap[level];
                            if (!console[method]) {
                                // eslint-disable-line no-console
                                method = 'log';
                            }

                            for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                                message[_key - 1] = arguments[_key];
                            }

                            console[method].apply(console, message); // eslint-disable-line no-console
                        }
                    }
                };

                exports['default'] = logger;
                module.exports = exports['default'];

                /***/
            },
            /* 18 */
            /***/
            function(module, exports) {

                // Build out our basic SafeString type
                'use strict';

                exports.__esModule = true;

                function SafeString(string) {
                    this.string = string;
                }

                SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
                    return '' + this.string;
                };

                exports['default'] = SafeString;
                module.exports = exports['default'];

                /***/
            },
            /* 19 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireWildcard = __webpack_require__(3)['default'];

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;
                exports.checkRevision = checkRevision;
                exports.template = template;
                exports.wrapProgram = wrapProgram;
                exports.resolvePartial = resolvePartial;
                exports.invokePartial = invokePartial;
                exports.noop = noop;

                var _utils = __webpack_require__(5);

                var Utils = _interopRequireWildcard(_utils);

                var _exception = __webpack_require__(6);

                var _exception2 = _interopRequireDefault(_exception);

                var _base = __webpack_require__(4);

                function checkRevision(compilerInfo) {
                    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
                        currentRevision = _base.COMPILER_REVISION;

                    if (compilerRevision !== currentRevision) {
                        if (compilerRevision < currentRevision) {
                            var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
                                compilerVersions = _base.REVISION_CHANGES[compilerRevision];
                            throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
                        } else {
                            // Use the embedded version info since the runtime doesn't know about this revision yet
                            throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
                        }
                    }
                }

                function template(templateSpec, env) {
                    /* istanbul ignore next */
                    if (!env) {
                        throw new _exception2['default']('No environment passed to template');
                    }
                    if (!templateSpec || !templateSpec.main) {
                        throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
                    }

                    templateSpec.main.decorator = templateSpec.main_d;

                    // Note: Using env.VM references rather than local var references throughout this section to allow
                    // for external users to override these as psuedo-supported APIs.
                    env.VM.checkRevision(templateSpec.compiler);

                    function invokePartialWrapper(partial, context, options) {
                        if (options.hash) {
                            context = Utils.extend({}, context, options.hash);
                            if (options.ids) {
                                options.ids[0] = true;
                            }
                        }

                        partial = env.VM.resolvePartial.call(this, partial, context, options);
                        var result = env.VM.invokePartial.call(this, partial, context, options);

                        if (result == null && env.compile) {
                            options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
                            result = options.partials[options.name](context, options);
                        }
                        if (result != null) {
                            if (options.indent) {
                                var lines = result.split('\n');
                                for (var i = 0, l = lines.length; i < l; i++) {
                                    if (!lines[i] && i + 1 === l) {
                                        break;
                                    }

                                    lines[i] = options.indent + lines[i];
                                }
                                result = lines.join('\n');
                            }
                            return result;
                        } else {
                            throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
                        }
                    }

                    // Just add water
                    var container = {
                        strict: function strict(obj, name) {
                            if (!(name in obj)) {
                                throw new _exception2['default']('"' + name + '" not defined in ' + obj);
                            }
                            return obj[name];
                        },
                        lookup: function lookup(depths, name) {
                            var len = depths.length;
                            for (var i = 0; i < len; i++) {
                                if (depths[i] && depths[i][name] != null) {
                                    return depths[i][name];
                                }
                            }
                        },
                        lambda: function lambda(current, context) {
                            return typeof current === 'function' ? current.call(context) : current;
                        },

                        escapeExpression: Utils.escapeExpression,
                        invokePartial: invokePartialWrapper,

                        fn: function fn(i) {
                            var ret = templateSpec[i];
                            ret.decorator = templateSpec[i + '_d'];
                            return ret;
                        },

                        programs: [],
                        program: function program(i, data, declaredBlockParams, blockParams, depths) {
                            var programWrapper = this.programs[i],
                                fn = this.fn(i);
                            if (data || depths || blockParams || declaredBlockParams) {
                                programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                            } else if (!programWrapper) {
                                programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                            }
                            return programWrapper;
                        },

                        data: function data(value, depth) {
                            while (value && depth--) {
                                value = value._parent;
                            }
                            return value;
                        },
                        merge: function merge(param, common) {
                            var obj = param || common;

                            if (param && common && param !== common) {
                                obj = Utils.extend({}, common, param);
                            }

                            return obj;
                        },

                        noop: env.VM.noop,
                        compilerInfo: templateSpec.compiler
                    };

                    function ret(context) {
                        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var data = options.data;

                        ret._setup(options);
                        if (!options.partial && templateSpec.useData) {
                            data = initData(context, data);
                        }
                        var depths = undefined,
                            blockParams = templateSpec.useBlockParams ? [] : undefined;
                        if (templateSpec.useDepths) {
                            if (options.depths) {
                                depths = context !== options.depths[0] ? [context].concat(options.depths) : options.depths;
                            } else {
                                depths = [context];
                            }
                        }

                        function main(context /*, options*/ ) {
                            return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
                        }
                        main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
                        return main(context, options);
                    }
                    ret.isTop = true;

                    ret._setup = function(options) {
                        if (!options.partial) {
                            container.helpers = container.merge(options.helpers, env.helpers);

                            if (templateSpec.usePartial) {
                                container.partials = container.merge(options.partials, env.partials);
                            }
                            if (templateSpec.usePartial || templateSpec.useDecorators) {
                                container.decorators = container.merge(options.decorators, env.decorators);
                            }
                        } else {
                            container.helpers = options.helpers;
                            container.partials = options.partials;
                            container.decorators = options.decorators;
                        }
                    };

                    ret._child = function(i, data, blockParams, depths) {
                        if (templateSpec.useBlockParams && !blockParams) {
                            throw new _exception2['default']('must pass block params');
                        }
                        if (templateSpec.useDepths && !depths) {
                            throw new _exception2['default']('must pass parent depths');
                        }

                        return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
                    };
                    return ret;
                }

                function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
                    function prog(context) {
                        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                        var currentDepths = depths;
                        if (depths && context !== depths[0]) {
                            currentDepths = [context].concat(depths);
                        }

                        return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
                    }

                    prog = executeDecorators(fn, prog, container, depths, data, blockParams);

                    prog.program = i;
                    prog.depth = depths ? depths.length : 0;
                    prog.blockParams = declaredBlockParams || 0;
                    return prog;
                }

                function resolvePartial(partial, context, options) {
                    if (!partial) {
                        if (options.name === '@partial-block') {
                            partial = options.data['partial-block'];
                        } else {
                            partial = options.partials[options.name];
                        }
                    } else if (!partial.call && !options.name) {
                        // This is a dynamic partial that returned a string
                        options.name = partial;
                        partial = options.partials[partial];
                    }
                    return partial;
                }

                function invokePartial(partial, context, options) {
                    options.partial = true;
                    if (options.ids) {
                        options.data.contextPath = options.ids[0] || options.data.contextPath;
                    }

                    var partialBlock = undefined;
                    if (options.fn && options.fn !== noop) {
                        options.data = _base.createFrame(options.data);
                        partialBlock = options.data['partial-block'] = options.fn;

                        if (partialBlock.partials) {
                            options.partials = Utils.extend({}, options.partials, partialBlock.partials);
                        }
                    }

                    if (partial === undefined && partialBlock) {
                        partial = partialBlock;
                    }

                    if (partial === undefined) {
                        throw new _exception2['default']('The partial ' + options.name + ' could not be found');
                    } else if (partial instanceof Function) {
                        return partial(context, options);
                    }
                }

                function noop() {
                    return '';
                }

                function initData(context, data) {
                    if (!data || !('root' in data)) {
                        data = data ? _base.createFrame(data) : {};
                        data.root = context;
                    }
                    return data;
                }

                function executeDecorators(fn, prog, container, depths, data, blockParams) {
                    if (fn.decorator) {
                        var props = {};
                        prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                        Utils.extend(prog, props);
                    }
                    return prog;
                }

                /***/
            },
            /* 20 */
            /***/
            function(module, exports) {

                /* WEBPACK VAR INJECTION */
                (function(global) { /* global window */
                    'use strict';

                    exports.__esModule = true;

                    exports['default'] = function(Handlebars) {
                        /* istanbul ignore next */
                        var root = typeof global !== 'undefined' ? global : window,
                            $Handlebars = root.Handlebars;
                        /* istanbul ignore next */
                        Handlebars.noConflict = function() {
                            if (root.Handlebars === Handlebars) {
                                root.Handlebars = $Handlebars;
                            }
                            return Handlebars;
                        };
                    };

                    module.exports = exports['default'];
                    /* WEBPACK VAR INJECTION */
                }.call(exports, (function() {
                    return this;
                }())))

                /***/
            },
            /* 21 */
            /***/
            function(module, exports) {

                'use strict';

                exports.__esModule = true;
                var AST = {
                    // Public API used to evaluate derived attributes regarding AST nodes
                    helpers: {
                        // a mustache is definitely a helper if:
                        // * it is an eligible helper, and
                        // * it has at least one parameter or hash segment
                        helperExpression: function helperExpression(node) {
                            return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
                        },

                        scopedId: function scopedId(path) {
                            return (/^\.|this\b/.test(path.original));
                        },

                        // an ID is simple if it only has one part, and that part is not
                        // `..` or `this`.
                        simpleId: function simpleId(path) {
                            return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
                        }
                    }
                };

                // Must be exported as an object rather than the root of the module as the jison lexer
                // must modify the object to operate properly.
                exports['default'] = AST;
                module.exports = exports['default'];

                /***/
            },
            /* 22 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                var _interopRequireWildcard = __webpack_require__(3)['default'];

                exports.__esModule = true;
                exports.parse = parse;

                var _parser = __webpack_require__(23);

                var _parser2 = _interopRequireDefault(_parser);

                var _whitespaceControl = __webpack_require__(24);

                var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

                var _helpers = __webpack_require__(26);

                var Helpers = _interopRequireWildcard(_helpers);

                var _utils = __webpack_require__(5);

                exports.parser = _parser2['default'];

                var yy = {};
                _utils.extend(yy, Helpers);

                function parse(input, options) {
                    // Just return if an already-compiled AST was passed in.
                    if (input.type === 'Program') {
                        return input;
                    }

                    _parser2['default'].yy = yy;

                    // Altering the shared object here, but this is ok as parser is a sync operation
                    yy.locInfo = function(locInfo) {
                        return new yy.SourceLocation(options && options.srcName, locInfo);
                    };

                    var strip = new _whitespaceControl2['default'](options);
                    return strip.accept(_parser2['default'].parse(input));
                }

                /***/
            },
            /* 23 */
            /***/
            function(module, exports) {

                /* istanbul ignore next */
                /* Jison generated parser */
                "use strict";

                var handlebars = (function() {
                    var parser = {
                        trace: function trace() {},
                        yy: {},
                        symbols_: {
                            "error": 2,
                            "root": 3,
                            "program": 4,
                            "EOF": 5,
                            "program_repetition0": 6,
                            "statement": 7,
                            "mustache": 8,
                            "block": 9,
                            "rawBlock": 10,
                            "partial": 11,
                            "partialBlock": 12,
                            "content": 13,
                            "COMMENT": 14,
                            "CONTENT": 15,
                            "openRawBlock": 16,
                            "rawBlock_repetition_plus0": 17,
                            "END_RAW_BLOCK": 18,
                            "OPEN_RAW_BLOCK": 19,
                            "helperName": 20,
                            "openRawBlock_repetition0": 21,
                            "openRawBlock_option0": 22,
                            "CLOSE_RAW_BLOCK": 23,
                            "openBlock": 24,
                            "block_option0": 25,
                            "closeBlock": 26,
                            "openInverse": 27,
                            "block_option1": 28,
                            "OPEN_BLOCK": 29,
                            "openBlock_repetition0": 30,
                            "openBlock_option0": 31,
                            "openBlock_option1": 32,
                            "CLOSE": 33,
                            "OPEN_INVERSE": 34,
                            "openInverse_repetition0": 35,
                            "openInverse_option0": 36,
                            "openInverse_option1": 37,
                            "openInverseChain": 38,
                            "OPEN_INVERSE_CHAIN": 39,
                            "openInverseChain_repetition0": 40,
                            "openInverseChain_option0": 41,
                            "openInverseChain_option1": 42,
                            "inverseAndProgram": 43,
                            "INVERSE": 44,
                            "inverseChain": 45,
                            "inverseChain_option0": 46,
                            "OPEN_ENDBLOCK": 47,
                            "OPEN": 48,
                            "mustache_repetition0": 49,
                            "mustache_option0": 50,
                            "OPEN_UNESCAPED": 51,
                            "mustache_repetition1": 52,
                            "mustache_option1": 53,
                            "CLOSE_UNESCAPED": 54,
                            "OPEN_PARTIAL": 55,
                            "partialName": 56,
                            "partial_repetition0": 57,
                            "partial_option0": 58,
                            "openPartialBlock": 59,
                            "OPEN_PARTIAL_BLOCK": 60,
                            "openPartialBlock_repetition0": 61,
                            "openPartialBlock_option0": 62,
                            "param": 63,
                            "sexpr": 64,
                            "OPEN_SEXPR": 65,
                            "sexpr_repetition0": 66,
                            "sexpr_option0": 67,
                            "CLOSE_SEXPR": 68,
                            "hash": 69,
                            "hash_repetition_plus0": 70,
                            "hashSegment": 71,
                            "ID": 72,
                            "EQUALS": 73,
                            "blockParams": 74,
                            "OPEN_BLOCK_PARAMS": 75,
                            "blockParams_repetition_plus0": 76,
                            "CLOSE_BLOCK_PARAMS": 77,
                            "path": 78,
                            "dataName": 79,
                            "STRING": 80,
                            "NUMBER": 81,
                            "BOOLEAN": 82,
                            "UNDEFINED": 83,
                            "NULL": 84,
                            "DATA": 85,
                            "pathSegments": 86,
                            "SEP": 87,
                            "$accept": 0,
                            "$end": 1
                        },
                        terminals_: {
                            2: "error",
                            5: "EOF",
                            14: "COMMENT",
                            15: "CONTENT",
                            18: "END_RAW_BLOCK",
                            19: "OPEN_RAW_BLOCK",
                            23: "CLOSE_RAW_BLOCK",
                            29: "OPEN_BLOCK",
                            33: "CLOSE",
                            34: "OPEN_INVERSE",
                            39: "OPEN_INVERSE_CHAIN",
                            44: "INVERSE",
                            47: "OPEN_ENDBLOCK",
                            48: "OPEN",
                            51: "OPEN_UNESCAPED",
                            54: "CLOSE_UNESCAPED",
                            55: "OPEN_PARTIAL",
                            60: "OPEN_PARTIAL_BLOCK",
                            65: "OPEN_SEXPR",
                            68: "CLOSE_SEXPR",
                            72: "ID",
                            73: "EQUALS",
                            75: "OPEN_BLOCK_PARAMS",
                            77: "CLOSE_BLOCK_PARAMS",
                            80: "STRING",
                            81: "NUMBER",
                            82: "BOOLEAN",
                            83: "UNDEFINED",
                            84: "NULL",
                            85: "DATA",
                            87: "SEP"
                        },
                        productions_: [0, [3, 2],
                            [4, 1],
                            [7, 1],
                            [7, 1],
                            [7, 1],
                            [7, 1],
                            [7, 1],
                            [7, 1],
                            [7, 1],
                            [13, 1],
                            [10, 3],
                            [16, 5],
                            [9, 4],
                            [9, 4],
                            [24, 6],
                            [27, 6],
                            [38, 6],
                            [43, 2],
                            [45, 3],
                            [45, 1],
                            [26, 3],
                            [8, 5],
                            [8, 5],
                            [11, 5],
                            [12, 3],
                            [59, 5],
                            [63, 1],
                            [63, 1],
                            [64, 5],
                            [69, 1],
                            [71, 3],
                            [74, 3],
                            [20, 1],
                            [20, 1],
                            [20, 1],
                            [20, 1],
                            [20, 1],
                            [20, 1],
                            [20, 1],
                            [56, 1],
                            [56, 1],
                            [79, 2],
                            [78, 1],
                            [86, 3],
                            [86, 1],
                            [6, 0],
                            [6, 2],
                            [17, 1],
                            [17, 2],
                            [21, 0],
                            [21, 2],
                            [22, 0],
                            [22, 1],
                            [25, 0],
                            [25, 1],
                            [28, 0],
                            [28, 1],
                            [30, 0],
                            [30, 2],
                            [31, 0],
                            [31, 1],
                            [32, 0],
                            [32, 1],
                            [35, 0],
                            [35, 2],
                            [36, 0],
                            [36, 1],
                            [37, 0],
                            [37, 1],
                            [40, 0],
                            [40, 2],
                            [41, 0],
                            [41, 1],
                            [42, 0],
                            [42, 1],
                            [46, 0],
                            [46, 1],
                            [49, 0],
                            [49, 2],
                            [50, 0],
                            [50, 1],
                            [52, 0],
                            [52, 2],
                            [53, 0],
                            [53, 1],
                            [57, 0],
                            [57, 2],
                            [58, 0],
                            [58, 1],
                            [61, 0],
                            [61, 2],
                            [62, 0],
                            [62, 1],
                            [66, 0],
                            [66, 2],
                            [67, 0],
                            [67, 1],
                            [70, 1],
                            [70, 2],
                            [76, 1],
                            [76, 2]
                        ],
                        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
                            /**/
                        ) {

                            var $0 = $$.length - 1;
                            switch (yystate) {
                                case 1:
                                    return $$[$0 - 1];
                                    break;
                                case 2:
                                    this.$ = yy.prepareProgram($$[$0]);
                                    break;
                                case 3:
                                    this.$ = $$[$0];
                                    break;
                                case 4:
                                    this.$ = $$[$0];
                                    break;
                                case 5:
                                    this.$ = $$[$0];
                                    break;
                                case 6:
                                    this.$ = $$[$0];
                                    break;
                                case 7:
                                    this.$ = $$[$0];
                                    break;
                                case 8:
                                    this.$ = $$[$0];
                                    break;
                                case 9:
                                    this.$ = {
                                        type: 'CommentStatement',
                                        value: yy.stripComment($$[$0]),
                                        strip: yy.stripFlags($$[$0], $$[$0]),
                                        loc: yy.locInfo(this._$)
                                    };

                                    break;
                                case 10:
                                    this.$ = {
                                        type: 'ContentStatement',
                                        original: $$[$0],
                                        value: $$[$0],
                                        loc: yy.locInfo(this._$)
                                    };

                                    break;
                                case 11:
                                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                    break;
                                case 12:
                                    this.$ = {
                                        path: $$[$0 - 3],
                                        params: $$[$0 - 2],
                                        hash: $$[$0 - 1]
                                    };
                                    break;
                                case 13:
                                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                                    break;
                                case 14:
                                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                                    break;
                                case 15:
                                    this.$ = {
                                        open: $$[$0 - 5],
                                        path: $$[$0 - 4],
                                        params: $$[$0 - 3],
                                        hash: $$[$0 - 2],
                                        blockParams: $$[$0 - 1],
                                        strip: yy.stripFlags($$[$0 - 5], $$[$0])
                                    };
                                    break;
                                case 16:
                                    this.$ = {
                                        path: $$[$0 - 4],
                                        params: $$[$0 - 3],
                                        hash: $$[$0 - 2],
                                        blockParams: $$[$0 - 1],
                                        strip: yy.stripFlags($$[$0 - 5], $$[$0])
                                    };
                                    break;
                                case 17:
                                    this.$ = {
                                        path: $$[$0 - 4],
                                        params: $$[$0 - 3],
                                        hash: $$[$0 - 2],
                                        blockParams: $$[$0 - 1],
                                        strip: yy.stripFlags($$[$0 - 5], $$[$0])
                                    };
                                    break;
                                case 18:
                                    this.$ = {
                                        strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]),
                                        program: $$[$0]
                                    };
                                    break;
                                case 19:
                                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                                    program.chained = true;

                                    this.$ = {
                                        strip: $$[$0 - 2].strip,
                                        program: program,
                                        chain: true
                                    };

                                    break;
                                case 20:
                                    this.$ = $$[$0];
                                    break;
                                case 21:
                                    this.$ = {
                                        path: $$[$0 - 1],
                                        strip: yy.stripFlags($$[$0 - 2], $$[$0])
                                    };
                                    break;
                                case 22:
                                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                    break;
                                case 23:
                                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                    break;
                                case 24:
                                    this.$ = {
                                        type: 'PartialStatement',
                                        name: $$[$0 - 3],
                                        params: $$[$0 - 2],
                                        hash: $$[$0 - 1],
                                        indent: '',
                                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                                        loc: yy.locInfo(this._$)
                                    };

                                    break;
                                case 25:
                                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                    break;
                                case 26:
                                    this.$ = {
                                        path: $$[$0 - 3],
                                        params: $$[$0 - 2],
                                        hash: $$[$0 - 1],
                                        strip: yy.stripFlags($$[$0 - 4], $$[$0])
                                    };
                                    break;
                                case 27:
                                    this.$ = $$[$0];
                                    break;
                                case 28:
                                    this.$ = $$[$0];
                                    break;
                                case 29:
                                    this.$ = {
                                        type: 'SubExpression',
                                        path: $$[$0 - 3],
                                        params: $$[$0 - 2],
                                        hash: $$[$0 - 1],
                                        loc: yy.locInfo(this._$)
                                    };

                                    break;
                                case 30:
                                    this.$ = {
                                        type: 'Hash',
                                        pairs: $$[$0],
                                        loc: yy.locInfo(this._$)
                                    };
                                    break;
                                case 31:
                                    this.$ = {
                                        type: 'HashPair',
                                        key: yy.id($$[$0 - 2]),
                                        value: $$[$0],
                                        loc: yy.locInfo(this._$)
                                    };
                                    break;
                                case 32:
                                    this.$ = yy.id($$[$0 - 1]);
                                    break;
                                case 33:
                                    this.$ = $$[$0];
                                    break;
                                case 34:
                                    this.$ = $$[$0];
                                    break;
                                case 35:
                                    this.$ = {
                                        type: 'StringLiteral',
                                        value: $$[$0],
                                        original: $$[$0],
                                        loc: yy.locInfo(this._$)
                                    };
                                    break;
                                case 36:
                                    this.$ = {
                                        type: 'NumberLiteral',
                                        value: Number($$[$0]),
                                        original: Number($$[$0]),
                                        loc: yy.locInfo(this._$)
                                    };
                                    break;
                                case 37:
                                    this.$ = {
                                        type: 'BooleanLiteral',
                                        value: $$[$0] === 'true',
                                        original: $$[$0] === 'true',
                                        loc: yy.locInfo(this._$)
                                    };
                                    break;
                                case 38:
                                    this.$ = {
                                        type: 'UndefinedLiteral',
                                        original: undefined,
                                        value: undefined,
                                        loc: yy.locInfo(this._$)
                                    };
                                    break;
                                case 39:
                                    this.$ = {
                                        type: 'NullLiteral',
                                        original: null,
                                        value: null,
                                        loc: yy.locInfo(this._$)
                                    };
                                    break;
                                case 40:
                                    this.$ = $$[$0];
                                    break;
                                case 41:
                                    this.$ = $$[$0];
                                    break;
                                case 42:
                                    this.$ = yy.preparePath(true, $$[$0], this._$);
                                    break;
                                case 43:
                                    this.$ = yy.preparePath(false, $$[$0], this._$);
                                    break;
                                case 44:
                                    $$[$0 - 2].push({
                                        part: yy.id($$[$0]),
                                        original: $$[$0],
                                        separator: $$[$0 - 1]
                                    });
                                    this.$ = $$[$0 - 2];
                                    break;
                                case 45:
                                    this.$ = [{
                                        part: yy.id($$[$0]),
                                        original: $$[$0]
                                    }];
                                    break;
                                case 46:
                                    this.$ = [];
                                    break;
                                case 47:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 48:
                                    this.$ = [$$[$0]];
                                    break;
                                case 49:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 50:
                                    this.$ = [];
                                    break;
                                case 51:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 58:
                                    this.$ = [];
                                    break;
                                case 59:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 64:
                                    this.$ = [];
                                    break;
                                case 65:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 70:
                                    this.$ = [];
                                    break;
                                case 71:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 78:
                                    this.$ = [];
                                    break;
                                case 79:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 82:
                                    this.$ = [];
                                    break;
                                case 83:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 86:
                                    this.$ = [];
                                    break;
                                case 87:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 90:
                                    this.$ = [];
                                    break;
                                case 91:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 94:
                                    this.$ = [];
                                    break;
                                case 95:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 98:
                                    this.$ = [$$[$0]];
                                    break;
                                case 99:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                                case 100:
                                    this.$ = [$$[$0]];
                                    break;
                                case 101:
                                    $$[$0 - 1].push($$[$0]);
                                    break;
                            }
                        },
                        table: [{
                            3: 1,
                            4: 2,
                            5: [2, 46],
                            6: 3,
                            14: [2, 46],
                            15: [2, 46],
                            19: [2, 46],
                            29: [2, 46],
                            34: [2, 46],
                            48: [2, 46],
                            51: [2, 46],
                            55: [2, 46],
                            60: [2, 46]
                        }, {
                            1: [3]
                        }, {
                            5: [1, 4]
                        }, {
                            5: [2, 2],
                            7: 5,
                            8: 6,
                            9: 7,
                            10: 8,
                            11: 9,
                            12: 10,
                            13: 11,
                            14: [1, 12],
                            15: [1, 20],
                            16: 17,
                            19: [1, 23],
                            24: 15,
                            27: 16,
                            29: [1, 21],
                            34: [1, 22],
                            39: [2, 2],
                            44: [2, 2],
                            47: [2, 2],
                            48: [1, 13],
                            51: [1, 14],
                            55: [1, 18],
                            59: 19,
                            60: [1, 24]
                        }, {
                            1: [2, 1]
                        }, {
                            5: [2, 47],
                            14: [2, 47],
                            15: [2, 47],
                            19: [2, 47],
                            29: [2, 47],
                            34: [2, 47],
                            39: [2, 47],
                            44: [2, 47],
                            47: [2, 47],
                            48: [2, 47],
                            51: [2, 47],
                            55: [2, 47],
                            60: [2, 47]
                        }, {
                            5: [2, 3],
                            14: [2, 3],
                            15: [2, 3],
                            19: [2, 3],
                            29: [2, 3],
                            34: [2, 3],
                            39: [2, 3],
                            44: [2, 3],
                            47: [2, 3],
                            48: [2, 3],
                            51: [2, 3],
                            55: [2, 3],
                            60: [2, 3]
                        }, {
                            5: [2, 4],
                            14: [2, 4],
                            15: [2, 4],
                            19: [2, 4],
                            29: [2, 4],
                            34: [2, 4],
                            39: [2, 4],
                            44: [2, 4],
                            47: [2, 4],
                            48: [2, 4],
                            51: [2, 4],
                            55: [2, 4],
                            60: [2, 4]
                        }, {
                            5: [2, 5],
                            14: [2, 5],
                            15: [2, 5],
                            19: [2, 5],
                            29: [2, 5],
                            34: [2, 5],
                            39: [2, 5],
                            44: [2, 5],
                            47: [2, 5],
                            48: [2, 5],
                            51: [2, 5],
                            55: [2, 5],
                            60: [2, 5]
                        }, {
                            5: [2, 6],
                            14: [2, 6],
                            15: [2, 6],
                            19: [2, 6],
                            29: [2, 6],
                            34: [2, 6],
                            39: [2, 6],
                            44: [2, 6],
                            47: [2, 6],
                            48: [2, 6],
                            51: [2, 6],
                            55: [2, 6],
                            60: [2, 6]
                        }, {
                            5: [2, 7],
                            14: [2, 7],
                            15: [2, 7],
                            19: [2, 7],
                            29: [2, 7],
                            34: [2, 7],
                            39: [2, 7],
                            44: [2, 7],
                            47: [2, 7],
                            48: [2, 7],
                            51: [2, 7],
                            55: [2, 7],
                            60: [2, 7]
                        }, {
                            5: [2, 8],
                            14: [2, 8],
                            15: [2, 8],
                            19: [2, 8],
                            29: [2, 8],
                            34: [2, 8],
                            39: [2, 8],
                            44: [2, 8],
                            47: [2, 8],
                            48: [2, 8],
                            51: [2, 8],
                            55: [2, 8],
                            60: [2, 8]
                        }, {
                            5: [2, 9],
                            14: [2, 9],
                            15: [2, 9],
                            19: [2, 9],
                            29: [2, 9],
                            34: [2, 9],
                            39: [2, 9],
                            44: [2, 9],
                            47: [2, 9],
                            48: [2, 9],
                            51: [2, 9],
                            55: [2, 9],
                            60: [2, 9]
                        }, {
                            20: 25,
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            20: 36,
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            4: 37,
                            6: 3,
                            14: [2, 46],
                            15: [2, 46],
                            19: [2, 46],
                            29: [2, 46],
                            34: [2, 46],
                            39: [2, 46],
                            44: [2, 46],
                            47: [2, 46],
                            48: [2, 46],
                            51: [2, 46],
                            55: [2, 46],
                            60: [2, 46]
                        }, {
                            4: 38,
                            6: 3,
                            14: [2, 46],
                            15: [2, 46],
                            19: [2, 46],
                            29: [2, 46],
                            34: [2, 46],
                            44: [2, 46],
                            47: [2, 46],
                            48: [2, 46],
                            51: [2, 46],
                            55: [2, 46],
                            60: [2, 46]
                        }, {
                            13: 40,
                            15: [1, 20],
                            17: 39
                        }, {
                            20: 42,
                            56: 41,
                            64: 43,
                            65: [1, 44],
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            4: 45,
                            6: 3,
                            14: [2, 46],
                            15: [2, 46],
                            19: [2, 46],
                            29: [2, 46],
                            34: [2, 46],
                            47: [2, 46],
                            48: [2, 46],
                            51: [2, 46],
                            55: [2, 46],
                            60: [2, 46]
                        }, {
                            5: [2, 10],
                            14: [2, 10],
                            15: [2, 10],
                            18: [2, 10],
                            19: [2, 10],
                            29: [2, 10],
                            34: [2, 10],
                            39: [2, 10],
                            44: [2, 10],
                            47: [2, 10],
                            48: [2, 10],
                            51: [2, 10],
                            55: [2, 10],
                            60: [2, 10]
                        }, {
                            20: 46,
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            20: 47,
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            20: 48,
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            20: 42,
                            56: 49,
                            64: 43,
                            65: [1, 44],
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            33: [2, 78],
                            49: 50,
                            65: [2, 78],
                            72: [2, 78],
                            80: [2, 78],
                            81: [2, 78],
                            82: [2, 78],
                            83: [2, 78],
                            84: [2, 78],
                            85: [2, 78]
                        }, {
                            23: [2, 33],
                            33: [2, 33],
                            54: [2, 33],
                            65: [2, 33],
                            68: [2, 33],
                            72: [2, 33],
                            75: [2, 33],
                            80: [2, 33],
                            81: [2, 33],
                            82: [2, 33],
                            83: [2, 33],
                            84: [2, 33],
                            85: [2, 33]
                        }, {
                            23: [2, 34],
                            33: [2, 34],
                            54: [2, 34],
                            65: [2, 34],
                            68: [2, 34],
                            72: [2, 34],
                            75: [2, 34],
                            80: [2, 34],
                            81: [2, 34],
                            82: [2, 34],
                            83: [2, 34],
                            84: [2, 34],
                            85: [2, 34]
                        }, {
                            23: [2, 35],
                            33: [2, 35],
                            54: [2, 35],
                            65: [2, 35],
                            68: [2, 35],
                            72: [2, 35],
                            75: [2, 35],
                            80: [2, 35],
                            81: [2, 35],
                            82: [2, 35],
                            83: [2, 35],
                            84: [2, 35],
                            85: [2, 35]
                        }, {
                            23: [2, 36],
                            33: [2, 36],
                            54: [2, 36],
                            65: [2, 36],
                            68: [2, 36],
                            72: [2, 36],
                            75: [2, 36],
                            80: [2, 36],
                            81: [2, 36],
                            82: [2, 36],
                            83: [2, 36],
                            84: [2, 36],
                            85: [2, 36]
                        }, {
                            23: [2, 37],
                            33: [2, 37],
                            54: [2, 37],
                            65: [2, 37],
                            68: [2, 37],
                            72: [2, 37],
                            75: [2, 37],
                            80: [2, 37],
                            81: [2, 37],
                            82: [2, 37],
                            83: [2, 37],
                            84: [2, 37],
                            85: [2, 37]
                        }, {
                            23: [2, 38],
                            33: [2, 38],
                            54: [2, 38],
                            65: [2, 38],
                            68: [2, 38],
                            72: [2, 38],
                            75: [2, 38],
                            80: [2, 38],
                            81: [2, 38],
                            82: [2, 38],
                            83: [2, 38],
                            84: [2, 38],
                            85: [2, 38]
                        }, {
                            23: [2, 39],
                            33: [2, 39],
                            54: [2, 39],
                            65: [2, 39],
                            68: [2, 39],
                            72: [2, 39],
                            75: [2, 39],
                            80: [2, 39],
                            81: [2, 39],
                            82: [2, 39],
                            83: [2, 39],
                            84: [2, 39],
                            85: [2, 39]
                        }, {
                            23: [2, 43],
                            33: [2, 43],
                            54: [2, 43],
                            65: [2, 43],
                            68: [2, 43],
                            72: [2, 43],
                            75: [2, 43],
                            80: [2, 43],
                            81: [2, 43],
                            82: [2, 43],
                            83: [2, 43],
                            84: [2, 43],
                            85: [2, 43],
                            87: [1, 51]
                        }, {
                            72: [1, 35],
                            86: 52
                        }, {
                            23: [2, 45],
                            33: [2, 45],
                            54: [2, 45],
                            65: [2, 45],
                            68: [2, 45],
                            72: [2, 45],
                            75: [2, 45],
                            80: [2, 45],
                            81: [2, 45],
                            82: [2, 45],
                            83: [2, 45],
                            84: [2, 45],
                            85: [2, 45],
                            87: [2, 45]
                        }, {
                            52: 53,
                            54: [2, 82],
                            65: [2, 82],
                            72: [2, 82],
                            80: [2, 82],
                            81: [2, 82],
                            82: [2, 82],
                            83: [2, 82],
                            84: [2, 82],
                            85: [2, 82]
                        }, {
                            25: 54,
                            38: 56,
                            39: [1, 58],
                            43: 57,
                            44: [1, 59],
                            45: 55,
                            47: [2, 54]
                        }, {
                            28: 60,
                            43: 61,
                            44: [1, 59],
                            47: [2, 56]
                        }, {
                            13: 63,
                            15: [1, 20],
                            18: [1, 62]
                        }, {
                            15: [2, 48],
                            18: [2, 48]
                        }, {
                            33: [2, 86],
                            57: 64,
                            65: [2, 86],
                            72: [2, 86],
                            80: [2, 86],
                            81: [2, 86],
                            82: [2, 86],
                            83: [2, 86],
                            84: [2, 86],
                            85: [2, 86]
                        }, {
                            33: [2, 40],
                            65: [2, 40],
                            72: [2, 40],
                            80: [2, 40],
                            81: [2, 40],
                            82: [2, 40],
                            83: [2, 40],
                            84: [2, 40],
                            85: [2, 40]
                        }, {
                            33: [2, 41],
                            65: [2, 41],
                            72: [2, 41],
                            80: [2, 41],
                            81: [2, 41],
                            82: [2, 41],
                            83: [2, 41],
                            84: [2, 41],
                            85: [2, 41]
                        }, {
                            20: 65,
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            26: 66,
                            47: [1, 67]
                        }, {
                            30: 68,
                            33: [2, 58],
                            65: [2, 58],
                            72: [2, 58],
                            75: [2, 58],
                            80: [2, 58],
                            81: [2, 58],
                            82: [2, 58],
                            83: [2, 58],
                            84: [2, 58],
                            85: [2, 58]
                        }, {
                            33: [2, 64],
                            35: 69,
                            65: [2, 64],
                            72: [2, 64],
                            75: [2, 64],
                            80: [2, 64],
                            81: [2, 64],
                            82: [2, 64],
                            83: [2, 64],
                            84: [2, 64],
                            85: [2, 64]
                        }, {
                            21: 70,
                            23: [2, 50],
                            65: [2, 50],
                            72: [2, 50],
                            80: [2, 50],
                            81: [2, 50],
                            82: [2, 50],
                            83: [2, 50],
                            84: [2, 50],
                            85: [2, 50]
                        }, {
                            33: [2, 90],
                            61: 71,
                            65: [2, 90],
                            72: [2, 90],
                            80: [2, 90],
                            81: [2, 90],
                            82: [2, 90],
                            83: [2, 90],
                            84: [2, 90],
                            85: [2, 90]
                        }, {
                            20: 75,
                            33: [2, 80],
                            50: 72,
                            63: 73,
                            64: 76,
                            65: [1, 44],
                            69: 74,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            72: [1, 80]
                        }, {
                            23: [2, 42],
                            33: [2, 42],
                            54: [2, 42],
                            65: [2, 42],
                            68: [2, 42],
                            72: [2, 42],
                            75: [2, 42],
                            80: [2, 42],
                            81: [2, 42],
                            82: [2, 42],
                            83: [2, 42],
                            84: [2, 42],
                            85: [2, 42],
                            87: [1, 51]
                        }, {
                            20: 75,
                            53: 81,
                            54: [2, 84],
                            63: 82,
                            64: 76,
                            65: [1, 44],
                            69: 83,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            26: 84,
                            47: [1, 67]
                        }, {
                            47: [2, 55]
                        }, {
                            4: 85,
                            6: 3,
                            14: [2, 46],
                            15: [2, 46],
                            19: [2, 46],
                            29: [2, 46],
                            34: [2, 46],
                            39: [2, 46],
                            44: [2, 46],
                            47: [2, 46],
                            48: [2, 46],
                            51: [2, 46],
                            55: [2, 46],
                            60: [2, 46]
                        }, {
                            47: [2, 20]
                        }, {
                            20: 86,
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            4: 87,
                            6: 3,
                            14: [2, 46],
                            15: [2, 46],
                            19: [2, 46],
                            29: [2, 46],
                            34: [2, 46],
                            47: [2, 46],
                            48: [2, 46],
                            51: [2, 46],
                            55: [2, 46],
                            60: [2, 46]
                        }, {
                            26: 88,
                            47: [1, 67]
                        }, {
                            47: [2, 57]
                        }, {
                            5: [2, 11],
                            14: [2, 11],
                            15: [2, 11],
                            19: [2, 11],
                            29: [2, 11],
                            34: [2, 11],
                            39: [2, 11],
                            44: [2, 11],
                            47: [2, 11],
                            48: [2, 11],
                            51: [2, 11],
                            55: [2, 11],
                            60: [2, 11]
                        }, {
                            15: [2, 49],
                            18: [2, 49]
                        }, {
                            20: 75,
                            33: [2, 88],
                            58: 89,
                            63: 90,
                            64: 76,
                            65: [1, 44],
                            69: 91,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            65: [2, 94],
                            66: 92,
                            68: [2, 94],
                            72: [2, 94],
                            80: [2, 94],
                            81: [2, 94],
                            82: [2, 94],
                            83: [2, 94],
                            84: [2, 94],
                            85: [2, 94]
                        }, {
                            5: [2, 25],
                            14: [2, 25],
                            15: [2, 25],
                            19: [2, 25],
                            29: [2, 25],
                            34: [2, 25],
                            39: [2, 25],
                            44: [2, 25],
                            47: [2, 25],
                            48: [2, 25],
                            51: [2, 25],
                            55: [2, 25],
                            60: [2, 25]
                        }, {
                            20: 93,
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            20: 75,
                            31: 94,
                            33: [2, 60],
                            63: 95,
                            64: 76,
                            65: [1, 44],
                            69: 96,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            75: [2, 60],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            20: 75,
                            33: [2, 66],
                            36: 97,
                            63: 98,
                            64: 76,
                            65: [1, 44],
                            69: 99,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            75: [2, 66],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            20: 75,
                            22: 100,
                            23: [2, 52],
                            63: 101,
                            64: 76,
                            65: [1, 44],
                            69: 102,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            20: 75,
                            33: [2, 92],
                            62: 103,
                            63: 104,
                            64: 76,
                            65: [1, 44],
                            69: 105,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            33: [1, 106]
                        }, {
                            33: [2, 79],
                            65: [2, 79],
                            72: [2, 79],
                            80: [2, 79],
                            81: [2, 79],
                            82: [2, 79],
                            83: [2, 79],
                            84: [2, 79],
                            85: [2, 79]
                        }, {
                            33: [2, 81]
                        }, {
                            23: [2, 27],
                            33: [2, 27],
                            54: [2, 27],
                            65: [2, 27],
                            68: [2, 27],
                            72: [2, 27],
                            75: [2, 27],
                            80: [2, 27],
                            81: [2, 27],
                            82: [2, 27],
                            83: [2, 27],
                            84: [2, 27],
                            85: [2, 27]
                        }, {
                            23: [2, 28],
                            33: [2, 28],
                            54: [2, 28],
                            65: [2, 28],
                            68: [2, 28],
                            72: [2, 28],
                            75: [2, 28],
                            80: [2, 28],
                            81: [2, 28],
                            82: [2, 28],
                            83: [2, 28],
                            84: [2, 28],
                            85: [2, 28]
                        }, {
                            23: [2, 30],
                            33: [2, 30],
                            54: [2, 30],
                            68: [2, 30],
                            71: 107,
                            72: [1, 108],
                            75: [2, 30]
                        }, {
                            23: [2, 98],
                            33: [2, 98],
                            54: [2, 98],
                            68: [2, 98],
                            72: [2, 98],
                            75: [2, 98]
                        }, {
                            23: [2, 45],
                            33: [2, 45],
                            54: [2, 45],
                            65: [2, 45],
                            68: [2, 45],
                            72: [2, 45],
                            73: [1, 109],
                            75: [2, 45],
                            80: [2, 45],
                            81: [2, 45],
                            82: [2, 45],
                            83: [2, 45],
                            84: [2, 45],
                            85: [2, 45],
                            87: [2, 45]
                        }, {
                            23: [2, 44],
                            33: [2, 44],
                            54: [2, 44],
                            65: [2, 44],
                            68: [2, 44],
                            72: [2, 44],
                            75: [2, 44],
                            80: [2, 44],
                            81: [2, 44],
                            82: [2, 44],
                            83: [2, 44],
                            84: [2, 44],
                            85: [2, 44],
                            87: [2, 44]
                        }, {
                            54: [1, 110]
                        }, {
                            54: [2, 83],
                            65: [2, 83],
                            72: [2, 83],
                            80: [2, 83],
                            81: [2, 83],
                            82: [2, 83],
                            83: [2, 83],
                            84: [2, 83],
                            85: [2, 83]
                        }, {
                            54: [2, 85]
                        }, {
                            5: [2, 13],
                            14: [2, 13],
                            15: [2, 13],
                            19: [2, 13],
                            29: [2, 13],
                            34: [2, 13],
                            39: [2, 13],
                            44: [2, 13],
                            47: [2, 13],
                            48: [2, 13],
                            51: [2, 13],
                            55: [2, 13],
                            60: [2, 13]
                        }, {
                            38: 56,
                            39: [1, 58],
                            43: 57,
                            44: [1, 59],
                            45: 112,
                            46: 111,
                            47: [2, 76]
                        }, {
                            33: [2, 70],
                            40: 113,
                            65: [2, 70],
                            72: [2, 70],
                            75: [2, 70],
                            80: [2, 70],
                            81: [2, 70],
                            82: [2, 70],
                            83: [2, 70],
                            84: [2, 70],
                            85: [2, 70]
                        }, {
                            47: [2, 18]
                        }, {
                            5: [2, 14],
                            14: [2, 14],
                            15: [2, 14],
                            19: [2, 14],
                            29: [2, 14],
                            34: [2, 14],
                            39: [2, 14],
                            44: [2, 14],
                            47: [2, 14],
                            48: [2, 14],
                            51: [2, 14],
                            55: [2, 14],
                            60: [2, 14]
                        }, {
                            33: [1, 114]
                        }, {
                            33: [2, 87],
                            65: [2, 87],
                            72: [2, 87],
                            80: [2, 87],
                            81: [2, 87],
                            82: [2, 87],
                            83: [2, 87],
                            84: [2, 87],
                            85: [2, 87]
                        }, {
                            33: [2, 89]
                        }, {
                            20: 75,
                            63: 116,
                            64: 76,
                            65: [1, 44],
                            67: 115,
                            68: [2, 96],
                            69: 117,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            33: [1, 118]
                        }, {
                            32: 119,
                            33: [2, 62],
                            74: 120,
                            75: [1, 121]
                        }, {
                            33: [2, 59],
                            65: [2, 59],
                            72: [2, 59],
                            75: [2, 59],
                            80: [2, 59],
                            81: [2, 59],
                            82: [2, 59],
                            83: [2, 59],
                            84: [2, 59],
                            85: [2, 59]
                        }, {
                            33: [2, 61],
                            75: [2, 61]
                        }, {
                            33: [2, 68],
                            37: 122,
                            74: 123,
                            75: [1, 121]
                        }, {
                            33: [2, 65],
                            65: [2, 65],
                            72: [2, 65],
                            75: [2, 65],
                            80: [2, 65],
                            81: [2, 65],
                            82: [2, 65],
                            83: [2, 65],
                            84: [2, 65],
                            85: [2, 65]
                        }, {
                            33: [2, 67],
                            75: [2, 67]
                        }, {
                            23: [1, 124]
                        }, {
                            23: [2, 51],
                            65: [2, 51],
                            72: [2, 51],
                            80: [2, 51],
                            81: [2, 51],
                            82: [2, 51],
                            83: [2, 51],
                            84: [2, 51],
                            85: [2, 51]
                        }, {
                            23: [2, 53]
                        }, {
                            33: [1, 125]
                        }, {
                            33: [2, 91],
                            65: [2, 91],
                            72: [2, 91],
                            80: [2, 91],
                            81: [2, 91],
                            82: [2, 91],
                            83: [2, 91],
                            84: [2, 91],
                            85: [2, 91]
                        }, {
                            33: [2, 93]
                        }, {
                            5: [2, 22],
                            14: [2, 22],
                            15: [2, 22],
                            19: [2, 22],
                            29: [2, 22],
                            34: [2, 22],
                            39: [2, 22],
                            44: [2, 22],
                            47: [2, 22],
                            48: [2, 22],
                            51: [2, 22],
                            55: [2, 22],
                            60: [2, 22]
                        }, {
                            23: [2, 99],
                            33: [2, 99],
                            54: [2, 99],
                            68: [2, 99],
                            72: [2, 99],
                            75: [2, 99]
                        }, {
                            73: [1, 109]
                        }, {
                            20: 75,
                            63: 126,
                            64: 76,
                            65: [1, 44],
                            72: [1, 35],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            5: [2, 23],
                            14: [2, 23],
                            15: [2, 23],
                            19: [2, 23],
                            29: [2, 23],
                            34: [2, 23],
                            39: [2, 23],
                            44: [2, 23],
                            47: [2, 23],
                            48: [2, 23],
                            51: [2, 23],
                            55: [2, 23],
                            60: [2, 23]
                        }, {
                            47: [2, 19]
                        }, {
                            47: [2, 77]
                        }, {
                            20: 75,
                            33: [2, 72],
                            41: 127,
                            63: 128,
                            64: 76,
                            65: [1, 44],
                            69: 129,
                            70: 77,
                            71: 78,
                            72: [1, 79],
                            75: [2, 72],
                            78: 26,
                            79: 27,
                            80: [1, 28],
                            81: [1, 29],
                            82: [1, 30],
                            83: [1, 31],
                            84: [1, 32],
                            85: [1, 34],
                            86: 33
                        }, {
                            5: [2, 24],
                            14: [2, 24],
                            15: [2, 24],
                            19: [2, 24],
                            29: [2, 24],
                            34: [2, 24],
                            39: [2, 24],
                            44: [2, 24],
                            47: [2, 24],
                            48: [2, 24],
                            51: [2, 24],
                            55: [2, 24],
                            60: [2, 24]
                        }, {
                            68: [1, 130]
                        }, {
                            65: [2, 95],
                            68: [2, 95],
                            72: [2, 95],
                            80: [2, 95],
                            81: [2, 95],
                            82: [2, 95],
                            83: [2, 95],
                            84: [2, 95],
                            85: [2, 95]
                        }, {
                            68: [2, 97]
                        }, {
                            5: [2, 21],
                            14: [2, 21],
                            15: [2, 21],
                            19: [2, 21],
                            29: [2, 21],
                            34: [2, 21],
                            39: [2, 21],
                            44: [2, 21],
                            47: [2, 21],
                            48: [2, 21],
                            51: [2, 21],
                            55: [2, 21],
                            60: [2, 21]
                        }, {
                            33: [1, 131]
                        }, {
                            33: [2, 63]
                        }, {
                            72: [1, 133],
                            76: 132
                        }, {
                            33: [1, 134]
                        }, {
                            33: [2, 69]
                        }, {
                            15: [2, 12]
                        }, {
                            14: [2, 26],
                            15: [2, 26],
                            19: [2, 26],
                            29: [2, 26],
                            34: [2, 26],
                            47: [2, 26],
                            48: [2, 26],
                            51: [2, 26],
                            55: [2, 26],
                            60: [2, 26]
                        }, {
                            23: [2, 31],
                            33: [2, 31],
                            54: [2, 31],
                            68: [2, 31],
                            72: [2, 31],
                            75: [2, 31]
                        }, {
                            33: [2, 74],
                            42: 135,
                            74: 136,
                            75: [1, 121]
                        }, {
                            33: [2, 71],
                            65: [2, 71],
                            72: [2, 71],
                            75: [2, 71],
                            80: [2, 71],
                            81: [2, 71],
                            82: [2, 71],
                            83: [2, 71],
                            84: [2, 71],
                            85: [2, 71]
                        }, {
                            33: [2, 73],
                            75: [2, 73]
                        }, {
                            23: [2, 29],
                            33: [2, 29],
                            54: [2, 29],
                            65: [2, 29],
                            68: [2, 29],
                            72: [2, 29],
                            75: [2, 29],
                            80: [2, 29],
                            81: [2, 29],
                            82: [2, 29],
                            83: [2, 29],
                            84: [2, 29],
                            85: [2, 29]
                        }, {
                            14: [2, 15],
                            15: [2, 15],
                            19: [2, 15],
                            29: [2, 15],
                            34: [2, 15],
                            39: [2, 15],
                            44: [2, 15],
                            47: [2, 15],
                            48: [2, 15],
                            51: [2, 15],
                            55: [2, 15],
                            60: [2, 15]
                        }, {
                            72: [1, 138],
                            77: [1, 137]
                        }, {
                            72: [2, 100],
                            77: [2, 100]
                        }, {
                            14: [2, 16],
                            15: [2, 16],
                            19: [2, 16],
                            29: [2, 16],
                            34: [2, 16],
                            44: [2, 16],
                            47: [2, 16],
                            48: [2, 16],
                            51: [2, 16],
                            55: [2, 16],
                            60: [2, 16]
                        }, {
                            33: [1, 139]
                        }, {
                            33: [2, 75]
                        }, {
                            33: [2, 32]
                        }, {
                            72: [2, 101],
                            77: [2, 101]
                        }, {
                            14: [2, 17],
                            15: [2, 17],
                            19: [2, 17],
                            29: [2, 17],
                            34: [2, 17],
                            39: [2, 17],
                            44: [2, 17],
                            47: [2, 17],
                            48: [2, 17],
                            51: [2, 17],
                            55: [2, 17],
                            60: [2, 17]
                        }],
                        defaultActions: {
                            4: [2, 1],
                            55: [2, 55],
                            57: [2, 20],
                            61: [2, 57],
                            74: [2, 81],
                            83: [2, 85],
                            87: [2, 18],
                            91: [2, 89],
                            102: [2, 53],
                            105: [2, 93],
                            111: [2, 19],
                            112: [2, 77],
                            117: [2, 97],
                            120: [2, 63],
                            123: [2, 69],
                            124: [2, 12],
                            136: [2, 75],
                            137: [2, 32]
                        },
                        parseError: function parseError(str, hash) {
                            throw new Error(str);
                        },
                        parse: function parse(input) {
                            var self = this,
                                stack = [0],
                                vstack = [null],
                                lstack = [],
                                table = this.table,
                                yytext = "",
                                yylineno = 0,
                                yyleng = 0,
                                recovering = 0,
                                TERROR = 2,
                                EOF = 1;
                            this.lexer.setInput(input);
                            this.lexer.yy = this.yy;
                            this.yy.lexer = this.lexer;
                            this.yy.parser = this;
                            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
                            var yyloc = this.lexer.yylloc;
                            lstack.push(yyloc);
                            var ranges = this.lexer.options && this.lexer.options.ranges;
                            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;

                            function popStack(n) {
                                stack.length = stack.length - 2 * n;
                                vstack.length = vstack.length - n;
                                lstack.length = lstack.length - n;
                            }

                            function lex() {
                                var token;
                                token = self.lexer.lex() || 1;
                                if (typeof token !== "number") {
                                    token = self.symbols_[token] || token;
                                }
                                return token;
                            }
                            var symbol,
                                preErrorSymbol,
                                state,
                                action,
                                a,
                                r,
                                yyval = {},
                                p,
                                len,
                                newState,
                                expected;
                            while (true) {
                                state = stack[stack.length - 1];
                                if (this.defaultActions[state]) {
                                    action = this.defaultActions[state];
                                } else {
                                    if (symbol === null || typeof symbol == "undefined") {
                                        symbol = lex();
                                    }
                                    action = table[state] && table[state][symbol];
                                }
                                if (typeof action === "undefined" || !action.length || !action[0]) {
                                    var errStr = "";
                                    if (!recovering) {
                                        expected = [];
                                        for (p in table[state])
                                            if (this.terminals_[p] && p > 2) {
                                                expected.push("'" + this.terminals_[p] + "'");
                                            }
                                        if (this.lexer.showPosition) {
                                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                                        } else {
                                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                                        }
                                        this.parseError(errStr, {
                                            text: this.lexer.match,
                                            token: this.terminals_[symbol] || symbol,
                                            line: this.lexer.yylineno,
                                            loc: yyloc,
                                            expected: expected
                                        });
                                    }
                                }
                                if (action[0] instanceof Array && action.length > 1) {
                                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                                }
                                switch (action[0]) {
                                    case 1:
                                        stack.push(symbol);
                                        vstack.push(this.lexer.yytext);
                                        lstack.push(this.lexer.yylloc);
                                        stack.push(action[1]);
                                        symbol = null;
                                        if (!preErrorSymbol) {
                                            yyleng = this.lexer.yyleng;
                                            yytext = this.lexer.yytext;
                                            yylineno = this.lexer.yylineno;
                                            yyloc = this.lexer.yylloc;
                                            if (recovering > 0) recovering--;
                                        } else {
                                            symbol = preErrorSymbol;
                                            preErrorSymbol = null;
                                        }
                                        break;
                                    case 2:
                                        len = this.productions_[action[1]][1];
                                        yyval.$ = vstack[vstack.length - len];
                                        yyval._$ = {
                                            first_line: lstack[lstack.length - (len || 1)].first_line,
                                            last_line: lstack[lstack.length - 1].last_line,
                                            first_column: lstack[lstack.length - (len || 1)].first_column,
                                            last_column: lstack[lstack.length - 1].last_column
                                        };
                                        if (ranges) {
                                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                                        }
                                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                                        if (typeof r !== "undefined") {
                                            return r;
                                        }
                                        if (len) {
                                            stack = stack.slice(0, -1 * len * 2);
                                            vstack = vstack.slice(0, -1 * len);
                                            lstack = lstack.slice(0, -1 * len);
                                        }
                                        stack.push(this.productions_[action[1]][0]);
                                        vstack.push(yyval.$);
                                        lstack.push(yyval._$);
                                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                                        stack.push(newState);
                                        break;
                                    case 3:
                                        return true;
                                }
                            }
                            return true;
                        }
                    };
                    /* Jison generated lexer */
                    var lexer = (function() {
                        var lexer = {
                            EOF: 1,
                            parseError: function parseError(str, hash) {
                                if (this.yy.parser) {
                                    this.yy.parser.parseError(str, hash);
                                } else {
                                    throw new Error(str);
                                }
                            },
                            setInput: function setInput(input) {
                                this._input = input;
                                this._more = this._less = this.done = false;
                                this.yylineno = this.yyleng = 0;
                                this.yytext = this.matched = this.match = '';
                                this.conditionStack = ['INITIAL'];
                                this.yylloc = {
                                    first_line: 1,
                                    first_column: 0,
                                    last_line: 1,
                                    last_column: 0
                                };
                                if (this.options.ranges) this.yylloc.range = [0, 0];
                                this.offset = 0;
                                return this;
                            },
                            input: function input() {
                                var ch = this._input[0];
                                this.yytext += ch;
                                this.yyleng++;
                                this.offset++;
                                this.match += ch;
                                this.matched += ch;
                                var lines = ch.match(/(?:\r\n?|\n).*/g);
                                if (lines) {
                                    this.yylineno++;
                                    this.yylloc.last_line++;
                                } else {
                                    this.yylloc.last_column++;
                                }
                                if (this.options.ranges) this.yylloc.range[1]++;

                                this._input = this._input.slice(1);
                                return ch;
                            },
                            unput: function unput(ch) {
                                var len = ch.length;
                                var lines = ch.split(/(?:\r\n?|\n)/g);

                                this._input = ch + this._input;
                                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                                //this.yyleng -= len;
                                this.offset -= len;
                                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                                this.match = this.match.substr(0, this.match.length - 1);
                                this.matched = this.matched.substr(0, this.matched.length - 1);

                                if (lines.length - 1) this.yylineno -= lines.length - 1;
                                var r = this.yylloc.range;

                                this.yylloc = {
                                    first_line: this.yylloc.first_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.first_column,
                                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                                };

                                if (this.options.ranges) {
                                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                                }
                                return this;
                            },
                            more: function more() {
                                this._more = true;
                                return this;
                            },
                            less: function less(n) {
                                this.unput(this.match.slice(n));
                            },
                            pastInput: function pastInput() {
                                var past = this.matched.substr(0, this.matched.length - this.match.length);
                                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                            },
                            upcomingInput: function upcomingInput() {
                                var next = this.match;
                                if (next.length < 20) {
                                    next += this._input.substr(0, 20 - next.length);
                                }
                                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                            },
                            showPosition: function showPosition() {
                                var pre = this.pastInput();
                                var c = new Array(pre.length + 1).join("-");
                                return pre + this.upcomingInput() + "\n" + c + "^";
                            },
                            next: function next() {
                                if (this.done) {
                                    return this.EOF;
                                }
                                if (!this._input) this.done = true;

                                var token, match, tempMatch, index, col, lines;
                                if (!this._more) {
                                    this.yytext = '';
                                    this.match = '';
                                }
                                var rules = this._currentRules();
                                for (var i = 0; i < rules.length; i++) {
                                    tempMatch = this._input.match(this.rules[rules[i]]);
                                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                                        match = tempMatch;
                                        index = i;
                                        if (!this.options.flex) break;
                                    }
                                }
                                if (match) {
                                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                                    if (lines) this.yylineno += lines.length;
                                    this.yylloc = {
                                        first_line: this.yylloc.last_line,
                                        last_line: this.yylineno + 1,
                                        first_column: this.yylloc.last_column,
                                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                                    };
                                    this.yytext += match[0];
                                    this.match += match[0];
                                    this.matches = match;
                                    this.yyleng = this.yytext.length;
                                    if (this.options.ranges) {
                                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                                    }
                                    this._more = false;
                                    this._input = this._input.slice(match[0].length);
                                    this.matched += match[0];
                                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                                    if (this.done && this._input) this.done = false;
                                    if (token) return token;
                                    else return;
                                }
                                if (this._input === "") {
                                    return this.EOF;
                                } else {
                                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                                        text: "",
                                        token: null,
                                        line: this.yylineno
                                    });
                                }
                            },
                            lex: function lex() {
                                var r = this.next();
                                if (typeof r !== 'undefined') {
                                    return r;
                                } else {
                                    return this.lex();
                                }
                            },
                            begin: function begin(condition) {
                                this.conditionStack.push(condition);
                            },
                            popState: function popState() {
                                return this.conditionStack.pop();
                            },
                            _currentRules: function _currentRules() {
                                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                            },
                            topState: function topState() {
                                return this.conditionStack[this.conditionStack.length - 2];
                            },
                            pushState: function begin(condition) {
                                this.begin(condition);
                            }
                        };
                        lexer.options = {};
                        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
                            /**/
                        ) {

                            function strip(start, end) {
                                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                            }

                            var YYSTATE = YY_START;
                            switch ($avoiding_name_collisions) {
                                case 0:
                                    if (yy_.yytext.slice(-2) === "\\\\") {
                                        strip(0, 1);
                                        this.begin("mu");
                                    } else if (yy_.yytext.slice(-1) === "\\") {
                                        strip(0, 1);
                                        this.begin("emu");
                                    } else {
                                        this.begin("mu");
                                    }
                                    if (yy_.yytext) return 15;

                                    break;
                                case 1:
                                    return 15;
                                    break;
                                case 2:
                                    this.popState();
                                    return 15;

                                    break;
                                case 3:
                                    this.begin('raw');
                                    return 15;
                                    break;
                                case 4:
                                    this.popState();
                                    // Should be using `this.topState()` below, but it currently
                                    // returns the second top instead of the first top. Opened an
                                    // issue about it at https://github.com/zaach/jison/issues/291
                                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
                                        return 15;
                                    } else {
                                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                                        return 'END_RAW_BLOCK';
                                    }

                                    break;
                                case 5:
                                    return 15;
                                    break;
                                case 6:
                                    this.popState();
                                    return 14;

                                    break;
                                case 7:
                                    return 65;
                                    break;
                                case 8:
                                    return 68;
                                    break;
                                case 9:
                                    return 19;
                                    break;
                                case 10:
                                    this.popState();
                                    this.begin('raw');
                                    return 23;

                                    break;
                                case 11:
                                    return 55;
                                    break;
                                case 12:
                                    return 60;
                                    break;
                                case 13:
                                    return 29;
                                    break;
                                case 14:
                                    return 47;
                                    break;
                                case 15:
                                    this.popState();
                                    return 44;
                                    break;
                                case 16:
                                    this.popState();
                                    return 44;
                                    break;
                                case 17:
                                    return 34;
                                    break;
                                case 18:
                                    return 39;
                                    break;
                                case 19:
                                    return 51;
                                    break;
                                case 20:
                                    return 48;
                                    break;
                                case 21:
                                    this.unput(yy_.yytext);
                                    this.popState();
                                    this.begin('com');

                                    break;
                                case 22:
                                    this.popState();
                                    return 14;

                                    break;
                                case 23:
                                    return 48;
                                    break;
                                case 24:
                                    return 73;
                                    break;
                                case 25:
                                    return 72;
                                    break;
                                case 26:
                                    return 72;
                                    break;
                                case 27:
                                    return 87;
                                    break;
                                case 28:
                                    // ignore whitespace
                                    break;
                                case 29:
                                    this.popState();
                                    return 54;
                                    break;
                                case 30:
                                    this.popState();
                                    return 33;
                                    break;
                                case 31:
                                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                                    return 80;
                                    break;
                                case 32:
                                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                                    return 80;
                                    break;
                                case 33:
                                    return 85;
                                    break;
                                case 34:
                                    return 82;
                                    break;
                                case 35:
                                    return 82;
                                    break;
                                case 36:
                                    return 83;
                                    break;
                                case 37:
                                    return 84;
                                    break;
                                case 38:
                                    return 81;
                                    break;
                                case 39:
                                    return 75;
                                    break;
                                case 40:
                                    return 77;
                                    break;
                                case 41:
                                    return 72;
                                    break;
                                case 42:
                                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');
                                    return 72;
                                    break;
                                case 43:
                                    return 'INVALID';
                                    break;
                                case 44:
                                    return 5;
                                    break;
                            }
                        };
                        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
                        lexer.conditions = {
                            "mu": {
                                "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
                                "inclusive": false
                            },
                            "emu": {
                                "rules": [2],
                                "inclusive": false
                            },
                            "com": {
                                "rules": [6],
                                "inclusive": false
                            },
                            "raw": {
                                "rules": [3, 4, 5],
                                "inclusive": false
                            },
                            "INITIAL": {
                                "rules": [0, 1, 44],
                                "inclusive": true
                            }
                        };
                        return lexer;
                    })();
                    parser.lexer = lexer;

                    function Parser() {
                        this.yy = {};
                    }
                    Parser.prototype = parser;
                    parser.Parser = Parser;
                    return new Parser();
                })();
                exports.__esModule = true;
                exports['default'] = handlebars;

                /***/
            },
            /* 24 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;

                var _visitor = __webpack_require__(25);

                var _visitor2 = _interopRequireDefault(_visitor);

                function WhitespaceControl() {
                    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                    this.options = options;
                }
                WhitespaceControl.prototype = new _visitor2['default']();

                WhitespaceControl.prototype.Program = function(program) {
                    var doStandalone = !this.options.ignoreStandalone;

                    var isRoot = !this.isRootSeen;
                    this.isRootSeen = true;

                    var body = program.body;
                    for (var i = 0, l = body.length; i < l; i++) {
                        var current = body[i],
                            strip = this.accept(current);

                        if (!strip) {
                            continue;
                        }

                        var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
                            _isNextWhitespace = isNextWhitespace(body, i, isRoot),
                            openStandalone = strip.openStandalone && _isPrevWhitespace,
                            closeStandalone = strip.closeStandalone && _isNextWhitespace,
                            inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

                        if (strip.close) {
                            omitRight(body, i, true);
                        }
                        if (strip.open) {
                            omitLeft(body, i, true);
                        }

                        if (doStandalone && inlineStandalone) {
                            omitRight(body, i);

                            if (omitLeft(body, i)) {
                                // If we are on a standalone node, save the indent info for partials
                                if (current.type === 'PartialStatement') {
                                    // Pull out the whitespace from the final line
                                    current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
                                }
                            }
                        }
                        if (doStandalone && openStandalone) {
                            omitRight((current.program || current.inverse).body);

                            // Strip out the previous content node if it's whitespace only
                            omitLeft(body, i);
                        }
                        if (doStandalone && closeStandalone) {
                            // Always strip the next node
                            omitRight(body, i);

                            omitLeft((current.inverse || current.program).body);
                        }
                    }

                    return program;
                };

                WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
                    this.accept(block.program);
                    this.accept(block.inverse);

                    // Find the inverse program that is involed with whitespace stripping.
                    var program = block.program || block.inverse,
                        inverse = block.program && block.inverse,
                        firstInverse = inverse,
                        lastInverse = inverse;

                    if (inverse && inverse.chained) {
                        firstInverse = inverse.body[0].program;

                        // Walk the inverse chain to find the last inverse that is actually in the chain.
                        while (lastInverse.chained) {
                            lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
                        }
                    }

                    var strip = {
                        open: block.openStrip.open,
                        close: block.closeStrip.close,

                        // Determine the standalone candiacy. Basically flag our content as being possibly standalone
                        // so our parent can determine if we actually are standalone
                        openStandalone: isNextWhitespace(program.body),
                        closeStandalone: isPrevWhitespace((firstInverse || program).body)
                    };

                    if (block.openStrip.close) {
                        omitRight(program.body, null, true);
                    }

                    if (inverse) {
                        var inverseStrip = block.inverseStrip;

                        if (inverseStrip.open) {
                            omitLeft(program.body, null, true);
                        }

                        if (inverseStrip.close) {
                            omitRight(firstInverse.body, null, true);
                        }
                        if (block.closeStrip.open) {
                            omitLeft(lastInverse.body, null, true);
                        }

                        // Find standalone else statments
                        if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
                            omitLeft(program.body);
                            omitRight(firstInverse.body);
                        }
                    } else if (block.closeStrip.open) {
                        omitLeft(program.body, null, true);
                    }

                    return strip;
                };

                WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
                    return mustache.strip;
                };

                WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
                    /* istanbul ignore next */
                    var strip = node.strip || {};
                    return {
                        inlineStandalone: true,
                        open: strip.open,
                        close: strip.close
                    };
                };

                function isPrevWhitespace(body, i, isRoot) {
                    if (i === undefined) {
                        i = body.length;
                    }

                    // Nodes that end with newlines are considered whitespace (but are special
                    // cased for strip operations)
                    var prev = body[i - 1],
                        sibling = body[i - 2];
                    if (!prev) {
                        return isRoot;
                    }

                    if (prev.type === 'ContentStatement') {
                        return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
                    }
                }

                function isNextWhitespace(body, i, isRoot) {
                    if (i === undefined) {
                        i = -1;
                    }

                    var next = body[i + 1],
                        sibling = body[i + 2];
                    if (!next) {
                        return isRoot;
                    }

                    if (next.type === 'ContentStatement') {
                        return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
                    }
                }

                // Marks the node to the right of the position as omitted.
                // I.e. {{foo}}' ' will mark the ' ' node as omitted.
                //
                // If i is undefined, then the first child will be marked as such.
                //
                // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
                // content is met.
                function omitRight(body, i, multiple) {
                    var current = body[i == null ? 0 : i + 1];
                    if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
                        return;
                    }

                    var original = current.value;
                    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
                    current.rightStripped = current.value !== original;
                }

                // Marks the node to the left of the position as omitted.
                // I.e. ' '{{foo}} will mark the ' ' node as omitted.
                //
                // If i is undefined then the last child will be marked as such.
                //
                // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
                // content is met.
                function omitLeft(body, i, multiple) {
                    var current = body[i == null ? body.length - 1 : i - 1];
                    if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
                        return;
                    }

                    // We omit the last node if it's whitespace only and not preceeded by a non-content node.
                    var original = current.value;
                    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
                    current.leftStripped = current.value !== original;
                    return current.leftStripped;
                }

                exports['default'] = WhitespaceControl;
                module.exports = exports['default'];

                /***/
            },
            /* 25 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;

                var _exception = __webpack_require__(6);

                var _exception2 = _interopRequireDefault(_exception);

                function Visitor() {
                    this.parents = [];
                }

                Visitor.prototype = {
                    constructor: Visitor,
                    mutating: false,

                    // Visits a given value. If mutating, will replace the value if necessary.
                    acceptKey: function acceptKey(node, name) {
                        var value = this.accept(node[name]);
                        if (this.mutating) {
                            // Hacky sanity check: This may have a few false positives for type for the helper
                            // methods but will generally do the right thing without a lot of overhead.
                            if (value && !Visitor.prototype[value.type]) {
                                throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
                            }
                            node[name] = value;
                        }
                    },

                    // Performs an accept operation with added sanity check to ensure
                    // required keys are not removed.
                    acceptRequired: function acceptRequired(node, name) {
                        this.acceptKey(node, name);

                        if (!node[name]) {
                            throw new _exception2['default'](node.type + ' requires ' + name);
                        }
                    },

                    // Traverses a given array. If mutating, empty respnses will be removed
                    // for child elements.
                    acceptArray: function acceptArray(array) {
                        for (var i = 0, l = array.length; i < l; i++) {
                            this.acceptKey(array, i);

                            if (!array[i]) {
                                array.splice(i, 1);
                                i--;
                                l--;
                            }
                        }
                    },

                    accept: function accept(object) {
                        if (!object) {
                            return;
                        }

                        /* istanbul ignore next: Sanity code */
                        if (!this[object.type]) {
                            throw new _exception2['default']('Unknown type: ' + object.type, object);
                        }

                        if (this.current) {
                            this.parents.unshift(this.current);
                        }
                        this.current = object;

                        var ret = this[object.type](object);

                        this.current = this.parents.shift();

                        if (!this.mutating || ret) {
                            return ret;
                        } else if (ret !== false) {
                            return object;
                        }
                    },

                    Program: function Program(program) {
                        this.acceptArray(program.body);
                    },

                    MustacheStatement: visitSubExpression,
                    Decorator: visitSubExpression,

                    BlockStatement: visitBlock,
                    DecoratorBlock: visitBlock,

                    PartialStatement: visitPartial,
                    PartialBlockStatement: function PartialBlockStatement(partial) {
                        visitPartial.call(this, partial);

                        this.acceptKey(partial, 'program');
                    },

                    ContentStatement: function ContentStatement() /* content */ {},
                    CommentStatement: function CommentStatement() /* comment */ {},

                    SubExpression: visitSubExpression,

                    PathExpression: function PathExpression() /* path */ {},

                    StringLiteral: function StringLiteral() /* string */ {},
                    NumberLiteral: function NumberLiteral() /* number */ {},
                    BooleanLiteral: function BooleanLiteral() /* bool */ {},
                    UndefinedLiteral: function UndefinedLiteral() /* literal */ {},
                    NullLiteral: function NullLiteral() /* literal */ {},

                    Hash: function Hash(hash) {
                        this.acceptArray(hash.pairs);
                    },
                    HashPair: function HashPair(pair) {
                        this.acceptRequired(pair, 'value');
                    }
                };

                function visitSubExpression(mustache) {
                    this.acceptRequired(mustache, 'path');
                    this.acceptArray(mustache.params);
                    this.acceptKey(mustache, 'hash');
                }

                function visitBlock(block) {
                    visitSubExpression.call(this, block);

                    this.acceptKey(block, 'program');
                    this.acceptKey(block, 'inverse');
                }

                function visitPartial(partial) {
                    this.acceptRequired(partial, 'name');
                    this.acceptArray(partial.params);
                    this.acceptKey(partial, 'hash');
                }

                exports['default'] = Visitor;
                module.exports = exports['default'];

                /***/
            },
            /* 26 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;
                exports.SourceLocation = SourceLocation;
                exports.id = id;
                exports.stripFlags = stripFlags;
                exports.stripComment = stripComment;
                exports.preparePath = preparePath;
                exports.prepareMustache = prepareMustache;
                exports.prepareRawBlock = prepareRawBlock;
                exports.prepareBlock = prepareBlock;
                exports.prepareProgram = prepareProgram;
                exports.preparePartialBlock = preparePartialBlock;

                var _exception = __webpack_require__(6);

                var _exception2 = _interopRequireDefault(_exception);

                function validateClose(open, close) {
                    close = close.path ? close.path.original : close;

                    if (open.path.original !== close) {
                        var errorNode = {
                            loc: open.path.loc
                        };

                        throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
                    }
                }

                function SourceLocation(source, locInfo) {
                    this.source = source;
                    this.start = {
                        line: locInfo.first_line,
                        column: locInfo.first_column
                    };
                    this.end = {
                        line: locInfo.last_line,
                        column: locInfo.last_column
                    };
                }

                function id(token) {
                    if (/^\[.*\]$/.test(token)) {
                        return token.substr(1, token.length - 2);
                    } else {
                        return token;
                    }
                }

                function stripFlags(open, close) {
                    return {
                        open: open.charAt(2) === '~',
                        close: close.charAt(close.length - 3) === '~'
                    };
                }

                function stripComment(comment) {
                    return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
                }

                function preparePath(data, parts, loc) {
                    loc = this.locInfo(loc);

                    var original = data ? '@' : '',
                        dig = [],
                        depth = 0,
                        depthString = '';

                    for (var i = 0, l = parts.length; i < l; i++) {
                        var part = parts[i].part,

                            // If we have [] syntax then we do not treat path references as operators,
                            // i.e. foo.[this] resolves to approximately context.foo['this']
                            isLiteral = parts[i].original !== part;
                        original += (parts[i].separator || '') + part;

                        if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
                            if (dig.length > 0) {
                                throw new _exception2['default']('Invalid path: ' + original, {
                                    loc: loc
                                });
                            } else if (part === '..') {
                                depth++;
                                depthString += '../';
                            }
                        } else {
                            dig.push(part);
                        }
                    }

                    return {
                        type: 'PathExpression',
                        data: data,
                        depth: depth,
                        parts: dig,
                        original: original,
                        loc: loc
                    };
                }

                function prepareMustache(path, params, hash, open, strip, locInfo) {
                    // Must use charAt to support IE pre-10
                    var escapeFlag = open.charAt(3) || open.charAt(2),
                        escaped = escapeFlag !== '{' && escapeFlag !== '&';

                    var decorator = /\*/.test(open);
                    return {
                        type: decorator ? 'Decorator' : 'MustacheStatement',
                        path: path,
                        params: params,
                        hash: hash,
                        escaped: escaped,
                        strip: strip,
                        loc: this.locInfo(locInfo)
                    };
                }

                function prepareRawBlock(openRawBlock, contents, close, locInfo) {
                    validateClose(openRawBlock, close);

                    locInfo = this.locInfo(locInfo);
                    var program = {
                        type: 'Program',
                        body: contents,
                        strip: {},
                        loc: locInfo
                    };

                    return {
                        type: 'BlockStatement',
                        path: openRawBlock.path,
                        params: openRawBlock.params,
                        hash: openRawBlock.hash,
                        program: program,
                        openStrip: {},
                        inverseStrip: {},
                        closeStrip: {},
                        loc: locInfo
                    };
                }

                function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
                    if (close && close.path) {
                        validateClose(openBlock, close);
                    }

                    var decorator = /\*/.test(openBlock.open);

                    program.blockParams = openBlock.blockParams;

                    var inverse = undefined,
                        inverseStrip = undefined;

                    if (inverseAndProgram) {
                        if (decorator) {
                            throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
                        }

                        if (inverseAndProgram.chain) {
                            inverseAndProgram.program.body[0].closeStrip = close.strip;
                        }

                        inverseStrip = inverseAndProgram.strip;
                        inverse = inverseAndProgram.program;
                    }

                    if (inverted) {
                        inverted = inverse;
                        inverse = program;
                        program = inverted;
                    }

                    return {
                        type: decorator ? 'DecoratorBlock' : 'BlockStatement',
                        path: openBlock.path,
                        params: openBlock.params,
                        hash: openBlock.hash,
                        program: program,
                        inverse: inverse,
                        openStrip: openBlock.strip,
                        inverseStrip: inverseStrip,
                        closeStrip: close && close.strip,
                        loc: this.locInfo(locInfo)
                    };
                }

                function prepareProgram(statements, loc) {
                    if (!loc && statements.length) {
                        var firstLoc = statements[0].loc,
                            lastLoc = statements[statements.length - 1].loc;

                        /* istanbul ignore else */
                        if (firstLoc && lastLoc) {
                            loc = {
                                source: firstLoc.source,
                                start: {
                                    line: firstLoc.start.line,
                                    column: firstLoc.start.column
                                },
                                end: {
                                    line: lastLoc.end.line,
                                    column: lastLoc.end.column
                                }
                            };
                        }
                    }

                    return {
                        type: 'Program',
                        body: statements,
                        strip: {},
                        loc: loc
                    };
                }

                function preparePartialBlock(open, program, close, locInfo) {
                    validateClose(open, close);

                    return {
                        type: 'PartialBlockStatement',
                        name: open.path,
                        params: open.params,
                        hash: open.hash,
                        program: program,
                        openStrip: open.strip,
                        closeStrip: close && close.strip,
                        loc: this.locInfo(locInfo)
                    };
                }

                /***/
            },
            /* 27 */
            /***/
            function(module, exports, __webpack_require__) {

                /* eslint-disable new-cap */

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;
                exports.Compiler = Compiler;
                exports.precompile = precompile;
                exports.compile = compile;

                var _exception = __webpack_require__(6);

                var _exception2 = _interopRequireDefault(_exception);

                var _utils = __webpack_require__(5);

                var _ast = __webpack_require__(21);

                var _ast2 = _interopRequireDefault(_ast);

                var slice = [].slice;

                function Compiler() {}

                // the foundHelper register will disambiguate helper lookup from finding a
                // function in a context. This is necessary for mustache compatibility, which
                // requires that context functions in blocks are evaluated by blockHelperMissing,
                // and then proceed as if the resulting value was provided to blockHelperMissing.

                Compiler.prototype = {
                    compiler: Compiler,

                    equals: function equals(other) {
                        var len = this.opcodes.length;
                        if (other.opcodes.length !== len) {
                            return false;
                        }

                        for (var i = 0; i < len; i++) {
                            var opcode = this.opcodes[i],
                                otherOpcode = other.opcodes[i];
                            if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
                                return false;
                            }
                        }

                        // We know that length is the same between the two arrays because they are directly tied
                        // to the opcode behavior above.
                        len = this.children.length;
                        for (var i = 0; i < len; i++) {
                            if (!this.children[i].equals(other.children[i])) {
                                return false;
                            }
                        }

                        return true;
                    },

                    guid: 0,

                    compile: function compile(program, options) {
                        this.sourceNode = [];
                        this.opcodes = [];
                        this.children = [];
                        this.options = options;
                        this.stringParams = options.stringParams;
                        this.trackIds = options.trackIds;

                        options.blockParams = options.blockParams || [];

                        // These changes will propagate to the other compiler components
                        var knownHelpers = options.knownHelpers;
                        options.knownHelpers = {
                            'helperMissing': true,
                            'blockHelperMissing': true,
                            'each': true,
                            'if': true,
                            'unless': true,
                            'with': true,
                            'log': true,
                            'lookup': true
                        };
                        if (knownHelpers) {
                            for (var _name in knownHelpers) {
                                /* istanbul ignore else */
                                if (_name in knownHelpers) {
                                    options.knownHelpers[_name] = knownHelpers[_name];
                                }
                            }
                        }

                        return this.accept(program);
                    },

                    compileProgram: function compileProgram(program) {
                        var childCompiler = new this.compiler(),
                            // eslint-disable-line new-cap
                            result = childCompiler.compile(program, this.options),
                            guid = this.guid++;

                        this.usePartial = this.usePartial || result.usePartial;

                        this.children[guid] = result;
                        this.useDepths = this.useDepths || result.useDepths;

                        return guid;
                    },

                    accept: function accept(node) {
                        /* istanbul ignore next: Sanity code */
                        if (!this[node.type]) {
                            throw new _exception2['default']('Unknown type: ' + node.type, node);
                        }

                        this.sourceNode.unshift(node);
                        var ret = this[node.type](node);
                        this.sourceNode.shift();
                        return ret;
                    },

                    Program: function Program(program) {
                        this.options.blockParams.unshift(program.blockParams);

                        var body = program.body,
                            bodyLength = body.length;
                        for (var i = 0; i < bodyLength; i++) {
                            this.accept(body[i]);
                        }

                        this.options.blockParams.shift();

                        this.isSimple = bodyLength === 1;
                        this.blockParams = program.blockParams ? program.blockParams.length : 0;

                        return this;
                    },

                    BlockStatement: function BlockStatement(block) {
                        transformLiteralToPath(block);

                        var program = block.program,
                            inverse = block.inverse;

                        program = program && this.compileProgram(program);
                        inverse = inverse && this.compileProgram(inverse);

                        var type = this.classifySexpr(block);

                        if (type === 'helper') {
                            this.helperSexpr(block, program, inverse);
                        } else if (type === 'simple') {
                            this.simpleSexpr(block);

                            // now that the simple mustache is resolved, we need to
                            // evaluate it by executing `blockHelperMissing`
                            this.opcode('pushProgram', program);
                            this.opcode('pushProgram', inverse);
                            this.opcode('emptyHash');
                            this.opcode('blockValue', block.path.original);
                        } else {
                            this.ambiguousSexpr(block, program, inverse);

                            // now that the simple mustache is resolved, we need to
                            // evaluate it by executing `blockHelperMissing`
                            this.opcode('pushProgram', program);
                            this.opcode('pushProgram', inverse);
                            this.opcode('emptyHash');
                            this.opcode('ambiguousBlockValue');
                        }

                        this.opcode('append');
                    },

                    DecoratorBlock: function DecoratorBlock(decorator) {
                        var program = decorator.program && this.compileProgram(decorator.program);
                        var params = this.setupFullMustacheParams(decorator, program, undefined),
                            path = decorator.path;

                        this.useDecorators = true;
                        this.opcode('registerDecorator', params.length, path.original);
                    },

                    PartialStatement: function PartialStatement(partial) {
                        this.usePartial = true;

                        var program = partial.program;
                        if (program) {
                            program = this.compileProgram(partial.program);
                        }

                        var params = partial.params;
                        if (params.length > 1) {
                            throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
                        } else if (!params.length) {
                            if (this.options.explicitPartialContext) {
                                this.opcode('pushLiteral', 'undefined');
                            } else {
                                params.push({
                                    type: 'PathExpression',
                                    parts: [],
                                    depth: 0
                                });
                            }
                        }

                        var partialName = partial.name.original,
                            isDynamic = partial.name.type === 'SubExpression';
                        if (isDynamic) {
                            this.accept(partial.name);
                        }

                        this.setupFullMustacheParams(partial, program, undefined, true);

                        var indent = partial.indent || '';
                        if (this.options.preventIndent && indent) {
                            this.opcode('appendContent', indent);
                            indent = '';
                        }

                        this.opcode('invokePartial', isDynamic, partialName, indent);
                        this.opcode('append');
                    },
                    PartialBlockStatement: function PartialBlockStatement(partialBlock) {
                        this.PartialStatement(partialBlock);
                    },

                    MustacheStatement: function MustacheStatement(mustache) {
                        this.SubExpression(mustache);

                        if (mustache.escaped && !this.options.noEscape) {
                            this.opcode('appendEscaped');
                        } else {
                            this.opcode('append');
                        }
                    },
                    Decorator: function Decorator(decorator) {
                        this.DecoratorBlock(decorator);
                    },

                    ContentStatement: function ContentStatement(content) {
                        if (content.value) {
                            this.opcode('appendContent', content.value);
                        }
                    },

                    CommentStatement: function CommentStatement() {},

                    SubExpression: function SubExpression(sexpr) {
                        transformLiteralToPath(sexpr);
                        var type = this.classifySexpr(sexpr);

                        if (type === 'simple') {
                            this.simpleSexpr(sexpr);
                        } else if (type === 'helper') {
                            this.helperSexpr(sexpr);
                        } else {
                            this.ambiguousSexpr(sexpr);
                        }
                    },
                    ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
                        var path = sexpr.path,
                            name = path.parts[0],
                            isBlock = program != null || inverse != null;

                        this.opcode('getContext', path.depth);

                        this.opcode('pushProgram', program);
                        this.opcode('pushProgram', inverse);

                        path.strict = true;
                        this.accept(path);

                        this.opcode('invokeAmbiguous', name, isBlock);
                    },

                    simpleSexpr: function simpleSexpr(sexpr) {
                        var path = sexpr.path;
                        path.strict = true;
                        this.accept(path);
                        this.opcode('resolvePossibleLambda');
                    },

                    helperSexpr: function helperSexpr(sexpr, program, inverse) {
                        var params = this.setupFullMustacheParams(sexpr, program, inverse),
                            path = sexpr.path,
                            name = path.parts[0];

                        if (this.options.knownHelpers[name]) {
                            this.opcode('invokeKnownHelper', params.length, name);
                        } else if (this.options.knownHelpersOnly) {
                            throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
                        } else {
                            path.strict = true;
                            path.falsy = true;

                            this.accept(path);
                            this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
                        }
                    },

                    PathExpression: function PathExpression(path) {
                        this.addDepth(path.depth);
                        this.opcode('getContext', path.depth);

                        var name = path.parts[0],
                            scoped = _ast2['default'].helpers.scopedId(path),
                            blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

                        if (blockParamId) {
                            this.opcode('lookupBlockParam', blockParamId, path.parts);
                        } else if (!name) {
                            // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
                            this.opcode('pushContext');
                        } else if (path.data) {
                            this.options.data = true;
                            this.opcode('lookupData', path.depth, path.parts, path.strict);
                        } else {
                            this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
                        }
                    },

                    StringLiteral: function StringLiteral(string) {
                        this.opcode('pushString', string.value);
                    },

                    NumberLiteral: function NumberLiteral(number) {
                        this.opcode('pushLiteral', number.value);
                    },

                    BooleanLiteral: function BooleanLiteral(bool) {
                        this.opcode('pushLiteral', bool.value);
                    },

                    UndefinedLiteral: function UndefinedLiteral() {
                        this.opcode('pushLiteral', 'undefined');
                    },

                    NullLiteral: function NullLiteral() {
                        this.opcode('pushLiteral', 'null');
                    },

                    Hash: function Hash(hash) {
                        var pairs = hash.pairs,
                            i = 0,
                            l = pairs.length;

                        this.opcode('pushHash');

                        for (; i < l; i++) {
                            this.pushParam(pairs[i].value);
                        }
                        while (i--) {
                            this.opcode('assignToHash', pairs[i].key);
                        }
                        this.opcode('popHash');
                    },

                    // HELPERS
                    opcode: function opcode(name) {
                        this.opcodes.push({
                            opcode: name,
                            args: slice.call(arguments, 1),
                            loc: this.sourceNode[0].loc
                        });
                    },

                    addDepth: function addDepth(depth) {
                        if (!depth) {
                            return;
                        }

                        this.useDepths = true;
                    },

                    classifySexpr: function classifySexpr(sexpr) {
                        var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

                        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

                        // a mustache is an eligible helper if:
                        // * its id is simple (a single part, not `this` or `..`)
                        var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

                        // if a mustache is an eligible helper but not a definite
                        // helper, it is ambiguous, and will be resolved in a later
                        // pass or at runtime.
                        var isEligible = !isBlockParam && (isHelper || isSimple);

                        // if ambiguous, we can possibly resolve the ambiguity now
                        // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
                        if (isEligible && !isHelper) {
                            var _name2 = sexpr.path.parts[0],
                                options = this.options;

                            if (options.knownHelpers[_name2]) {
                                isHelper = true;
                            } else if (options.knownHelpersOnly) {
                                isEligible = false;
                            }
                        }

                        if (isHelper) {
                            return 'helper';
                        } else if (isEligible) {
                            return 'ambiguous';
                        } else {
                            return 'simple';
                        }
                    },

                    pushParams: function pushParams(params) {
                        for (var i = 0, l = params.length; i < l; i++) {
                            this.pushParam(params[i]);
                        }
                    },

                    pushParam: function pushParam(val) {
                        var value = val.value != null ? val.value : val.original || '';

                        if (this.stringParams) {
                            if (value.replace) {
                                value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
                            }

                            if (val.depth) {
                                this.addDepth(val.depth);
                            }
                            this.opcode('getContext', val.depth || 0);
                            this.opcode('pushStringParam', value, val.type);

                            if (val.type === 'SubExpression') {
                                // SubExpressions get evaluated and passed in
                                // in string params mode.
                                this.accept(val);
                            }
                        } else {
                            if (this.trackIds) {
                                var blockParamIndex = undefined;
                                if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
                                    blockParamIndex = this.blockParamIndex(val.parts[0]);
                                }
                                if (blockParamIndex) {
                                    var blockParamChild = val.parts.slice(1).join('.');
                                    this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
                                } else {
                                    value = val.original || value;
                                    if (value.replace) {
                                        value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
                                    }

                                    this.opcode('pushId', val.type, value);
                                }
                            }
                            this.accept(val);
                        }
                    },

                    setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
                        var params = sexpr.params;
                        this.pushParams(params);

                        this.opcode('pushProgram', program);
                        this.opcode('pushProgram', inverse);

                        if (sexpr.hash) {
                            this.accept(sexpr.hash);
                        } else {
                            this.opcode('emptyHash', omitEmpty);
                        }

                        return params;
                    },

                    blockParamIndex: function blockParamIndex(name) {
                        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
                            var blockParams = this.options.blockParams[depth],
                                param = blockParams && _utils.indexOf(blockParams, name);
                            if (blockParams && param >= 0) {
                                return [depth, param];
                            }
                        }
                    }
                };

                function precompile(input, options, env) {
                    if (input == null || typeof input !== 'string' && input.type !== 'Program') {
                        throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
                    }

                    options = options || {};
                    if (!('data' in options)) {
                        options.data = true;
                    }
                    if (options.compat) {
                        options.useDepths = true;
                    }

                    var ast = env.parse(input, options),
                        environment = new env.Compiler().compile(ast, options);
                    return new env.JavaScriptCompiler().compile(environment, options);
                }

                function compile(input, options, env) {
                    if (options === undefined) options = {};

                    if (input == null || typeof input !== 'string' && input.type !== 'Program') {
                        throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
                    }

                    if (!('data' in options)) {
                        options.data = true;
                    }
                    if (options.compat) {
                        options.useDepths = true;
                    }

                    var compiled = undefined;

                    function compileInput() {
                        var ast = env.parse(input, options),
                            environment = new env.Compiler().compile(ast, options),
                            templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
                        return env.template(templateSpec);
                    }

                    // Template is only compiled on first use and cached after that point.
                    function ret(context, execOptions) {
                        if (!compiled) {
                            compiled = compileInput();
                        }
                        return compiled.call(this, context, execOptions);
                    }
                    ret._setup = function(setupOptions) {
                        if (!compiled) {
                            compiled = compileInput();
                        }
                        return compiled._setup(setupOptions);
                    };
                    ret._child = function(i, data, blockParams, depths) {
                        if (!compiled) {
                            compiled = compileInput();
                        }
                        return compiled._child(i, data, blockParams, depths);
                    };
                    return ret;
                }

                function argEquals(a, b) {
                    if (a === b) {
                        return true;
                    }

                    if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
                        for (var i = 0; i < a.length; i++) {
                            if (!argEquals(a[i], b[i])) {
                                return false;
                            }
                        }
                        return true;
                    }
                }

                function transformLiteralToPath(sexpr) {
                    if (!sexpr.path.parts) {
                        var literal = sexpr.path;
                        // Casting to string here to make false and 0 literal values play nicely with the rest
                        // of the system.
                        sexpr.path = {
                            type: 'PathExpression',
                            data: false,
                            depth: 0,
                            parts: [literal.original + ''],
                            original: literal.original + '',
                            loc: literal.loc
                        };
                    }
                }

                /***/
            },
            /* 28 */
            /***/
            function(module, exports, __webpack_require__) {

                'use strict';

                var _interopRequireDefault = __webpack_require__(1)['default'];

                exports.__esModule = true;

                var _base = __webpack_require__(4);

                var _exception = __webpack_require__(6);

                var _exception2 = _interopRequireDefault(_exception);

                var _utils = __webpack_require__(5);

                var _codeGen = __webpack_require__(29);

                var _codeGen2 = _interopRequireDefault(_codeGen);

                function Literal(value) {
                    this.value = value;
                }

                function JavaScriptCompiler() {}

                JavaScriptCompiler.prototype = {
                    // PUBLIC API: You can override these methods in a subclass to provide
                    // alternative compiled forms for name lookup and buffering semantics
                    nameLookup: function nameLookup(parent, name /* , type*/ ) {
                        if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
                            return [parent, '.', name];
                        } else {
                            return [parent, '[', JSON.stringify(name), ']'];
                        }
                    },
                    depthedLookup: function depthedLookup(name) {
                        return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
                    },

                    compilerInfo: function compilerInfo() {
                        var revision = _base.COMPILER_REVISION,
                            versions = _base.REVISION_CHANGES[revision];
                        return [revision, versions];
                    },

                    appendToBuffer: function appendToBuffer(source, location, explicit) {
                        // Force a source as this simplifies the merge logic.
                        if (!_utils.isArray(source)) {
                            source = [source];
                        }
                        source = this.source.wrap(source, location);

                        if (this.environment.isSimple) {
                            return ['return ', source, ';'];
                        } else if (explicit) {
                            // This is a case where the buffer operation occurs as a child of another
                            // construct, generally braces. We have to explicitly output these buffer
                            // operations to ensure that the emitted code goes in the correct location.
                            return ['buffer += ', source, ';'];
                        } else {
                            source.appendToBuffer = true;
                            return source;
                        }
                    },

                    initializeBuffer: function initializeBuffer() {
                        return this.quotedString('');
                    },
                    // END PUBLIC API

                    compile: function compile(environment, options, context, asObject) {
                        this.environment = environment;
                        this.options = options;
                        this.stringParams = this.options.stringParams;
                        this.trackIds = this.options.trackIds;
                        this.precompile = !asObject;

                        this.name = this.environment.name;
                        this.isChild = !!context;
                        this.context = context || {
                            decorators: [],
                            programs: [],
                            environments: []
                        };

                        this.preamble();

                        this.stackSlot = 0;
                        this.stackVars = [];
                        this.aliases = {};
                        this.registers = {
                            list: []
                        };
                        this.hashes = [];
                        this.compileStack = [];
                        this.inlineStack = [];
                        this.blockParams = [];

                        this.compileChildren(environment, options);

                        this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
                        this.useBlockParams = this.useBlockParams || environment.useBlockParams;

                        var opcodes = environment.opcodes,
                            opcode = undefined,
                            firstLoc = undefined,
                            i = undefined,
                            l = undefined;

                        for (i = 0, l = opcodes.length; i < l; i++) {
                            opcode = opcodes[i];

                            this.source.currentLocation = opcode.loc;
                            firstLoc = firstLoc || opcode.loc;
                            this[opcode.opcode].apply(this, opcode.args);
                        }

                        // Flush any trailing content that might be pending.
                        this.source.currentLocation = firstLoc;
                        this.pushSource('');

                        /* istanbul ignore next */
                        if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
                            throw new _exception2['default']('Compile completed with content left on stack');
                        }

                        if (!this.decorators.isEmpty()) {
                            this.useDecorators = true;

                            this.decorators.prepend('var decorators = container.decorators;\n');
                            this.decorators.push('return fn;');

                            if (asObject) {
                                this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
                            } else {
                                this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
                                this.decorators.push('}\n');
                                this.decorators = this.decorators.merge();
                            }
                        } else {
                            this.decorators = undefined;
                        }

                        var fn = this.createFunctionContext(asObject);
                        if (!this.isChild) {
                            var ret = {
                                compiler: this.compilerInfo(),
                                main: fn
                            };

                            if (this.decorators) {
                                ret.main_d = this.decorators; // eslint-disable-line camelcase
                                ret.useDecorators = true;
                            }

                            var _context = this.context;
                            var programs = _context.programs;
                            var decorators = _context.decorators;

                            for (i = 0, l = programs.length; i < l; i++) {
                                if (programs[i]) {
                                    ret[i] = programs[i];
                                    if (decorators[i]) {
                                        ret[i + '_d'] = decorators[i];
                                        ret.useDecorators = true;
                                    }
                                }
                            }

                            if (this.environment.usePartial) {
                                ret.usePartial = true;
                            }
                            if (this.options.data) {
                                ret.useData = true;
                            }
                            if (this.useDepths) {
                                ret.useDepths = true;
                            }
                            if (this.useBlockParams) {
                                ret.useBlockParams = true;
                            }
                            if (this.options.compat) {
                                ret.compat = true;
                            }

                            if (!asObject) {
                                ret.compiler = JSON.stringify(ret.compiler);

                                this.source.currentLocation = {
                                    start: {
                                        line: 1,
                                        column: 0
                                    }
                                };
                                ret = this.objectLiteral(ret);

                                if (options.srcName) {
                                    ret = ret.toStringWithSourceMap({
                                        file: options.destName
                                    });
                                    ret.map = ret.map && ret.map.toString();
                                } else {
                                    ret = ret.toString();
                                }
                            } else {
                                ret.compilerOptions = this.options;
                            }

                            return ret;
                        } else {
                            return fn;
                        }
                    },

                    preamble: function preamble() {
                        // track the last context pushed into place to allow skipping the
                        // getContext opcode when it would be a noop
                        this.lastContext = 0;
                        this.source = new _codeGen2['default'](this.options.srcName);
                        this.decorators = new _codeGen2['default'](this.options.srcName);
                    },

                    createFunctionContext: function createFunctionContext(asObject) {
                        var varDeclarations = '';

                        var locals = this.stackVars.concat(this.registers.list);
                        if (locals.length > 0) {
                            varDeclarations += ', ' + locals.join(', ');
                        }

                        // Generate minimizer alias mappings
                        //
                        // When using true SourceNodes, this will update all references to the given alias
                        // as the source nodes are reused in situ. For the non-source node compilation mode,
                        // aliases will not be used, but this case is already being run on the client and
                        // we aren't concern about minimizing the template size.
                        var aliasCount = 0;
                        for (var alias in this.aliases) {
                            // eslint-disable-line guard-for-in
                            var node = this.aliases[alias];

                            if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
                                varDeclarations += ', alias' + ++aliasCount + '=' + alias;
                                node.children[0] = 'alias' + aliasCount;
                            }
                        }

                        var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

                        if (this.useBlockParams || this.useDepths) {
                            params.push('blockParams');
                        }
                        if (this.useDepths) {
                            params.push('depths');
                        }

                        // Perform a second pass over the output to merge content when possible
                        var source = this.mergeSource(varDeclarations);

                        if (asObject) {
                            params.push(source);

                            return Function.apply(this, params);
                        } else {
                            return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
                        }
                    },
                    mergeSource: function mergeSource(varDeclarations) {
                        var isSimple = this.environment.isSimple,
                            appendOnly = !this.forceBuffer,
                            appendFirst = undefined,
                            sourceSeen = undefined,
                            bufferStart = undefined,
                            bufferEnd = undefined;
                        this.source.each(function(line) {
                            if (line.appendToBuffer) {
                                if (bufferStart) {
                                    line.prepend('  + ');
                                } else {
                                    bufferStart = line;
                                }
                                bufferEnd = line;
                            } else {
                                if (bufferStart) {
                                    if (!sourceSeen) {
                                        appendFirst = true;
                                    } else {
                                        bufferStart.prepend('buffer += ');
                                    }
                                    bufferEnd.add(';');
                                    bufferStart = bufferEnd = undefined;
                                }

                                sourceSeen = true;
                                if (!isSimple) {
                                    appendOnly = false;
                                }
                            }
                        });

                        if (appendOnly) {
                            if (bufferStart) {
                                bufferStart.prepend('return ');
                                bufferEnd.add(';');
                            } else if (!sourceSeen) {
                                this.source.push('return "";');
                            }
                        } else {
                            varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

                            if (bufferStart) {
                                bufferStart.prepend('return buffer + ');
                                bufferEnd.add(';');
                            } else {
                                this.source.push('return buffer;');
                            }
                        }

                        if (varDeclarations) {
                            this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
                        }

                        return this.source.merge();
                    },

                    // [blockValue]
                    //
                    // On stack, before: hash, inverse, program, value
                    // On stack, after: return value of blockHelperMissing
                    //
                    // The purpose of this opcode is to take a block of the form
                    // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
                    // replace it on the stack with the result of properly
                    // invoking blockHelperMissing.
                    blockValue: function blockValue(name) {
                        var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                            params = [this.contextName(0)];
                        this.setupHelperArgs(name, 0, params);

                        var blockName = this.popStack();
                        params.splice(1, 0, blockName);

                        this.push(this.source.functionCall(blockHelperMissing, 'call', params));
                    },

                    // [ambiguousBlockValue]
                    //
                    // On stack, before: hash, inverse, program, value
                    // Compiler value, before: lastHelper=value of last found helper, if any
                    // On stack, after, if no lastHelper: same as [blockValue]
                    // On stack, after, if lastHelper: value
                    ambiguousBlockValue: function ambiguousBlockValue() {
                        // We're being a bit cheeky and reusing the options value from the prior exec
                        var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                            params = [this.contextName(0)];
                        this.setupHelperArgs('', 0, params, true);

                        this.flushInline();

                        var current = this.topStack();
                        params.splice(1, 0, current);

                        this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
                    },

                    // [appendContent]
                    //
                    // On stack, before: ...
                    // On stack, after: ...
                    //
                    // Appends the string value of `content` to the current buffer
                    appendContent: function appendContent(content) {
                        if (this.pendingContent) {
                            content = this.pendingContent + content;
                        } else {
                            this.pendingLocation = this.source.currentLocation;
                        }

                        this.pendingContent = content;
                    },

                    // [append]
                    //
                    // On stack, before: value, ...
                    // On stack, after: ...
                    //
                    // Coerces `value` to a String and appends it to the current buffer.
                    //
                    // If `value` is truthy, or 0, it is coerced into a string and appended
                    // Otherwise, the empty string is appended
                    append: function append() {
                        if (this.isInline()) {
                            this.replaceStack(function(current) {
                                return [' != null ? ', current, ' : ""'];
                            });

                            this.pushSource(this.appendToBuffer(this.popStack()));
                        } else {
                            var local = this.popStack();
                            this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
                            if (this.environment.isSimple) {
                                this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
                            }
                        }
                    },

                    // [appendEscaped]
                    //
                    // On stack, before: value, ...
                    // On stack, after: ...
                    //
                    // Escape `value` and append it to the buffer
                    appendEscaped: function appendEscaped() {
                        this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
                    },

                    // [getContext]
                    //
                    // On stack, before: ...
                    // On stack, after: ...
                    // Compiler value, after: lastContext=depth
                    //
                    // Set the value of the `lastContext` compiler value to the depth
                    getContext: function getContext(depth) {
                        this.lastContext = depth;
                    },

                    // [pushContext]
                    //
                    // On stack, before: ...
                    // On stack, after: currentContext, ...
                    //
                    // Pushes the value of the current context onto the stack.
                    pushContext: function pushContext() {
                        this.pushStackLiteral(this.contextName(this.lastContext));
                    },

                    // [lookupOnContext]
                    //
                    // On stack, before: ...
                    // On stack, after: currentContext[name], ...
                    //
                    // Looks up the value of `name` on the current context and pushes
                    // it onto the stack.
                    lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
                        var i = 0;

                        if (!scoped && this.options.compat && !this.lastContext) {
                            // The depthed query is expected to handle the undefined logic for the root level that
                            // is implemented below, so we evaluate that directly in compat mode
                            this.push(this.depthedLookup(parts[i++]));
                        } else {
                            this.pushContext();
                        }

                        this.resolvePath('context', parts, i, falsy, strict);
                    },

                    // [lookupBlockParam]
                    //
                    // On stack, before: ...
                    // On stack, after: blockParam[name], ...
                    //
                    // Looks up the value of `parts` on the given block param and pushes
                    // it onto the stack.
                    lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
                        this.useBlockParams = true;

                        this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
                        this.resolvePath('context', parts, 1);
                    },

                    // [lookupData]
                    //
                    // On stack, before: ...
                    // On stack, after: data, ...
                    //
                    // Push the data lookup operator
                    lookupData: function lookupData(depth, parts, strict) {
                        if (!depth) {
                            this.pushStackLiteral('data');
                        } else {
                            this.pushStackLiteral('container.data(data, ' + depth + ')');
                        }

                        this.resolvePath('data', parts, 0, true, strict);
                    },

                    resolvePath: function resolvePath(type, parts, i, falsy, strict) {
                        // istanbul ignore next

                        var _this = this;

                        if (this.options.strict || this.options.assumeObjects) {
                            this.push(strictLookup(this.options.strict && strict, this, parts, type));
                            return;
                        }

                        var len = parts.length;
                        for (; i < len; i++) {
                            /* eslint-disable no-loop-func */
                            this.replaceStack(function(current) {
                                var lookup = _this.nameLookup(current, parts[i], type);
                                // We want to ensure that zero and false are handled properly if the context (falsy flag)
                                // needs to have the special handling for these values.
                                if (!falsy) {
                                    return [' != null ? ', lookup, ' : ', current];
                                } else {
                                    // Otherwise we can use generic falsy handling
                                    return [' && ', lookup];
                                }
                            });
                            /* eslint-enable no-loop-func */
                        }
                    },

                    // [resolvePossibleLambda]
                    //
                    // On stack, before: value, ...
                    // On stack, after: resolved value, ...
                    //
                    // If the `value` is a lambda, replace it on the stack by
                    // the return value of the lambda
                    resolvePossibleLambda: function resolvePossibleLambda() {
                        this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
                    },

                    // [pushStringParam]
                    //
                    // On stack, before: ...
                    // On stack, after: string, currentContext, ...
                    //
                    // This opcode is designed for use in string mode, which
                    // provides the string value of a parameter along with its
                    // depth rather than resolving it immediately.
                    pushStringParam: function pushStringParam(string, type) {
                        this.pushContext();
                        this.pushString(type);

                        // If it's a subexpression, the string result
                        // will be pushed after this opcode.
                        if (type !== 'SubExpression') {
                            if (typeof string === 'string') {
                                this.pushString(string);
                            } else {
                                this.pushStackLiteral(string);
                            }
                        }
                    },

                    emptyHash: function emptyHash(omitEmpty) {
                        if (this.trackIds) {
                            this.push('{}'); // hashIds
                        }
                        if (this.stringParams) {
                            this.push('{}'); // hashContexts
                            this.push('{}'); // hashTypes
                        }
                        this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
                    },
                    pushHash: function pushHash() {
                        if (this.hash) {
                            this.hashes.push(this.hash);
                        }
                        this.hash = {
                            values: [],
                            types: [],
                            contexts: [],
                            ids: []
                        };
                    },
                    popHash: function popHash() {
                        var hash = this.hash;
                        this.hash = this.hashes.pop();

                        if (this.trackIds) {
                            this.push(this.objectLiteral(hash.ids));
                        }
                        if (this.stringParams) {
                            this.push(this.objectLiteral(hash.contexts));
                            this.push(this.objectLiteral(hash.types));
                        }

                        this.push(this.objectLiteral(hash.values));
                    },

                    // [pushString]
                    //
                    // On stack, before: ...
                    // On stack, after: quotedString(string), ...
                    //
                    // Push a quoted version of `string` onto the stack
                    pushString: function pushString(string) {
                        this.pushStackLiteral(this.quotedString(string));
                    },

                    // [pushLiteral]
                    //
                    // On stack, before: ...
                    // On stack, after: value, ...
                    //
                    // Pushes a value onto the stack. This operation prevents
                    // the compiler from creating a temporary variable to hold
                    // it.
                    pushLiteral: function pushLiteral(value) {
                        this.pushStackLiteral(value);
                    },

                    // [pushProgram]
                    //
                    // On stack, before: ...
                    // On stack, after: program(guid), ...
                    //
                    // Push a program expression onto the stack. This takes
                    // a compile-time guid and converts it into a runtime-accessible
                    // expression.
                    pushProgram: function pushProgram(guid) {
                        if (guid != null) {
                            this.pushStackLiteral(this.programExpression(guid));
                        } else {
                            this.pushStackLiteral(null);
                        }
                    },

                    // [registerDecorator]
                    //
                    // On stack, before: hash, program, params..., ...
                    // On stack, after: ...
                    //
                    // Pops off the decorator's parameters, invokes the decorator,
                    // and inserts the decorator into the decorators list.
                    registerDecorator: function registerDecorator(paramSize, name) {
                        var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
                            options = this.setupHelperArgs(name, paramSize);

                        this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
                    },

                    // [invokeHelper]
                    //
                    // On stack, before: hash, inverse, program, params..., ...
                    // On stack, after: result of helper invocation
                    //
                    // Pops off the helper's parameters, invokes the helper,
                    // and pushes the helper's return value onto the stack.
                    //
                    // If the helper is not found, `helperMissing` is called.
                    invokeHelper: function invokeHelper(paramSize, name, isSimple) {
                        var nonHelper = this.popStack(),
                            helper = this.setupHelper(paramSize, name),
                            simple = isSimple ? [helper.name, ' || '] : '';

                        var lookup = ['('].concat(simple, nonHelper);
                        if (!this.options.strict) {
                            lookup.push(' || ', this.aliasable('helpers.helperMissing'));
                        }
                        lookup.push(')');

                        this.push(this.source.functionCall(lookup, 'call', helper.callParams));
                    },

                    // [invokeKnownHelper]
                    //
                    // On stack, before: hash, inverse, program, params..., ...
                    // On stack, after: result of helper invocation
                    //
                    // This operation is used when the helper is known to exist,
                    // so a `helperMissing` fallback is not required.
                    invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
                        var helper = this.setupHelper(paramSize, name);
                        this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
                    },

                    // [invokeAmbiguous]
                    //
                    // On stack, before: hash, inverse, program, params..., ...
                    // On stack, after: result of disambiguation
                    //
                    // This operation is used when an expression like `{{foo}}`
                    // is provided, but we don't know at compile-time whether it
                    // is a helper or a path.
                    //
                    // This operation emits more code than the other options,
                    // and can be avoided by passing the `knownHelpers` and
                    // `knownHelpersOnly` flags at compile-time.
                    invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
                        this.useRegister('helper');

                        var nonHelper = this.popStack();

                        this.emptyHash();
                        var helper = this.setupHelper(0, name, helperCall);

                        var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

                        var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
                        if (!this.options.strict) {
                            lookup[0] = '(helper = ';
                            lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
                        }

                        this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
                    },

                    // [invokePartial]
                    //
                    // On stack, before: context, ...
                    // On stack after: result of partial invocation
                    //
                    // This operation pops off a context, invokes a partial with that context,
                    // and pushes the result of the invocation back.
                    invokePartial: function invokePartial(isDynamic, name, indent) {
                        var params = [],
                            options = this.setupParams(name, 1, params);

                        if (isDynamic) {
                            name = this.popStack();
                            delete options.name;
                        }

                        if (indent) {
                            options.indent = JSON.stringify(indent);
                        }
                        options.helpers = 'helpers';
                        options.partials = 'partials';
                        options.decorators = 'container.decorators';

                        if (!isDynamic) {
                            params.unshift(this.nameLookup('partials', name, 'partial'));
                        } else {
                            params.unshift(name);
                        }

                        if (this.options.compat) {
                            options.depths = 'depths';
                        }
                        options = this.objectLiteral(options);
                        params.push(options);

                        this.push(this.source.functionCall('container.invokePartial', '', params));
                    },

                    // [assignToHash]
                    //
                    // On stack, before: value, ..., hash, ...
                    // On stack, after: ..., hash, ...
                    //
                    // Pops a value off the stack and assigns it to the current hash
                    assignToHash: function assignToHash(key) {
                        var value = this.popStack(),
                            context = undefined,
                            type = undefined,
                            id = undefined;

                        if (this.trackIds) {
                            id = this.popStack();
                        }
                        if (this.stringParams) {
                            type = this.popStack();
                            context = this.popStack();
                        }

                        var hash = this.hash;
                        if (context) {
                            hash.contexts[key] = context;
                        }
                        if (type) {
                            hash.types[key] = type;
                        }
                        if (id) {
                            hash.ids[key] = id;
                        }
                        hash.values[key] = value;
                    },

                    pushId: function pushId(type, name, child) {
                        if (type === 'BlockParam') {
                            this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
                        } else if (type === 'PathExpression') {
                            this.pushString(name);
                        } else if (type === 'SubExpression') {
                            this.pushStackLiteral('true');
                        } else {
                            this.pushStackLiteral('null');
                        }
                    },

                    // HELPERS

                    compiler: JavaScriptCompiler,

                    compileChildren: function compileChildren(environment, options) {
                        var children = environment.children,
                            child = undefined,
                            compiler = undefined;

                        for (var i = 0, l = children.length; i < l; i++) {
                            child = children[i];
                            compiler = new this.compiler(); // eslint-disable-line new-cap

                            var index = this.matchExistingProgram(child);

                            if (index == null) {
                                this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
                                index = this.context.programs.length;
                                child.index = index;
                                child.name = 'program' + index;
                                this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
                                this.context.decorators[index] = compiler.decorators;
                                this.context.environments[index] = child;

                                this.useDepths = this.useDepths || compiler.useDepths;
                                this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
                            } else {
                                child.index = index;
                                child.name = 'program' + index;

                                this.useDepths = this.useDepths || child.useDepths;
                                this.useBlockParams = this.useBlockParams || child.useBlockParams;
                            }
                        }
                    },
                    matchExistingProgram: function matchExistingProgram(child) {
                        for (var i = 0, len = this.context.environments.length; i < len; i++) {
                            var environment = this.context.environments[i];
                            if (environment && environment.equals(child)) {
                                return i;
                            }
                        }
                    },

                    programExpression: function programExpression(guid) {
                        var child = this.environment.children[guid],
                            programParams = [child.index, 'data', child.blockParams];

                        if (this.useBlockParams || this.useDepths) {
                            programParams.push('blockParams');
                        }
                        if (this.useDepths) {
                            programParams.push('depths');
                        }

                        return 'container.program(' + programParams.join(', ') + ')';
                    },

                    useRegister: function useRegister(name) {
                        if (!this.registers[name]) {
                            this.registers[name] = true;
                            this.registers.list.push(name);
                        }
                    },

                    push: function push(expr) {
                        if (!(expr instanceof Literal)) {
                            expr = this.source.wrap(expr);
                        }

                        this.inlineStack.push(expr);
                        return expr;
                    },

                    pushStackLiteral: function pushStackLiteral(item) {
                        this.push(new Literal(item));
                    },

                    pushSource: function pushSource(source) {
                        if (this.pendingContent) {
                            this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
                            this.pendingContent = undefined;
                        }

                        if (source) {
                            this.source.push(source);
                        }
                    },

                    replaceStack: function replaceStack(callback) {
                        var prefix = ['('],
                            stack = undefined,
                            createdStack = undefined,
                            usedLiteral = undefined;

                        /* istanbul ignore next */
                        if (!this.isInline()) {
                            throw new _exception2['default']('replaceStack on non-inline');
                        }

                        // We want to merge the inline statement into the replacement statement via ','
                        var top = this.popStack(true);

                        if (top instanceof Literal) {
                            // Literals do not need to be inlined
                            stack = [top.value];
                            prefix = ['(', stack];
                            usedLiteral = true;
                        } else {
                            // Get or create the current stack name for use by the inline
                            createdStack = true;
                            var _name = this.incrStack();

                            prefix = ['((', this.push(_name), ' = ', top, ')'];
                            stack = this.topStack();
                        }

                        var item = callback.call(this, stack);

                        if (!usedLiteral) {
                            this.popStack();
                        }
                        if (createdStack) {
                            this.stackSlot--;
                        }
                        this.push(prefix.concat(item, ')'));
                    },

                    incrStack: function incrStack() {
                        this.stackSlot++;
                        if (this.stackSlot > this.stackVars.length) {
                            this.stackVars.push('stack' + this.stackSlot);
                        }
                        return this.topStackName();
                    },
                    topStackName: function topStackName() {
                        return 'stack' + this.stackSlot;
                    },
                    flushInline: function flushInline() {
                        var inlineStack = this.inlineStack;
                        this.inlineStack = [];
                        for (var i = 0, len = inlineStack.length; i < len; i++) {
                            var entry = inlineStack[i];
                            /* istanbul ignore if */
                            if (entry instanceof Literal) {
                                this.compileStack.push(entry);
                            } else {
                                var stack = this.incrStack();
                                this.pushSource([stack, ' = ', entry, ';']);
                                this.compileStack.push(stack);
                            }
                        }
                    },
                    isInline: function isInline() {
                        return this.inlineStack.length;
                    },

                    popStack: function popStack(wrapped) {
                        var inline = this.isInline(),
                            item = (inline ? this.inlineStack : this.compileStack).pop();

                        if (!wrapped && item instanceof Literal) {
                            return item.value;
                        } else {
                            if (!inline) {
                                /* istanbul ignore next */
                                if (!this.stackSlot) {
                                    throw new _exception2['default']('Invalid stack pop');
                                }
                                this.stackSlot--;
                            }
                            return item;
                        }
                    },

                    topStack: function topStack() {
                        var stack = this.isInline() ? this.inlineStack : this.compileStack,
                            item = stack[stack.length - 1];

                        /* istanbul ignore if */
                        if (item instanceof Literal) {
                            return item.value;
                        } else {
                            return item;
                        }
                    },

                    contextName: function contextName(context) {
                        if (this.useDepths && context) {
                            return 'depths[' + context + ']';
                        } else {
                            return 'depth' + context;
                        }
                    },

                    quotedString: function quotedString(str) {
                        return this.source.quotedString(str);
                    },

                    objectLiteral: function objectLiteral(obj) {
                        return this.source.objectLiteral(obj);
                    },

                    aliasable: function aliasable(name) {
                        var ret = this.aliases[name];
                        if (ret) {
                            ret.referenceCount++;
                            return ret;
                        }

                        ret = this.aliases[name] = this.source.wrap(name);
                        ret.aliasable = true;
                        ret.referenceCount = 1;

                        return ret;
                    },

                    setupHelper: function setupHelper(paramSize, name, blockHelper) {
                        var params = [],
                            paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
                        var foundHelper = this.nameLookup('helpers', name, 'helper'),
                            callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : {}');

                        return {
                            params: params,
                            paramsInit: paramsInit,
                            name: foundHelper,
                            callParams: [callContext].concat(params)
                        };
                    },

                    setupParams: function setupParams(helper, paramSize, params) {
                        var options = {},
                            contexts = [],
                            types = [],
                            ids = [],
                            objectArgs = !params,
                            param = undefined;

                        if (objectArgs) {
                            params = [];
                        }

                        options.name = this.quotedString(helper);
                        options.hash = this.popStack();

                        if (this.trackIds) {
                            options.hashIds = this.popStack();
                        }
                        if (this.stringParams) {
                            options.hashTypes = this.popStack();
                            options.hashContexts = this.popStack();
                        }

                        var inverse = this.popStack(),
                            program = this.popStack();

                        // Avoid setting fn and inverse if neither are set. This allows
                        // helpers to do a check for `if (options.fn)`
                        if (program || inverse) {
                            options.fn = program || 'container.noop';
                            options.inverse = inverse || 'container.noop';
                        }

                        // The parameters go on to the stack in order (making sure that they are evaluated in order)
                        // so we need to pop them off the stack in reverse order
                        var i = paramSize;
                        while (i--) {
                            param = this.popStack();
                            params[i] = param;

                            if (this.trackIds) {
                                ids[i] = this.popStack();
                            }
                            if (this.stringParams) {
                                types[i] = this.popStack();
                                contexts[i] = this.popStack();
                            }
                        }

                        if (objectArgs) {
                            options.args = this.source.generateArray(params);
                        }

                        if (this.trackIds) {
                            options.ids = this.source.generateArray(ids);
                        }
                        if (this.stringParams) {
                            options.types = this.source.generateArray(types);
                            options.contexts = this.source.generateArray(contexts);
                        }

                        if (this.options.data) {
                            options.data = 'data';
                        }
                        if (this.useBlockParams) {
                            options.blockParams = 'blockParams';
                        }
                        return options;
                    },

                    setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
                        var options = this.setupParams(helper, paramSize, params);
                        options = this.objectLiteral(options);
                        if (useRegister) {
                            this.useRegister('options');
                            params.push('options');
                            return ['options=', options];
                        } else if (params) {
                            params.push(options);
                            return '';
                        } else {
                            return options;
                        }
                    }
                };

                (function() {
                    var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

                    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

                    for (var i = 0, l = reservedWords.length; i < l; i++) {
                        compilerWords[reservedWords[i]] = true;
                    }
                })();

                JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
                    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
                };

                function strictLookup(requireTerminal, compiler, parts, type) {
                    var stack = compiler.popStack(),
                        i = 0,
                        len = parts.length;
                    if (requireTerminal) {
                        len--;
                    }

                    for (; i < len; i++) {
                        stack = compiler.nameLookup(stack, parts[i], type);
                    }

                    if (requireTerminal) {
                        return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
                    } else {
                        return stack;
                    }
                }

                exports['default'] = JavaScriptCompiler;
                module.exports = exports['default'];

                /***/
            },
            /* 29 */
            /***/
            function(module, exports, __webpack_require__) {

                /* global define */
                'use strict';

                exports.__esModule = true;

                var _utils = __webpack_require__(5);

                var SourceNode = undefined;

                try {
                    /* istanbul ignore next */
                    if (false) {
                        // We don't support this in AMD environments. For these environments, we asusme that
                        // they are running on the browser and thus have no need for the source-map library.
                        var SourceMap = require('source-map');
                        SourceNode = SourceMap.SourceNode;
                    }
                } catch (err) {}
                /* NOP */

                /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
                if (!SourceNode) {
                    SourceNode = function(line, column, srcFile, chunks) {
                        this.src = '';
                        if (chunks) {
                            this.add(chunks);
                        }
                    };
                    /* istanbul ignore next */
                    SourceNode.prototype = {
                        add: function add(chunks) {
                            if (_utils.isArray(chunks)) {
                                chunks = chunks.join('');
                            }
                            this.src += chunks;
                        },
                        prepend: function prepend(chunks) {
                            if (_utils.isArray(chunks)) {
                                chunks = chunks.join('');
                            }
                            this.src = chunks + this.src;
                        },
                        toStringWithSourceMap: function toStringWithSourceMap() {
                            return {
                                code: this.toString()
                            };
                        },
                        toString: function toString() {
                            return this.src;
                        }
                    };
                }

                function castChunk(chunk, codeGen, loc) {
                    if (_utils.isArray(chunk)) {
                        var ret = [];

                        for (var i = 0, len = chunk.length; i < len; i++) {
                            ret.push(codeGen.wrap(chunk[i], loc));
                        }
                        return ret;
                    } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
                        // Handle primitives that the SourceNode will throw up on
                        return chunk + '';
                    }
                    return chunk;
                }

                function CodeGen(srcFile) {
                    this.srcFile = srcFile;
                    this.source = [];
                }

                CodeGen.prototype = {
                    isEmpty: function isEmpty() {
                        return !this.source.length;
                    },
                    prepend: function prepend(source, loc) {
                        this.source.unshift(this.wrap(source, loc));
                    },
                    push: function push(source, loc) {
                        this.source.push(this.wrap(source, loc));
                    },

                    merge: function merge() {
                        var source = this.empty();
                        this.each(function(line) {
                            source.add(['  ', line, '\n']);
                        });
                        return source;
                    },

                    each: function each(iter) {
                        for (var i = 0, len = this.source.length; i < len; i++) {
                            iter(this.source[i]);
                        }
                    },

                    empty: function empty() {
                        var loc = this.currentLocation || {
                            start: {}
                        };
                        return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
                    },
                    wrap: function wrap(chunk) {
                        var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || {
                            start: {}
                        } : arguments[1];

                        if (chunk instanceof SourceNode) {
                            return chunk;
                        }

                        chunk = castChunk(chunk, this, loc);

                        return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
                    },

                    functionCall: function functionCall(fn, type, params) {
                        params = this.generateList(params);
                        return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
                    },

                    quotedString: function quotedString(str) {
                        return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
                            .replace(/\u2029/g, '\\u2029') + '"';
                    },

                    objectLiteral: function objectLiteral(obj) {
                        var pairs = [];

                        for (var key in obj) {
                            if (obj.hasOwnProperty(key)) {
                                var value = castChunk(obj[key], this);
                                if (value !== 'undefined') {
                                    pairs.push([this.quotedString(key), ':', value]);
                                }
                            }
                        }

                        var ret = this.generateList(pairs);
                        ret.prepend('{');
                        ret.add('}');
                        return ret;
                    },

                    generateList: function generateList(entries) {
                        var ret = this.empty();

                        for (var i = 0, len = entries.length; i < len; i++) {
                            if (i) {
                                ret.add(',');
                            }

                            ret.add(castChunk(entries[i], this));
                        }

                        return ret;
                    },

                    generateArray: function generateArray(entries) {
                        var ret = this.generateList(entries);
                        ret.prepend('[');
                        ret.add(']');

                        return ret;
                    }
                };

                exports['default'] = CodeGen;
                module.exports = exports['default'];

                /***/
            }
            /******/
        ])
});;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJoYW5kbGViYXJzL2hhbmRsZWJhcnMtdjQuMC41LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG5cclxuIGhhbmRsZWJhcnMgdjQuMC41XHJcblxyXG5Db3B5cmlnaHQgKEMpIDIwMTEtMjAxNSBieSBZZWh1ZGEgS2F0elxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG5USEUgU09GVFdBUkUuXHJcblxyXG5AbGljZW5zZVxyXG4qL1xyXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcclxuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcclxuXHRcdGV4cG9ydHNbXCJIYW5kbGViYXJzXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJIYW5kbGViYXJzXCJdID0gZmFjdG9yeSgpO1xyXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcclxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcclxuXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcblxyXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXHJcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcblxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXHJcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxyXG4vKioqKioqLyBcdFx0fTtcclxuXHJcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG5cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xyXG5cclxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0fVxyXG5cclxuXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xyXG5cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcblxyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuXHJcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc1J1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNSdW50aW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNSdW50aW1lKTtcclxuXHJcblx0Ly8gQ29tcGlsZXIgaW1wb3J0c1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNDb21waWxlckFzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNDb21waWxlckFzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzQ29tcGlsZXJBc3QpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNDb21waWxlckJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQ29tcGlsZXJDb21waWxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNDb21waWxlckphdmFzY3JpcHRDb21waWxlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNDb21waWxlckphdmFzY3JpcHRDb21waWxlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzQ29tcGlsZXJKYXZhc2NyaXB0Q29tcGlsZXIpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNDb21waWxlclZpc2l0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQ29tcGlsZXJWaXNpdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNDb21waWxlclZpc2l0b3IpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNOb0NvbmZsaWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc05vQ29uZmxpY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFuZGxlYmFyc05vQ29uZmxpY3QpO1xyXG5cclxuXHR2YXIgX2NyZWF0ZSA9IF9oYW5kbGViYXJzUnVudGltZTJbJ2RlZmF1bHQnXS5jcmVhdGU7XHJcblx0ZnVuY3Rpb24gY3JlYXRlKCkge1xyXG5cdCAgdmFyIGhiID0gX2NyZWF0ZSgpO1xyXG5cclxuXHQgIGhiLmNvbXBpbGUgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcclxuXHQgICAgcmV0dXJuIF9oYW5kbGViYXJzQ29tcGlsZXJDb21waWxlci5jb21waWxlKGlucHV0LCBvcHRpb25zLCBoYik7XHJcblx0ICB9O1xyXG5cdCAgaGIucHJlY29tcGlsZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xyXG5cdCAgICByZXR1cm4gX2hhbmRsZWJhcnNDb21waWxlckNvbXBpbGVyLnByZWNvbXBpbGUoaW5wdXQsIG9wdGlvbnMsIGhiKTtcclxuXHQgIH07XHJcblxyXG5cdCAgaGIuQVNUID0gX2hhbmRsZWJhcnNDb21waWxlckFzdDJbJ2RlZmF1bHQnXTtcclxuXHQgIGhiLkNvbXBpbGVyID0gX2hhbmRsZWJhcnNDb21waWxlckNvbXBpbGVyLkNvbXBpbGVyO1xyXG5cdCAgaGIuSmF2YVNjcmlwdENvbXBpbGVyID0gX2hhbmRsZWJhcnNDb21waWxlckphdmFzY3JpcHRDb21waWxlcjJbJ2RlZmF1bHQnXTtcclxuXHQgIGhiLlBhcnNlciA9IF9oYW5kbGViYXJzQ29tcGlsZXJCYXNlLnBhcnNlcjtcclxuXHQgIGhiLnBhcnNlID0gX2hhbmRsZWJhcnNDb21waWxlckJhc2UucGFyc2U7XHJcblxyXG5cdCAgcmV0dXJuIGhiO1xyXG5cdH1cclxuXHJcblx0dmFyIGluc3QgPSBjcmVhdGUoKTtcclxuXHRpbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcclxuXHJcblx0X2hhbmRsZWJhcnNOb0NvbmZsaWN0MlsnZGVmYXVsdCddKGluc3QpO1xyXG5cclxuXHRpbnN0LlZpc2l0b3IgPSBfaGFuZGxlYmFyc0NvbXBpbGVyVmlzaXRvcjJbJ2RlZmF1bHQnXTtcclxuXHJcblx0aW5zdFsnZGVmYXVsdCddID0gaW5zdDtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gaW5zdDtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmopIHtcclxuXHQgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XHJcblx0ICAgIFwiZGVmYXVsdFwiOiBvYmpcclxuXHQgIH07XHJcblx0fTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDIgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVsnZGVmYXVsdCddO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG5cdHZhciBiYXNlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2hhbmRsZWJhcnNCYXNlKTtcclxuXHJcblx0Ly8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxyXG5cdC8vIChUaGlzIGlzIGRvbmUgdG8gZWFzaWx5IHNoYXJlIGNvZGUgYmV0d2VlbiBjb21tb25qcyBhbmQgYnJvd3NlIGVudnMpXHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc1NhZmVTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzU2FmZVN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzU2FmZVN0cmluZyk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzRXhjZXB0aW9uKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHR2YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaGFuZGxlYmFyc1V0aWxzKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5cclxuXHR2YXIgcnVudGltZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9oYW5kbGViYXJzUnVudGltZSk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc05vQ29uZmxpY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzTm9Db25mbGljdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzTm9Db25mbGljdCk7XHJcblxyXG5cdC8vIEZvciBjb21wYXRpYmlsaXR5IGFuZCB1c2FnZSBvdXRzaWRlIG9mIG1vZHVsZSBzeXN0ZW1zLCBtYWtlIHRoZSBIYW5kbGViYXJzIG9iamVjdCBhIG5hbWVzcGFjZVxyXG5cdGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuXHQgIHZhciBoYiA9IG5ldyBiYXNlLkhhbmRsZWJhcnNFbnZpcm9ubWVudCgpO1xyXG5cclxuXHQgIFV0aWxzLmV4dGVuZChoYiwgYmFzZSk7XHJcblx0ICBoYi5TYWZlU3RyaW5nID0gX2hhbmRsZWJhcnNTYWZlU3RyaW5nMlsnZGVmYXVsdCddO1xyXG5cdCAgaGIuRXhjZXB0aW9uID0gX2hhbmRsZWJhcnNFeGNlcHRpb24yWydkZWZhdWx0J107XHJcblx0ICBoYi5VdGlscyA9IFV0aWxzO1xyXG5cdCAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XHJcblxyXG5cdCAgaGIuVk0gPSBydW50aW1lO1xyXG5cdCAgaGIudGVtcGxhdGUgPSBmdW5jdGlvbiAoc3BlYykge1xyXG5cdCAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XHJcblx0ICB9O1xyXG5cclxuXHQgIHJldHVybiBoYjtcclxuXHR9XHJcblxyXG5cdHZhciBpbnN0ID0gY3JlYXRlKCk7XHJcblx0aW5zdC5jcmVhdGUgPSBjcmVhdGU7XHJcblxyXG5cdF9oYW5kbGViYXJzTm9Db25mbGljdDJbJ2RlZmF1bHQnXShpbnN0KTtcclxuXHJcblx0aW5zdFsnZGVmYXVsdCddID0gaW5zdDtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gaW5zdDtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDMgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmopIHtcclxuXHQgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcclxuXHQgICAgcmV0dXJuIG9iajtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHZhciBuZXdPYmogPSB7fTtcclxuXHJcblx0ICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuXHQgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcclxuXHQgICAgcmV0dXJuIG5ld09iajtcclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLkhhbmRsZWJhcnNFbnZpcm9ubWVudCA9IEhhbmRsZWJhcnNFbnZpcm9ubWVudDtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuXHJcblx0dmFyIF9kZWNvcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblxyXG5cdHZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcblxyXG5cdHZhciBfbG9nZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xvZ2dlcik7XHJcblxyXG5cdHZhciBWRVJTSU9OID0gJzQuMC41JztcclxuXHRleHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xyXG5cdHZhciBDT01QSUxFUl9SRVZJU0lPTiA9IDc7XHJcblxyXG5cdGV4cG9ydHMuQ09NUElMRVJfUkVWSVNJT04gPSBDT01QSUxFUl9SRVZJU0lPTjtcclxuXHR2YXIgUkVWSVNJT05fQ0hBTkdFUyA9IHtcclxuXHQgIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XHJcblx0ICAyOiAnPT0gMS4wLjAtcmMuMycsXHJcblx0ICAzOiAnPT0gMS4wLjAtcmMuNCcsXHJcblx0ICA0OiAnPT0gMS54LngnLFxyXG5cdCAgNTogJz09IDIuMC4wLWFscGhhLngnLFxyXG5cdCAgNjogJz49IDIuMC4wLWJldGEuMScsXHJcblx0ICA3OiAnPj0gNC4wLjAnXHJcblx0fTtcclxuXHJcblx0ZXhwb3J0cy5SRVZJU0lPTl9DSEFOR0VTID0gUkVWSVNJT05fQ0hBTkdFUztcclxuXHR2YXIgb2JqZWN0VHlwZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5cclxuXHRmdW5jdGlvbiBIYW5kbGViYXJzRW52aXJvbm1lbnQoaGVscGVycywgcGFydGlhbHMsIGRlY29yYXRvcnMpIHtcclxuXHQgIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XHJcblx0ICB0aGlzLnBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XHJcblx0ICB0aGlzLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzIHx8IHt9O1xyXG5cclxuXHQgIF9oZWxwZXJzLnJlZ2lzdGVyRGVmYXVsdEhlbHBlcnModGhpcyk7XHJcblx0ICBfZGVjb3JhdG9ycy5yZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKHRoaXMpO1xyXG5cdH1cclxuXHJcblx0SGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcclxuXHQgIGNvbnN0cnVjdG9yOiBIYW5kbGViYXJzRW52aXJvbm1lbnQsXHJcblxyXG5cdCAgbG9nZ2VyOiBfbG9nZ2VyMlsnZGVmYXVsdCddLFxyXG5cdCAgbG9nOiBfbG9nZ2VyMlsnZGVmYXVsdCddLmxvZyxcclxuXHJcblx0ICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24gcmVnaXN0ZXJIZWxwZXIobmFtZSwgZm4pIHtcclxuXHQgICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XHJcblx0ICAgICAgaWYgKGZuKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIF91dGlscy5leHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXJIZWxwZXIobmFtZSkge1xyXG5cdCAgICBkZWxldGUgdGhpcy5oZWxwZXJzW25hbWVdO1xyXG5cdCAgfSxcclxuXHJcblx0ICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uIHJlZ2lzdGVyUGFydGlhbChuYW1lLCBwYXJ0aWFsKSB7XHJcblx0ICAgIGlmIChfdXRpbHMudG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xyXG5cdCAgICAgIF91dGlscy5leHRlbmQodGhpcy5wYXJ0aWFscywgbmFtZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0F0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBwYXJ0aWFsIGNhbGxlZCBcIicgKyBuYW1lICsgJ1wiIGFzIHVuZGVmaW5lZCcpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIHVucmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbiB1bnJlZ2lzdGVyUGFydGlhbChuYW1lKSB7XHJcblx0ICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xyXG5cdCAgfSxcclxuXHJcblx0ICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gcmVnaXN0ZXJEZWNvcmF0b3IobmFtZSwgZm4pIHtcclxuXHQgICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XHJcblx0ICAgICAgaWYgKGZuKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBkZWNvcmF0b3JzJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIF91dGlscy5leHRlbmQodGhpcy5kZWNvcmF0b3JzLCBuYW1lKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uIHVucmVnaXN0ZXJEZWNvcmF0b3IobmFtZSkge1xyXG5cdCAgICBkZWxldGUgdGhpcy5kZWNvcmF0b3JzW25hbWVdO1xyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdHZhciBsb2cgPSBfbG9nZ2VyMlsnZGVmYXVsdCddLmxvZztcclxuXHJcblx0ZXhwb3J0cy5sb2cgPSBsb2c7XHJcblx0ZXhwb3J0cy5jcmVhdGVGcmFtZSA9IF91dGlscy5jcmVhdGVGcmFtZTtcclxuXHRleHBvcnRzLmxvZ2dlciA9IF9sb2dnZXIyWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9LFxyXG4vKiA1ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0ZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XHJcblx0ZXhwb3J0cy5pbmRleE9mID0gaW5kZXhPZjtcclxuXHRleHBvcnRzLmVzY2FwZUV4cHJlc3Npb24gPSBlc2NhcGVFeHByZXNzaW9uO1xyXG5cdGV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XHJcblx0ZXhwb3J0cy5jcmVhdGVGcmFtZSA9IGNyZWF0ZUZyYW1lO1xyXG5cdGV4cG9ydHMuYmxvY2tQYXJhbXMgPSBibG9ja1BhcmFtcztcclxuXHRleHBvcnRzLmFwcGVuZENvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGg7XHJcblx0dmFyIGVzY2FwZSA9IHtcclxuXHQgICcmJzogJyZhbXA7JyxcclxuXHQgICc8JzogJyZsdDsnLFxyXG5cdCAgJz4nOiAnJmd0OycsXHJcblx0ICAnXCInOiAnJnF1b3Q7JyxcclxuXHQgIFwiJ1wiOiAnJiN4Mjc7JyxcclxuXHQgICdgJzogJyYjeDYwOycsXHJcblx0ICAnPSc6ICcmI3gzRDsnXHJcblx0fTtcclxuXHJcblx0dmFyIGJhZENoYXJzID0gL1smPD5cIidgPV0vZyxcclxuXHQgICAgcG9zc2libGUgPSAvWyY8PlwiJ2A9XS87XHJcblxyXG5cdGZ1bmN0aW9uIGVzY2FwZUNoYXIoY2hyKSB7XHJcblx0ICByZXR1cm4gZXNjYXBlW2Nocl07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBleHRlbmQob2JqIC8qICwgLi4uc291cmNlICovKSB7XHJcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzW2ldKSB7XHJcblx0ICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcclxuXHQgICAgICAgIG9ialtrZXldID0gYXJndW1lbnRzW2ldW2tleV07XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9XHJcblxyXG5cdCAgcmV0dXJuIG9iajtcclxuXHR9XHJcblxyXG5cdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcblxyXG5cdGV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcclxuXHQvLyBTb3VyY2VkIGZyb20gbG9kYXNoXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxyXG5cdC8qIGVzbGludC1kaXNhYmxlIGZ1bmMtc3R5bGUgKi9cclxuXHR2YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcclxuXHQgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XHJcblx0fTtcclxuXHQvLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcclxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdGlmIChpc0Z1bmN0aW9uKC94LykpIHtcclxuXHQgIGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcclxuXHQgIH07XHJcblx0fVxyXG5cdGV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XHJcblxyXG5cdC8qIGVzbGludC1lbmFibGUgZnVuYy1zdHlsZSAqL1xyXG5cclxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHQgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHRleHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xyXG5cdC8vIE9sZGVyIElFIHZlcnNpb25zIGRvIG5vdCBkaXJlY3RseSBzdXBwb3J0IGluZGV4T2Ygc28gd2UgbXVzdCBpbXBsZW1lbnQgb3VyIG93biwgc2FkbHkuXHJcblxyXG5cdGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XHJcblx0ICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xyXG5cdCAgICAgIHJldHVybiBpO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0ICByZXR1cm4gLTE7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBlc2NhcGVFeHByZXNzaW9uKHN0cmluZykge1xyXG5cdCAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XHJcblx0ICAgIC8vIGRvbid0IGVzY2FwZSBTYWZlU3RyaW5ncywgc2luY2UgdGhleSdyZSBhbHJlYWR5IHNhZmVcclxuXHQgICAgaWYgKHN0cmluZyAmJiBzdHJpbmcudG9IVE1MKSB7XHJcblx0ICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcclxuXHQgICAgfSBlbHNlIGlmIChzdHJpbmcgPT0gbnVsbCkge1xyXG5cdCAgICAgIHJldHVybiAnJztcclxuXHQgICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XHJcblx0ICAgICAgcmV0dXJuIHN0cmluZyArICcnO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcclxuXHQgICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXHJcblx0ICAgIC8vIGFuIG9iamVjdCdzIHRvIHN0cmluZyBoYXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGl0LlxyXG5cdCAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcclxuXHQgIH1cclxuXHJcblx0ICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkge1xyXG5cdCAgICByZXR1cm4gc3RyaW5nO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcclxuXHQgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJldHVybiBmYWxzZTtcclxuXHQgIH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZUZyYW1lKG9iamVjdCkge1xyXG5cdCAgdmFyIGZyYW1lID0gZXh0ZW5kKHt9LCBvYmplY3QpO1xyXG5cdCAgZnJhbWUuX3BhcmVudCA9IG9iamVjdDtcclxuXHQgIHJldHVybiBmcmFtZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJsb2NrUGFyYW1zKHBhcmFtcywgaWRzKSB7XHJcblx0ICBwYXJhbXMucGF0aCA9IGlkcztcclxuXHQgIHJldHVybiBwYXJhbXM7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcclxuXHQgIHJldHVybiAoY29udGV4dFBhdGggPyBjb250ZXh0UGF0aCArICcuJyA6ICcnKSArIGlkO1xyXG5cdH1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIGVycm9yUHJvcHMgPSBbJ2Rlc2NyaXB0aW9uJywgJ2ZpbGVOYW1lJywgJ2xpbmVOdW1iZXInLCAnbWVzc2FnZScsICduYW1lJywgJ251bWJlcicsICdzdGFjayddO1xyXG5cclxuXHRmdW5jdGlvbiBFeGNlcHRpb24obWVzc2FnZSwgbm9kZSkge1xyXG5cdCAgdmFyIGxvYyA9IG5vZGUgJiYgbm9kZS5sb2MsXHJcblx0ICAgICAgbGluZSA9IHVuZGVmaW5lZCxcclxuXHQgICAgICBjb2x1bW4gPSB1bmRlZmluZWQ7XHJcblx0ICBpZiAobG9jKSB7XHJcblx0ICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcclxuXHQgICAgY29sdW1uID0gbG9jLnN0YXJ0LmNvbHVtbjtcclxuXHJcblx0ICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgY29sdW1uO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcclxuXHJcblx0ICAvLyBVbmZvcnR1bmF0ZWx5IGVycm9ycyBhcmUgbm90IGVudW1lcmFibGUgaW4gQ2hyb21lIChhdCBsZWFzdCksIHNvIGBmb3IgcHJvcCBpbiB0bXBgIGRvZXNuJ3Qgd29yay5cclxuXHQgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xyXG5cdCAgICB0aGlzW2Vycm9yUHJvcHNbaWR4XV0gPSB0bXBbZXJyb3JQcm9wc1tpZHhdXTtcclxuXHQgIH1cclxuXHJcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcblx0ICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEV4Y2VwdGlvbik7XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKGxvYykge1xyXG5cdCAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lO1xyXG5cdCAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcclxuXHQgIH1cclxuXHR9XHJcblxyXG5cdEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gRXhjZXB0aW9uO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSxcclxuLyogNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMgPSByZWdpc3RlckRlZmF1bHRIZWxwZXJzO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc0Jsb2NrSGVscGVyTWlzc2luZyk7XHJcblxyXG5cdHZhciBfaGVscGVyc0VhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNFYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNFYWNoKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzSGVscGVyTWlzc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNIZWxwZXJNaXNzaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNIZWxwZXJNaXNzaW5nKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzSWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzSWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc0lmKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzTG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblxyXG5cdHZhciBfaGVscGVyc0xvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzTG9nKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzTG9va3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblxyXG5cdHZhciBfaGVscGVyc0xvb2t1cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzTG9va3VwKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzV2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNXaXRoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNXaXRoKTtcclxuXHJcblx0ZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0SGVscGVycyhpbnN0YW5jZSkge1xyXG5cdCAgX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xyXG5cdCAgX2hlbHBlcnNFYWNoMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzSGVscGVyTWlzc2luZzJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XHJcblx0ICBfaGVscGVyc0lmMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzTG9nMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzTG9va3VwMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzV2l0aDJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XHJcblx0fVxyXG5cclxuLyoqKi8gfSxcclxuLyogOCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignYmxvY2tIZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcclxuXHQgICAgdmFyIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXHJcblx0ICAgICAgICBmbiA9IG9wdGlvbnMuZm47XHJcblxyXG5cdCAgICBpZiAoY29udGV4dCA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgIHJldHVybiBmbih0aGlzKTtcclxuXHQgICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcclxuXHQgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcclxuXHQgICAgfSBlbHNlIGlmIChfdXRpbHMuaXNBcnJheShjb250ZXh0KSkge1xyXG5cdCAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgIGlmIChvcHRpb25zLmlkcykge1xyXG5cdCAgICAgICAgICBvcHRpb25zLmlkcyA9IFtvcHRpb25zLm5hbWVdO1xyXG5cdCAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XHJcblx0ICAgICAgICB2YXIgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xyXG5cdCAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IF91dGlscy5hcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMubmFtZSk7XHJcblx0ICAgICAgICBvcHRpb25zID0geyBkYXRhOiBkYXRhIH07XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSxcclxuLyogOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XHJcblx0ICAgIGlmICghb3B0aW9ucykge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdNdXN0IHBhc3MgaXRlcmF0b3IgdG8gI2VhY2gnKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGZuID0gb3B0aW9ucy5mbixcclxuXHQgICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXHJcblx0ICAgICAgICBpID0gMCxcclxuXHQgICAgICAgIHJldCA9ICcnLFxyXG5cdCAgICAgICAgZGF0YSA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGNvbnRleHRQYXRoID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xyXG5cdCAgICAgIGNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoX3V0aWxzLmlzRnVuY3Rpb24oY29udGV4dCkpIHtcclxuXHQgICAgICBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAob3B0aW9ucy5kYXRhKSB7XHJcblx0ICAgICAgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBmdW5jdGlvbiBleGVjSXRlcmF0aW9uKGZpZWxkLCBpbmRleCwgbGFzdCkge1xyXG5cdCAgICAgIGlmIChkYXRhKSB7XHJcblx0ICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xyXG5cdCAgICAgICAgZGF0YS5pbmRleCA9IGluZGV4O1xyXG5cdCAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xyXG5cdCAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xyXG5cclxuXHQgICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xyXG5cdCAgICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gY29udGV4dFBhdGggKyBmaWVsZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XHJcblx0ICAgICAgICBkYXRhOiBkYXRhLFxyXG5cdCAgICAgICAgYmxvY2tQYXJhbXM6IF91dGlscy5ibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoY29udGV4dCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgICBpZiAoX3V0aWxzLmlzQXJyYXkoY29udGV4dCkpIHtcclxuXHQgICAgICAgIGZvciAodmFyIGogPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdCAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XHJcblx0ICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihpLCBpLCBpID09PSBjb250ZXh0Lmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHZhciBwcmlvcktleSA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dCkge1xyXG5cdCAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0ICAgICAgICAgICAgLy8gV2UncmUgcnVubmluZyB0aGUgaXRlcmF0aW9ucyBvbmUgc3RlcCBvdXQgb2Ygc3luYyBzbyB3ZSBjYW4gZGV0ZWN0XHJcblx0ICAgICAgICAgICAgLy8gdGhlIGxhc3QgaXRlcmF0aW9uIHdpdGhvdXQgaGF2ZSB0byBzY2FuIHRoZSBvYmplY3QgdHdpY2UgYW5kIGNyZWF0ZVxyXG5cdCAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXHJcblx0ICAgICAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcHJpb3JLZXkgPSBrZXk7XHJcblx0ICAgICAgICAgICAgaSsrO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoaSA9PT0gMCkge1xyXG5cdCAgICAgIHJldCA9IGludmVyc2UodGhpcyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9KTtcclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDEwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbiAoKSAvKiBbYXJncywgXW9wdGlvbnMgKi97XHJcblx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XHJcblx0ICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXHJcblx0ICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnTWlzc2luZyBoZWxwZXI6IFwiJyArIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0ubmFtZSArICdcIicpO1xyXG5cdCAgICB9XHJcblx0ICB9KTtcclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDExICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uIChjb25kaXRpb25hbCwgb3B0aW9ucykge1xyXG5cdCAgICBpZiAoX3V0aWxzLmlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7XHJcblx0ICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5jYWxsKHRoaXMpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHJlbmRlciB0aGUgcG9zaXRpdmUgcGF0aCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IGFuZCBub3QgZW1wdHkuXHJcblx0ICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXHJcblx0ICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXHJcblx0ICAgIGlmICghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCB8fCBfdXRpbHMuaXNFbXB0eShjb25kaXRpb25hbCkpIHtcclxuXHQgICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xyXG5cdCAgICB9XHJcblx0ICB9KTtcclxuXHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24gKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XHJcblx0ICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzWydpZiddLmNhbGwodGhpcywgY29uZGl0aW9uYWwsIHsgZm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNoIH0pO1xyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb2cnLCBmdW5jdGlvbiAoKSAvKiBtZXNzYWdlLCBvcHRpb25zICove1xyXG5cdCAgICB2YXIgYXJncyA9IFt1bmRlZmluZWRdLFxyXG5cdCAgICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG5cdCAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgbGV2ZWwgPSAxO1xyXG5cdCAgICBpZiAob3B0aW9ucy5oYXNoLmxldmVsICE9IG51bGwpIHtcclxuXHQgICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcclxuXHQgICAgfSBlbHNlIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhLmxldmVsICE9IG51bGwpIHtcclxuXHQgICAgICBsZXZlbCA9IG9wdGlvbnMuZGF0YS5sZXZlbDtcclxuXHQgICAgfVxyXG5cdCAgICBhcmdzWzBdID0gbGV2ZWw7XHJcblxyXG5cdCAgICBpbnN0YW5jZS5sb2cuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxMyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb29rdXAnLCBmdW5jdGlvbiAob2JqLCBmaWVsZCkge1xyXG5cdCAgICByZXR1cm4gb2JqICYmIG9ialtmaWVsZF07XHJcblx0ICB9KTtcclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE0ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcclxuXHQgICAgaWYgKF91dGlscy5pc0Z1bmN0aW9uKGNvbnRleHQpKSB7XHJcblx0ICAgICAgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGZuID0gb3B0aW9ucy5mbjtcclxuXHJcblx0ICAgIGlmICghX3V0aWxzLmlzRW1wdHkoY29udGV4dCkpIHtcclxuXHQgICAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcclxuXHQgICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XHJcblx0ICAgICAgICBkYXRhID0gX3V0aWxzLmNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XHJcblx0ICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIHtcclxuXHQgICAgICAgIGRhdGE6IGRhdGEsXHJcblx0ICAgICAgICBibG9ja1BhcmFtczogX3V0aWxzLmJsb2NrUGFyYW1zKFtjb250ZXh0XSwgW2RhdGEgJiYgZGF0YS5jb250ZXh0UGF0aF0pXHJcblx0ICAgICAgfSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnMgPSByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzO1xyXG5cclxuXHR2YXIgX2RlY29yYXRvcnNJbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcblx0dmFyIF9kZWNvcmF0b3JzSW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlY29yYXRvcnNJbmxpbmUpO1xyXG5cclxuXHRmdW5jdGlvbiByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKGluc3RhbmNlKSB7XHJcblx0ICBfZGVjb3JhdG9yc0lubGluZTJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XHJcblx0fVxyXG5cclxuLyoqKi8gfSxcclxuLyogMTYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJEZWNvcmF0b3IoJ2lubGluZScsIGZ1bmN0aW9uIChmbiwgcHJvcHMsIGNvbnRhaW5lciwgb3B0aW9ucykge1xyXG5cdCAgICB2YXIgcmV0ID0gZm47XHJcblx0ICAgIGlmICghcHJvcHMucGFydGlhbHMpIHtcclxuXHQgICAgICBwcm9wcy5wYXJ0aWFscyA9IHt9O1xyXG5cdCAgICAgIHJldCA9IGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XHJcblx0ICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGFydGlhbHMgc3RhY2sgZnJhbWUgcHJpb3IgdG8gZXhlYy5cclxuXHQgICAgICAgIHZhciBvcmlnaW5hbCA9IGNvbnRhaW5lci5wYXJ0aWFscztcclxuXHQgICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IF91dGlscy5leHRlbmQoe30sIG9yaWdpbmFsLCBwcm9wcy5wYXJ0aWFscyk7XHJcblx0ICAgICAgICB2YXIgcmV0ID0gZm4oY29udGV4dCwgb3B0aW9ucyk7XHJcblx0ICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcmlnaW5hbDtcclxuXHQgICAgICAgIHJldHVybiByZXQ7XHJcblx0ICAgICAgfTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcHJvcHMucGFydGlhbHNbb3B0aW9ucy5hcmdzWzBdXSA9IG9wdGlvbnMuZm47XHJcblxyXG5cdCAgICByZXR1cm4gcmV0O1xyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxNyAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0dmFyIGxvZ2dlciA9IHtcclxuXHQgIG1ldGhvZE1hcDogWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSxcclxuXHQgIGxldmVsOiAnaW5mbycsXHJcblxyXG5cdCAgLy8gTWFwcyBhIGdpdmVuIGxldmVsIHZhbHVlIHRvIHRoZSBgbWV0aG9kTWFwYCBpbmRleGVzIGFib3ZlLlxyXG5cdCAgbG9va3VwTGV2ZWw6IGZ1bmN0aW9uIGxvb2t1cExldmVsKGxldmVsKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgdmFyIGxldmVsTWFwID0gX3V0aWxzLmluZGV4T2YobG9nZ2VyLm1ldGhvZE1hcCwgbGV2ZWwudG9Mb3dlckNhc2UoKSk7XHJcblx0ICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcclxuXHQgICAgICAgIGxldmVsID0gbGV2ZWxNYXA7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiBsZXZlbDtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGhvc3QgZW52aXJvbm1lbnRcclxuXHQgIGxvZzogZnVuY3Rpb24gbG9nKGxldmVsKSB7XHJcblx0ICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcclxuXHJcblx0ICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWwpIHtcclxuXHQgICAgICB2YXIgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XHJcblx0ICAgICAgaWYgKCFjb25zb2xlW21ldGhvZF0pIHtcclxuXHQgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG5cdCAgICAgICAgbWV0aG9kID0gJ2xvZyc7XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZSA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuXHQgICAgICAgIG1lc3NhZ2VbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgY29uc29sZVttZXRob2RdLmFwcGx5KGNvbnNvbGUsIG1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGxvZ2dlcjtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDE4ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyBCdWlsZCBvdXQgb3VyIGJhc2ljIFNhZmVTdHJpbmcgdHlwZVxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRmdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xyXG5cdCAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XHJcblx0fVxyXG5cclxuXHRTYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IFNhZmVTdHJpbmcucHJvdG90eXBlLnRvSFRNTCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xyXG5cdH07XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNhZmVTdHJpbmc7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9LFxyXG4vKiAxOSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpWydkZWZhdWx0J107XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGV4cG9ydHMuY2hlY2tSZXZpc2lvbiA9IGNoZWNrUmV2aXNpb247XHJcblx0ZXhwb3J0cy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xyXG5cdGV4cG9ydHMud3JhcFByb2dyYW0gPSB3cmFwUHJvZ3JhbTtcclxuXHRleHBvcnRzLnJlc29sdmVQYXJ0aWFsID0gcmVzb2x2ZVBhcnRpYWw7XHJcblx0ZXhwb3J0cy5pbnZva2VQYXJ0aWFsID0gaW52b2tlUGFydGlhbDtcclxuXHRleHBvcnRzLm5vb3AgPSBub29wO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0dmFyIFV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xyXG5cclxuXHR2YXIgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxuXHRmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xyXG5cdCAgdmFyIGNvbXBpbGVyUmV2aXNpb24gPSBjb21waWxlckluZm8gJiYgY29tcGlsZXJJbmZvWzBdIHx8IDEsXHJcblx0ICAgICAgY3VycmVudFJldmlzaW9uID0gX2Jhc2UuQ09NUElMRVJfUkVWSVNJT047XHJcblxyXG5cdCAgaWYgKGNvbXBpbGVyUmV2aXNpb24gIT09IGN1cnJlbnRSZXZpc2lvbikge1xyXG5cdCAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xyXG5cdCAgICAgIHZhciBydW50aW1lVmVyc2lvbnMgPSBfYmFzZS5SRVZJU0lPTl9DSEFOR0VTW2N1cnJlbnRSZXZpc2lvbl0sXHJcblx0ICAgICAgICAgIGNvbXBpbGVyVmVyc2lvbnMgPSBfYmFzZS5SRVZJU0lPTl9DSEFOR0VTW2NvbXBpbGVyUmV2aXNpb25dO1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICsgJ1BsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBydW50aW1lVmVyc2lvbnMgKyAnKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKCcgKyBjb21waWxlclZlcnNpb25zICsgJykuJyk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArICdQbGVhc2UgdXBkYXRlIHlvdXIgcnVudGltZSB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBjb21waWxlckluZm9bMV0gKyAnKS4nKTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICBpZiAoIWVudikge1xyXG5cdCAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnTm8gZW52aXJvbm1lbnQgcGFzc2VkIHRvIHRlbXBsYXRlJyk7XHJcblx0ICB9XHJcblx0ICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcclxuXHQgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XHJcblx0ICB9XHJcblxyXG5cdCAgdGVtcGxhdGVTcGVjLm1haW4uZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjLm1haW5fZDtcclxuXHJcblx0ICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xyXG5cdCAgLy8gZm9yIGV4dGVybmFsIHVzZXJzIHRvIG92ZXJyaWRlIHRoZXNlIGFzIHBzdWVkby1zdXBwb3J0ZWQgQVBJcy5cclxuXHQgIGVudi5WTS5jaGVja1JldmlzaW9uKHRlbXBsYXRlU3BlYy5jb21waWxlcik7XHJcblxyXG5cdCAgZnVuY3Rpb24gaW52b2tlUGFydGlhbFdyYXBwZXIocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xyXG5cdCAgICBpZiAob3B0aW9ucy5oYXNoKSB7XHJcblx0ICAgICAgY29udGV4dCA9IFV0aWxzLmV4dGVuZCh7fSwgY29udGV4dCwgb3B0aW9ucy5oYXNoKTtcclxuXHQgICAgICBpZiAob3B0aW9ucy5pZHMpIHtcclxuXHQgICAgICAgIG9wdGlvbnMuaWRzWzBdID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgICAgdmFyIHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XHJcblxyXG5cdCAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcclxuXHQgICAgICBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0gPSBlbnYuY29tcGlsZShwYXJ0aWFsLCB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJPcHRpb25zLCBlbnYpO1xyXG5cdCAgICAgIHJlc3VsdCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXShjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcclxuXHQgICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcclxuXHQgICAgICAgIHZhciBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgIGxpbmVzW2ldID0gb3B0aW9ucy5pbmRlbnQgKyBsaW5lc1tpXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgY29tcGlsZWQgd2hlbiBydW5uaW5nIGluIHJ1bnRpbWUtb25seSBtb2RlJyk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICAvLyBKdXN0IGFkZCB3YXRlclxyXG5cdCAgdmFyIGNvbnRhaW5lciA9IHtcclxuXHQgICAgc3RyaWN0OiBmdW5jdGlvbiBzdHJpY3Qob2JqLCBuYW1lKSB7XHJcblx0ICAgICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnXCInICsgbmFtZSArICdcIiBub3QgZGVmaW5lZCBpbiAnICsgb2JqKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgcmV0dXJuIG9ialtuYW1lXTtcclxuXHQgICAgfSxcclxuXHQgICAgbG9va3VwOiBmdW5jdGlvbiBsb29rdXAoZGVwdGhzLCBuYW1lKSB7XHJcblx0ICAgICAgdmFyIGxlbiA9IGRlcHRocy5sZW5ndGg7XHJcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgICAgaWYgKGRlcHRoc1tpXSAmJiBkZXB0aHNbaV1bbmFtZV0gIT0gbnVsbCkge1xyXG5cdCAgICAgICAgICByZXR1cm4gZGVwdGhzW2ldW25hbWVdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSxcclxuXHQgICAgbGFtYmRhOiBmdW5jdGlvbiBsYW1iZGEoY3VycmVudCwgY29udGV4dCkge1xyXG5cdCAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxyXG5cdCAgICBpbnZva2VQYXJ0aWFsOiBpbnZva2VQYXJ0aWFsV3JhcHBlcixcclxuXHJcblx0ICAgIGZuOiBmdW5jdGlvbiBmbihpKSB7XHJcblx0ICAgICAgdmFyIHJldCA9IHRlbXBsYXRlU3BlY1tpXTtcclxuXHQgICAgICByZXQuZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjW2kgKyAnX2QnXTtcclxuXHQgICAgICByZXR1cm4gcmV0O1xyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgcHJvZ3JhbXM6IFtdLFxyXG5cdCAgICBwcm9ncmFtOiBmdW5jdGlvbiBwcm9ncmFtKGksIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcclxuXHQgICAgICB2YXIgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldLFxyXG5cdCAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XHJcblx0ICAgICAgaWYgKGRhdGEgfHwgZGVwdGhzIHx8IGJsb2NrUGFyYW1zIHx8IGRlY2xhcmVkQmxvY2tQYXJhbXMpIHtcclxuXHQgICAgICAgIHByb2dyYW1XcmFwcGVyID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAoIXByb2dyYW1XcmFwcGVyKSB7XHJcblx0ICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbik7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEodmFsdWUsIGRlcHRoKSB7XHJcblx0ICAgICAgd2hpbGUgKHZhbHVlICYmIGRlcHRoLS0pIHtcclxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcclxuXHQgICAgICB9XHJcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICB9LFxyXG5cdCAgICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UocGFyYW0sIGNvbW1vbikge1xyXG5cdCAgICAgIHZhciBvYmogPSBwYXJhbSB8fCBjb21tb247XHJcblxyXG5cdCAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgcGFyYW0gIT09IGNvbW1vbikge1xyXG5cdCAgICAgICAgb2JqID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtKTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHJldHVybiBvYmo7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICBub29wOiBlbnYuVk0ubm9vcCxcclxuXHQgICAgY29tcGlsZXJJbmZvOiB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJcclxuXHQgIH07XHJcblxyXG5cdCAgZnVuY3Rpb24gcmV0KGNvbnRleHQpIHtcclxuXHQgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcclxuXHJcblx0ICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xyXG5cclxuXHQgICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcclxuXHQgICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcclxuXHQgICAgICBkYXRhID0gaW5pdERhdGEoY29udGV4dCwgZGF0YSk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIGRlcHRocyA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGJsb2NrUGFyYW1zID0gdGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zID8gW10gOiB1bmRlZmluZWQ7XHJcblx0ICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XHJcblx0ICAgICAgICBkZXB0aHMgPSBjb250ZXh0ICE9PSBvcHRpb25zLmRlcHRoc1swXSA/IFtjb250ZXh0XS5jb25jYXQob3B0aW9ucy5kZXB0aHMpIDogb3B0aW9ucy5kZXB0aHM7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIGRlcHRocyA9IFtjb250ZXh0XTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZ1bmN0aW9uIG1haW4oY29udGV4dCAvKiwgb3B0aW9ucyovKSB7XHJcblx0ICAgICAgcmV0dXJuICcnICsgdGVtcGxhdGVTcGVjLm1haW4oY29udGFpbmVyLCBjb250ZXh0LCBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcclxuXHQgICAgfVxyXG5cdCAgICBtYWluID0gZXhlY3V0ZURlY29yYXRvcnModGVtcGxhdGVTcGVjLm1haW4sIG1haW4sIGNvbnRhaW5lciwgb3B0aW9ucy5kZXB0aHMgfHwgW10sIGRhdGEsIGJsb2NrUGFyYW1zKTtcclxuXHQgICAgcmV0dXJuIG1haW4oY29udGV4dCwgb3B0aW9ucyk7XHJcblx0ICB9XHJcblx0ICByZXQuaXNUb3AgPSB0cnVlO1xyXG5cclxuXHQgIHJldC5fc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdCAgICBpZiAoIW9wdGlvbnMucGFydGlhbCkge1xyXG5cdCAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuaGVscGVycywgZW52LmhlbHBlcnMpO1xyXG5cclxuXHQgICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwpIHtcclxuXHQgICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLnBhcnRpYWxzLCBlbnYucGFydGlhbHMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZVBhcnRpYWwgfHwgdGVtcGxhdGVTcGVjLnVzZURlY29yYXRvcnMpIHtcclxuXHQgICAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuZGVjb3JhdG9ycywgZW52LmRlY29yYXRvcnMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBjb250YWluZXIuaGVscGVycyA9IG9wdGlvbnMuaGVscGVycztcclxuXHQgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xyXG5cdCAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gb3B0aW9ucy5kZWNvcmF0b3JzO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cclxuXHQgIHJldC5fY2hpbGQgPSBmdW5jdGlvbiAoaSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocykge1xyXG5cdCAgICBpZiAodGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zICYmICFibG9ja1BhcmFtcykge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdtdXN0IHBhc3MgYmxvY2sgcGFyYW1zJyk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdtdXN0IHBhc3MgcGFyZW50IGRlcHRocycpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCB0ZW1wbGF0ZVNwZWNbaV0sIGRhdGEsIDAsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xyXG5cdCAgfTtcclxuXHQgIHJldHVybiByZXQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB3cmFwUHJvZ3JhbShjb250YWluZXIsIGksIGZuLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XHJcblx0ICBmdW5jdGlvbiBwcm9nKGNvbnRleHQpIHtcclxuXHQgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcclxuXHJcblx0ICAgIHZhciBjdXJyZW50RGVwdGhzID0gZGVwdGhzO1xyXG5cdCAgICBpZiAoZGVwdGhzICYmIGNvbnRleHQgIT09IGRlcHRoc1swXSkge1xyXG5cdCAgICAgIGN1cnJlbnREZXB0aHMgPSBbY29udGV4dF0uY29uY2F0KGRlcHRocyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiBmbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIG9wdGlvbnMuZGF0YSB8fCBkYXRhLCBibG9ja1BhcmFtcyAmJiBbb3B0aW9ucy5ibG9ja1BhcmFtc10uY29uY2F0KGJsb2NrUGFyYW1zKSwgY3VycmVudERlcHRocyk7XHJcblx0ICB9XHJcblxyXG5cdCAgcHJvZyA9IGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpO1xyXG5cclxuXHQgIHByb2cucHJvZ3JhbSA9IGk7XHJcblx0ICBwcm9nLmRlcHRoID0gZGVwdGhzID8gZGVwdGhzLmxlbmd0aCA6IDA7XHJcblx0ICBwcm9nLmJsb2NrUGFyYW1zID0gZGVjbGFyZWRCbG9ja1BhcmFtcyB8fCAwO1xyXG5cdCAgcmV0dXJuIHByb2c7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XHJcblx0ICBpZiAoIXBhcnRpYWwpIHtcclxuXHQgICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gJ0BwYXJ0aWFsLWJsb2NrJykge1xyXG5cdCAgICAgIHBhcnRpYWwgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xyXG5cdCAgICB9XHJcblx0ICB9IGVsc2UgaWYgKCFwYXJ0aWFsLmNhbGwgJiYgIW9wdGlvbnMubmFtZSkge1xyXG5cdCAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwYXJ0aWFsIHRoYXQgcmV0dXJuZWQgYSBzdHJpbmdcclxuXHQgICAgb3B0aW9ucy5uYW1lID0gcGFydGlhbDtcclxuXHQgICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbcGFydGlhbF07XHJcblx0ICB9XHJcblx0ICByZXR1cm4gcGFydGlhbDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xyXG5cdCAgb3B0aW9ucy5wYXJ0aWFsID0gdHJ1ZTtcclxuXHQgIGlmIChvcHRpb25zLmlkcykge1xyXG5cdCAgICBvcHRpb25zLmRhdGEuY29udGV4dFBhdGggPSBvcHRpb25zLmlkc1swXSB8fCBvcHRpb25zLmRhdGEuY29udGV4dFBhdGg7XHJcblx0ICB9XHJcblxyXG5cdCAgdmFyIHBhcnRpYWxCbG9jayA9IHVuZGVmaW5lZDtcclxuXHQgIGlmIChvcHRpb25zLmZuICYmIG9wdGlvbnMuZm4gIT09IG5vb3ApIHtcclxuXHQgICAgb3B0aW9ucy5kYXRhID0gX2Jhc2UuY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcclxuXHQgICAgcGFydGlhbEJsb2NrID0gb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBvcHRpb25zLmZuO1xyXG5cclxuXHQgICAgaWYgKHBhcnRpYWxCbG9jay5wYXJ0aWFscykge1xyXG5cdCAgICAgIG9wdGlvbnMucGFydGlhbHMgPSBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMucGFydGlhbHMsIHBhcnRpYWxCbG9jay5wYXJ0aWFscyk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICBpZiAocGFydGlhbCA9PT0gdW5kZWZpbmVkICYmIHBhcnRpYWxCbG9jaykge1xyXG5cdCAgICBwYXJ0aWFsID0gcGFydGlhbEJsb2NrO1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xyXG5cdCAgfSBlbHNlIGlmIChwYXJ0aWFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuXHQgICAgcmV0dXJuIHBhcnRpYWwoY29udGV4dCwgb3B0aW9ucyk7XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBub29wKCkge1xyXG5cdCAgcmV0dXJuICcnO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW5pdERhdGEoY29udGV4dCwgZGF0YSkge1xyXG5cdCAgaWYgKCFkYXRhIHx8ICEoJ3Jvb3QnIGluIGRhdGEpKSB7XHJcblx0ICAgIGRhdGEgPSBkYXRhID8gX2Jhc2UuY3JlYXRlRnJhbWUoZGF0YSkgOiB7fTtcclxuXHQgICAgZGF0YS5yb290ID0gY29udGV4dDtcclxuXHQgIH1cclxuXHQgIHJldHVybiBkYXRhO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcykge1xyXG5cdCAgaWYgKGZuLmRlY29yYXRvcikge1xyXG5cdCAgICB2YXIgcHJvcHMgPSB7fTtcclxuXHQgICAgcHJvZyA9IGZuLmRlY29yYXRvcihwcm9nLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aHMgJiYgZGVwdGhzWzBdLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcclxuXHQgICAgVXRpbHMuZXh0ZW5kKHByb2csIHByb3BzKTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBwcm9nO1xyXG5cdH1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIwICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogZ2xvYmFsIHdpbmRvdyAqL1xyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKEhhbmRsZWJhcnMpIHtcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxyXG5cdCAgICAgICRIYW5kbGViYXJzID0gcm9vdC5IYW5kbGViYXJzO1xyXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgIEhhbmRsZWJhcnMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgaWYgKHJvb3QuSGFuZGxlYmFycyA9PT0gSGFuZGxlYmFycykge1xyXG5cdCAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBIYW5kbGViYXJzO1xyXG5cdCAgfTtcclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdHZhciBBU1QgPSB7XHJcblx0ICAvLyBQdWJsaWMgQVBJIHVzZWQgdG8gZXZhbHVhdGUgZGVyaXZlZCBhdHRyaWJ1dGVzIHJlZ2FyZGluZyBBU1Qgbm9kZXNcclxuXHQgIGhlbHBlcnM6IHtcclxuXHQgICAgLy8gYSBtdXN0YWNoZSBpcyBkZWZpbml0ZWx5IGEgaGVscGVyIGlmOlxyXG5cdCAgICAvLyAqIGl0IGlzIGFuIGVsaWdpYmxlIGhlbHBlciwgYW5kXHJcblx0ICAgIC8vICogaXQgaGFzIGF0IGxlYXN0IG9uZSBwYXJhbWV0ZXIgb3IgaGFzaCBzZWdtZW50XHJcblx0ICAgIGhlbHBlckV4cHJlc3Npb246IGZ1bmN0aW9uIGhlbHBlckV4cHJlc3Npb24obm9kZSkge1xyXG5cdCAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdTdWJFeHByZXNzaW9uJyB8fCAobm9kZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnIHx8IG5vZGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JykgJiYgISEobm9kZS5wYXJhbXMgJiYgbm9kZS5wYXJhbXMubGVuZ3RoIHx8IG5vZGUuaGFzaCk7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICBzY29wZWRJZDogZnVuY3Rpb24gc2NvcGVkSWQocGF0aCkge1xyXG5cdCAgICAgIHJldHVybiAoL15cXC58dGhpc1xcYi8udGVzdChwYXRoLm9yaWdpbmFsKVxyXG5cdCAgICAgICk7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICAvLyBhbiBJRCBpcyBzaW1wbGUgaWYgaXQgb25seSBoYXMgb25lIHBhcnQsIGFuZCB0aGF0IHBhcnQgaXMgbm90XHJcblx0ICAgIC8vIGAuLmAgb3IgYHRoaXNgLlxyXG5cdCAgICBzaW1wbGVJZDogZnVuY3Rpb24gc2ltcGxlSWQocGF0aCkge1xyXG5cdCAgICAgIHJldHVybiBwYXRoLnBhcnRzLmxlbmd0aCA9PT0gMSAmJiAhQVNULmhlbHBlcnMuc2NvcGVkSWQocGF0aCkgJiYgIXBhdGguZGVwdGg7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHQvLyBNdXN0IGJlIGV4cG9ydGVkIGFzIGFuIG9iamVjdCByYXRoZXIgdGhhbiB0aGUgcm9vdCBvZiB0aGUgbW9kdWxlIGFzIHRoZSBqaXNvbiBsZXhlclxyXG5cdC8vIG11c3QgbW9kaWZ5IHRoZSBvYmplY3QgdG8gb3BlcmF0ZSBwcm9wZXJseS5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBBU1Q7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyMiAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGV4cG9ydHMucGFyc2UgPSBwYXJzZTtcclxuXHJcblx0dmFyIF9wYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuXHJcblx0dmFyIF9wYXJzZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyc2VyKTtcclxuXHJcblx0dmFyIF93aGl0ZXNwYWNlQ29udHJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5cclxuXHR2YXIgX3doaXRlc3BhY2VDb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3doaXRlc3BhY2VDb250cm9sKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcblxyXG5cdHZhciBIZWxwZXJzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2hlbHBlcnMpO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0ZXhwb3J0cy5wYXJzZXIgPSBfcGFyc2VyMlsnZGVmYXVsdCddO1xyXG5cclxuXHR2YXIgeXkgPSB7fTtcclxuXHRfdXRpbHMuZXh0ZW5kKHl5LCBIZWxwZXJzKTtcclxuXHJcblx0ZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcclxuXHQgIC8vIEp1c3QgcmV0dXJuIGlmIGFuIGFscmVhZHktY29tcGlsZWQgQVNUIHdhcyBwYXNzZWQgaW4uXHJcblx0ICBpZiAoaW5wdXQudHlwZSA9PT0gJ1Byb2dyYW0nKSB7XHJcblx0ICAgIHJldHVybiBpbnB1dDtcclxuXHQgIH1cclxuXHJcblx0ICBfcGFyc2VyMlsnZGVmYXVsdCddLnl5ID0geXk7XHJcblxyXG5cdCAgLy8gQWx0ZXJpbmcgdGhlIHNoYXJlZCBvYmplY3QgaGVyZSwgYnV0IHRoaXMgaXMgb2sgYXMgcGFyc2VyIGlzIGEgc3luYyBvcGVyYXRpb25cclxuXHQgIHl5LmxvY0luZm8gPSBmdW5jdGlvbiAobG9jSW5mbykge1xyXG5cdCAgICByZXR1cm4gbmV3IHl5LlNvdXJjZUxvY2F0aW9uKG9wdGlvbnMgJiYgb3B0aW9ucy5zcmNOYW1lLCBsb2NJbmZvKTtcclxuXHQgIH07XHJcblxyXG5cdCAgdmFyIHN0cmlwID0gbmV3IF93aGl0ZXNwYWNlQ29udHJvbDJbJ2RlZmF1bHQnXShvcHRpb25zKTtcclxuXHQgIHJldHVybiBzdHJpcC5hY2NlcHQoX3BhcnNlcjJbJ2RlZmF1bHQnXS5wYXJzZShpbnB1dCkpO1xyXG5cdH1cclxuXHJcbi8qKiovIH0sXHJcbi8qIDIzICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdC8qIEppc29uIGdlbmVyYXRlZCBwYXJzZXIgKi9cclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0dmFyIGhhbmRsZWJhcnMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICB2YXIgcGFyc2VyID0geyB0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7fSxcclxuXHQgICAgICAgIHl5OiB7fSxcclxuXHQgICAgICAgIHN5bWJvbHNfOiB7IFwiZXJyb3JcIjogMiwgXCJyb290XCI6IDMsIFwicHJvZ3JhbVwiOiA0LCBcIkVPRlwiOiA1LCBcInByb2dyYW1fcmVwZXRpdGlvbjBcIjogNiwgXCJzdGF0ZW1lbnRcIjogNywgXCJtdXN0YWNoZVwiOiA4LCBcImJsb2NrXCI6IDksIFwicmF3QmxvY2tcIjogMTAsIFwicGFydGlhbFwiOiAxMSwgXCJwYXJ0aWFsQmxvY2tcIjogMTIsIFwiY29udGVudFwiOiAxMywgXCJDT01NRU5UXCI6IDE0LCBcIkNPTlRFTlRcIjogMTUsIFwib3BlblJhd0Jsb2NrXCI6IDE2LCBcInJhd0Jsb2NrX3JlcGV0aXRpb25fcGx1czBcIjogMTcsIFwiRU5EX1JBV19CTE9DS1wiOiAxOCwgXCJPUEVOX1JBV19CTE9DS1wiOiAxOSwgXCJoZWxwZXJOYW1lXCI6IDIwLCBcIm9wZW5SYXdCbG9ja19yZXBldGl0aW9uMFwiOiAyMSwgXCJvcGVuUmF3QmxvY2tfb3B0aW9uMFwiOiAyMiwgXCJDTE9TRV9SQVdfQkxPQ0tcIjogMjMsIFwib3BlbkJsb2NrXCI6IDI0LCBcImJsb2NrX29wdGlvbjBcIjogMjUsIFwiY2xvc2VCbG9ja1wiOiAyNiwgXCJvcGVuSW52ZXJzZVwiOiAyNywgXCJibG9ja19vcHRpb24xXCI6IDI4LCBcIk9QRU5fQkxPQ0tcIjogMjksIFwib3BlbkJsb2NrX3JlcGV0aXRpb24wXCI6IDMwLCBcIm9wZW5CbG9ja19vcHRpb24wXCI6IDMxLCBcIm9wZW5CbG9ja19vcHRpb24xXCI6IDMyLCBcIkNMT1NFXCI6IDMzLCBcIk9QRU5fSU5WRVJTRVwiOiAzNCwgXCJvcGVuSW52ZXJzZV9yZXBldGl0aW9uMFwiOiAzNSwgXCJvcGVuSW52ZXJzZV9vcHRpb24wXCI6IDM2LCBcIm9wZW5JbnZlcnNlX29wdGlvbjFcIjogMzcsIFwib3BlbkludmVyc2VDaGFpblwiOiAzOCwgXCJPUEVOX0lOVkVSU0VfQ0hBSU5cIjogMzksIFwib3BlbkludmVyc2VDaGFpbl9yZXBldGl0aW9uMFwiOiA0MCwgXCJvcGVuSW52ZXJzZUNoYWluX29wdGlvbjBcIjogNDEsIFwib3BlbkludmVyc2VDaGFpbl9vcHRpb24xXCI6IDQyLCBcImludmVyc2VBbmRQcm9ncmFtXCI6IDQzLCBcIklOVkVSU0VcIjogNDQsIFwiaW52ZXJzZUNoYWluXCI6IDQ1LCBcImludmVyc2VDaGFpbl9vcHRpb24wXCI6IDQ2LCBcIk9QRU5fRU5EQkxPQ0tcIjogNDcsIFwiT1BFTlwiOiA0OCwgXCJtdXN0YWNoZV9yZXBldGl0aW9uMFwiOiA0OSwgXCJtdXN0YWNoZV9vcHRpb24wXCI6IDUwLCBcIk9QRU5fVU5FU0NBUEVEXCI6IDUxLCBcIm11c3RhY2hlX3JlcGV0aXRpb24xXCI6IDUyLCBcIm11c3RhY2hlX29wdGlvbjFcIjogNTMsIFwiQ0xPU0VfVU5FU0NBUEVEXCI6IDU0LCBcIk9QRU5fUEFSVElBTFwiOiA1NSwgXCJwYXJ0aWFsTmFtZVwiOiA1NiwgXCJwYXJ0aWFsX3JlcGV0aXRpb24wXCI6IDU3LCBcInBhcnRpYWxfb3B0aW9uMFwiOiA1OCwgXCJvcGVuUGFydGlhbEJsb2NrXCI6IDU5LCBcIk9QRU5fUEFSVElBTF9CTE9DS1wiOiA2MCwgXCJvcGVuUGFydGlhbEJsb2NrX3JlcGV0aXRpb24wXCI6IDYxLCBcIm9wZW5QYXJ0aWFsQmxvY2tfb3B0aW9uMFwiOiA2MiwgXCJwYXJhbVwiOiA2MywgXCJzZXhwclwiOiA2NCwgXCJPUEVOX1NFWFBSXCI6IDY1LCBcInNleHByX3JlcGV0aXRpb24wXCI6IDY2LCBcInNleHByX29wdGlvbjBcIjogNjcsIFwiQ0xPU0VfU0VYUFJcIjogNjgsIFwiaGFzaFwiOiA2OSwgXCJoYXNoX3JlcGV0aXRpb25fcGx1czBcIjogNzAsIFwiaGFzaFNlZ21lbnRcIjogNzEsIFwiSURcIjogNzIsIFwiRVFVQUxTXCI6IDczLCBcImJsb2NrUGFyYW1zXCI6IDc0LCBcIk9QRU5fQkxPQ0tfUEFSQU1TXCI6IDc1LCBcImJsb2NrUGFyYW1zX3JlcGV0aXRpb25fcGx1czBcIjogNzYsIFwiQ0xPU0VfQkxPQ0tfUEFSQU1TXCI6IDc3LCBcInBhdGhcIjogNzgsIFwiZGF0YU5hbWVcIjogNzksIFwiU1RSSU5HXCI6IDgwLCBcIk5VTUJFUlwiOiA4MSwgXCJCT09MRUFOXCI6IDgyLCBcIlVOREVGSU5FRFwiOiA4MywgXCJOVUxMXCI6IDg0LCBcIkRBVEFcIjogODUsIFwicGF0aFNlZ21lbnRzXCI6IDg2LCBcIlNFUFwiOiA4NywgXCIkYWNjZXB0XCI6IDAsIFwiJGVuZFwiOiAxIH0sXHJcblx0ICAgICAgICB0ZXJtaW5hbHNfOiB7IDI6IFwiZXJyb3JcIiwgNTogXCJFT0ZcIiwgMTQ6IFwiQ09NTUVOVFwiLCAxNTogXCJDT05URU5UXCIsIDE4OiBcIkVORF9SQVdfQkxPQ0tcIiwgMTk6IFwiT1BFTl9SQVdfQkxPQ0tcIiwgMjM6IFwiQ0xPU0VfUkFXX0JMT0NLXCIsIDI5OiBcIk9QRU5fQkxPQ0tcIiwgMzM6IFwiQ0xPU0VcIiwgMzQ6IFwiT1BFTl9JTlZFUlNFXCIsIDM5OiBcIk9QRU5fSU5WRVJTRV9DSEFJTlwiLCA0NDogXCJJTlZFUlNFXCIsIDQ3OiBcIk9QRU5fRU5EQkxPQ0tcIiwgNDg6IFwiT1BFTlwiLCA1MTogXCJPUEVOX1VORVNDQVBFRFwiLCA1NDogXCJDTE9TRV9VTkVTQ0FQRURcIiwgNTU6IFwiT1BFTl9QQVJUSUFMXCIsIDYwOiBcIk9QRU5fUEFSVElBTF9CTE9DS1wiLCA2NTogXCJPUEVOX1NFWFBSXCIsIDY4OiBcIkNMT1NFX1NFWFBSXCIsIDcyOiBcIklEXCIsIDczOiBcIkVRVUFMU1wiLCA3NTogXCJPUEVOX0JMT0NLX1BBUkFNU1wiLCA3NzogXCJDTE9TRV9CTE9DS19QQVJBTVNcIiwgODA6IFwiU1RSSU5HXCIsIDgxOiBcIk5VTUJFUlwiLCA4MjogXCJCT09MRUFOXCIsIDgzOiBcIlVOREVGSU5FRFwiLCA4NDogXCJOVUxMXCIsIDg1OiBcIkRBVEFcIiwgODc6IFwiU0VQXCIgfSxcclxuXHQgICAgICAgIHByb2R1Y3Rpb25zXzogWzAsIFszLCAyXSwgWzQsIDFdLCBbNywgMV0sIFs3LCAxXSwgWzcsIDFdLCBbNywgMV0sIFs3LCAxXSwgWzcsIDFdLCBbNywgMV0sIFsxMywgMV0sIFsxMCwgM10sIFsxNiwgNV0sIFs5LCA0XSwgWzksIDRdLCBbMjQsIDZdLCBbMjcsIDZdLCBbMzgsIDZdLCBbNDMsIDJdLCBbNDUsIDNdLCBbNDUsIDFdLCBbMjYsIDNdLCBbOCwgNV0sIFs4LCA1XSwgWzExLCA1XSwgWzEyLCAzXSwgWzU5LCA1XSwgWzYzLCAxXSwgWzYzLCAxXSwgWzY0LCA1XSwgWzY5LCAxXSwgWzcxLCAzXSwgWzc0LCAzXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzU2LCAxXSwgWzU2LCAxXSwgWzc5LCAyXSwgWzc4LCAxXSwgWzg2LCAzXSwgWzg2LCAxXSwgWzYsIDBdLCBbNiwgMl0sIFsxNywgMV0sIFsxNywgMl0sIFsyMSwgMF0sIFsyMSwgMl0sIFsyMiwgMF0sIFsyMiwgMV0sIFsyNSwgMF0sIFsyNSwgMV0sIFsyOCwgMF0sIFsyOCwgMV0sIFszMCwgMF0sIFszMCwgMl0sIFszMSwgMF0sIFszMSwgMV0sIFszMiwgMF0sIFszMiwgMV0sIFszNSwgMF0sIFszNSwgMl0sIFszNiwgMF0sIFszNiwgMV0sIFszNywgMF0sIFszNywgMV0sIFs0MCwgMF0sIFs0MCwgMl0sIFs0MSwgMF0sIFs0MSwgMV0sIFs0MiwgMF0sIFs0MiwgMV0sIFs0NiwgMF0sIFs0NiwgMV0sIFs0OSwgMF0sIFs0OSwgMl0sIFs1MCwgMF0sIFs1MCwgMV0sIFs1MiwgMF0sIFs1MiwgMl0sIFs1MywgMF0sIFs1MywgMV0sIFs1NywgMF0sIFs1NywgMl0sIFs1OCwgMF0sIFs1OCwgMV0sIFs2MSwgMF0sIFs2MSwgMl0sIFs2MiwgMF0sIFs2MiwgMV0sIFs2NiwgMF0sIFs2NiwgMl0sIFs2NywgMF0sIFs2NywgMV0sIFs3MCwgMV0sIFs3MCwgMl0sIFs3NiwgMV0sIFs3NiwgMl1dLFxyXG5cdCAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJFxyXG5cdCAgICAgICAgLyoqLykge1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAoeXlzdGF0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCRbJDAgLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlUHJvZ3JhbSgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ29tbWVudFN0YXRlbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHl5LnN0cmlwQ29tbWVudCgkJFskMF0pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwXSwgJCRbJDBdKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NvbnRlbnRTdGF0ZW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsOiAkJFskMF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICQkWyQwXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTE6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlUmF3QmxvY2soJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBwYXRoOiAkJFskMCAtIDNdLCBwYXJhbXM6ICQkWyQwIC0gMl0sIGhhc2g6ICQkWyQwIC0gMV0gfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZUJsb2NrKCQkWyQwIC0gM10sICQkWyQwIC0gMl0sICQkWyQwIC0gMV0sICQkWyQwXSwgZmFsc2UsIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlQmxvY2soJCRbJDAgLSAzXSwgJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCB0cnVlLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBvcGVuOiAkJFskMCAtIDVdLCBwYXRoOiAkJFskMCAtIDRdLCBwYXJhbXM6ICQkWyQwIC0gM10sIGhhc2g6ICQkWyQwIC0gMl0sIGJsb2NrUGFyYW1zOiAkJFskMCAtIDFdLCBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDVdLCAkJFskMF0pIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxNjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgcGF0aDogJCRbJDAgLSA0XSwgcGFyYW1zOiAkJFskMCAtIDNdLCBoYXNoOiAkJFskMCAtIDJdLCBibG9ja1BhcmFtczogJCRbJDAgLSAxXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA1XSwgJCRbJDBdKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTc6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHBhdGg6ICQkWyQwIC0gNF0sIHBhcmFtczogJCRbJDAgLSAzXSwgaGFzaDogJCRbJDAgLSAyXSwgYmxvY2tQYXJhbXM6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNV0sICQkWyQwXSkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDFdLCAkJFskMCAtIDFdKSwgcHJvZ3JhbTogJCRbJDBdIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlID0geXkucHJlcGFyZUJsb2NrKCQkWyQwIC0gMl0sICQkWyQwIC0gMV0sICQkWyQwXSwgJCRbJDBdLCBmYWxzZSwgdGhpcy5fJCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbSA9IHl5LnByZXBhcmVQcm9ncmFtKFtpbnZlcnNlXSwgJCRbJDAgLSAxXS5sb2MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5jaGFpbmVkID0gdHJ1ZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHN0cmlwOiAkJFskMCAtIDJdLnN0cmlwLCBwcm9ncmFtOiBwcm9ncmFtLCBjaGFpbjogdHJ1ZSB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDIwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjE6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHBhdGg6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gMl0sICQkWyQwXSkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDIyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZU11c3RhY2hlKCQkWyQwIC0gM10sICQkWyQwIC0gMl0sICQkWyQwIC0gMV0sICQkWyQwIC0gNF0sIHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA0XSwgJCRbJDBdKSwgdGhpcy5fJCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyMzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVNdXN0YWNoZSgkJFskMCAtIDNdLCAkJFskMCAtIDJdLCAkJFskMCAtIDFdLCAkJFskMCAtIDRdLCB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNF0sICQkWyQwXSksIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BhcnRpYWxTdGF0ZW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICQkWyQwIC0gM10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiAkJFskMCAtIDJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6ICQkWyQwIC0gMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiAnJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDRdLCAkJFskMF0pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyNTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVQYXJ0aWFsQmxvY2soJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI2OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBwYXRoOiAkJFskMCAtIDNdLCBwYXJhbXM6ICQkWyQwIC0gMl0sIGhhc2g6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNF0sICQkWyQwXSkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjg6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU3ViRXhwcmVzc2lvbicsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJCRbJDAgLSAzXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6ICQkWyQwIC0gMl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogJCRbJDAgLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdIYXNoJywgcGFpcnM6ICQkWyQwXSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgdHlwZTogJ0hhc2hQYWlyJywga2V5OiB5eS5pZCgkJFskMCAtIDJdKSwgdmFsdWU6ICQkWyQwXSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LmlkKCQkWyQwIC0gMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzM6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnU3RyaW5nTGl0ZXJhbCcsIHZhbHVlOiAkJFskMF0sIG9yaWdpbmFsOiAkJFskMF0sIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzY6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdOdW1iZXJMaXRlcmFsJywgdmFsdWU6IE51bWJlcigkJFskMF0pLCBvcmlnaW5hbDogTnVtYmVyKCQkWyQwXSksIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzc6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdCb29sZWFuTGl0ZXJhbCcsIHZhbHVlOiAkJFskMF0gPT09ICd0cnVlJywgb3JpZ2luYWw6ICQkWyQwXSA9PT0gJ3RydWUnLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnVW5kZWZpbmVkTGl0ZXJhbCcsIG9yaWdpbmFsOiB1bmRlZmluZWQsIHZhbHVlOiB1bmRlZmluZWQsIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzk6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdOdWxsTGl0ZXJhbCcsIG9yaWdpbmFsOiBudWxsLCB2YWx1ZTogbnVsbCwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0MDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlUGF0aCh0cnVlLCAkJFskMF0sIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDM6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlUGF0aChmYWxzZSwgJCRbJDBdLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAyXS5wdXNoKHsgcGFydDogeXkuaWQoJCRbJDBdKSwgb3JpZ2luYWw6ICQkWyQwXSwgc2VwYXJhdG9yOiAkJFskMCAtIDFdIH0pO3RoaXMuJCA9ICQkWyQwIC0gMl07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0NTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFt7IHBhcnQ6IHl5LmlkKCQkWyQwXSksIG9yaWdpbmFsOiAkJFskMF0gfV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0NjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gWyQkWyQwXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0OTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDUxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA1ODpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTk6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDY0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA2NTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDcxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA3ODpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzk6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDgyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA4MzpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgODY6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDg3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5MDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTE6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDk0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5NTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTg6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbJCRbJDBdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDk5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxMDA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbJCRbJDBdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEwMTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRhYmxlOiBbeyAzOiAxLCA0OiAyLCA1OiBbMiwgNDZdLCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDQ4OiBbMiwgNDZdLCA1MTogWzIsIDQ2XSwgNTU6IFsyLCA0Nl0sIDYwOiBbMiwgNDZdIH0sIHsgMTogWzNdIH0sIHsgNTogWzEsIDRdIH0sIHsgNTogWzIsIDJdLCA3OiA1LCA4OiA2LCA5OiA3LCAxMDogOCwgMTE6IDksIDEyOiAxMCwgMTM6IDExLCAxNDogWzEsIDEyXSwgMTU6IFsxLCAyMF0sIDE2OiAxNywgMTk6IFsxLCAyM10sIDI0OiAxNSwgMjc6IDE2LCAyOTogWzEsIDIxXSwgMzQ6IFsxLCAyMl0sIDM5OiBbMiwgMl0sIDQ0OiBbMiwgMl0sIDQ3OiBbMiwgMl0sIDQ4OiBbMSwgMTNdLCA1MTogWzEsIDE0XSwgNTU6IFsxLCAxOF0sIDU5OiAxOSwgNjA6IFsxLCAyNF0gfSwgeyAxOiBbMiwgMV0gfSwgeyA1OiBbMiwgNDddLCAxNDogWzIsIDQ3XSwgMTU6IFsyLCA0N10sIDE5OiBbMiwgNDddLCAyOTogWzIsIDQ3XSwgMzQ6IFsyLCA0N10sIDM5OiBbMiwgNDddLCA0NDogWzIsIDQ3XSwgNDc6IFsyLCA0N10sIDQ4OiBbMiwgNDddLCA1MTogWzIsIDQ3XSwgNTU6IFsyLCA0N10sIDYwOiBbMiwgNDddIH0sIHsgNTogWzIsIDNdLCAxNDogWzIsIDNdLCAxNTogWzIsIDNdLCAxOTogWzIsIDNdLCAyOTogWzIsIDNdLCAzNDogWzIsIDNdLCAzOTogWzIsIDNdLCA0NDogWzIsIDNdLCA0NzogWzIsIDNdLCA0ODogWzIsIDNdLCA1MTogWzIsIDNdLCA1NTogWzIsIDNdLCA2MDogWzIsIDNdIH0sIHsgNTogWzIsIDRdLCAxNDogWzIsIDRdLCAxNTogWzIsIDRdLCAxOTogWzIsIDRdLCAyOTogWzIsIDRdLCAzNDogWzIsIDRdLCAzOTogWzIsIDRdLCA0NDogWzIsIDRdLCA0NzogWzIsIDRdLCA0ODogWzIsIDRdLCA1MTogWzIsIDRdLCA1NTogWzIsIDRdLCA2MDogWzIsIDRdIH0sIHsgNTogWzIsIDVdLCAxNDogWzIsIDVdLCAxNTogWzIsIDVdLCAxOTogWzIsIDVdLCAyOTogWzIsIDVdLCAzNDogWzIsIDVdLCAzOTogWzIsIDVdLCA0NDogWzIsIDVdLCA0NzogWzIsIDVdLCA0ODogWzIsIDVdLCA1MTogWzIsIDVdLCA1NTogWzIsIDVdLCA2MDogWzIsIDVdIH0sIHsgNTogWzIsIDZdLCAxNDogWzIsIDZdLCAxNTogWzIsIDZdLCAxOTogWzIsIDZdLCAyOTogWzIsIDZdLCAzNDogWzIsIDZdLCAzOTogWzIsIDZdLCA0NDogWzIsIDZdLCA0NzogWzIsIDZdLCA0ODogWzIsIDZdLCA1MTogWzIsIDZdLCA1NTogWzIsIDZdLCA2MDogWzIsIDZdIH0sIHsgNTogWzIsIDddLCAxNDogWzIsIDddLCAxNTogWzIsIDddLCAxOTogWzIsIDddLCAyOTogWzIsIDddLCAzNDogWzIsIDddLCAzOTogWzIsIDddLCA0NDogWzIsIDddLCA0NzogWzIsIDddLCA0ODogWzIsIDddLCA1MTogWzIsIDddLCA1NTogWzIsIDddLCA2MDogWzIsIDddIH0sIHsgNTogWzIsIDhdLCAxNDogWzIsIDhdLCAxNTogWzIsIDhdLCAxOTogWzIsIDhdLCAyOTogWzIsIDhdLCAzNDogWzIsIDhdLCAzOTogWzIsIDhdLCA0NDogWzIsIDhdLCA0NzogWzIsIDhdLCA0ODogWzIsIDhdLCA1MTogWzIsIDhdLCA1NTogWzIsIDhdLCA2MDogWzIsIDhdIH0sIHsgNTogWzIsIDldLCAxNDogWzIsIDldLCAxNTogWzIsIDldLCAxOTogWzIsIDldLCAyOTogWzIsIDldLCAzNDogWzIsIDldLCAzOTogWzIsIDldLCA0NDogWzIsIDldLCA0NzogWzIsIDldLCA0ODogWzIsIDldLCA1MTogWzIsIDldLCA1NTogWzIsIDldLCA2MDogWzIsIDldIH0sIHsgMjA6IDI1LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiAzNiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiAzNywgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCAzOTogWzIsIDQ2XSwgNDQ6IFsyLCA0Nl0sIDQ3OiBbMiwgNDZdLCA0ODogWzIsIDQ2XSwgNTE6IFsyLCA0Nl0sIDU1OiBbMiwgNDZdLCA2MDogWzIsIDQ2XSB9LCB7IDQ6IDM4LCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDQ0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyAxMzogNDAsIDE1OiBbMSwgMjBdLCAxNzogMzkgfSwgeyAyMDogNDIsIDU2OiA0MSwgNjQ6IDQzLCA2NTogWzEsIDQ0XSwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiA0NSwgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyA1OiBbMiwgMTBdLCAxNDogWzIsIDEwXSwgMTU6IFsyLCAxMF0sIDE4OiBbMiwgMTBdLCAxOTogWzIsIDEwXSwgMjk6IFsyLCAxMF0sIDM0OiBbMiwgMTBdLCAzOTogWzIsIDEwXSwgNDQ6IFsyLCAxMF0sIDQ3OiBbMiwgMTBdLCA0ODogWzIsIDEwXSwgNTE6IFsyLCAxMF0sIDU1OiBbMiwgMTBdLCA2MDogWzIsIDEwXSB9LCB7IDIwOiA0NiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyMDogNDcsIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDQ4LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA0MiwgNTY6IDQ5LCA2NDogNDMsIDY1OiBbMSwgNDRdLCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDMzOiBbMiwgNzhdLCA0OTogNTAsIDY1OiBbMiwgNzhdLCA3MjogWzIsIDc4XSwgODA6IFsyLCA3OF0sIDgxOiBbMiwgNzhdLCA4MjogWzIsIDc4XSwgODM6IFsyLCA3OF0sIDg0OiBbMiwgNzhdLCA4NTogWzIsIDc4XSB9LCB7IDIzOiBbMiwgMzNdLCAzMzogWzIsIDMzXSwgNTQ6IFsyLCAzM10sIDY1OiBbMiwgMzNdLCA2ODogWzIsIDMzXSwgNzI6IFsyLCAzM10sIDc1OiBbMiwgMzNdLCA4MDogWzIsIDMzXSwgODE6IFsyLCAzM10sIDgyOiBbMiwgMzNdLCA4MzogWzIsIDMzXSwgODQ6IFsyLCAzM10sIDg1OiBbMiwgMzNdIH0sIHsgMjM6IFsyLCAzNF0sIDMzOiBbMiwgMzRdLCA1NDogWzIsIDM0XSwgNjU6IFsyLCAzNF0sIDY4OiBbMiwgMzRdLCA3MjogWzIsIDM0XSwgNzU6IFsyLCAzNF0sIDgwOiBbMiwgMzRdLCA4MTogWzIsIDM0XSwgODI6IFsyLCAzNF0sIDgzOiBbMiwgMzRdLCA4NDogWzIsIDM0XSwgODU6IFsyLCAzNF0gfSwgeyAyMzogWzIsIDM1XSwgMzM6IFsyLCAzNV0sIDU0OiBbMiwgMzVdLCA2NTogWzIsIDM1XSwgNjg6IFsyLCAzNV0sIDcyOiBbMiwgMzVdLCA3NTogWzIsIDM1XSwgODA6IFsyLCAzNV0sIDgxOiBbMiwgMzVdLCA4MjogWzIsIDM1XSwgODM6IFsyLCAzNV0sIDg0OiBbMiwgMzVdLCA4NTogWzIsIDM1XSB9LCB7IDIzOiBbMiwgMzZdLCAzMzogWzIsIDM2XSwgNTQ6IFsyLCAzNl0sIDY1OiBbMiwgMzZdLCA2ODogWzIsIDM2XSwgNzI6IFsyLCAzNl0sIDc1OiBbMiwgMzZdLCA4MDogWzIsIDM2XSwgODE6IFsyLCAzNl0sIDgyOiBbMiwgMzZdLCA4MzogWzIsIDM2XSwgODQ6IFsyLCAzNl0sIDg1OiBbMiwgMzZdIH0sIHsgMjM6IFsyLCAzN10sIDMzOiBbMiwgMzddLCA1NDogWzIsIDM3XSwgNjU6IFsyLCAzN10sIDY4OiBbMiwgMzddLCA3MjogWzIsIDM3XSwgNzU6IFsyLCAzN10sIDgwOiBbMiwgMzddLCA4MTogWzIsIDM3XSwgODI6IFsyLCAzN10sIDgzOiBbMiwgMzddLCA4NDogWzIsIDM3XSwgODU6IFsyLCAzN10gfSwgeyAyMzogWzIsIDM4XSwgMzM6IFsyLCAzOF0sIDU0OiBbMiwgMzhdLCA2NTogWzIsIDM4XSwgNjg6IFsyLCAzOF0sIDcyOiBbMiwgMzhdLCA3NTogWzIsIDM4XSwgODA6IFsyLCAzOF0sIDgxOiBbMiwgMzhdLCA4MjogWzIsIDM4XSwgODM6IFsyLCAzOF0sIDg0OiBbMiwgMzhdLCA4NTogWzIsIDM4XSB9LCB7IDIzOiBbMiwgMzldLCAzMzogWzIsIDM5XSwgNTQ6IFsyLCAzOV0sIDY1OiBbMiwgMzldLCA2ODogWzIsIDM5XSwgNzI6IFsyLCAzOV0sIDc1OiBbMiwgMzldLCA4MDogWzIsIDM5XSwgODE6IFsyLCAzOV0sIDgyOiBbMiwgMzldLCA4MzogWzIsIDM5XSwgODQ6IFsyLCAzOV0sIDg1OiBbMiwgMzldIH0sIHsgMjM6IFsyLCA0M10sIDMzOiBbMiwgNDNdLCA1NDogWzIsIDQzXSwgNjU6IFsyLCA0M10sIDY4OiBbMiwgNDNdLCA3MjogWzIsIDQzXSwgNzU6IFsyLCA0M10sIDgwOiBbMiwgNDNdLCA4MTogWzIsIDQzXSwgODI6IFsyLCA0M10sIDgzOiBbMiwgNDNdLCA4NDogWzIsIDQzXSwgODU6IFsyLCA0M10sIDg3OiBbMSwgNTFdIH0sIHsgNzI6IFsxLCAzNV0sIDg2OiA1MiB9LCB7IDIzOiBbMiwgNDVdLCAzMzogWzIsIDQ1XSwgNTQ6IFsyLCA0NV0sIDY1OiBbMiwgNDVdLCA2ODogWzIsIDQ1XSwgNzI6IFsyLCA0NV0sIDc1OiBbMiwgNDVdLCA4MDogWzIsIDQ1XSwgODE6IFsyLCA0NV0sIDgyOiBbMiwgNDVdLCA4MzogWzIsIDQ1XSwgODQ6IFsyLCA0NV0sIDg1OiBbMiwgNDVdLCA4NzogWzIsIDQ1XSB9LCB7IDUyOiA1MywgNTQ6IFsyLCA4Ml0sIDY1OiBbMiwgODJdLCA3MjogWzIsIDgyXSwgODA6IFsyLCA4Ml0sIDgxOiBbMiwgODJdLCA4MjogWzIsIDgyXSwgODM6IFsyLCA4Ml0sIDg0OiBbMiwgODJdLCA4NTogWzIsIDgyXSB9LCB7IDI1OiA1NCwgMzg6IDU2LCAzOTogWzEsIDU4XSwgNDM6IDU3LCA0NDogWzEsIDU5XSwgNDU6IDU1LCA0NzogWzIsIDU0XSB9LCB7IDI4OiA2MCwgNDM6IDYxLCA0NDogWzEsIDU5XSwgNDc6IFsyLCA1Nl0gfSwgeyAxMzogNjMsIDE1OiBbMSwgMjBdLCAxODogWzEsIDYyXSB9LCB7IDE1OiBbMiwgNDhdLCAxODogWzIsIDQ4XSB9LCB7IDMzOiBbMiwgODZdLCA1NzogNjQsIDY1OiBbMiwgODZdLCA3MjogWzIsIDg2XSwgODA6IFsyLCA4Nl0sIDgxOiBbMiwgODZdLCA4MjogWzIsIDg2XSwgODM6IFsyLCA4Nl0sIDg0OiBbMiwgODZdLCA4NTogWzIsIDg2XSB9LCB7IDMzOiBbMiwgNDBdLCA2NTogWzIsIDQwXSwgNzI6IFsyLCA0MF0sIDgwOiBbMiwgNDBdLCA4MTogWzIsIDQwXSwgODI6IFsyLCA0MF0sIDgzOiBbMiwgNDBdLCA4NDogWzIsIDQwXSwgODU6IFsyLCA0MF0gfSwgeyAzMzogWzIsIDQxXSwgNjU6IFsyLCA0MV0sIDcyOiBbMiwgNDFdLCA4MDogWzIsIDQxXSwgODE6IFsyLCA0MV0sIDgyOiBbMiwgNDFdLCA4MzogWzIsIDQxXSwgODQ6IFsyLCA0MV0sIDg1OiBbMiwgNDFdIH0sIHsgMjA6IDY1LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDI2OiA2NiwgNDc6IFsxLCA2N10gfSwgeyAzMDogNjgsIDMzOiBbMiwgNThdLCA2NTogWzIsIDU4XSwgNzI6IFsyLCA1OF0sIDc1OiBbMiwgNThdLCA4MDogWzIsIDU4XSwgODE6IFsyLCA1OF0sIDgyOiBbMiwgNThdLCA4MzogWzIsIDU4XSwgODQ6IFsyLCA1OF0sIDg1OiBbMiwgNThdIH0sIHsgMzM6IFsyLCA2NF0sIDM1OiA2OSwgNjU6IFsyLCA2NF0sIDcyOiBbMiwgNjRdLCA3NTogWzIsIDY0XSwgODA6IFsyLCA2NF0sIDgxOiBbMiwgNjRdLCA4MjogWzIsIDY0XSwgODM6IFsyLCA2NF0sIDg0OiBbMiwgNjRdLCA4NTogWzIsIDY0XSB9LCB7IDIxOiA3MCwgMjM6IFsyLCA1MF0sIDY1OiBbMiwgNTBdLCA3MjogWzIsIDUwXSwgODA6IFsyLCA1MF0sIDgxOiBbMiwgNTBdLCA4MjogWzIsIDUwXSwgODM6IFsyLCA1MF0sIDg0OiBbMiwgNTBdLCA4NTogWzIsIDUwXSB9LCB7IDMzOiBbMiwgOTBdLCA2MTogNzEsIDY1OiBbMiwgOTBdLCA3MjogWzIsIDkwXSwgODA6IFsyLCA5MF0sIDgxOiBbMiwgOTBdLCA4MjogWzIsIDkwXSwgODM6IFsyLCA5MF0sIDg0OiBbMiwgOTBdLCA4NTogWzIsIDkwXSB9LCB7IDIwOiA3NSwgMzM6IFsyLCA4MF0sIDUwOiA3MiwgNjM6IDczLCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2OTogNzQsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDcyOiBbMSwgODBdIH0sIHsgMjM6IFsyLCA0Ml0sIDMzOiBbMiwgNDJdLCA1NDogWzIsIDQyXSwgNjU6IFsyLCA0Ml0sIDY4OiBbMiwgNDJdLCA3MjogWzIsIDQyXSwgNzU6IFsyLCA0Ml0sIDgwOiBbMiwgNDJdLCA4MTogWzIsIDQyXSwgODI6IFsyLCA0Ml0sIDgzOiBbMiwgNDJdLCA4NDogWzIsIDQyXSwgODU6IFsyLCA0Ml0sIDg3OiBbMSwgNTFdIH0sIHsgMjA6IDc1LCA1MzogODEsIDU0OiBbMiwgODRdLCA2MzogODIsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA4MywgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjY6IDg0LCA0NzogWzEsIDY3XSB9LCB7IDQ3OiBbMiwgNTVdIH0sIHsgNDogODUsIDY6IDMsIDE0OiBbMiwgNDZdLCAxNTogWzIsIDQ2XSwgMTk6IFsyLCA0Nl0sIDI5OiBbMiwgNDZdLCAzNDogWzIsIDQ2XSwgMzk6IFsyLCA0Nl0sIDQ0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyA0NzogWzIsIDIwXSB9LCB7IDIwOiA4NiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiA4NywgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyAyNjogODgsIDQ3OiBbMSwgNjddIH0sIHsgNDc6IFsyLCA1N10gfSwgeyA1OiBbMiwgMTFdLCAxNDogWzIsIDExXSwgMTU6IFsyLCAxMV0sIDE5OiBbMiwgMTFdLCAyOTogWzIsIDExXSwgMzQ6IFsyLCAxMV0sIDM5OiBbMiwgMTFdLCA0NDogWzIsIDExXSwgNDc6IFsyLCAxMV0sIDQ4OiBbMiwgMTFdLCA1MTogWzIsIDExXSwgNTU6IFsyLCAxMV0sIDYwOiBbMiwgMTFdIH0sIHsgMTU6IFsyLCA0OV0sIDE4OiBbMiwgNDldIH0sIHsgMjA6IDc1LCAzMzogWzIsIDg4XSwgNTg6IDg5LCA2MzogOTAsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA5MSwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNjU6IFsyLCA5NF0sIDY2OiA5MiwgNjg6IFsyLCA5NF0sIDcyOiBbMiwgOTRdLCA4MDogWzIsIDk0XSwgODE6IFsyLCA5NF0sIDgyOiBbMiwgOTRdLCA4MzogWzIsIDk0XSwgODQ6IFsyLCA5NF0sIDg1OiBbMiwgOTRdIH0sIHsgNTogWzIsIDI1XSwgMTQ6IFsyLCAyNV0sIDE1OiBbMiwgMjVdLCAxOTogWzIsIDI1XSwgMjk6IFsyLCAyNV0sIDM0OiBbMiwgMjVdLCAzOTogWzIsIDI1XSwgNDQ6IFsyLCAyNV0sIDQ3OiBbMiwgMjVdLCA0ODogWzIsIDI1XSwgNTE6IFsyLCAyNV0sIDU1OiBbMiwgMjVdLCA2MDogWzIsIDI1XSB9LCB7IDIwOiA5MywgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyMDogNzUsIDMxOiA5NCwgMzM6IFsyLCA2MF0sIDYzOiA5NSwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNjk6IDk2LCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc1OiBbMiwgNjBdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDc1LCAzMzogWzIsIDY2XSwgMzY6IDk3LCA2MzogOTgsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA5OSwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3NTogWzIsIDY2XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA3NSwgMjI6IDEwMCwgMjM6IFsyLCA1Ml0sIDYzOiAxMDEsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiAxMDIsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA3NSwgMzM6IFsyLCA5Ml0sIDYyOiAxMDMsIDYzOiAxMDQsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiAxMDUsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDMzOiBbMSwgMTA2XSB9LCB7IDMzOiBbMiwgNzldLCA2NTogWzIsIDc5XSwgNzI6IFsyLCA3OV0sIDgwOiBbMiwgNzldLCA4MTogWzIsIDc5XSwgODI6IFsyLCA3OV0sIDgzOiBbMiwgNzldLCA4NDogWzIsIDc5XSwgODU6IFsyLCA3OV0gfSwgeyAzMzogWzIsIDgxXSB9LCB7IDIzOiBbMiwgMjddLCAzMzogWzIsIDI3XSwgNTQ6IFsyLCAyN10sIDY1OiBbMiwgMjddLCA2ODogWzIsIDI3XSwgNzI6IFsyLCAyN10sIDc1OiBbMiwgMjddLCA4MDogWzIsIDI3XSwgODE6IFsyLCAyN10sIDgyOiBbMiwgMjddLCA4MzogWzIsIDI3XSwgODQ6IFsyLCAyN10sIDg1OiBbMiwgMjddIH0sIHsgMjM6IFsyLCAyOF0sIDMzOiBbMiwgMjhdLCA1NDogWzIsIDI4XSwgNjU6IFsyLCAyOF0sIDY4OiBbMiwgMjhdLCA3MjogWzIsIDI4XSwgNzU6IFsyLCAyOF0sIDgwOiBbMiwgMjhdLCA4MTogWzIsIDI4XSwgODI6IFsyLCAyOF0sIDgzOiBbMiwgMjhdLCA4NDogWzIsIDI4XSwgODU6IFsyLCAyOF0gfSwgeyAyMzogWzIsIDMwXSwgMzM6IFsyLCAzMF0sIDU0OiBbMiwgMzBdLCA2ODogWzIsIDMwXSwgNzE6IDEwNywgNzI6IFsxLCAxMDhdLCA3NTogWzIsIDMwXSB9LCB7IDIzOiBbMiwgOThdLCAzMzogWzIsIDk4XSwgNTQ6IFsyLCA5OF0sIDY4OiBbMiwgOThdLCA3MjogWzIsIDk4XSwgNzU6IFsyLCA5OF0gfSwgeyAyMzogWzIsIDQ1XSwgMzM6IFsyLCA0NV0sIDU0OiBbMiwgNDVdLCA2NTogWzIsIDQ1XSwgNjg6IFsyLCA0NV0sIDcyOiBbMiwgNDVdLCA3MzogWzEsIDEwOV0sIDc1OiBbMiwgNDVdLCA4MDogWzIsIDQ1XSwgODE6IFsyLCA0NV0sIDgyOiBbMiwgNDVdLCA4MzogWzIsIDQ1XSwgODQ6IFsyLCA0NV0sIDg1OiBbMiwgNDVdLCA4NzogWzIsIDQ1XSB9LCB7IDIzOiBbMiwgNDRdLCAzMzogWzIsIDQ0XSwgNTQ6IFsyLCA0NF0sIDY1OiBbMiwgNDRdLCA2ODogWzIsIDQ0XSwgNzI6IFsyLCA0NF0sIDc1OiBbMiwgNDRdLCA4MDogWzIsIDQ0XSwgODE6IFsyLCA0NF0sIDgyOiBbMiwgNDRdLCA4MzogWzIsIDQ0XSwgODQ6IFsyLCA0NF0sIDg1OiBbMiwgNDRdLCA4NzogWzIsIDQ0XSB9LCB7IDU0OiBbMSwgMTEwXSB9LCB7IDU0OiBbMiwgODNdLCA2NTogWzIsIDgzXSwgNzI6IFsyLCA4M10sIDgwOiBbMiwgODNdLCA4MTogWzIsIDgzXSwgODI6IFsyLCA4M10sIDgzOiBbMiwgODNdLCA4NDogWzIsIDgzXSwgODU6IFsyLCA4M10gfSwgeyA1NDogWzIsIDg1XSB9LCB7IDU6IFsyLCAxM10sIDE0OiBbMiwgMTNdLCAxNTogWzIsIDEzXSwgMTk6IFsyLCAxM10sIDI5OiBbMiwgMTNdLCAzNDogWzIsIDEzXSwgMzk6IFsyLCAxM10sIDQ0OiBbMiwgMTNdLCA0NzogWzIsIDEzXSwgNDg6IFsyLCAxM10sIDUxOiBbMiwgMTNdLCA1NTogWzIsIDEzXSwgNjA6IFsyLCAxM10gfSwgeyAzODogNTYsIDM5OiBbMSwgNThdLCA0MzogNTcsIDQ0OiBbMSwgNTldLCA0NTogMTEyLCA0NjogMTExLCA0NzogWzIsIDc2XSB9LCB7IDMzOiBbMiwgNzBdLCA0MDogMTEzLCA2NTogWzIsIDcwXSwgNzI6IFsyLCA3MF0sIDc1OiBbMiwgNzBdLCA4MDogWzIsIDcwXSwgODE6IFsyLCA3MF0sIDgyOiBbMiwgNzBdLCA4MzogWzIsIDcwXSwgODQ6IFsyLCA3MF0sIDg1OiBbMiwgNzBdIH0sIHsgNDc6IFsyLCAxOF0gfSwgeyA1OiBbMiwgMTRdLCAxNDogWzIsIDE0XSwgMTU6IFsyLCAxNF0sIDE5OiBbMiwgMTRdLCAyOTogWzIsIDE0XSwgMzQ6IFsyLCAxNF0sIDM5OiBbMiwgMTRdLCA0NDogWzIsIDE0XSwgNDc6IFsyLCAxNF0sIDQ4OiBbMiwgMTRdLCA1MTogWzIsIDE0XSwgNTU6IFsyLCAxNF0sIDYwOiBbMiwgMTRdIH0sIHsgMzM6IFsxLCAxMTRdIH0sIHsgMzM6IFsyLCA4N10sIDY1OiBbMiwgODddLCA3MjogWzIsIDg3XSwgODA6IFsyLCA4N10sIDgxOiBbMiwgODddLCA4MjogWzIsIDg3XSwgODM6IFsyLCA4N10sIDg0OiBbMiwgODddLCA4NTogWzIsIDg3XSB9LCB7IDMzOiBbMiwgODldIH0sIHsgMjA6IDc1LCA2MzogMTE2LCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2NzogMTE1LCA2ODogWzIsIDk2XSwgNjk6IDExNywgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMzM6IFsxLCAxMThdIH0sIHsgMzI6IDExOSwgMzM6IFsyLCA2Ml0sIDc0OiAxMjAsIDc1OiBbMSwgMTIxXSB9LCB7IDMzOiBbMiwgNTldLCA2NTogWzIsIDU5XSwgNzI6IFsyLCA1OV0sIDc1OiBbMiwgNTldLCA4MDogWzIsIDU5XSwgODE6IFsyLCA1OV0sIDgyOiBbMiwgNTldLCA4MzogWzIsIDU5XSwgODQ6IFsyLCA1OV0sIDg1OiBbMiwgNTldIH0sIHsgMzM6IFsyLCA2MV0sIDc1OiBbMiwgNjFdIH0sIHsgMzM6IFsyLCA2OF0sIDM3OiAxMjIsIDc0OiAxMjMsIDc1OiBbMSwgMTIxXSB9LCB7IDMzOiBbMiwgNjVdLCA2NTogWzIsIDY1XSwgNzI6IFsyLCA2NV0sIDc1OiBbMiwgNjVdLCA4MDogWzIsIDY1XSwgODE6IFsyLCA2NV0sIDgyOiBbMiwgNjVdLCA4MzogWzIsIDY1XSwgODQ6IFsyLCA2NV0sIDg1OiBbMiwgNjVdIH0sIHsgMzM6IFsyLCA2N10sIDc1OiBbMiwgNjddIH0sIHsgMjM6IFsxLCAxMjRdIH0sIHsgMjM6IFsyLCA1MV0sIDY1OiBbMiwgNTFdLCA3MjogWzIsIDUxXSwgODA6IFsyLCA1MV0sIDgxOiBbMiwgNTFdLCA4MjogWzIsIDUxXSwgODM6IFsyLCA1MV0sIDg0OiBbMiwgNTFdLCA4NTogWzIsIDUxXSB9LCB7IDIzOiBbMiwgNTNdIH0sIHsgMzM6IFsxLCAxMjVdIH0sIHsgMzM6IFsyLCA5MV0sIDY1OiBbMiwgOTFdLCA3MjogWzIsIDkxXSwgODA6IFsyLCA5MV0sIDgxOiBbMiwgOTFdLCA4MjogWzIsIDkxXSwgODM6IFsyLCA5MV0sIDg0OiBbMiwgOTFdLCA4NTogWzIsIDkxXSB9LCB7IDMzOiBbMiwgOTNdIH0sIHsgNTogWzIsIDIyXSwgMTQ6IFsyLCAyMl0sIDE1OiBbMiwgMjJdLCAxOTogWzIsIDIyXSwgMjk6IFsyLCAyMl0sIDM0OiBbMiwgMjJdLCAzOTogWzIsIDIyXSwgNDQ6IFsyLCAyMl0sIDQ3OiBbMiwgMjJdLCA0ODogWzIsIDIyXSwgNTE6IFsyLCAyMl0sIDU1OiBbMiwgMjJdLCA2MDogWzIsIDIyXSB9LCB7IDIzOiBbMiwgOTldLCAzMzogWzIsIDk5XSwgNTQ6IFsyLCA5OV0sIDY4OiBbMiwgOTldLCA3MjogWzIsIDk5XSwgNzU6IFsyLCA5OV0gfSwgeyA3MzogWzEsIDEwOV0gfSwgeyAyMDogNzUsIDYzOiAxMjYsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNTogWzIsIDIzXSwgMTQ6IFsyLCAyM10sIDE1OiBbMiwgMjNdLCAxOTogWzIsIDIzXSwgMjk6IFsyLCAyM10sIDM0OiBbMiwgMjNdLCAzOTogWzIsIDIzXSwgNDQ6IFsyLCAyM10sIDQ3OiBbMiwgMjNdLCA0ODogWzIsIDIzXSwgNTE6IFsyLCAyM10sIDU1OiBbMiwgMjNdLCA2MDogWzIsIDIzXSB9LCB7IDQ3OiBbMiwgMTldIH0sIHsgNDc6IFsyLCA3N10gfSwgeyAyMDogNzUsIDMzOiBbMiwgNzJdLCA0MTogMTI3LCA2MzogMTI4LCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2OTogMTI5LCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc1OiBbMiwgNzJdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNTogWzIsIDI0XSwgMTQ6IFsyLCAyNF0sIDE1OiBbMiwgMjRdLCAxOTogWzIsIDI0XSwgMjk6IFsyLCAyNF0sIDM0OiBbMiwgMjRdLCAzOTogWzIsIDI0XSwgNDQ6IFsyLCAyNF0sIDQ3OiBbMiwgMjRdLCA0ODogWzIsIDI0XSwgNTE6IFsyLCAyNF0sIDU1OiBbMiwgMjRdLCA2MDogWzIsIDI0XSB9LCB7IDY4OiBbMSwgMTMwXSB9LCB7IDY1OiBbMiwgOTVdLCA2ODogWzIsIDk1XSwgNzI6IFsyLCA5NV0sIDgwOiBbMiwgOTVdLCA4MTogWzIsIDk1XSwgODI6IFsyLCA5NV0sIDgzOiBbMiwgOTVdLCA4NDogWzIsIDk1XSwgODU6IFsyLCA5NV0gfSwgeyA2ODogWzIsIDk3XSB9LCB7IDU6IFsyLCAyMV0sIDE0OiBbMiwgMjFdLCAxNTogWzIsIDIxXSwgMTk6IFsyLCAyMV0sIDI5OiBbMiwgMjFdLCAzNDogWzIsIDIxXSwgMzk6IFsyLCAyMV0sIDQ0OiBbMiwgMjFdLCA0NzogWzIsIDIxXSwgNDg6IFsyLCAyMV0sIDUxOiBbMiwgMjFdLCA1NTogWzIsIDIxXSwgNjA6IFsyLCAyMV0gfSwgeyAzMzogWzEsIDEzMV0gfSwgeyAzMzogWzIsIDYzXSB9LCB7IDcyOiBbMSwgMTMzXSwgNzY6IDEzMiB9LCB7IDMzOiBbMSwgMTM0XSB9LCB7IDMzOiBbMiwgNjldIH0sIHsgMTU6IFsyLCAxMl0gfSwgeyAxNDogWzIsIDI2XSwgMTU6IFsyLCAyNl0sIDE5OiBbMiwgMjZdLCAyOTogWzIsIDI2XSwgMzQ6IFsyLCAyNl0sIDQ3OiBbMiwgMjZdLCA0ODogWzIsIDI2XSwgNTE6IFsyLCAyNl0sIDU1OiBbMiwgMjZdLCA2MDogWzIsIDI2XSB9LCB7IDIzOiBbMiwgMzFdLCAzMzogWzIsIDMxXSwgNTQ6IFsyLCAzMV0sIDY4OiBbMiwgMzFdLCA3MjogWzIsIDMxXSwgNzU6IFsyLCAzMV0gfSwgeyAzMzogWzIsIDc0XSwgNDI6IDEzNSwgNzQ6IDEzNiwgNzU6IFsxLCAxMjFdIH0sIHsgMzM6IFsyLCA3MV0sIDY1OiBbMiwgNzFdLCA3MjogWzIsIDcxXSwgNzU6IFsyLCA3MV0sIDgwOiBbMiwgNzFdLCA4MTogWzIsIDcxXSwgODI6IFsyLCA3MV0sIDgzOiBbMiwgNzFdLCA4NDogWzIsIDcxXSwgODU6IFsyLCA3MV0gfSwgeyAzMzogWzIsIDczXSwgNzU6IFsyLCA3M10gfSwgeyAyMzogWzIsIDI5XSwgMzM6IFsyLCAyOV0sIDU0OiBbMiwgMjldLCA2NTogWzIsIDI5XSwgNjg6IFsyLCAyOV0sIDcyOiBbMiwgMjldLCA3NTogWzIsIDI5XSwgODA6IFsyLCAyOV0sIDgxOiBbMiwgMjldLCA4MjogWzIsIDI5XSwgODM6IFsyLCAyOV0sIDg0OiBbMiwgMjldLCA4NTogWzIsIDI5XSB9LCB7IDE0OiBbMiwgMTVdLCAxNTogWzIsIDE1XSwgMTk6IFsyLCAxNV0sIDI5OiBbMiwgMTVdLCAzNDogWzIsIDE1XSwgMzk6IFsyLCAxNV0sIDQ0OiBbMiwgMTVdLCA0NzogWzIsIDE1XSwgNDg6IFsyLCAxNV0sIDUxOiBbMiwgMTVdLCA1NTogWzIsIDE1XSwgNjA6IFsyLCAxNV0gfSwgeyA3MjogWzEsIDEzOF0sIDc3OiBbMSwgMTM3XSB9LCB7IDcyOiBbMiwgMTAwXSwgNzc6IFsyLCAxMDBdIH0sIHsgMTQ6IFsyLCAxNl0sIDE1OiBbMiwgMTZdLCAxOTogWzIsIDE2XSwgMjk6IFsyLCAxNl0sIDM0OiBbMiwgMTZdLCA0NDogWzIsIDE2XSwgNDc6IFsyLCAxNl0sIDQ4OiBbMiwgMTZdLCA1MTogWzIsIDE2XSwgNTU6IFsyLCAxNl0sIDYwOiBbMiwgMTZdIH0sIHsgMzM6IFsxLCAxMzldIH0sIHsgMzM6IFsyLCA3NV0gfSwgeyAzMzogWzIsIDMyXSB9LCB7IDcyOiBbMiwgMTAxXSwgNzc6IFsyLCAxMDFdIH0sIHsgMTQ6IFsyLCAxN10sIDE1OiBbMiwgMTddLCAxOTogWzIsIDE3XSwgMjk6IFsyLCAxN10sIDM0OiBbMiwgMTddLCAzOTogWzIsIDE3XSwgNDQ6IFsyLCAxN10sIDQ3OiBbMiwgMTddLCA0ODogWzIsIDE3XSwgNTE6IFsyLCAxN10sIDU1OiBbMiwgMTddLCA2MDogWzIsIDE3XSB9XSxcclxuXHQgICAgICAgIGRlZmF1bHRBY3Rpb25zOiB7IDQ6IFsyLCAxXSwgNTU6IFsyLCA1NV0sIDU3OiBbMiwgMjBdLCA2MTogWzIsIDU3XSwgNzQ6IFsyLCA4MV0sIDgzOiBbMiwgODVdLCA4NzogWzIsIDE4XSwgOTE6IFsyLCA4OV0sIDEwMjogWzIsIDUzXSwgMTA1OiBbMiwgOTNdLCAxMTE6IFsyLCAxOV0sIDExMjogWzIsIDc3XSwgMTE3OiBbMiwgOTddLCAxMjA6IFsyLCA2M10sIDEyMzogWzIsIDY5XSwgMTI0OiBbMiwgMTJdLCAxMzY6IFsyLCA3NV0sIDEzNzogWzIsIDMyXSB9LFxyXG5cdCAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcclxuXHQgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrID0gWzBdLFxyXG5cdCAgICAgICAgICAgICAgICB2c3RhY2sgPSBbbnVsbF0sXHJcblx0ICAgICAgICAgICAgICAgIGxzdGFjayA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHRoaXMudGFibGUsXHJcblx0ICAgICAgICAgICAgICAgIHl5dGV4dCA9IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgIHl5bGluZW5vID0gMCxcclxuXHQgICAgICAgICAgICAgICAgeXlsZW5nID0gMCxcclxuXHQgICAgICAgICAgICAgICAgcmVjb3ZlcmluZyA9IDAsXHJcblx0ICAgICAgICAgICAgICAgIFRFUlJPUiA9IDIsXHJcblx0ICAgICAgICAgICAgICAgIEVPRiA9IDE7XHJcblx0ICAgICAgICAgICAgdGhpcy5sZXhlci5zZXRJbnB1dChpbnB1dCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5sZXhlci55eSA9IHRoaXMueXk7XHJcblx0ICAgICAgICAgICAgdGhpcy55eS5sZXhlciA9IHRoaXMubGV4ZXI7XHJcblx0ICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIgPSB0aGlzO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5sZXhlci55eWxsb2MgPT0gXCJ1bmRlZmluZWRcIikgdGhpcy5sZXhlci55eWxsb2MgPSB7fTtcclxuXHQgICAgICAgICAgICB2YXIgeXlsb2MgPSB0aGlzLmxleGVyLnl5bGxvYztcclxuXHQgICAgICAgICAgICBsc3RhY2sucHVzaCh5eWxvYyk7XHJcblx0ICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMubGV4ZXIub3B0aW9ucyAmJiB0aGlzLmxleGVyLm9wdGlvbnMucmFuZ2VzO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy55eS5wYXJzZUVycm9yID09PSBcImZ1bmN0aW9uXCIpIHRoaXMucGFyc2VFcnJvciA9IHRoaXMueXkucGFyc2VFcnJvcjtcclxuXHQgICAgICAgICAgICBmdW5jdGlvbiBwb3BTdGFjayhuKSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIgKiBuO1xyXG5cdCAgICAgICAgICAgICAgICB2c3RhY2subGVuZ3RoID0gdnN0YWNrLmxlbmd0aCAtIG47XHJcblx0ICAgICAgICAgICAgICAgIGxzdGFjay5sZW5ndGggPSBsc3RhY2subGVuZ3RoIC0gbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZnVuY3Rpb24gbGV4KCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gc2VsZi5sZXhlci5sZXgoKSB8fCAxO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSBcIm51bWJlclwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIHN5bWJvbCxcclxuXHQgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlLFxyXG5cdCAgICAgICAgICAgICAgICBhY3Rpb24sXHJcblx0ICAgICAgICAgICAgICAgIGEsXHJcblx0ICAgICAgICAgICAgICAgIHIsXHJcblx0ICAgICAgICAgICAgICAgIHl5dmFsID0ge30sXHJcblx0ICAgICAgICAgICAgICAgIHAsXHJcblx0ICAgICAgICAgICAgICAgIGxlbixcclxuXHQgICAgICAgICAgICAgICAgbmV3U3RhdGUsXHJcblx0ICAgICAgICAgICAgICAgIGV4cGVjdGVkO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcInVuZGVmaW5lZFwiIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSBcIlwiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNvdmVyaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgaW4gdGFibGVbc3RhdGVdKSBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiAyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goXCInXCIgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyBcIidcIik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxleGVyLnNob3dQb3NpdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBcIlBhcnNlIGVycm9yIG9uIGxpbmUgXCIgKyAoeXlsaW5lbm8gKyAxKSArIFwiOlxcblwiICsgdGhpcy5sZXhlci5zaG93UG9zaXRpb24oKSArIFwiXFxuRXhwZWN0aW5nIFwiICsgZXhwZWN0ZWQuam9pbihcIiwgXCIpICsgXCIsIGdvdCAnXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9IFwiUGFyc2UgZXJyb3Igb24gbGluZSBcIiArICh5eWxpbmVubyArIDEpICsgXCI6IFVuZXhwZWN0ZWQgXCIgKyAoc3ltYm9sID09IDEgPyBcImVuZCBvZiBpbnB1dFwiIDogXCInXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwgeyB0ZXh0OiB0aGlzLmxleGVyLm1hdGNoLCB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLCBsaW5lOiB0aGlzLmxleGVyLnl5bGluZW5vLCBsb2M6IHl5bG9jLCBleHBlY3RlZDogZXhwZWN0ZWQgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogXCIgKyBzdGF0ZSArIFwiLCB0b2tlbjogXCIgKyBzeW1ib2wpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKHRoaXMubGV4ZXIueXl0ZXh0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsc3RhY2sucHVzaCh0aGlzLmxleGVyLnl5bGxvYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB5eWxlbmcgPSB0aGlzLmxleGVyLnl5bGVuZztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXl0ZXh0ID0gdGhpcy5sZXhlci55eXRleHQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl5bGluZW5vID0gdGhpcy5sZXhlci55eWxpbmVubztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXlsb2MgPSB0aGlzLmxleGVyLnl5bGxvYztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKSByZWNvdmVyaW5nLS07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gcHJlRXJyb3JTeW1ib2w7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHl5dmFsLl8kID0geyBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLCBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHl5dmFsLCB5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHRoaXMueXksIGFjdGlvblsxXSwgdnN0YWNrLCBsc3RhY2spO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLyogSmlzb24gZ2VuZXJhdGVkIGxleGVyICovXHJcblx0ICAgIHZhciBsZXhlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbGV4ZXIgPSB7IEVPRjogMSxcclxuXHQgICAgICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24gc2V0SW5wdXQoaW5wdXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2xlc3MgPSB0aGlzLmRvbmUgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7IGZpcnN0X2xpbmU6IDEsIGZpcnN0X2NvbHVtbjogMCwgbGFzdF9saW5lOiAxLCBsYXN0X2NvbHVtbjogMCB9O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwgMF07XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eWxlbmcrKztcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQrKztcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChsaW5lcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNoO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgdW5wdXQ6IGZ1bmN0aW9uIHVucHV0KGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbiAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XHJcblx0ICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYyA9IHsgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgbW9yZTogZnVuY3Rpb24gbW9yZSgpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgbGVzczogZnVuY3Rpb24gbGVzcyhuKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uIHBhc3RJbnB1dCgpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbiB1cGNvbWluZ0lucHV0KCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IDIwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMCAtIG5leHQubGVuZ3RoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsIDIwKSArIChuZXh0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24gc2hvd1Bvc2l0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW5wdXQpIHRoaXMuZG9uZSA9IHRydWU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW4sIG1hdGNoLCB0ZW1wTWF0Y2gsIGluZGV4LCBjb2wsIGxpbmVzO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzKSB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jID0geyBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBydWxlc1tpbmRleF0sIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB0aGlzLmRvbmUgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbikgcmV0dXJuIHRva2VuO2Vsc2UgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHsgdGV4dDogXCJcIiwgdG9rZW46IG51bGwsIGxpbmU6IHRoaXMueXlsaW5lbm8gfSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGxleDogZnVuY3Rpb24gbGV4KCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBiZWdpbjogZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uIHBvcFN0YXRlKCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbiB0b3BTdGF0ZSgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAyXTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcclxuXHQgICAgICAgICAgICB9IH07XHJcblx0ICAgICAgICBsZXhlci5vcHRpb25zID0ge307XHJcblx0ICAgICAgICBsZXhlci5wZXJmb3JtQWN0aW9uID0gZnVuY3Rpb24gYW5vbnltb3VzKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUXHJcblx0ICAgICAgICAvKiovKSB7XHJcblxyXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHN0cmlwKHN0YXJ0LCBlbmQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cihzdGFydCwgeXlfLnl5bGVuZyAtIGVuZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB2YXIgWVlTVEFURSA9IFlZX1NUQVJUO1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAoJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoeXlfLnl5dGV4dC5zbGljZSgtMikgPT09IFwiXFxcXFxcXFxcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwKDAsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJtdVwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeXlfLnl5dGV4dC5zbGljZSgtMSkgPT09IFwiXFxcXFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAoMCwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihcImVtdVwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihcIm11XCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHl5Xy55eXRleHQpIHJldHVybiAxNTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbigncmF3Jyk7cmV0dXJuIDE1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSB1c2luZyBgdGhpcy50b3BTdGF0ZSgpYCBiZWxvdywgYnV0IGl0IGN1cnJlbnRseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0aGUgc2Vjb25kIHRvcCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCB0b3AuIE9wZW5lZCBhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaXNzdWUgYWJvdXQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL3phYWNoL2ppc29uL2lzc3Vlcy8yOTFcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0gPT09ICdyYXcnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoNSwgeXlfLnl5bGVuZyAtIDkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnRU5EX1JBV19CTE9DSyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDY6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA2NTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDg6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNjg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE5O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKCdyYXcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAyMztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxMTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA1NTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDYwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTM6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA0NztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiA0NDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE2OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiA0NDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTg6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMzk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA1MTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDIwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQ4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjE6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnVucHV0KHl5Xy55eXRleHQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbignY29tJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjM6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA3MztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDcyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjY6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHdoaXRlc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiA1NDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDMwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiAzMztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDMxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgeXlfLnl5dGV4dCA9IHN0cmlwKDEsIDIpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKTtyZXR1cm4gODA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSBzdHJpcCgxLCAyKS5yZXBsYWNlKC9cXFxcJy9nLCBcIidcIik7cmV0dXJuIDgwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzM6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gODU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA4MjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDgyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzY6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gODM7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDgxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzk6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0MDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA3NztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDcyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5yZXBsYWNlKC9cXFxcKFtcXFxcXFxdXSkvZywgJyQxJyk7cmV0dXJuIDcyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDM6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0lOVkFMSUQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBsZXhlci5ydWxlcyA9IFsvXig/OlteXFx4MDBdKj8oPz0oXFx7XFx7KSkpLywgL14oPzpbXlxceDAwXSspLywgL14oPzpbXlxceDAwXXsyLH0/KD89KFxce1xce3xcXFxcXFx7XFx7fFxcXFxcXFxcXFx7XFx7fCQpKSkvLCAvXig/Olxce1xce1xce1xceyg/PVteL10pKS8sIC9eKD86XFx7XFx7XFx7XFx7XFwvW15cXHMhXCIjJS0sXFwuXFwvOy0+QFxcWy1cXF5gXFx7LX5dKyg/PVs9fVxcc1xcLy5dKVxcfVxcfVxcfVxcfSkvLCAvXig/OlteXFx4MDBdKj8oPz0oXFx7XFx7XFx7XFx7KSkpLywgL14oPzpbXFxzXFxTXSo/LS0ofik/XFx9XFx9KS8sIC9eKD86XFwoKS8sIC9eKD86XFwpKS8sIC9eKD86XFx7XFx7XFx7XFx7KS8sIC9eKD86XFx9XFx9XFx9XFx9KS8sIC9eKD86XFx7XFx7KH4pPz4pLywgL14oPzpcXHtcXHsofik/Iz4pLywgL14oPzpcXHtcXHsofik/I1xcKj8pLywgL14oPzpcXHtcXHsofik/XFwvKS8sIC9eKD86XFx7XFx7KH4pP1xcXlxccyoofik/XFx9XFx9KS8sIC9eKD86XFx7XFx7KH4pP1xccyplbHNlXFxzKih+KT9cXH1cXH0pLywgL14oPzpcXHtcXHsofik/XFxeKS8sIC9eKD86XFx7XFx7KH4pP1xccyplbHNlXFxiKS8sIC9eKD86XFx7XFx7KH4pP1xceykvLCAvXig/Olxce1xceyh+KT8mKS8sIC9eKD86XFx7XFx7KH4pPyEtLSkvLCAvXig/Olxce1xceyh+KT8hW1xcc1xcU10qP1xcfVxcfSkvLCAvXig/Olxce1xceyh+KT9cXCo/KS8sIC9eKD86PSkvLCAvXig/OlxcLlxcLikvLCAvXig/OlxcLig/PShbPX59XFxzXFwvLil8XSkpKS8sIC9eKD86W1xcLy5dKS8sIC9eKD86XFxzKykvLCAvXig/OlxcfSh+KT9cXH1cXH0pLywgL14oPzoofik/XFx9XFx9KS8sIC9eKD86XCIoXFxcXFtcIl18W15cIl0pKlwiKS8sIC9eKD86JyhcXFxcWyddfFteJ10pKicpLywgL14oPzpAKS8sIC9eKD86dHJ1ZSg/PShbfn1cXHMpXSkpKS8sIC9eKD86ZmFsc2UoPz0oW359XFxzKV0pKSkvLCAvXig/OnVuZGVmaW5lZCg/PShbfn1cXHMpXSkpKS8sIC9eKD86bnVsbCg/PShbfn1cXHMpXSkpKS8sIC9eKD86LT9bMC05XSsoPzpcXC5bMC05XSspPyg/PShbfn1cXHMpXSkpKS8sIC9eKD86YXNcXHMrXFx8KS8sIC9eKD86XFx8KS8sIC9eKD86KFteXFxzIVwiIyUtLFxcLlxcLzstPkBcXFstXFxeYFxcey1+XSsoPz0oWz1+fVxcc1xcLy4pfF0pKSkpLywgL14oPzpcXFsoXFxcXFxcXXxbXlxcXV0pKlxcXSkvLCAvXig/Oi4pLywgL14oPzokKS9dO1xyXG5cdCAgICAgICAgbGV4ZXIuY29uZGl0aW9ucyA9IHsgXCJtdVwiOiB7IFwicnVsZXNcIjogWzcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LCAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NF0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiZW11XCI6IHsgXCJydWxlc1wiOiBbMl0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiY29tXCI6IHsgXCJydWxlc1wiOiBbNl0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwicmF3XCI6IHsgXCJydWxlc1wiOiBbMywgNCwgNV0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiSU5JVElBTFwiOiB7IFwicnVsZXNcIjogWzAsIDEsIDQ0XSwgXCJpbmNsdXNpdmVcIjogdHJ1ZSB9IH07XHJcblx0ICAgICAgICByZXR1cm4gbGV4ZXI7XHJcblx0ICAgIH0pKCk7XHJcblx0ICAgIHBhcnNlci5sZXhlciA9IGxleGVyO1xyXG5cdCAgICBmdW5jdGlvbiBQYXJzZXIoKSB7XHJcblx0ICAgICAgICB0aGlzLnl5ID0ge307XHJcblx0ICAgIH1QYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO3BhcnNlci5QYXJzZXIgPSBQYXJzZXI7XHJcblx0ICAgIHJldHVybiBuZXcgUGFyc2VyKCk7XHJcblx0fSkoKTtleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGhhbmRsZWJhcnM7XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNCAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF92aXNpdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XHJcblxyXG5cdHZhciBfdmlzaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpdG9yKTtcclxuXHJcblx0ZnVuY3Rpb24gV2hpdGVzcGFjZUNvbnRyb2woKSB7XHJcblx0ICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xyXG5cclxuXHQgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0fVxyXG5cdFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZSA9IG5ldyBfdmlzaXRvcjJbJ2RlZmF1bHQnXSgpO1xyXG5cclxuXHRXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XHJcblx0ICB2YXIgZG9TdGFuZGFsb25lID0gIXRoaXMub3B0aW9ucy5pZ25vcmVTdGFuZGFsb25lO1xyXG5cclxuXHQgIHZhciBpc1Jvb3QgPSAhdGhpcy5pc1Jvb3RTZWVuO1xyXG5cdCAgdGhpcy5pc1Jvb3RTZWVuID0gdHJ1ZTtcclxuXHJcblx0ICB2YXIgYm9keSA9IHByb2dyYW0uYm9keTtcclxuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gYm9keS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgdmFyIGN1cnJlbnQgPSBib2R5W2ldLFxyXG5cdCAgICAgICAgc3RyaXAgPSB0aGlzLmFjY2VwdChjdXJyZW50KTtcclxuXHJcblx0ICAgIGlmICghc3RyaXApIHtcclxuXHQgICAgICBjb250aW51ZTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIF9pc1ByZXZXaGl0ZXNwYWNlID0gaXNQcmV2V2hpdGVzcGFjZShib2R5LCBpLCBpc1Jvb3QpLFxyXG5cdCAgICAgICAgX2lzTmV4dFdoaXRlc3BhY2UgPSBpc05leHRXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCksXHJcblx0ICAgICAgICBvcGVuU3RhbmRhbG9uZSA9IHN0cmlwLm9wZW5TdGFuZGFsb25lICYmIF9pc1ByZXZXaGl0ZXNwYWNlLFxyXG5cdCAgICAgICAgY2xvc2VTdGFuZGFsb25lID0gc3RyaXAuY2xvc2VTdGFuZGFsb25lICYmIF9pc05leHRXaGl0ZXNwYWNlLFxyXG5cdCAgICAgICAgaW5saW5lU3RhbmRhbG9uZSA9IHN0cmlwLmlubGluZVN0YW5kYWxvbmUgJiYgX2lzUHJldldoaXRlc3BhY2UgJiYgX2lzTmV4dFdoaXRlc3BhY2U7XHJcblxyXG5cdCAgICBpZiAoc3RyaXAuY2xvc2UpIHtcclxuXHQgICAgICBvbWl0UmlnaHQoYm9keSwgaSwgdHJ1ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHN0cmlwLm9wZW4pIHtcclxuXHQgICAgICBvbWl0TGVmdChib2R5LCBpLCB0cnVlKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKGRvU3RhbmRhbG9uZSAmJiBpbmxpbmVTdGFuZGFsb25lKSB7XHJcblx0ICAgICAgb21pdFJpZ2h0KGJvZHksIGkpO1xyXG5cclxuXHQgICAgICBpZiAob21pdExlZnQoYm9keSwgaSkpIHtcclxuXHQgICAgICAgIC8vIElmIHdlIGFyZSBvbiBhIHN0YW5kYWxvbmUgbm9kZSwgc2F2ZSB0aGUgaW5kZW50IGluZm8gZm9yIHBhcnRpYWxzXHJcblx0ICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSAnUGFydGlhbFN0YXRlbWVudCcpIHtcclxuXHQgICAgICAgICAgLy8gUHVsbCBvdXQgdGhlIHdoaXRlc3BhY2UgZnJvbSB0aGUgZmluYWwgbGluZVxyXG5cdCAgICAgICAgICBjdXJyZW50LmluZGVudCA9IC8oWyBcXHRdKyQpLy5leGVjKGJvZHlbaSAtIDFdLm9yaWdpbmFsKVsxXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGRvU3RhbmRhbG9uZSAmJiBvcGVuU3RhbmRhbG9uZSkge1xyXG5cdCAgICAgIG9taXRSaWdodCgoY3VycmVudC5wcm9ncmFtIHx8IGN1cnJlbnQuaW52ZXJzZSkuYm9keSk7XHJcblxyXG5cdCAgICAgIC8vIFN0cmlwIG91dCB0aGUgcHJldmlvdXMgY29udGVudCBub2RlIGlmIGl0J3Mgd2hpdGVzcGFjZSBvbmx5XHJcblx0ICAgICAgb21pdExlZnQoYm9keSwgaSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGRvU3RhbmRhbG9uZSAmJiBjbG9zZVN0YW5kYWxvbmUpIHtcclxuXHQgICAgICAvLyBBbHdheXMgc3RyaXAgdGhlIG5leHQgbm9kZVxyXG5cdCAgICAgIG9taXRSaWdodChib2R5LCBpKTtcclxuXHJcblx0ICAgICAgb21pdExlZnQoKGN1cnJlbnQuaW52ZXJzZSB8fCBjdXJyZW50LnByb2dyYW0pLmJvZHkpO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblxyXG5cdCAgcmV0dXJuIHByb2dyYW07XHJcblx0fTtcclxuXHJcblx0V2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkJsb2NrU3RhdGVtZW50ID0gV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkRlY29yYXRvckJsb2NrID0gV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLlBhcnRpYWxCbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChibG9jaykge1xyXG5cdCAgdGhpcy5hY2NlcHQoYmxvY2sucHJvZ3JhbSk7XHJcblx0ICB0aGlzLmFjY2VwdChibG9jay5pbnZlcnNlKTtcclxuXHJcblx0ICAvLyBGaW5kIHRoZSBpbnZlcnNlIHByb2dyYW0gdGhhdCBpcyBpbnZvbGVkIHdpdGggd2hpdGVzcGFjZSBzdHJpcHBpbmcuXHJcblx0ICB2YXIgcHJvZ3JhbSA9IGJsb2NrLnByb2dyYW0gfHwgYmxvY2suaW52ZXJzZSxcclxuXHQgICAgICBpbnZlcnNlID0gYmxvY2sucHJvZ3JhbSAmJiBibG9jay5pbnZlcnNlLFxyXG5cdCAgICAgIGZpcnN0SW52ZXJzZSA9IGludmVyc2UsXHJcblx0ICAgICAgbGFzdEludmVyc2UgPSBpbnZlcnNlO1xyXG5cclxuXHQgIGlmIChpbnZlcnNlICYmIGludmVyc2UuY2hhaW5lZCkge1xyXG5cdCAgICBmaXJzdEludmVyc2UgPSBpbnZlcnNlLmJvZHlbMF0ucHJvZ3JhbTtcclxuXHJcblx0ICAgIC8vIFdhbGsgdGhlIGludmVyc2UgY2hhaW4gdG8gZmluZCB0aGUgbGFzdCBpbnZlcnNlIHRoYXQgaXMgYWN0dWFsbHkgaW4gdGhlIGNoYWluLlxyXG5cdCAgICB3aGlsZSAobGFzdEludmVyc2UuY2hhaW5lZCkge1xyXG5cdCAgICAgIGxhc3RJbnZlcnNlID0gbGFzdEludmVyc2UuYm9keVtsYXN0SW52ZXJzZS5ib2R5Lmxlbmd0aCAtIDFdLnByb2dyYW07XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICB2YXIgc3RyaXAgPSB7XHJcblx0ICAgIG9wZW46IGJsb2NrLm9wZW5TdHJpcC5vcGVuLFxyXG5cdCAgICBjbG9zZTogYmxvY2suY2xvc2VTdHJpcC5jbG9zZSxcclxuXHJcblx0ICAgIC8vIERldGVybWluZSB0aGUgc3RhbmRhbG9uZSBjYW5kaWFjeS4gQmFzaWNhbGx5IGZsYWcgb3VyIGNvbnRlbnQgYXMgYmVpbmcgcG9zc2libHkgc3RhbmRhbG9uZVxyXG5cdCAgICAvLyBzbyBvdXIgcGFyZW50IGNhbiBkZXRlcm1pbmUgaWYgd2UgYWN0dWFsbHkgYXJlIHN0YW5kYWxvbmVcclxuXHQgICAgb3BlblN0YW5kYWxvbmU6IGlzTmV4dFdoaXRlc3BhY2UocHJvZ3JhbS5ib2R5KSxcclxuXHQgICAgY2xvc2VTdGFuZGFsb25lOiBpc1ByZXZXaGl0ZXNwYWNlKChmaXJzdEludmVyc2UgfHwgcHJvZ3JhbSkuYm9keSlcclxuXHQgIH07XHJcblxyXG5cdCAgaWYgKGJsb2NrLm9wZW5TdHJpcC5jbG9zZSkge1xyXG5cdCAgICBvbWl0UmlnaHQocHJvZ3JhbS5ib2R5LCBudWxsLCB0cnVlKTtcclxuXHQgIH1cclxuXHJcblx0ICBpZiAoaW52ZXJzZSkge1xyXG5cdCAgICB2YXIgaW52ZXJzZVN0cmlwID0gYmxvY2suaW52ZXJzZVN0cmlwO1xyXG5cclxuXHQgICAgaWYgKGludmVyc2VTdHJpcC5vcGVuKSB7XHJcblx0ICAgICAgb21pdExlZnQocHJvZ3JhbS5ib2R5LCBudWxsLCB0cnVlKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKGludmVyc2VTdHJpcC5jbG9zZSkge1xyXG5cdCAgICAgIG9taXRSaWdodChmaXJzdEludmVyc2UuYm9keSwgbnVsbCwgdHJ1ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGJsb2NrLmNsb3NlU3RyaXAub3Blbikge1xyXG5cdCAgICAgIG9taXRMZWZ0KGxhc3RJbnZlcnNlLmJvZHksIG51bGwsIHRydWUpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBGaW5kIHN0YW5kYWxvbmUgZWxzZSBzdGF0bWVudHNcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlU3RhbmRhbG9uZSAmJiBpc1ByZXZXaGl0ZXNwYWNlKHByb2dyYW0uYm9keSkgJiYgaXNOZXh0V2hpdGVzcGFjZShmaXJzdEludmVyc2UuYm9keSkpIHtcclxuXHQgICAgICBvbWl0TGVmdChwcm9ncmFtLmJvZHkpO1xyXG5cdCAgICAgIG9taXRSaWdodChmaXJzdEludmVyc2UuYm9keSk7XHJcblx0ICAgIH1cclxuXHQgIH0gZWxzZSBpZiAoYmxvY2suY2xvc2VTdHJpcC5vcGVuKSB7XHJcblx0ICAgIG9taXRMZWZ0KHByb2dyYW0uYm9keSwgbnVsbCwgdHJ1ZSk7XHJcblx0ICB9XHJcblxyXG5cdCAgcmV0dXJuIHN0cmlwO1xyXG5cdH07XHJcblxyXG5cdFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5EZWNvcmF0b3IgPSBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuTXVzdGFjaGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobXVzdGFjaGUpIHtcclxuXHQgIHJldHVybiBtdXN0YWNoZS5zdHJpcDtcclxuXHR9O1xyXG5cclxuXHRXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUGFydGlhbFN0YXRlbWVudCA9IFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5Db21tZW50U3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICB2YXIgc3RyaXAgPSBub2RlLnN0cmlwIHx8IHt9O1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgaW5saW5lU3RhbmRhbG9uZTogdHJ1ZSxcclxuXHQgICAgb3Blbjogc3RyaXAub3BlbixcclxuXHQgICAgY2xvc2U6IHN0cmlwLmNsb3NlXHJcblx0ICB9O1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGlzUHJldldoaXRlc3BhY2UoYm9keSwgaSwgaXNSb290KSB7XHJcblx0ICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgIGkgPSBib2R5Lmxlbmd0aDtcclxuXHQgIH1cclxuXHJcblx0ICAvLyBOb2RlcyB0aGF0IGVuZCB3aXRoIG5ld2xpbmVzIGFyZSBjb25zaWRlcmVkIHdoaXRlc3BhY2UgKGJ1dCBhcmUgc3BlY2lhbFxyXG5cdCAgLy8gY2FzZWQgZm9yIHN0cmlwIG9wZXJhdGlvbnMpXHJcblx0ICB2YXIgcHJldiA9IGJvZHlbaSAtIDFdLFxyXG5cdCAgICAgIHNpYmxpbmcgPSBib2R5W2kgLSAyXTtcclxuXHQgIGlmICghcHJldikge1xyXG5cdCAgICByZXR1cm4gaXNSb290O1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChwcmV2LnR5cGUgPT09ICdDb250ZW50U3RhdGVtZW50Jykge1xyXG5cdCAgICByZXR1cm4gKHNpYmxpbmcgfHwgIWlzUm9vdCA/IC9cXHI/XFxuXFxzKj8kLyA6IC8oXnxcXHI/XFxuKVxccyo/JC8pLnRlc3QocHJldi5vcmlnaW5hbCk7XHJcblx0ICB9XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGlzTmV4dFdoaXRlc3BhY2UoYm9keSwgaSwgaXNSb290KSB7XHJcblx0ICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgIGkgPSAtMTtcclxuXHQgIH1cclxuXHJcblx0ICB2YXIgbmV4dCA9IGJvZHlbaSArIDFdLFxyXG5cdCAgICAgIHNpYmxpbmcgPSBib2R5W2kgKyAyXTtcclxuXHQgIGlmICghbmV4dCkge1xyXG5cdCAgICByZXR1cm4gaXNSb290O1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChuZXh0LnR5cGUgPT09ICdDb250ZW50U3RhdGVtZW50Jykge1xyXG5cdCAgICByZXR1cm4gKHNpYmxpbmcgfHwgIWlzUm9vdCA/IC9eXFxzKj9cXHI/XFxuLyA6IC9eXFxzKj8oXFxyP1xcbnwkKS8pLnRlc3QobmV4dC5vcmlnaW5hbCk7XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHQvLyBNYXJrcyB0aGUgbm9kZSB0byB0aGUgcmlnaHQgb2YgdGhlIHBvc2l0aW9uIGFzIG9taXR0ZWQuXHJcblx0Ly8gSS5lLiB7e2Zvb319JyAnIHdpbGwgbWFyayB0aGUgJyAnIG5vZGUgYXMgb21pdHRlZC5cclxuXHQvL1xyXG5cdC8vIElmIGkgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIG1hcmtlZCBhcyBzdWNoLlxyXG5cdC8vXHJcblx0Ly8gSWYgbXVsaXRwbGUgaXMgdHJ1dGh5IHRoZW4gYWxsIHdoaXRlc3BhY2Ugd2lsbCBiZSBzdHJpcHBlZCBvdXQgdW50aWwgbm9uLXdoaXRlc3BhY2VcclxuXHQvLyBjb250ZW50IGlzIG1ldC5cclxuXHRmdW5jdGlvbiBvbWl0UmlnaHQoYm9keSwgaSwgbXVsdGlwbGUpIHtcclxuXHQgIHZhciBjdXJyZW50ID0gYm9keVtpID09IG51bGwgPyAwIDogaSArIDFdO1xyXG5cdCAgaWYgKCFjdXJyZW50IHx8IGN1cnJlbnQudHlwZSAhPT0gJ0NvbnRlbnRTdGF0ZW1lbnQnIHx8ICFtdWx0aXBsZSAmJiBjdXJyZW50LnJpZ2h0U3RyaXBwZWQpIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBvcmlnaW5hbCA9IGN1cnJlbnQudmFsdWU7XHJcblx0ICBjdXJyZW50LnZhbHVlID0gY3VycmVudC52YWx1ZS5yZXBsYWNlKG11bHRpcGxlID8gL15cXHMrLyA6IC9eWyBcXHRdKlxccj9cXG4/LywgJycpO1xyXG5cdCAgY3VycmVudC5yaWdodFN0cmlwcGVkID0gY3VycmVudC52YWx1ZSAhPT0gb3JpZ2luYWw7XHJcblx0fVxyXG5cclxuXHQvLyBNYXJrcyB0aGUgbm9kZSB0byB0aGUgbGVmdCBvZiB0aGUgcG9zaXRpb24gYXMgb21pdHRlZC5cclxuXHQvLyBJLmUuICcgJ3t7Zm9vfX0gd2lsbCBtYXJrIHRoZSAnICcgbm9kZSBhcyBvbWl0dGVkLlxyXG5cdC8vXHJcblx0Ly8gSWYgaSBpcyB1bmRlZmluZWQgdGhlbiB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlIG1hcmtlZCBhcyBzdWNoLlxyXG5cdC8vXHJcblx0Ly8gSWYgbXVsaXRwbGUgaXMgdHJ1dGh5IHRoZW4gYWxsIHdoaXRlc3BhY2Ugd2lsbCBiZSBzdHJpcHBlZCBvdXQgdW50aWwgbm9uLXdoaXRlc3BhY2VcclxuXHQvLyBjb250ZW50IGlzIG1ldC5cclxuXHRmdW5jdGlvbiBvbWl0TGVmdChib2R5LCBpLCBtdWx0aXBsZSkge1xyXG5cdCAgdmFyIGN1cnJlbnQgPSBib2R5W2kgPT0gbnVsbCA/IGJvZHkubGVuZ3RoIC0gMSA6IGkgLSAxXTtcclxuXHQgIGlmICghY3VycmVudCB8fCBjdXJyZW50LnR5cGUgIT09ICdDb250ZW50U3RhdGVtZW50JyB8fCAhbXVsdGlwbGUgJiYgY3VycmVudC5sZWZ0U3RyaXBwZWQpIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cclxuXHQgIC8vIFdlIG9taXQgdGhlIGxhc3Qgbm9kZSBpZiBpdCdzIHdoaXRlc3BhY2Ugb25seSBhbmQgbm90IHByZWNlZWRlZCBieSBhIG5vbi1jb250ZW50IG5vZGUuXHJcblx0ICB2YXIgb3JpZ2luYWwgPSBjdXJyZW50LnZhbHVlO1xyXG5cdCAgY3VycmVudC52YWx1ZSA9IGN1cnJlbnQudmFsdWUucmVwbGFjZShtdWx0aXBsZSA/IC9cXHMrJC8gOiAvWyBcXHRdKyQvLCAnJyk7XHJcblx0ICBjdXJyZW50LmxlZnRTdHJpcHBlZCA9IGN1cnJlbnQudmFsdWUgIT09IG9yaWdpbmFsO1xyXG5cdCAgcmV0dXJuIGN1cnJlbnQubGVmdFN0cmlwcGVkO1xyXG5cdH1cclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gV2hpdGVzcGFjZUNvbnRyb2w7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9LFxyXG4vKiAyNSAqL1xyXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xyXG5cclxuXHRmdW5jdGlvbiBWaXNpdG9yKCkge1xyXG5cdCAgdGhpcy5wYXJlbnRzID0gW107XHJcblx0fVxyXG5cclxuXHRWaXNpdG9yLnByb3RvdHlwZSA9IHtcclxuXHQgIGNvbnN0cnVjdG9yOiBWaXNpdG9yLFxyXG5cdCAgbXV0YXRpbmc6IGZhbHNlLFxyXG5cclxuXHQgIC8vIFZpc2l0cyBhIGdpdmVuIHZhbHVlLiBJZiBtdXRhdGluZywgd2lsbCByZXBsYWNlIHRoZSB2YWx1ZSBpZiBuZWNlc3NhcnkuXHJcblx0ICBhY2NlcHRLZXk6IGZ1bmN0aW9uIGFjY2VwdEtleShub2RlLCBuYW1lKSB7XHJcblx0ICAgIHZhciB2YWx1ZSA9IHRoaXMuYWNjZXB0KG5vZGVbbmFtZV0pO1xyXG5cdCAgICBpZiAodGhpcy5tdXRhdGluZykge1xyXG5cdCAgICAgIC8vIEhhY2t5IHNhbml0eSBjaGVjazogVGhpcyBtYXkgaGF2ZSBhIGZldyBmYWxzZSBwb3NpdGl2ZXMgZm9yIHR5cGUgZm9yIHRoZSBoZWxwZXJcclxuXHQgICAgICAvLyBtZXRob2RzIGJ1dCB3aWxsIGdlbmVyYWxseSBkbyB0aGUgcmlnaHQgdGhpbmcgd2l0aG91dCBhIGxvdCBvZiBvdmVyaGVhZC5cclxuXHQgICAgICBpZiAodmFsdWUgJiYgIVZpc2l0b3IucHJvdG90eXBlW3ZhbHVlLnR5cGVdKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVW5leHBlY3RlZCBub2RlIHR5cGUgXCInICsgdmFsdWUudHlwZSArICdcIiBmb3VuZCB3aGVuIGFjY2VwdGluZyAnICsgbmFtZSArICcgb24gJyArIG5vZGUudHlwZSk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIG5vZGVbbmFtZV0gPSB2YWx1ZTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBQZXJmb3JtcyBhbiBhY2NlcHQgb3BlcmF0aW9uIHdpdGggYWRkZWQgc2FuaXR5IGNoZWNrIHRvIGVuc3VyZVxyXG5cdCAgLy8gcmVxdWlyZWQga2V5cyBhcmUgbm90IHJlbW92ZWQuXHJcblx0ICBhY2NlcHRSZXF1aXJlZDogZnVuY3Rpb24gYWNjZXB0UmVxdWlyZWQobm9kZSwgbmFtZSkge1xyXG5cdCAgICB0aGlzLmFjY2VwdEtleShub2RlLCBuYW1lKTtcclxuXHJcblx0ICAgIGlmICghbm9kZVtuYW1lXSkge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKG5vZGUudHlwZSArICcgcmVxdWlyZXMgJyArIG5hbWUpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFRyYXZlcnNlcyBhIGdpdmVuIGFycmF5LiBJZiBtdXRhdGluZywgZW1wdHkgcmVzcG5zZXMgd2lsbCBiZSByZW1vdmVkXHJcblx0ICAvLyBmb3IgY2hpbGQgZWxlbWVudHMuXHJcblx0ICBhY2NlcHRBcnJheTogZnVuY3Rpb24gYWNjZXB0QXJyYXkoYXJyYXkpIHtcclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgICB0aGlzLmFjY2VwdEtleShhcnJheSwgaSk7XHJcblxyXG5cdCAgICAgIGlmICghYXJyYXlbaV0pIHtcclxuXHQgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgIGktLTtcclxuXHQgICAgICAgIGwtLTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgYWNjZXB0OiBmdW5jdGlvbiBhY2NlcHQob2JqZWN0KSB7XHJcblx0ICAgIGlmICghb2JqZWN0KSB7XHJcblx0ICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogU2FuaXR5IGNvZGUgKi9cclxuXHQgICAgaWYgKCF0aGlzW29iamVjdC50eXBlXSkge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbmtub3duIHR5cGU6ICcgKyBvYmplY3QudHlwZSwgb2JqZWN0KTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKHRoaXMuY3VycmVudCkge1xyXG5cdCAgICAgIHRoaXMucGFyZW50cy51bnNoaWZ0KHRoaXMuY3VycmVudCk7XHJcblx0ICAgIH1cclxuXHQgICAgdGhpcy5jdXJyZW50ID0gb2JqZWN0O1xyXG5cclxuXHQgICAgdmFyIHJldCA9IHRoaXNbb2JqZWN0LnR5cGVdKG9iamVjdCk7XHJcblxyXG5cdCAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnBhcmVudHMuc2hpZnQoKTtcclxuXHJcblx0ICAgIGlmICghdGhpcy5tdXRhdGluZyB8fCByZXQpIHtcclxuXHQgICAgICByZXR1cm4gcmV0O1xyXG5cdCAgICB9IGVsc2UgaWYgKHJldCAhPT0gZmFsc2UpIHtcclxuXHQgICAgICByZXR1cm4gb2JqZWN0O1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIFByb2dyYW06IGZ1bmN0aW9uIFByb2dyYW0ocHJvZ3JhbSkge1xyXG5cdCAgICB0aGlzLmFjY2VwdEFycmF5KHByb2dyYW0uYm9keSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIE11c3RhY2hlU3RhdGVtZW50OiB2aXNpdFN1YkV4cHJlc3Npb24sXHJcblx0ICBEZWNvcmF0b3I6IHZpc2l0U3ViRXhwcmVzc2lvbixcclxuXHJcblx0ICBCbG9ja1N0YXRlbWVudDogdmlzaXRCbG9jayxcclxuXHQgIERlY29yYXRvckJsb2NrOiB2aXNpdEJsb2NrLFxyXG5cclxuXHQgIFBhcnRpYWxTdGF0ZW1lbnQ6IHZpc2l0UGFydGlhbCxcclxuXHQgIFBhcnRpYWxCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gUGFydGlhbEJsb2NrU3RhdGVtZW50KHBhcnRpYWwpIHtcclxuXHQgICAgdmlzaXRQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCk7XHJcblxyXG5cdCAgICB0aGlzLmFjY2VwdEtleShwYXJ0aWFsLCAncHJvZ3JhbScpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBDb250ZW50U3RhdGVtZW50OiBmdW5jdGlvbiBDb250ZW50U3RhdGVtZW50KCkgLyogY29udGVudCAqL3t9LFxyXG5cdCAgQ29tbWVudFN0YXRlbWVudDogZnVuY3Rpb24gQ29tbWVudFN0YXRlbWVudCgpIC8qIGNvbW1lbnQgKi97fSxcclxuXHJcblx0ICBTdWJFeHByZXNzaW9uOiB2aXNpdFN1YkV4cHJlc3Npb24sXHJcblxyXG5cdCAgUGF0aEV4cHJlc3Npb246IGZ1bmN0aW9uIFBhdGhFeHByZXNzaW9uKCkgLyogcGF0aCAqL3t9LFxyXG5cclxuXHQgIFN0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uIFN0cmluZ0xpdGVyYWwoKSAvKiBzdHJpbmcgKi97fSxcclxuXHQgIE51bWJlckxpdGVyYWw6IGZ1bmN0aW9uIE51bWJlckxpdGVyYWwoKSAvKiBudW1iZXIgKi97fSxcclxuXHQgIEJvb2xlYW5MaXRlcmFsOiBmdW5jdGlvbiBCb29sZWFuTGl0ZXJhbCgpIC8qIGJvb2wgKi97fSxcclxuXHQgIFVuZGVmaW5lZExpdGVyYWw6IGZ1bmN0aW9uIFVuZGVmaW5lZExpdGVyYWwoKSAvKiBsaXRlcmFsICove30sXHJcblx0ICBOdWxsTGl0ZXJhbDogZnVuY3Rpb24gTnVsbExpdGVyYWwoKSAvKiBsaXRlcmFsICove30sXHJcblxyXG5cdCAgSGFzaDogZnVuY3Rpb24gSGFzaChoYXNoKSB7XHJcblx0ICAgIHRoaXMuYWNjZXB0QXJyYXkoaGFzaC5wYWlycyk7XHJcblx0ICB9LFxyXG5cdCAgSGFzaFBhaXI6IGZ1bmN0aW9uIEhhc2hQYWlyKHBhaXIpIHtcclxuXHQgICAgdGhpcy5hY2NlcHRSZXF1aXJlZChwYWlyLCAndmFsdWUnKTtcclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiB2aXNpdFN1YkV4cHJlc3Npb24obXVzdGFjaGUpIHtcclxuXHQgIHRoaXMuYWNjZXB0UmVxdWlyZWQobXVzdGFjaGUsICdwYXRoJyk7XHJcblx0ICB0aGlzLmFjY2VwdEFycmF5KG11c3RhY2hlLnBhcmFtcyk7XHJcblx0ICB0aGlzLmFjY2VwdEtleShtdXN0YWNoZSwgJ2hhc2gnKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gdmlzaXRCbG9jayhibG9jaykge1xyXG5cdCAgdmlzaXRTdWJFeHByZXNzaW9uLmNhbGwodGhpcywgYmxvY2spO1xyXG5cclxuXHQgIHRoaXMuYWNjZXB0S2V5KGJsb2NrLCAncHJvZ3JhbScpO1xyXG5cdCAgdGhpcy5hY2NlcHRLZXkoYmxvY2ssICdpbnZlcnNlJyk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIHZpc2l0UGFydGlhbChwYXJ0aWFsKSB7XHJcblx0ICB0aGlzLmFjY2VwdFJlcXVpcmVkKHBhcnRpYWwsICduYW1lJyk7XHJcblx0ICB0aGlzLmFjY2VwdEFycmF5KHBhcnRpYWwucGFyYW1zKTtcclxuXHQgIHRoaXMuYWNjZXB0S2V5KHBhcnRpYWwsICdoYXNoJyk7XHJcblx0fVxyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBWaXNpdG9yO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSxcclxuLyogMjYgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0ZXhwb3J0cy5Tb3VyY2VMb2NhdGlvbiA9IFNvdXJjZUxvY2F0aW9uO1xyXG5cdGV4cG9ydHMuaWQgPSBpZDtcclxuXHRleHBvcnRzLnN0cmlwRmxhZ3MgPSBzdHJpcEZsYWdzO1xyXG5cdGV4cG9ydHMuc3RyaXBDb21tZW50ID0gc3RyaXBDb21tZW50O1xyXG5cdGV4cG9ydHMucHJlcGFyZVBhdGggPSBwcmVwYXJlUGF0aDtcclxuXHRleHBvcnRzLnByZXBhcmVNdXN0YWNoZSA9IHByZXBhcmVNdXN0YWNoZTtcclxuXHRleHBvcnRzLnByZXBhcmVSYXdCbG9jayA9IHByZXBhcmVSYXdCbG9jaztcclxuXHRleHBvcnRzLnByZXBhcmVCbG9jayA9IHByZXBhcmVCbG9jaztcclxuXHRleHBvcnRzLnByZXBhcmVQcm9ncmFtID0gcHJlcGFyZVByb2dyYW07XHJcblx0ZXhwb3J0cy5wcmVwYXJlUGFydGlhbEJsb2NrID0gcHJlcGFyZVBhcnRpYWxCbG9jaztcclxuXHJcblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xyXG5cclxuXHRmdW5jdGlvbiB2YWxpZGF0ZUNsb3NlKG9wZW4sIGNsb3NlKSB7XHJcblx0ICBjbG9zZSA9IGNsb3NlLnBhdGggPyBjbG9zZS5wYXRoLm9yaWdpbmFsIDogY2xvc2U7XHJcblxyXG5cdCAgaWYgKG9wZW4ucGF0aC5vcmlnaW5hbCAhPT0gY2xvc2UpIHtcclxuXHQgICAgdmFyIGVycm9yTm9kZSA9IHsgbG9jOiBvcGVuLnBhdGgubG9jIH07XHJcblxyXG5cdCAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXShvcGVuLnBhdGgub3JpZ2luYWwgKyBcIiBkb2Vzbid0IG1hdGNoIFwiICsgY2xvc2UsIGVycm9yTm9kZSk7XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihzb3VyY2UsIGxvY0luZm8pIHtcclxuXHQgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgdGhpcy5zdGFydCA9IHtcclxuXHQgICAgbGluZTogbG9jSW5mby5maXJzdF9saW5lLFxyXG5cdCAgICBjb2x1bW46IGxvY0luZm8uZmlyc3RfY29sdW1uXHJcblx0ICB9O1xyXG5cdCAgdGhpcy5lbmQgPSB7XHJcblx0ICAgIGxpbmU6IGxvY0luZm8ubGFzdF9saW5lLFxyXG5cdCAgICBjb2x1bW46IGxvY0luZm8ubGFzdF9jb2x1bW5cclxuXHQgIH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpZCh0b2tlbikge1xyXG5cdCAgaWYgKC9eXFxbLipcXF0kLy50ZXN0KHRva2VuKSkge1xyXG5cdCAgICByZXR1cm4gdG9rZW4uc3Vic3RyKDEsIHRva2VuLmxlbmd0aCAtIDIpO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc3RyaXBGbGFncyhvcGVuLCBjbG9zZSkge1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgb3Blbjogb3Blbi5jaGFyQXQoMikgPT09ICd+JyxcclxuXHQgICAgY2xvc2U6IGNsb3NlLmNoYXJBdChjbG9zZS5sZW5ndGggLSAzKSA9PT0gJ34nXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc3RyaXBDb21tZW50KGNvbW1lbnQpIHtcclxuXHQgIHJldHVybiBjb21tZW50LnJlcGxhY2UoL15cXHtcXHt+P1xcIS0/LT8vLCAnJykucmVwbGFjZSgvLT8tP34/XFx9XFx9JC8sICcnKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVQYXRoKGRhdGEsIHBhcnRzLCBsb2MpIHtcclxuXHQgIGxvYyA9IHRoaXMubG9jSW5mbyhsb2MpO1xyXG5cclxuXHQgIHZhciBvcmlnaW5hbCA9IGRhdGEgPyAnQCcgOiAnJyxcclxuXHQgICAgICBkaWcgPSBbXSxcclxuXHQgICAgICBkZXB0aCA9IDAsXHJcblx0ICAgICAgZGVwdGhTdHJpbmcgPSAnJztcclxuXHJcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICB2YXIgcGFydCA9IHBhcnRzW2ldLnBhcnQsXHJcblxyXG5cdCAgICAvLyBJZiB3ZSBoYXZlIFtdIHN5bnRheCB0aGVuIHdlIGRvIG5vdCB0cmVhdCBwYXRoIHJlZmVyZW5jZXMgYXMgb3BlcmF0b3JzLFxyXG5cdCAgICAvLyBpLmUuIGZvby5bdGhpc10gcmVzb2x2ZXMgdG8gYXBwcm94aW1hdGVseSBjb250ZXh0LmZvb1sndGhpcyddXHJcblx0ICAgIGlzTGl0ZXJhbCA9IHBhcnRzW2ldLm9yaWdpbmFsICE9PSBwYXJ0O1xyXG5cdCAgICBvcmlnaW5hbCArPSAocGFydHNbaV0uc2VwYXJhdG9yIHx8ICcnKSArIHBhcnQ7XHJcblxyXG5cdCAgICBpZiAoIWlzTGl0ZXJhbCAmJiAocGFydCA9PT0gJy4uJyB8fCBwYXJ0ID09PSAnLicgfHwgcGFydCA9PT0gJ3RoaXMnKSkge1xyXG5cdCAgICAgIGlmIChkaWcubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0ludmFsaWQgcGF0aDogJyArIG9yaWdpbmFsLCB7IGxvYzogbG9jIH0pO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xyXG5cdCAgICAgICAgZGVwdGgrKztcclxuXHQgICAgICAgIGRlcHRoU3RyaW5nICs9ICcuLi8nO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBkaWcucHVzaChwYXJ0KTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXHJcblx0ICAgIGRhdGE6IGRhdGEsXHJcblx0ICAgIGRlcHRoOiBkZXB0aCxcclxuXHQgICAgcGFydHM6IGRpZyxcclxuXHQgICAgb3JpZ2luYWw6IG9yaWdpbmFsLFxyXG5cdCAgICBsb2M6IGxvY1xyXG5cdCAgfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVNdXN0YWNoZShwYXRoLCBwYXJhbXMsIGhhc2gsIG9wZW4sIHN0cmlwLCBsb2NJbmZvKSB7XHJcblx0ICAvLyBNdXN0IHVzZSBjaGFyQXQgdG8gc3VwcG9ydCBJRSBwcmUtMTBcclxuXHQgIHZhciBlc2NhcGVGbGFnID0gb3Blbi5jaGFyQXQoMykgfHwgb3Blbi5jaGFyQXQoMiksXHJcblx0ICAgICAgZXNjYXBlZCA9IGVzY2FwZUZsYWcgIT09ICd7JyAmJiBlc2NhcGVGbGFnICE9PSAnJic7XHJcblxyXG5cdCAgdmFyIGRlY29yYXRvciA9IC9cXCovLnRlc3Qob3Blbik7XHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB0eXBlOiBkZWNvcmF0b3IgPyAnRGVjb3JhdG9yJyA6ICdNdXN0YWNoZVN0YXRlbWVudCcsXHJcblx0ICAgIHBhdGg6IHBhdGgsXHJcblx0ICAgIHBhcmFtczogcGFyYW1zLFxyXG5cdCAgICBoYXNoOiBoYXNoLFxyXG5cdCAgICBlc2NhcGVkOiBlc2NhcGVkLFxyXG5cdCAgICBzdHJpcDogc3RyaXAsXHJcblx0ICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlcGFyZVJhd0Jsb2NrKG9wZW5SYXdCbG9jaywgY29udGVudHMsIGNsb3NlLCBsb2NJbmZvKSB7XHJcblx0ICB2YWxpZGF0ZUNsb3NlKG9wZW5SYXdCbG9jaywgY2xvc2UpO1xyXG5cclxuXHQgIGxvY0luZm8gPSB0aGlzLmxvY0luZm8obG9jSW5mbyk7XHJcblx0ICB2YXIgcHJvZ3JhbSA9IHtcclxuXHQgICAgdHlwZTogJ1Byb2dyYW0nLFxyXG5cdCAgICBib2R5OiBjb250ZW50cyxcclxuXHQgICAgc3RyaXA6IHt9LFxyXG5cdCAgICBsb2M6IGxvY0luZm9cclxuXHQgIH07XHJcblxyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgdHlwZTogJ0Jsb2NrU3RhdGVtZW50JyxcclxuXHQgICAgcGF0aDogb3BlblJhd0Jsb2NrLnBhdGgsXHJcblx0ICAgIHBhcmFtczogb3BlblJhd0Jsb2NrLnBhcmFtcyxcclxuXHQgICAgaGFzaDogb3BlblJhd0Jsb2NrLmhhc2gsXHJcblx0ICAgIHByb2dyYW06IHByb2dyYW0sXHJcblx0ICAgIG9wZW5TdHJpcDoge30sXHJcblx0ICAgIGludmVyc2VTdHJpcDoge30sXHJcblx0ICAgIGNsb3NlU3RyaXA6IHt9LFxyXG5cdCAgICBsb2M6IGxvY0luZm9cclxuXHQgIH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVwYXJlQmxvY2sob3BlbkJsb2NrLCBwcm9ncmFtLCBpbnZlcnNlQW5kUHJvZ3JhbSwgY2xvc2UsIGludmVydGVkLCBsb2NJbmZvKSB7XHJcblx0ICBpZiAoY2xvc2UgJiYgY2xvc2UucGF0aCkge1xyXG5cdCAgICB2YWxpZGF0ZUNsb3NlKG9wZW5CbG9jaywgY2xvc2UpO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBkZWNvcmF0b3IgPSAvXFwqLy50ZXN0KG9wZW5CbG9jay5vcGVuKTtcclxuXHJcblx0ICBwcm9ncmFtLmJsb2NrUGFyYW1zID0gb3BlbkJsb2NrLmJsb2NrUGFyYW1zO1xyXG5cclxuXHQgIHZhciBpbnZlcnNlID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgIGludmVyc2VTdHJpcCA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICBpZiAoaW52ZXJzZUFuZFByb2dyYW0pIHtcclxuXHQgICAgaWYgKGRlY29yYXRvcikge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbmV4cGVjdGVkIGludmVyc2UgYmxvY2sgb24gZGVjb3JhdG9yJywgaW52ZXJzZUFuZFByb2dyYW0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoaW52ZXJzZUFuZFByb2dyYW0uY2hhaW4pIHtcclxuXHQgICAgICBpbnZlcnNlQW5kUHJvZ3JhbS5wcm9ncmFtLmJvZHlbMF0uY2xvc2VTdHJpcCA9IGNsb3NlLnN0cmlwO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpbnZlcnNlU3RyaXAgPSBpbnZlcnNlQW5kUHJvZ3JhbS5zdHJpcDtcclxuXHQgICAgaW52ZXJzZSA9IGludmVyc2VBbmRQcm9ncmFtLnByb2dyYW07XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKGludmVydGVkKSB7XHJcblx0ICAgIGludmVydGVkID0gaW52ZXJzZTtcclxuXHQgICAgaW52ZXJzZSA9IHByb2dyYW07XHJcblx0ICAgIHByb2dyYW0gPSBpbnZlcnRlZDtcclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB0eXBlOiBkZWNvcmF0b3IgPyAnRGVjb3JhdG9yQmxvY2snIDogJ0Jsb2NrU3RhdGVtZW50JyxcclxuXHQgICAgcGF0aDogb3BlbkJsb2NrLnBhdGgsXHJcblx0ICAgIHBhcmFtczogb3BlbkJsb2NrLnBhcmFtcyxcclxuXHQgICAgaGFzaDogb3BlbkJsb2NrLmhhc2gsXHJcblx0ICAgIHByb2dyYW06IHByb2dyYW0sXHJcblx0ICAgIGludmVyc2U6IGludmVyc2UsXHJcblx0ICAgIG9wZW5TdHJpcDogb3BlbkJsb2NrLnN0cmlwLFxyXG5cdCAgICBpbnZlcnNlU3RyaXA6IGludmVyc2VTdHJpcCxcclxuXHQgICAgY2xvc2VTdHJpcDogY2xvc2UgJiYgY2xvc2Uuc3RyaXAsXHJcblx0ICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlcGFyZVByb2dyYW0oc3RhdGVtZW50cywgbG9jKSB7XHJcblx0ICBpZiAoIWxvYyAmJiBzdGF0ZW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICB2YXIgZmlyc3RMb2MgPSBzdGF0ZW1lbnRzWzBdLmxvYyxcclxuXHQgICAgICAgIGxhc3RMb2MgPSBzdGF0ZW1lbnRzW3N0YXRlbWVudHMubGVuZ3RoIC0gMV0ubG9jO1xyXG5cclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgICAgaWYgKGZpcnN0TG9jICYmIGxhc3RMb2MpIHtcclxuXHQgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICBzb3VyY2U6IGZpcnN0TG9jLnNvdXJjZSxcclxuXHQgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgIGxpbmU6IGZpcnN0TG9jLnN0YXJ0LmxpbmUsXHJcblx0ICAgICAgICAgIGNvbHVtbjogZmlyc3RMb2Muc3RhcnQuY29sdW1uXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgIGxpbmU6IGxhc3RMb2MuZW5kLmxpbmUsXHJcblx0ICAgICAgICAgIGNvbHVtbjogbGFzdExvYy5lbmQuY29sdW1uXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHR5cGU6ICdQcm9ncmFtJyxcclxuXHQgICAgYm9keTogc3RhdGVtZW50cyxcclxuXHQgICAgc3RyaXA6IHt9LFxyXG5cdCAgICBsb2M6IGxvY1xyXG5cdCAgfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVQYXJ0aWFsQmxvY2sob3BlbiwgcHJvZ3JhbSwgY2xvc2UsIGxvY0luZm8pIHtcclxuXHQgIHZhbGlkYXRlQ2xvc2Uob3BlbiwgY2xvc2UpO1xyXG5cclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHR5cGU6ICdQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQnLFxyXG5cdCAgICBuYW1lOiBvcGVuLnBhdGgsXHJcblx0ICAgIHBhcmFtczogb3Blbi5wYXJhbXMsXHJcblx0ICAgIGhhc2g6IG9wZW4uaGFzaCxcclxuXHQgICAgcHJvZ3JhbTogcHJvZ3JhbSxcclxuXHQgICAgb3BlblN0cmlwOiBvcGVuLnN0cmlwLFxyXG5cdCAgICBjbG9zZVN0cmlwOiBjbG9zZSAmJiBjbG9zZS5zdHJpcCxcclxuXHQgICAgbG9jOiB0aGlzLmxvY0luZm8obG9jSW5mbylcclxuXHQgIH07XHJcblx0fVxyXG5cclxuLyoqKi8gfSxcclxuLyogMjcgKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLkNvbXBpbGVyID0gQ29tcGlsZXI7XHJcblx0ZXhwb3J0cy5wcmVjb21waWxlID0gcHJlY29tcGlsZTtcclxuXHRleHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHR2YXIgX2FzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG5cclxuXHR2YXIgX2FzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3QpO1xyXG5cclxuXHR2YXIgc2xpY2UgPSBbXS5zbGljZTtcclxuXHJcblx0ZnVuY3Rpb24gQ29tcGlsZXIoKSB7fVxyXG5cclxuXHQvLyB0aGUgZm91bmRIZWxwZXIgcmVnaXN0ZXIgd2lsbCBkaXNhbWJpZ3VhdGUgaGVscGVyIGxvb2t1cCBmcm9tIGZpbmRpbmcgYVxyXG5cdC8vIGZ1bmN0aW9uIGluIGEgY29udGV4dC4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIG11c3RhY2hlIGNvbXBhdGliaWxpdHksIHdoaWNoXHJcblx0Ly8gcmVxdWlyZXMgdGhhdCBjb250ZXh0IGZ1bmN0aW9ucyBpbiBibG9ja3MgYXJlIGV2YWx1YXRlZCBieSBibG9ja0hlbHBlck1pc3NpbmcsXHJcblx0Ly8gYW5kIHRoZW4gcHJvY2VlZCBhcyBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIHdhcyBwcm92aWRlZCB0byBibG9ja0hlbHBlck1pc3NpbmcuXHJcblxyXG5cdENvbXBpbGVyLnByb3RvdHlwZSA9IHtcclxuXHQgIGNvbXBpbGVyOiBDb21waWxlcixcclxuXHJcblx0ICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG5cdCAgICB2YXIgbGVuID0gdGhpcy5vcGNvZGVzLmxlbmd0aDtcclxuXHQgICAgaWYgKG90aGVyLm9wY29kZXMubGVuZ3RoICE9PSBsZW4pIHtcclxuXHQgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICB2YXIgb3Bjb2RlID0gdGhpcy5vcGNvZGVzW2ldLFxyXG5cdCAgICAgICAgICBvdGhlck9wY29kZSA9IG90aGVyLm9wY29kZXNbaV07XHJcblx0ICAgICAgaWYgKG9wY29kZS5vcGNvZGUgIT09IG90aGVyT3Bjb2RlLm9wY29kZSB8fCAhYXJnRXF1YWxzKG9wY29kZS5hcmdzLCBvdGhlck9wY29kZS5hcmdzKSkge1xyXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgLy8gV2Uga25vdyB0aGF0IGxlbmd0aCBpcyB0aGUgc2FtZSBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgdGllZFxyXG5cdCAgICAvLyB0byB0aGUgb3Bjb2RlIGJlaGF2aW9yIGFib3ZlLlxyXG5cdCAgICBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIGlmICghdGhpcy5jaGlsZHJlbltpXS5lcXVhbHMob3RoZXIuY2hpbGRyZW5baV0pKSB7XHJcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0sXHJcblxyXG5cdCAgZ3VpZDogMCxcclxuXHJcblx0ICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHByb2dyYW0sIG9wdGlvbnMpIHtcclxuXHQgICAgdGhpcy5zb3VyY2VOb2RlID0gW107XHJcblx0ICAgIHRoaXMub3Bjb2RlcyA9IFtdO1xyXG5cdCAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblx0ICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0ICAgIHRoaXMuc3RyaW5nUGFyYW1zID0gb3B0aW9ucy5zdHJpbmdQYXJhbXM7XHJcblx0ICAgIHRoaXMudHJhY2tJZHMgPSBvcHRpb25zLnRyYWNrSWRzO1xyXG5cclxuXHQgICAgb3B0aW9ucy5ibG9ja1BhcmFtcyA9IG9wdGlvbnMuYmxvY2tQYXJhbXMgfHwgW107XHJcblxyXG5cdCAgICAvLyBUaGVzZSBjaGFuZ2VzIHdpbGwgcHJvcGFnYXRlIHRvIHRoZSBvdGhlciBjb21waWxlciBjb21wb25lbnRzXHJcblx0ICAgIHZhciBrbm93bkhlbHBlcnMgPSBvcHRpb25zLmtub3duSGVscGVycztcclxuXHQgICAgb3B0aW9ucy5rbm93bkhlbHBlcnMgPSB7XHJcblx0ICAgICAgJ2hlbHBlck1pc3NpbmcnOiB0cnVlLFxyXG5cdCAgICAgICdibG9ja0hlbHBlck1pc3NpbmcnOiB0cnVlLFxyXG5cdCAgICAgICdlYWNoJzogdHJ1ZSxcclxuXHQgICAgICAnaWYnOiB0cnVlLFxyXG5cdCAgICAgICd1bmxlc3MnOiB0cnVlLFxyXG5cdCAgICAgICd3aXRoJzogdHJ1ZSxcclxuXHQgICAgICAnbG9nJzogdHJ1ZSxcclxuXHQgICAgICAnbG9va3VwJzogdHJ1ZVxyXG5cdCAgICB9O1xyXG5cdCAgICBpZiAoa25vd25IZWxwZXJzKSB7XHJcblx0ICAgICAgZm9yICh2YXIgX25hbWUgaW4ga25vd25IZWxwZXJzKSB7XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgICAgICAgaWYgKF9uYW1lIGluIGtub3duSGVscGVycykge1xyXG5cdCAgICAgICAgICBvcHRpb25zLmtub3duSGVscGVyc1tfbmFtZV0gPSBrbm93bkhlbHBlcnNbX25hbWVdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuIHRoaXMuYWNjZXB0KHByb2dyYW0pO1xyXG5cdCAgfSxcclxuXHJcblx0ICBjb21waWxlUHJvZ3JhbTogZnVuY3Rpb24gY29tcGlsZVByb2dyYW0ocHJvZ3JhbSkge1xyXG5cdCAgICB2YXIgY2hpbGRDb21waWxlciA9IG5ldyB0aGlzLmNvbXBpbGVyKCksXHJcblx0ICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcclxuXHQgICAgcmVzdWx0ID0gY2hpbGRDb21waWxlci5jb21waWxlKHByb2dyYW0sIHRoaXMub3B0aW9ucyksXHJcblx0ICAgICAgICBndWlkID0gdGhpcy5ndWlkKys7XHJcblxyXG5cdCAgICB0aGlzLnVzZVBhcnRpYWwgPSB0aGlzLnVzZVBhcnRpYWwgfHwgcmVzdWx0LnVzZVBhcnRpYWw7XHJcblxyXG5cdCAgICB0aGlzLmNoaWxkcmVuW2d1aWRdID0gcmVzdWx0O1xyXG5cdCAgICB0aGlzLnVzZURlcHRocyA9IHRoaXMudXNlRGVwdGhzIHx8IHJlc3VsdC51c2VEZXB0aHM7XHJcblxyXG5cdCAgICByZXR1cm4gZ3VpZDtcclxuXHQgIH0sXHJcblxyXG5cdCAgYWNjZXB0OiBmdW5jdGlvbiBhY2NlcHQobm9kZSkge1xyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogU2FuaXR5IGNvZGUgKi9cclxuXHQgICAgaWYgKCF0aGlzW25vZGUudHlwZV0pIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVW5rbm93biB0eXBlOiAnICsgbm9kZS50eXBlLCBub2RlKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5zb3VyY2VOb2RlLnVuc2hpZnQobm9kZSk7XHJcblx0ICAgIHZhciByZXQgPSB0aGlzW25vZGUudHlwZV0obm9kZSk7XHJcblx0ICAgIHRoaXMuc291cmNlTm9kZS5zaGlmdCgpO1xyXG5cdCAgICByZXR1cm4gcmV0O1xyXG5cdCAgfSxcclxuXHJcblx0ICBQcm9ncmFtOiBmdW5jdGlvbiBQcm9ncmFtKHByb2dyYW0pIHtcclxuXHQgICAgdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zLnVuc2hpZnQocHJvZ3JhbS5ibG9ja1BhcmFtcyk7XHJcblxyXG5cdCAgICB2YXIgYm9keSA9IHByb2dyYW0uYm9keSxcclxuXHQgICAgICAgIGJvZHlMZW5ndGggPSBib2R5Lmxlbmd0aDtcclxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5TGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICB0aGlzLmFjY2VwdChib2R5W2ldKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zLnNoaWZ0KCk7XHJcblxyXG5cdCAgICB0aGlzLmlzU2ltcGxlID0gYm9keUxlbmd0aCA9PT0gMTtcclxuXHQgICAgdGhpcy5ibG9ja1BhcmFtcyA9IHByb2dyYW0uYmxvY2tQYXJhbXMgPyBwcm9ncmFtLmJsb2NrUGFyYW1zLmxlbmd0aCA6IDA7XHJcblxyXG5cdCAgICByZXR1cm4gdGhpcztcclxuXHQgIH0sXHJcblxyXG5cdCAgQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIEJsb2NrU3RhdGVtZW50KGJsb2NrKSB7XHJcblx0ICAgIHRyYW5zZm9ybUxpdGVyYWxUb1BhdGgoYmxvY2spO1xyXG5cclxuXHQgICAgdmFyIHByb2dyYW0gPSBibG9jay5wcm9ncmFtLFxyXG5cdCAgICAgICAgaW52ZXJzZSA9IGJsb2NrLmludmVyc2U7XHJcblxyXG5cdCAgICBwcm9ncmFtID0gcHJvZ3JhbSAmJiB0aGlzLmNvbXBpbGVQcm9ncmFtKHByb2dyYW0pO1xyXG5cdCAgICBpbnZlcnNlID0gaW52ZXJzZSAmJiB0aGlzLmNvbXBpbGVQcm9ncmFtKGludmVyc2UpO1xyXG5cclxuXHQgICAgdmFyIHR5cGUgPSB0aGlzLmNsYXNzaWZ5U2V4cHIoYmxvY2spO1xyXG5cclxuXHQgICAgaWYgKHR5cGUgPT09ICdoZWxwZXInKSB7XHJcblx0ICAgICAgdGhpcy5oZWxwZXJTZXhwcihibG9jaywgcHJvZ3JhbSwgaW52ZXJzZSk7XHJcblx0ICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3NpbXBsZScpIHtcclxuXHQgICAgICB0aGlzLnNpbXBsZVNleHByKGJsb2NrKTtcclxuXHJcblx0ICAgICAgLy8gbm93IHRoYXQgdGhlIHNpbXBsZSBtdXN0YWNoZSBpcyByZXNvbHZlZCwgd2UgbmVlZCB0b1xyXG5cdCAgICAgIC8vIGV2YWx1YXRlIGl0IGJ5IGV4ZWN1dGluZyBgYmxvY2tIZWxwZXJNaXNzaW5nYFxyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIHByb2dyYW0pO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdlbXB0eUhhc2gnKTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnYmxvY2tWYWx1ZScsIGJsb2NrLnBhdGgub3JpZ2luYWwpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMuYW1iaWd1b3VzU2V4cHIoYmxvY2ssIHByb2dyYW0sIGludmVyc2UpO1xyXG5cclxuXHQgICAgICAvLyBub3cgdGhhdCB0aGUgc2ltcGxlIG11c3RhY2hlIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvXHJcblx0ICAgICAgLy8gZXZhbHVhdGUgaXQgYnkgZXhlY3V0aW5nIGBibG9ja0hlbHBlck1pc3NpbmdgXHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgaW52ZXJzZSk7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2VtcHR5SGFzaCcpO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdhbWJpZ3VvdXNCbG9ja1ZhbHVlJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMub3Bjb2RlKCdhcHBlbmQnKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgRGVjb3JhdG9yQmxvY2s6IGZ1bmN0aW9uIERlY29yYXRvckJsb2NrKGRlY29yYXRvcikge1xyXG5cdCAgICB2YXIgcHJvZ3JhbSA9IGRlY29yYXRvci5wcm9ncmFtICYmIHRoaXMuY29tcGlsZVByb2dyYW0oZGVjb3JhdG9yLnByb2dyYW0pO1xyXG5cdCAgICB2YXIgcGFyYW1zID0gdGhpcy5zZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyhkZWNvcmF0b3IsIHByb2dyYW0sIHVuZGVmaW5lZCksXHJcblx0ICAgICAgICBwYXRoID0gZGVjb3JhdG9yLnBhdGg7XHJcblxyXG5cdCAgICB0aGlzLnVzZURlY29yYXRvcnMgPSB0cnVlO1xyXG5cdCAgICB0aGlzLm9wY29kZSgncmVnaXN0ZXJEZWNvcmF0b3InLCBwYXJhbXMubGVuZ3RoLCBwYXRoLm9yaWdpbmFsKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgUGFydGlhbFN0YXRlbWVudDogZnVuY3Rpb24gUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsKSB7XHJcblx0ICAgIHRoaXMudXNlUGFydGlhbCA9IHRydWU7XHJcblxyXG5cdCAgICB2YXIgcHJvZ3JhbSA9IHBhcnRpYWwucHJvZ3JhbTtcclxuXHQgICAgaWYgKHByb2dyYW0pIHtcclxuXHQgICAgICBwcm9ncmFtID0gdGhpcy5jb21waWxlUHJvZ3JhbShwYXJ0aWFsLnByb2dyYW0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgcGFyYW1zID0gcGFydGlhbC5wYXJhbXM7XHJcblx0ICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMSkge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbnN1cHBvcnRlZCBudW1iZXIgb2YgcGFydGlhbCBhcmd1bWVudHM6ICcgKyBwYXJhbXMubGVuZ3RoLCBwYXJ0aWFsKTtcclxuXHQgICAgfSBlbHNlIGlmICghcGFyYW1zLmxlbmd0aCkge1xyXG5cdCAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwbGljaXRQYXJ0aWFsQ29udGV4dCkge1xyXG5cdCAgICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hMaXRlcmFsJywgJ3VuZGVmaW5lZCcpO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBwYXJhbXMucHVzaCh7IHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsIHBhcnRzOiBbXSwgZGVwdGg6IDAgfSk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgcGFydGlhbE5hbWUgPSBwYXJ0aWFsLm5hbWUub3JpZ2luYWwsXHJcblx0ICAgICAgICBpc0R5bmFtaWMgPSBwYXJ0aWFsLm5hbWUudHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nO1xyXG5cdCAgICBpZiAoaXNEeW5hbWljKSB7XHJcblx0ICAgICAgdGhpcy5hY2NlcHQocGFydGlhbC5uYW1lKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5zZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyhwYXJ0aWFsLCBwcm9ncmFtLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cclxuXHQgICAgdmFyIGluZGVudCA9IHBhcnRpYWwuaW5kZW50IHx8ICcnO1xyXG5cdCAgICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnRJbmRlbnQgJiYgaW5kZW50KSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2FwcGVuZENvbnRlbnQnLCBpbmRlbnQpO1xyXG5cdCAgICAgIGluZGVudCA9ICcnO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLm9wY29kZSgnaW52b2tlUGFydGlhbCcsIGlzRHluYW1pYywgcGFydGlhbE5hbWUsIGluZGVudCk7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdhcHBlbmQnKTtcclxuXHQgIH0sXHJcblx0ICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIFBhcnRpYWxCbG9ja1N0YXRlbWVudChwYXJ0aWFsQmxvY2spIHtcclxuXHQgICAgdGhpcy5QYXJ0aWFsU3RhdGVtZW50KHBhcnRpYWxCbG9jayk7XHJcblx0ICB9LFxyXG5cclxuXHQgIE11c3RhY2hlU3RhdGVtZW50OiBmdW5jdGlvbiBNdXN0YWNoZVN0YXRlbWVudChtdXN0YWNoZSkge1xyXG5cdCAgICB0aGlzLlN1YkV4cHJlc3Npb24obXVzdGFjaGUpO1xyXG5cclxuXHQgICAgaWYgKG11c3RhY2hlLmVzY2FwZWQgJiYgIXRoaXMub3B0aW9ucy5ub0VzY2FwZSkge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRFc2NhcGVkJyk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2FwcGVuZCcpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgRGVjb3JhdG9yOiBmdW5jdGlvbiBEZWNvcmF0b3IoZGVjb3JhdG9yKSB7XHJcblx0ICAgIHRoaXMuRGVjb3JhdG9yQmxvY2soZGVjb3JhdG9yKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgQ29udGVudFN0YXRlbWVudDogZnVuY3Rpb24gQ29udGVudFN0YXRlbWVudChjb250ZW50KSB7XHJcblx0ICAgIGlmIChjb250ZW50LnZhbHVlKSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2FwcGVuZENvbnRlbnQnLCBjb250ZW50LnZhbHVlKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBDb21tZW50U3RhdGVtZW50OiBmdW5jdGlvbiBDb21tZW50U3RhdGVtZW50KCkge30sXHJcblxyXG5cdCAgU3ViRXhwcmVzc2lvbjogZnVuY3Rpb24gU3ViRXhwcmVzc2lvbihzZXhwcikge1xyXG5cdCAgICB0cmFuc2Zvcm1MaXRlcmFsVG9QYXRoKHNleHByKTtcclxuXHQgICAgdmFyIHR5cGUgPSB0aGlzLmNsYXNzaWZ5U2V4cHIoc2V4cHIpO1xyXG5cclxuXHQgICAgaWYgKHR5cGUgPT09ICdzaW1wbGUnKSB7XHJcblx0ICAgICAgdGhpcy5zaW1wbGVTZXhwcihzZXhwcik7XHJcblx0ICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2hlbHBlcicpIHtcclxuXHQgICAgICB0aGlzLmhlbHBlclNleHByKHNleHByKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLmFtYmlndW91c1NleHByKHNleHByKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIGFtYmlndW91c1NleHByOiBmdW5jdGlvbiBhbWJpZ3VvdXNTZXhwcihzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSkge1xyXG5cdCAgICB2YXIgcGF0aCA9IHNleHByLnBhdGgsXHJcblx0ICAgICAgICBuYW1lID0gcGF0aC5wYXJ0c1swXSxcclxuXHQgICAgICAgIGlzQmxvY2sgPSBwcm9ncmFtICE9IG51bGwgfHwgaW52ZXJzZSAhPSBudWxsO1xyXG5cclxuXHQgICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCBwYXRoLmRlcHRoKTtcclxuXHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIHByb2dyYW0pO1xyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcclxuXHJcblx0ICAgIHBhdGguc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgdGhpcy5hY2NlcHQocGF0aCk7XHJcblxyXG5cdCAgICB0aGlzLm9wY29kZSgnaW52b2tlQW1iaWd1b3VzJywgbmFtZSwgaXNCbG9jayk7XHJcblx0ICB9LFxyXG5cclxuXHQgIHNpbXBsZVNleHByOiBmdW5jdGlvbiBzaW1wbGVTZXhwcihzZXhwcikge1xyXG5cdCAgICB2YXIgcGF0aCA9IHNleHByLnBhdGg7XHJcblx0ICAgIHBhdGguc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgdGhpcy5hY2NlcHQocGF0aCk7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdyZXNvbHZlUG9zc2libGVMYW1iZGEnKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgaGVscGVyU2V4cHI6IGZ1bmN0aW9uIGhlbHBlclNleHByKHNleHByLCBwcm9ncmFtLCBpbnZlcnNlKSB7XHJcblx0ICAgIHZhciBwYXJhbXMgPSB0aGlzLnNldHVwRnVsbE11c3RhY2hlUGFyYW1zKHNleHByLCBwcm9ncmFtLCBpbnZlcnNlKSxcclxuXHQgICAgICAgIHBhdGggPSBzZXhwci5wYXRoLFxyXG5cdCAgICAgICAgbmFtZSA9IHBhdGgucGFydHNbMF07XHJcblxyXG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmtub3duSGVscGVyc1tuYW1lXSkge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdpbnZva2VLbm93bkhlbHBlcicsIHBhcmFtcy5sZW5ndGgsIG5hbWUpO1xyXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5rbm93bkhlbHBlcnNPbmx5KSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1lvdSBzcGVjaWZpZWQga25vd25IZWxwZXJzT25seSwgYnV0IHVzZWQgdGhlIHVua25vd24gaGVscGVyICcgKyBuYW1lLCBzZXhwcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcGF0aC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICAgIHBhdGguZmFsc3kgPSB0cnVlO1xyXG5cclxuXHQgICAgICB0aGlzLmFjY2VwdChwYXRoKTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnaW52b2tlSGVscGVyJywgcGFyYW1zLmxlbmd0aCwgcGF0aC5vcmlnaW5hbCwgX2FzdDJbJ2RlZmF1bHQnXS5oZWxwZXJzLnNpbXBsZUlkKHBhdGgpKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBQYXRoRXhwcmVzc2lvbjogZnVuY3Rpb24gUGF0aEV4cHJlc3Npb24ocGF0aCkge1xyXG5cdCAgICB0aGlzLmFkZERlcHRoKHBhdGguZGVwdGgpO1xyXG5cdCAgICB0aGlzLm9wY29kZSgnZ2V0Q29udGV4dCcsIHBhdGguZGVwdGgpO1xyXG5cclxuXHQgICAgdmFyIG5hbWUgPSBwYXRoLnBhcnRzWzBdLFxyXG5cdCAgICAgICAgc2NvcGVkID0gX2FzdDJbJ2RlZmF1bHQnXS5oZWxwZXJzLnNjb3BlZElkKHBhdGgpLFxyXG5cdCAgICAgICAgYmxvY2tQYXJhbUlkID0gIXBhdGguZGVwdGggJiYgIXNjb3BlZCAmJiB0aGlzLmJsb2NrUGFyYW1JbmRleChuYW1lKTtcclxuXHJcblx0ICAgIGlmIChibG9ja1BhcmFtSWQpIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnbG9va3VwQmxvY2tQYXJhbScsIGJsb2NrUGFyYW1JZCwgcGF0aC5wYXJ0cyk7XHJcblx0ICAgIH0gZWxzZSBpZiAoIW5hbWUpIHtcclxuXHQgICAgICAvLyBDb250ZXh0IHJlZmVyZW5jZSwgaS5lLiBge3tmb28gLn19YCBvciBge3tmb28gLi59fWBcclxuXHQgICAgICB0aGlzLm9wY29kZSgncHVzaENvbnRleHQnKTtcclxuXHQgICAgfSBlbHNlIGlmIChwYXRoLmRhdGEpIHtcclxuXHQgICAgICB0aGlzLm9wdGlvbnMuZGF0YSA9IHRydWU7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2xvb2t1cERhdGEnLCBwYXRoLmRlcHRoLCBwYXRoLnBhcnRzLCBwYXRoLnN0cmljdCk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2xvb2t1cE9uQ29udGV4dCcsIHBhdGgucGFydHMsIHBhdGguZmFsc3ksIHBhdGguc3RyaWN0LCBzY29wZWQpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIFN0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uIFN0cmluZ0xpdGVyYWwoc3RyaW5nKSB7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoU3RyaW5nJywgc3RyaW5nLnZhbHVlKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgTnVtYmVyTGl0ZXJhbDogZnVuY3Rpb24gTnVtYmVyTGl0ZXJhbChudW1iZXIpIHtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hMaXRlcmFsJywgbnVtYmVyLnZhbHVlKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgQm9vbGVhbkxpdGVyYWw6IGZ1bmN0aW9uIEJvb2xlYW5MaXRlcmFsKGJvb2wpIHtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hMaXRlcmFsJywgYm9vbC52YWx1ZSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIFVuZGVmaW5lZExpdGVyYWw6IGZ1bmN0aW9uIFVuZGVmaW5lZExpdGVyYWwoKSB7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsICd1bmRlZmluZWQnKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgTnVsbExpdGVyYWw6IGZ1bmN0aW9uIE51bGxMaXRlcmFsKCkge1xyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCAnbnVsbCcpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBIYXNoOiBmdW5jdGlvbiBIYXNoKGhhc2gpIHtcclxuXHQgICAgdmFyIHBhaXJzID0gaGFzaC5wYWlycyxcclxuXHQgICAgICAgIGkgPSAwLFxyXG5cdCAgICAgICAgbCA9IHBhaXJzLmxlbmd0aDtcclxuXHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoSGFzaCcpO1xyXG5cclxuXHQgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgICB0aGlzLnB1c2hQYXJhbShwYWlyc1tpXS52YWx1ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgd2hpbGUgKGktLSkge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdhc3NpZ25Ub0hhc2gnLCBwYWlyc1tpXS5rZXkpO1xyXG5cdCAgICB9XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwb3BIYXNoJyk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIEhFTFBFUlNcclxuXHQgIG9wY29kZTogZnVuY3Rpb24gb3Bjb2RlKG5hbWUpIHtcclxuXHQgICAgdGhpcy5vcGNvZGVzLnB1c2goeyBvcGNvZGU6IG5hbWUsIGFyZ3M6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgbG9jOiB0aGlzLnNvdXJjZU5vZGVbMF0ubG9jIH0pO1xyXG5cdCAgfSxcclxuXHJcblx0ICBhZGREZXB0aDogZnVuY3Rpb24gYWRkRGVwdGgoZGVwdGgpIHtcclxuXHQgICAgaWYgKCFkZXB0aCkge1xyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy51c2VEZXB0aHMgPSB0cnVlO1xyXG5cdCAgfSxcclxuXHJcblx0ICBjbGFzc2lmeVNleHByOiBmdW5jdGlvbiBjbGFzc2lmeVNleHByKHNleHByKSB7XHJcblx0ICAgIHZhciBpc1NpbXBsZSA9IF9hc3QyWydkZWZhdWx0J10uaGVscGVycy5zaW1wbGVJZChzZXhwci5wYXRoKTtcclxuXHJcblx0ICAgIHZhciBpc0Jsb2NrUGFyYW0gPSBpc1NpbXBsZSAmJiAhIXRoaXMuYmxvY2tQYXJhbUluZGV4KHNleHByLnBhdGgucGFydHNbMF0pO1xyXG5cclxuXHQgICAgLy8gYSBtdXN0YWNoZSBpcyBhbiBlbGlnaWJsZSBoZWxwZXIgaWY6XHJcblx0ICAgIC8vICogaXRzIGlkIGlzIHNpbXBsZSAoYSBzaW5nbGUgcGFydCwgbm90IGB0aGlzYCBvciBgLi5gKVxyXG5cdCAgICB2YXIgaXNIZWxwZXIgPSAhaXNCbG9ja1BhcmFtICYmIF9hc3QyWydkZWZhdWx0J10uaGVscGVycy5oZWxwZXJFeHByZXNzaW9uKHNleHByKTtcclxuXHJcblx0ICAgIC8vIGlmIGEgbXVzdGFjaGUgaXMgYW4gZWxpZ2libGUgaGVscGVyIGJ1dCBub3QgYSBkZWZpbml0ZVxyXG5cdCAgICAvLyBoZWxwZXIsIGl0IGlzIGFtYmlndW91cywgYW5kIHdpbGwgYmUgcmVzb2x2ZWQgaW4gYSBsYXRlclxyXG5cdCAgICAvLyBwYXNzIG9yIGF0IHJ1bnRpbWUuXHJcblx0ICAgIHZhciBpc0VsaWdpYmxlID0gIWlzQmxvY2tQYXJhbSAmJiAoaXNIZWxwZXIgfHwgaXNTaW1wbGUpO1xyXG5cclxuXHQgICAgLy8gaWYgYW1iaWd1b3VzLCB3ZSBjYW4gcG9zc2libHkgcmVzb2x2ZSB0aGUgYW1iaWd1aXR5IG5vd1xyXG5cdCAgICAvLyBBbiBlbGlnaWJsZSBoZWxwZXIgaXMgb25lIHRoYXQgZG9lcyBub3QgaGF2ZSBhIGNvbXBsZXggcGF0aCwgaS5lLiBgdGhpcy5mb29gLCBgLi4vZm9vYCBldGMuXHJcblx0ICAgIGlmIChpc0VsaWdpYmxlICYmICFpc0hlbHBlcikge1xyXG5cdCAgICAgIHZhciBfbmFtZTIgPSBzZXhwci5wYXRoLnBhcnRzWzBdLFxyXG5cdCAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHQgICAgICBpZiAob3B0aW9ucy5rbm93bkhlbHBlcnNbX25hbWUyXSkge1xyXG5cdCAgICAgICAgaXNIZWxwZXIgPSB0cnVlO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5rbm93bkhlbHBlcnNPbmx5KSB7XHJcblx0ICAgICAgICBpc0VsaWdpYmxlID0gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoaXNIZWxwZXIpIHtcclxuXHQgICAgICByZXR1cm4gJ2hlbHBlcic7XHJcblx0ICAgIH0gZWxzZSBpZiAoaXNFbGlnaWJsZSkge1xyXG5cdCAgICAgIHJldHVybiAnYW1iaWd1b3VzJztcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gJ3NpbXBsZSc7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgcHVzaFBhcmFtczogZnVuY3Rpb24gcHVzaFBhcmFtcyhwYXJhbXMpIHtcclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJhbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoUGFyYW0ocGFyYW1zW2ldKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBwdXNoUGFyYW06IGZ1bmN0aW9uIHB1c2hQYXJhbSh2YWwpIHtcclxuXHQgICAgdmFyIHZhbHVlID0gdmFsLnZhbHVlICE9IG51bGwgPyB2YWwudmFsdWUgOiB2YWwub3JpZ2luYWwgfHwgJyc7XHJcblxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICBpZiAodmFsdWUucmVwbGFjZSkge1xyXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKFxcLj9cXC5cXC8pKi9nLCAnJykucmVwbGFjZSgvXFwvL2csICcuJyk7XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICBpZiAodmFsLmRlcHRoKSB7XHJcblx0ICAgICAgICB0aGlzLmFkZERlcHRoKHZhbC5kZXB0aCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdnZXRDb250ZXh0JywgdmFsLmRlcHRoIHx8IDApO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdwdXNoU3RyaW5nUGFyYW0nLCB2YWx1ZSwgdmFsLnR5cGUpO1xyXG5cclxuXHQgICAgICBpZiAodmFsLnR5cGUgPT09ICdTdWJFeHByZXNzaW9uJykge1xyXG5cdCAgICAgICAgLy8gU3ViRXhwcmVzc2lvbnMgZ2V0IGV2YWx1YXRlZCBhbmQgcGFzc2VkIGluXHJcblx0ICAgICAgICAvLyBpbiBzdHJpbmcgcGFyYW1zIG1vZGUuXHJcblx0ICAgICAgICB0aGlzLmFjY2VwdCh2YWwpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBpZiAodGhpcy50cmFja0lkcykge1xyXG5cdCAgICAgICAgdmFyIGJsb2NrUGFyYW1JbmRleCA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgIGlmICh2YWwucGFydHMgJiYgIV9hc3QyWydkZWZhdWx0J10uaGVscGVycy5zY29wZWRJZCh2YWwpICYmICF2YWwuZGVwdGgpIHtcclxuXHQgICAgICAgICAgYmxvY2tQYXJhbUluZGV4ID0gdGhpcy5ibG9ja1BhcmFtSW5kZXgodmFsLnBhcnRzWzBdKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChibG9ja1BhcmFtSW5kZXgpIHtcclxuXHQgICAgICAgICAgdmFyIGJsb2NrUGFyYW1DaGlsZCA9IHZhbC5wYXJ0cy5zbGljZSgxKS5qb2luKCcuJyk7XHJcblx0ICAgICAgICAgIHRoaXMub3Bjb2RlKCdwdXNoSWQnLCAnQmxvY2tQYXJhbScsIGJsb2NrUGFyYW1JbmRleCwgYmxvY2tQYXJhbUNoaWxkKTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIHZhbHVlID0gdmFsLm9yaWdpbmFsIHx8IHZhbHVlO1xyXG5cdCAgICAgICAgICBpZiAodmFsdWUucmVwbGFjZSkge1xyXG5cdCAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXnRoaXMoPzpcXC58JCkvLCAnJykucmVwbGFjZSgvXlxcLlxcLy8sICcnKS5yZXBsYWNlKC9eXFwuJC8sICcnKTtcclxuXHQgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hJZCcsIHZhbC50eXBlLCB2YWx1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHRoaXMuYWNjZXB0KHZhbCk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXM6IGZ1bmN0aW9uIHNldHVwRnVsbE11c3RhY2hlUGFyYW1zKHNleHByLCBwcm9ncmFtLCBpbnZlcnNlLCBvbWl0RW1wdHkpIHtcclxuXHQgICAgdmFyIHBhcmFtcyA9IHNleHByLnBhcmFtcztcclxuXHQgICAgdGhpcy5wdXNoUGFyYW1zKHBhcmFtcyk7XHJcblxyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgaW52ZXJzZSk7XHJcblxyXG5cdCAgICBpZiAoc2V4cHIuaGFzaCkge1xyXG5cdCAgICAgIHRoaXMuYWNjZXB0KHNleHByLmhhc2gpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdlbXB0eUhhc2gnLCBvbWl0RW1wdHkpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gcGFyYW1zO1xyXG5cdCAgfSxcclxuXHJcblx0ICBibG9ja1BhcmFtSW5kZXg6IGZ1bmN0aW9uIGJsb2NrUGFyYW1JbmRleChuYW1lKSB7XHJcblx0ICAgIGZvciAodmFyIGRlcHRoID0gMCwgbGVuID0gdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zLmxlbmd0aDsgZGVwdGggPCBsZW47IGRlcHRoKyspIHtcclxuXHQgICAgICB2YXIgYmxvY2tQYXJhbXMgPSB0aGlzLm9wdGlvbnMuYmxvY2tQYXJhbXNbZGVwdGhdLFxyXG5cdCAgICAgICAgICBwYXJhbSA9IGJsb2NrUGFyYW1zICYmIF91dGlscy5pbmRleE9mKGJsb2NrUGFyYW1zLCBuYW1lKTtcclxuXHQgICAgICBpZiAoYmxvY2tQYXJhbXMgJiYgcGFyYW0gPj0gMCkge1xyXG5cdCAgICAgICAgcmV0dXJuIFtkZXB0aCwgcGFyYW1dO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHByZWNvbXBpbGUoaW5wdXQsIG9wdGlvbnMsIGVudikge1xyXG5cdCAgaWYgKGlucHV0ID09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyAmJiBpbnB1dC50eXBlICE9PSAnUHJvZ3JhbScpIHtcclxuXHQgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1lvdSBtdXN0IHBhc3MgYSBzdHJpbmcgb3IgSGFuZGxlYmFycyBBU1QgdG8gSGFuZGxlYmFycy5wcmVjb21waWxlLiBZb3UgcGFzc2VkICcgKyBpbnB1dCk7XHJcblx0ICB9XHJcblxyXG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0ICBpZiAoISgnZGF0YScgaW4gb3B0aW9ucykpIHtcclxuXHQgICAgb3B0aW9ucy5kYXRhID0gdHJ1ZTtcclxuXHQgIH1cclxuXHQgIGlmIChvcHRpb25zLmNvbXBhdCkge1xyXG5cdCAgICBvcHRpb25zLnVzZURlcHRocyA9IHRydWU7XHJcblx0ICB9XHJcblxyXG5cdCAgdmFyIGFzdCA9IGVudi5wYXJzZShpbnB1dCwgb3B0aW9ucyksXHJcblx0ICAgICAgZW52aXJvbm1lbnQgPSBuZXcgZW52LkNvbXBpbGVyKCkuY29tcGlsZShhc3QsIG9wdGlvbnMpO1xyXG5cdCAgcmV0dXJuIG5ldyBlbnYuSmF2YVNjcmlwdENvbXBpbGVyKCkuY29tcGlsZShlbnZpcm9ubWVudCwgb3B0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjb21waWxlKGlucHV0LCBvcHRpb25zLCBlbnYpIHtcclxuXHQgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcclxuXHJcblx0ICBpZiAoaW5wdXQgPT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnICYmIGlucHV0LnR5cGUgIT09ICdQcm9ncmFtJykge1xyXG5cdCAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnWW91IG11c3QgcGFzcyBhIHN0cmluZyBvciBIYW5kbGViYXJzIEFTVCB0byBIYW5kbGViYXJzLmNvbXBpbGUuIFlvdSBwYXNzZWQgJyArIGlucHV0KTtcclxuXHQgIH1cclxuXHJcblx0ICBpZiAoISgnZGF0YScgaW4gb3B0aW9ucykpIHtcclxuXHQgICAgb3B0aW9ucy5kYXRhID0gdHJ1ZTtcclxuXHQgIH1cclxuXHQgIGlmIChvcHRpb25zLmNvbXBhdCkge1xyXG5cdCAgICBvcHRpb25zLnVzZURlcHRocyA9IHRydWU7XHJcblx0ICB9XHJcblxyXG5cdCAgdmFyIGNvbXBpbGVkID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgIGZ1bmN0aW9uIGNvbXBpbGVJbnB1dCgpIHtcclxuXHQgICAgdmFyIGFzdCA9IGVudi5wYXJzZShpbnB1dCwgb3B0aW9ucyksXHJcblx0ICAgICAgICBlbnZpcm9ubWVudCA9IG5ldyBlbnYuQ29tcGlsZXIoKS5jb21waWxlKGFzdCwgb3B0aW9ucyksXHJcblx0ICAgICAgICB0ZW1wbGF0ZVNwZWMgPSBuZXcgZW52LkphdmFTY3JpcHRDb21waWxlcigpLmNvbXBpbGUoZW52aXJvbm1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblx0ICAgIHJldHVybiBlbnYudGVtcGxhdGUodGVtcGxhdGVTcGVjKTtcclxuXHQgIH1cclxuXHJcblx0ICAvLyBUZW1wbGF0ZSBpcyBvbmx5IGNvbXBpbGVkIG9uIGZpcnN0IHVzZSBhbmQgY2FjaGVkIGFmdGVyIHRoYXQgcG9pbnQuXHJcblx0ICBmdW5jdGlvbiByZXQoY29udGV4dCwgZXhlY09wdGlvbnMpIHtcclxuXHQgICAgaWYgKCFjb21waWxlZCkge1xyXG5cdCAgICAgIGNvbXBpbGVkID0gY29tcGlsZUlucHV0KCk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGNvbXBpbGVkLmNhbGwodGhpcywgY29udGV4dCwgZXhlY09wdGlvbnMpO1xyXG5cdCAgfVxyXG5cdCAgcmV0Ll9zZXR1cCA9IGZ1bmN0aW9uIChzZXR1cE9wdGlvbnMpIHtcclxuXHQgICAgaWYgKCFjb21waWxlZCkge1xyXG5cdCAgICAgIGNvbXBpbGVkID0gY29tcGlsZUlucHV0KCk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGNvbXBpbGVkLl9zZXR1cChzZXR1cE9wdGlvbnMpO1xyXG5cdCAgfTtcclxuXHQgIHJldC5fY2hpbGQgPSBmdW5jdGlvbiAoaSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocykge1xyXG5cdCAgICBpZiAoIWNvbXBpbGVkKSB7XHJcblx0ICAgICAgY29tcGlsZWQgPSBjb21waWxlSW5wdXQoKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gY29tcGlsZWQuX2NoaWxkKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xyXG5cdCAgfTtcclxuXHQgIHJldHVybiByZXQ7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhcmdFcXVhbHMoYSwgYikge1xyXG5cdCAgaWYgKGEgPT09IGIpIHtcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKF91dGlscy5pc0FycmF5KGEpICYmIF91dGlscy5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCkge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICBpZiAoIWFyZ0VxdWFscyhhW2ldLCBiW2ldKSkge1xyXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybUxpdGVyYWxUb1BhdGgoc2V4cHIpIHtcclxuXHQgIGlmICghc2V4cHIucGF0aC5wYXJ0cykge1xyXG5cdCAgICB2YXIgbGl0ZXJhbCA9IHNleHByLnBhdGg7XHJcblx0ICAgIC8vIENhc3RpbmcgdG8gc3RyaW5nIGhlcmUgdG8gbWFrZSBmYWxzZSBhbmQgMCBsaXRlcmFsIHZhbHVlcyBwbGF5IG5pY2VseSB3aXRoIHRoZSByZXN0XHJcblx0ICAgIC8vIG9mIHRoZSBzeXN0ZW0uXHJcblx0ICAgIHNleHByLnBhdGggPSB7XHJcblx0ICAgICAgdHlwZTogJ1BhdGhFeHByZXNzaW9uJyxcclxuXHQgICAgICBkYXRhOiBmYWxzZSxcclxuXHQgICAgICBkZXB0aDogMCxcclxuXHQgICAgICBwYXJ0czogW2xpdGVyYWwub3JpZ2luYWwgKyAnJ10sXHJcblx0ICAgICAgb3JpZ2luYWw6IGxpdGVyYWwub3JpZ2luYWwgKyAnJyxcclxuXHQgICAgICBsb2M6IGxpdGVyYWwubG9jXHJcblx0ICAgIH07XHJcblx0ICB9XHJcblx0fVxyXG5cclxuLyoqKi8gfSxcclxuLyogMjggKi9cclxuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBfY29kZUdlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xyXG5cclxuXHR2YXIgX2NvZGVHZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZUdlbik7XHJcblxyXG5cdGZ1bmN0aW9uIExpdGVyYWwodmFsdWUpIHtcclxuXHQgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEphdmFTY3JpcHRDb21waWxlcigpIHt9XHJcblxyXG5cdEphdmFTY3JpcHRDb21waWxlci5wcm90b3R5cGUgPSB7XHJcblx0ICAvLyBQVUJMSUMgQVBJOiBZb3UgY2FuIG92ZXJyaWRlIHRoZXNlIG1ldGhvZHMgaW4gYSBzdWJjbGFzcyB0byBwcm92aWRlXHJcblx0ICAvLyBhbHRlcm5hdGl2ZSBjb21waWxlZCBmb3JtcyBmb3IgbmFtZSBsb29rdXAgYW5kIGJ1ZmZlcmluZyBzZW1hbnRpY3NcclxuXHQgIG5hbWVMb29rdXA6IGZ1bmN0aW9uIG5hbWVMb29rdXAocGFyZW50LCBuYW1lIC8qICwgdHlwZSovKSB7XHJcblx0ICAgIGlmIChKYXZhU2NyaXB0Q29tcGlsZXIuaXNWYWxpZEphdmFTY3JpcHRWYXJpYWJsZU5hbWUobmFtZSkpIHtcclxuXHQgICAgICByZXR1cm4gW3BhcmVudCwgJy4nLCBuYW1lXTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gW3BhcmVudCwgJ1snLCBKU09OLnN0cmluZ2lmeShuYW1lKSwgJ10nXTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIGRlcHRoZWRMb29rdXA6IGZ1bmN0aW9uIGRlcHRoZWRMb29rdXAobmFtZSkge1xyXG5cdCAgICByZXR1cm4gW3RoaXMuYWxpYXNhYmxlKCdjb250YWluZXIubG9va3VwJyksICcoZGVwdGhzLCBcIicsIG5hbWUsICdcIiknXTtcclxuXHQgIH0sXHJcblxyXG5cdCAgY29tcGlsZXJJbmZvOiBmdW5jdGlvbiBjb21waWxlckluZm8oKSB7XHJcblx0ICAgIHZhciByZXZpc2lvbiA9IF9iYXNlLkNPTVBJTEVSX1JFVklTSU9OLFxyXG5cdCAgICAgICAgdmVyc2lvbnMgPSBfYmFzZS5SRVZJU0lPTl9DSEFOR0VTW3JldmlzaW9uXTtcclxuXHQgICAgcmV0dXJuIFtyZXZpc2lvbiwgdmVyc2lvbnNdO1xyXG5cdCAgfSxcclxuXHJcblx0ICBhcHBlbmRUb0J1ZmZlcjogZnVuY3Rpb24gYXBwZW5kVG9CdWZmZXIoc291cmNlLCBsb2NhdGlvbiwgZXhwbGljaXQpIHtcclxuXHQgICAgLy8gRm9yY2UgYSBzb3VyY2UgYXMgdGhpcyBzaW1wbGlmaWVzIHRoZSBtZXJnZSBsb2dpYy5cclxuXHQgICAgaWYgKCFfdXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XHJcblx0ICAgICAgc291cmNlID0gW3NvdXJjZV07XHJcblx0ICAgIH1cclxuXHQgICAgc291cmNlID0gdGhpcy5zb3VyY2Uud3JhcChzb3VyY2UsIGxvY2F0aW9uKTtcclxuXHJcblx0ICAgIGlmICh0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlKSB7XHJcblx0ICAgICAgcmV0dXJuIFsncmV0dXJuICcsIHNvdXJjZSwgJzsnXTtcclxuXHQgICAgfSBlbHNlIGlmIChleHBsaWNpdCkge1xyXG5cdCAgICAgIC8vIFRoaXMgaXMgYSBjYXNlIHdoZXJlIHRoZSBidWZmZXIgb3BlcmF0aW9uIG9jY3VycyBhcyBhIGNoaWxkIG9mIGFub3RoZXJcclxuXHQgICAgICAvLyBjb25zdHJ1Y3QsIGdlbmVyYWxseSBicmFjZXMuIFdlIGhhdmUgdG8gZXhwbGljaXRseSBvdXRwdXQgdGhlc2UgYnVmZmVyXHJcblx0ICAgICAgLy8gb3BlcmF0aW9ucyB0byBlbnN1cmUgdGhhdCB0aGUgZW1pdHRlZCBjb2RlIGdvZXMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24uXHJcblx0ICAgICAgcmV0dXJuIFsnYnVmZmVyICs9ICcsIHNvdXJjZSwgJzsnXTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBzb3VyY2UuYXBwZW5kVG9CdWZmZXIgPSB0cnVlO1xyXG5cdCAgICAgIHJldHVybiBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgaW5pdGlhbGl6ZUJ1ZmZlcjogZnVuY3Rpb24gaW5pdGlhbGl6ZUJ1ZmZlcigpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMucXVvdGVkU3RyaW5nKCcnKTtcclxuXHQgIH0sXHJcblx0ICAvLyBFTkQgUFVCTElDIEFQSVxyXG5cclxuXHQgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUoZW52aXJvbm1lbnQsIG9wdGlvbnMsIGNvbnRleHQsIGFzT2JqZWN0KSB7XHJcblx0ICAgIHRoaXMuZW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudDtcclxuXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHQgICAgdGhpcy5zdHJpbmdQYXJhbXMgPSB0aGlzLm9wdGlvbnMuc3RyaW5nUGFyYW1zO1xyXG5cdCAgICB0aGlzLnRyYWNrSWRzID0gdGhpcy5vcHRpb25zLnRyYWNrSWRzO1xyXG5cdCAgICB0aGlzLnByZWNvbXBpbGUgPSAhYXNPYmplY3Q7XHJcblxyXG5cdCAgICB0aGlzLm5hbWUgPSB0aGlzLmVudmlyb25tZW50Lm5hbWU7XHJcblx0ICAgIHRoaXMuaXNDaGlsZCA9ICEhY29udGV4dDtcclxuXHQgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCB7XHJcblx0ICAgICAgZGVjb3JhdG9yczogW10sXHJcblx0ICAgICAgcHJvZ3JhbXM6IFtdLFxyXG5cdCAgICAgIGVudmlyb25tZW50czogW11cclxuXHQgICAgfTtcclxuXHJcblx0ICAgIHRoaXMucHJlYW1ibGUoKTtcclxuXHJcblx0ICAgIHRoaXMuc3RhY2tTbG90ID0gMDtcclxuXHQgICAgdGhpcy5zdGFja1ZhcnMgPSBbXTtcclxuXHQgICAgdGhpcy5hbGlhc2VzID0ge307XHJcblx0ICAgIHRoaXMucmVnaXN0ZXJzID0geyBsaXN0OiBbXSB9O1xyXG5cdCAgICB0aGlzLmhhc2hlcyA9IFtdO1xyXG5cdCAgICB0aGlzLmNvbXBpbGVTdGFjayA9IFtdO1xyXG5cdCAgICB0aGlzLmlubGluZVN0YWNrID0gW107XHJcblx0ICAgIHRoaXMuYmxvY2tQYXJhbXMgPSBbXTtcclxuXHJcblx0ICAgIHRoaXMuY29tcGlsZUNoaWxkcmVuKGVudmlyb25tZW50LCBvcHRpb25zKTtcclxuXHJcblx0ICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgZW52aXJvbm1lbnQudXNlRGVwdGhzIHx8IGVudmlyb25tZW50LnVzZURlY29yYXRvcnMgfHwgdGhpcy5vcHRpb25zLmNvbXBhdDtcclxuXHQgICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgZW52aXJvbm1lbnQudXNlQmxvY2tQYXJhbXM7XHJcblxyXG5cdCAgICB2YXIgb3Bjb2RlcyA9IGVudmlyb25tZW50Lm9wY29kZXMsXHJcblx0ICAgICAgICBvcGNvZGUgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBmaXJzdExvYyA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGkgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBsID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgZm9yIChpID0gMCwgbCA9IG9wY29kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgICAgb3Bjb2RlID0gb3Bjb2Rlc1tpXTtcclxuXHJcblx0ICAgICAgdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uID0gb3Bjb2RlLmxvYztcclxuXHQgICAgICBmaXJzdExvYyA9IGZpcnN0TG9jIHx8IG9wY29kZS5sb2M7XHJcblx0ICAgICAgdGhpc1tvcGNvZGUub3Bjb2RlXS5hcHBseSh0aGlzLCBvcGNvZGUuYXJncyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIEZsdXNoIGFueSB0cmFpbGluZyBjb250ZW50IHRoYXQgbWlnaHQgYmUgcGVuZGluZy5cclxuXHQgICAgdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uID0gZmlyc3RMb2M7XHJcblx0ICAgIHRoaXMucHVzaFNvdXJjZSgnJyk7XHJcblxyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICBpZiAodGhpcy5zdGFja1Nsb3QgfHwgdGhpcy5pbmxpbmVTdGFjay5sZW5ndGggfHwgdGhpcy5jb21waWxlU3RhY2subGVuZ3RoKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0NvbXBpbGUgY29tcGxldGVkIHdpdGggY29udGVudCBsZWZ0IG9uIHN0YWNrJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICghdGhpcy5kZWNvcmF0b3JzLmlzRW1wdHkoKSkge1xyXG5cdCAgICAgIHRoaXMudXNlRGVjb3JhdG9ycyA9IHRydWU7XHJcblxyXG5cdCAgICAgIHRoaXMuZGVjb3JhdG9ycy5wcmVwZW5kKCd2YXIgZGVjb3JhdG9ycyA9IGNvbnRhaW5lci5kZWNvcmF0b3JzO1xcbicpO1xyXG5cdCAgICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKCdyZXR1cm4gZm47Jyk7XHJcblxyXG5cdCAgICAgIGlmIChhc09iamVjdCkge1xyXG5cdCAgICAgICAgdGhpcy5kZWNvcmF0b3JzID0gRnVuY3Rpb24uYXBwbHkodGhpcywgWydmbicsICdwcm9wcycsICdjb250YWluZXInLCAnZGVwdGgwJywgJ2RhdGEnLCAnYmxvY2tQYXJhbXMnLCAnZGVwdGhzJywgdGhpcy5kZWNvcmF0b3JzLm1lcmdlKCldKTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdGhpcy5kZWNvcmF0b3JzLnByZXBlbmQoJ2Z1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aDAsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcXG4nKTtcclxuXHQgICAgICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKCd9XFxuJyk7XHJcblx0ICAgICAgICB0aGlzLmRlY29yYXRvcnMgPSB0aGlzLmRlY29yYXRvcnMubWVyZ2UoKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5kZWNvcmF0b3JzID0gdW5kZWZpbmVkO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgZm4gPSB0aGlzLmNyZWF0ZUZ1bmN0aW9uQ29udGV4dChhc09iamVjdCk7XHJcblx0ICAgIGlmICghdGhpcy5pc0NoaWxkKSB7XHJcblx0ICAgICAgdmFyIHJldCA9IHtcclxuXHQgICAgICAgIGNvbXBpbGVyOiB0aGlzLmNvbXBpbGVySW5mbygpLFxyXG5cdCAgICAgICAgbWFpbjogZm5cclxuXHQgICAgICB9O1xyXG5cclxuXHQgICAgICBpZiAodGhpcy5kZWNvcmF0b3JzKSB7XHJcblx0ICAgICAgICByZXQubWFpbl9kID0gdGhpcy5kZWNvcmF0b3JzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG5cdCAgICAgICAgcmV0LnVzZURlY29yYXRvcnMgPSB0cnVlO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgdmFyIF9jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG5cdCAgICAgIHZhciBwcm9ncmFtcyA9IF9jb250ZXh0LnByb2dyYW1zO1xyXG5cdCAgICAgIHZhciBkZWNvcmF0b3JzID0gX2NvbnRleHQuZGVjb3JhdG9ycztcclxuXHJcblx0ICAgICAgZm9yIChpID0gMCwgbCA9IHByb2dyYW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgICAgaWYgKHByb2dyYW1zW2ldKSB7XHJcblx0ICAgICAgICAgIHJldFtpXSA9IHByb2dyYW1zW2ldO1xyXG5cdCAgICAgICAgICBpZiAoZGVjb3JhdG9yc1tpXSkge1xyXG5cdCAgICAgICAgICAgIHJldFtpICsgJ19kJ10gPSBkZWNvcmF0b3JzW2ldO1xyXG5cdCAgICAgICAgICAgIHJldC51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgaWYgKHRoaXMuZW52aXJvbm1lbnQudXNlUGFydGlhbCkge1xyXG5cdCAgICAgICAgcmV0LnVzZVBhcnRpYWwgPSB0cnVlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAodGhpcy5vcHRpb25zLmRhdGEpIHtcclxuXHQgICAgICAgIHJldC51c2VEYXRhID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRoaXMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgICByZXQudXNlRGVwdGhzID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRoaXMudXNlQmxvY2tQYXJhbXMpIHtcclxuXHQgICAgICAgIHJldC51c2VCbG9ja1BhcmFtcyA9IHRydWU7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0KSB7XHJcblx0ICAgICAgICByZXQuY29tcGF0ID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIGlmICghYXNPYmplY3QpIHtcclxuXHQgICAgICAgIHJldC5jb21waWxlciA9IEpTT04uc3RyaW5naWZ5KHJldC5jb21waWxlcik7XHJcblxyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uID0geyBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDAgfSB9O1xyXG5cdCAgICAgICAgcmV0ID0gdGhpcy5vYmplY3RMaXRlcmFsKHJldCk7XHJcblxyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc3JjTmFtZSkge1xyXG5cdCAgICAgICAgICByZXQgPSByZXQudG9TdHJpbmdXaXRoU291cmNlTWFwKHsgZmlsZTogb3B0aW9ucy5kZXN0TmFtZSB9KTtcclxuXHQgICAgICAgICAgcmV0Lm1hcCA9IHJldC5tYXAgJiYgcmV0Lm1hcC50b1N0cmluZygpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgcmV0ID0gcmV0LnRvU3RyaW5nKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHJldC5jb21waWxlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICByZXR1cm4gcmV0O1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiBmbjtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBwcmVhbWJsZTogZnVuY3Rpb24gcHJlYW1ibGUoKSB7XHJcblx0ICAgIC8vIHRyYWNrIHRoZSBsYXN0IGNvbnRleHQgcHVzaGVkIGludG8gcGxhY2UgdG8gYWxsb3cgc2tpcHBpbmcgdGhlXHJcblx0ICAgIC8vIGdldENvbnRleHQgb3Bjb2RlIHdoZW4gaXQgd291bGQgYmUgYSBub29wXHJcblx0ICAgIHRoaXMubGFzdENvbnRleHQgPSAwO1xyXG5cdCAgICB0aGlzLnNvdXJjZSA9IG5ldyBfY29kZUdlbjJbJ2RlZmF1bHQnXSh0aGlzLm9wdGlvbnMuc3JjTmFtZSk7XHJcblx0ICAgIHRoaXMuZGVjb3JhdG9ycyA9IG5ldyBfY29kZUdlbjJbJ2RlZmF1bHQnXSh0aGlzLm9wdGlvbnMuc3JjTmFtZSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIGNyZWF0ZUZ1bmN0aW9uQ29udGV4dDogZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Db250ZXh0KGFzT2JqZWN0KSB7XHJcblx0ICAgIHZhciB2YXJEZWNsYXJhdGlvbnMgPSAnJztcclxuXHJcblx0ICAgIHZhciBsb2NhbHMgPSB0aGlzLnN0YWNrVmFycy5jb25jYXQodGhpcy5yZWdpc3RlcnMubGlzdCk7XHJcblx0ICAgIGlmIChsb2NhbHMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgIHZhckRlY2xhcmF0aW9ucyArPSAnLCAnICsgbG9jYWxzLmpvaW4oJywgJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIEdlbmVyYXRlIG1pbmltaXplciBhbGlhcyBtYXBwaW5nc1xyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBXaGVuIHVzaW5nIHRydWUgU291cmNlTm9kZXMsIHRoaXMgd2lsbCB1cGRhdGUgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIGdpdmVuIGFsaWFzXHJcblx0ICAgIC8vIGFzIHRoZSBzb3VyY2Ugbm9kZXMgYXJlIHJldXNlZCBpbiBzaXR1LiBGb3IgdGhlIG5vbi1zb3VyY2Ugbm9kZSBjb21waWxhdGlvbiBtb2RlLFxyXG5cdCAgICAvLyBhbGlhc2VzIHdpbGwgbm90IGJlIHVzZWQsIGJ1dCB0aGlzIGNhc2UgaXMgYWxyZWFkeSBiZWluZyBydW4gb24gdGhlIGNsaWVudCBhbmRcclxuXHQgICAgLy8gd2UgYXJlbid0IGNvbmNlcm4gYWJvdXQgbWluaW1pemluZyB0aGUgdGVtcGxhdGUgc2l6ZS5cclxuXHQgICAgdmFyIGFsaWFzQ291bnQgPSAwO1xyXG5cdCAgICBmb3IgKHZhciBhbGlhcyBpbiB0aGlzLmFsaWFzZXMpIHtcclxuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxyXG5cdCAgICAgIHZhciBub2RlID0gdGhpcy5hbGlhc2VzW2FsaWFzXTtcclxuXHJcblx0ICAgICAgaWYgKHRoaXMuYWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShhbGlhcykgJiYgbm9kZS5jaGlsZHJlbiAmJiBub2RlLnJlZmVyZW5jZUNvdW50ID4gMSkge1xyXG5cdCAgICAgICAgdmFyRGVjbGFyYXRpb25zICs9ICcsIGFsaWFzJyArICsrYWxpYXNDb3VudCArICc9JyArIGFsaWFzO1xyXG5cdCAgICAgICAgbm9kZS5jaGlsZHJlblswXSA9ICdhbGlhcycgKyBhbGlhc0NvdW50O1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIHBhcmFtcyA9IFsnY29udGFpbmVyJywgJ2RlcHRoMCcsICdoZWxwZXJzJywgJ3BhcnRpYWxzJywgJ2RhdGEnXTtcclxuXHJcblx0ICAgIGlmICh0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IHRoaXMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgcGFyYW1zLnB1c2goJ2Jsb2NrUGFyYW1zJyk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgcGFyYW1zLnB1c2goJ2RlcHRocycpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBQZXJmb3JtIGEgc2Vjb25kIHBhc3Mgb3ZlciB0aGUgb3V0cHV0IHRvIG1lcmdlIGNvbnRlbnQgd2hlbiBwb3NzaWJsZVxyXG5cdCAgICB2YXIgc291cmNlID0gdGhpcy5tZXJnZVNvdXJjZSh2YXJEZWNsYXJhdGlvbnMpO1xyXG5cclxuXHQgICAgaWYgKGFzT2JqZWN0KSB7XHJcblx0ICAgICAgcGFyYW1zLnB1c2goc291cmNlKTtcclxuXHJcblx0ICAgICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtcyk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMuc291cmNlLndyYXAoWydmdW5jdGlvbignLCBwYXJhbXMuam9pbignLCcpLCAnKSB7XFxuICAnLCBzb3VyY2UsICd9J10pO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgbWVyZ2VTb3VyY2U6IGZ1bmN0aW9uIG1lcmdlU291cmNlKHZhckRlY2xhcmF0aW9ucykge1xyXG5cdCAgICB2YXIgaXNTaW1wbGUgPSB0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlLFxyXG5cdCAgICAgICAgYXBwZW5kT25seSA9ICF0aGlzLmZvcmNlQnVmZmVyLFxyXG5cdCAgICAgICAgYXBwZW5kRmlyc3QgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBzb3VyY2VTZWVuID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgYnVmZmVyU3RhcnQgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBidWZmZXJFbmQgPSB1bmRlZmluZWQ7XHJcblx0ICAgIHRoaXMuc291cmNlLmVhY2goZnVuY3Rpb24gKGxpbmUpIHtcclxuXHQgICAgICBpZiAobGluZS5hcHBlbmRUb0J1ZmZlcikge1xyXG5cdCAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XHJcblx0ICAgICAgICAgIGxpbmUucHJlcGVuZCgnICArICcpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgYnVmZmVyU3RhcnQgPSBsaW5lO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgYnVmZmVyRW5kID0gbGluZTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XHJcblx0ICAgICAgICAgIGlmICghc291cmNlU2Vlbikge1xyXG5cdCAgICAgICAgICAgIGFwcGVuZEZpcnN0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBidWZmZXJTdGFydC5wcmVwZW5kKCdidWZmZXIgKz0gJyk7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgICAgYnVmZmVyRW5kLmFkZCgnOycpO1xyXG5cdCAgICAgICAgICBidWZmZXJTdGFydCA9IGJ1ZmZlckVuZCA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgIH1cclxuXHJcblx0ICAgICAgICBzb3VyY2VTZWVuID0gdHJ1ZTtcclxuXHQgICAgICAgIGlmICghaXNTaW1wbGUpIHtcclxuXHQgICAgICAgICAgYXBwZW5kT25seSA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSk7XHJcblxyXG5cdCAgICBpZiAoYXBwZW5kT25seSkge1xyXG5cdCAgICAgIGlmIChidWZmZXJTdGFydCkge1xyXG5cdCAgICAgICAgYnVmZmVyU3RhcnQucHJlcGVuZCgncmV0dXJuICcpO1xyXG5cdCAgICAgICAgYnVmZmVyRW5kLmFkZCgnOycpO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAoIXNvdXJjZVNlZW4pIHtcclxuXHQgICAgICAgIHRoaXMuc291cmNlLnB1c2goJ3JldHVybiBcIlwiOycpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB2YXJEZWNsYXJhdGlvbnMgKz0gJywgYnVmZmVyID0gJyArIChhcHBlbmRGaXJzdCA/ICcnIDogdGhpcy5pbml0aWFsaXplQnVmZmVyKCkpO1xyXG5cclxuXHQgICAgICBpZiAoYnVmZmVyU3RhcnQpIHtcclxuXHQgICAgICAgIGJ1ZmZlclN0YXJ0LnByZXBlbmQoJ3JldHVybiBidWZmZXIgKyAnKTtcclxuXHQgICAgICAgIGJ1ZmZlckVuZC5hZGQoJzsnKTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UucHVzaCgncmV0dXJuIGJ1ZmZlcjsnKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICh2YXJEZWNsYXJhdGlvbnMpIHtcclxuXHQgICAgICB0aGlzLnNvdXJjZS5wcmVwZW5kKCd2YXIgJyArIHZhckRlY2xhcmF0aW9ucy5zdWJzdHJpbmcoMikgKyAoYXBwZW5kRmlyc3QgPyAnJyA6ICc7XFxuJykpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gdGhpcy5zb3VyY2UubWVyZ2UoKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2Jsb2NrVmFsdWVdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgdmFsdWVcclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcmV0dXJuIHZhbHVlIG9mIGJsb2NrSGVscGVyTWlzc2luZ1xyXG5cdCAgLy9cclxuXHQgIC8vIFRoZSBwdXJwb3NlIG9mIHRoaXMgb3Bjb2RlIGlzIHRvIHRha2UgYSBibG9jayBvZiB0aGUgZm9ybVxyXG5cdCAgLy8gYHt7I3RoaXMuZm9vfX0uLi57ey90aGlzLmZvb319YCwgcmVzb2x2ZSB0aGUgdmFsdWUgb2YgYGZvb2AsIGFuZFxyXG5cdCAgLy8gcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgd2l0aCB0aGUgcmVzdWx0IG9mIHByb3Blcmx5XHJcblx0ICAvLyBpbnZva2luZyBibG9ja0hlbHBlck1pc3NpbmcuXHJcblx0ICBibG9ja1ZhbHVlOiBmdW5jdGlvbiBibG9ja1ZhbHVlKG5hbWUpIHtcclxuXHQgICAgdmFyIGJsb2NrSGVscGVyTWlzc2luZyA9IHRoaXMuYWxpYXNhYmxlKCdoZWxwZXJzLmJsb2NrSGVscGVyTWlzc2luZycpLFxyXG5cdCAgICAgICAgcGFyYW1zID0gW3RoaXMuY29udGV4dE5hbWUoMCldO1xyXG5cdCAgICB0aGlzLnNldHVwSGVscGVyQXJncyhuYW1lLCAwLCBwYXJhbXMpO1xyXG5cclxuXHQgICAgdmFyIGJsb2NrTmFtZSA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgcGFyYW1zLnNwbGljZSgxLCAwLCBibG9ja05hbWUpO1xyXG5cclxuXHQgICAgdGhpcy5wdXNoKHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbChibG9ja0hlbHBlck1pc3NpbmcsICdjYWxsJywgcGFyYW1zKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFthbWJpZ3VvdXNCbG9ja1ZhbHVlXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHZhbHVlXHJcblx0ICAvLyBDb21waWxlciB2YWx1ZSwgYmVmb3JlOiBsYXN0SGVscGVyPXZhbHVlIG9mIGxhc3QgZm91bmQgaGVscGVyLCBpZiBhbnlcclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlciwgaWYgbm8gbGFzdEhlbHBlcjogc2FtZSBhcyBbYmxvY2tWYWx1ZV1cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlciwgaWYgbGFzdEhlbHBlcjogdmFsdWVcclxuXHQgIGFtYmlndW91c0Jsb2NrVmFsdWU6IGZ1bmN0aW9uIGFtYmlndW91c0Jsb2NrVmFsdWUoKSB7XHJcblx0ICAgIC8vIFdlJ3JlIGJlaW5nIGEgYml0IGNoZWVreSBhbmQgcmV1c2luZyB0aGUgb3B0aW9ucyB2YWx1ZSBmcm9tIHRoZSBwcmlvciBleGVjXHJcblx0ICAgIHZhciBibG9ja0hlbHBlck1pc3NpbmcgPSB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5ibG9ja0hlbHBlck1pc3NpbmcnKSxcclxuXHQgICAgICAgIHBhcmFtcyA9IFt0aGlzLmNvbnRleHROYW1lKDApXTtcclxuXHQgICAgdGhpcy5zZXR1cEhlbHBlckFyZ3MoJycsIDAsIHBhcmFtcywgdHJ1ZSk7XHJcblxyXG5cdCAgICB0aGlzLmZsdXNoSW5saW5lKCk7XHJcblxyXG5cdCAgICB2YXIgY3VycmVudCA9IHRoaXMudG9wU3RhY2soKTtcclxuXHQgICAgcGFyYW1zLnNwbGljZSgxLCAwLCBjdXJyZW50KTtcclxuXHJcblx0ICAgIHRoaXMucHVzaFNvdXJjZShbJ2lmICghJywgdGhpcy5sYXN0SGVscGVyLCAnKSB7ICcsIGN1cnJlbnQsICcgPSAnLCB0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoYmxvY2tIZWxwZXJNaXNzaW5nLCAnY2FsbCcsIHBhcmFtcyksICd9J10pO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbYXBwZW5kQ29udGVudF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gQXBwZW5kcyB0aGUgc3RyaW5nIHZhbHVlIG9mIGBjb250ZW50YCB0byB0aGUgY3VycmVudCBidWZmZXJcclxuXHQgIGFwcGVuZENvbnRlbnQ6IGZ1bmN0aW9uIGFwcGVuZENvbnRlbnQoY29udGVudCkge1xyXG5cdCAgICBpZiAodGhpcy5wZW5kaW5nQ29udGVudCkge1xyXG5cdCAgICAgIGNvbnRlbnQgPSB0aGlzLnBlbmRpbmdDb250ZW50ICsgY29udGVudDtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLnBlbmRpbmdMb2NhdGlvbiA9IHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbjtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5wZW5kaW5nQ29udGVudCA9IGNvbnRlbnQ7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFthcHBlbmRdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBDb2VyY2VzIGB2YWx1ZWAgdG8gYSBTdHJpbmcgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGN1cnJlbnQgYnVmZmVyLlxyXG5cdCAgLy9cclxuXHQgIC8vIElmIGB2YWx1ZWAgaXMgdHJ1dGh5LCBvciAwLCBpdCBpcyBjb2VyY2VkIGludG8gYSBzdHJpbmcgYW5kIGFwcGVuZGVkXHJcblx0ICAvLyBPdGhlcndpc2UsIHRoZSBlbXB0eSBzdHJpbmcgaXMgYXBwZW5kZWRcclxuXHQgIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xyXG5cdCAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XHJcblx0ICAgICAgdGhpcy5yZXBsYWNlU3RhY2soZnVuY3Rpb24gKGN1cnJlbnQpIHtcclxuXHQgICAgICAgIHJldHVybiBbJyAhPSBudWxsID8gJywgY3VycmVudCwgJyA6IFwiXCInXTtcclxuXHQgICAgICB9KTtcclxuXHJcblx0ICAgICAgdGhpcy5wdXNoU291cmNlKHRoaXMuYXBwZW5kVG9CdWZmZXIodGhpcy5wb3BTdGFjaygpKSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdmFyIGxvY2FsID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIHRoaXMucHVzaFNvdXJjZShbJ2lmICgnLCBsb2NhbCwgJyAhPSBudWxsKSB7ICcsIHRoaXMuYXBwZW5kVG9CdWZmZXIobG9jYWwsIHVuZGVmaW5lZCwgdHJ1ZSksICcgfSddKTtcclxuXHQgICAgICBpZiAodGhpcy5lbnZpcm9ubWVudC5pc1NpbXBsZSkge1xyXG5cdCAgICAgICAgdGhpcy5wdXNoU291cmNlKFsnZWxzZSB7ICcsIHRoaXMuYXBwZW5kVG9CdWZmZXIoXCInJ1wiLCB1bmRlZmluZWQsIHRydWUpLCAnIH0nXSk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFthcHBlbmRFc2NhcGVkXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gRXNjYXBlIGB2YWx1ZWAgYW5kIGFwcGVuZCBpdCB0byB0aGUgYnVmZmVyXHJcblx0ICBhcHBlbmRFc2NhcGVkOiBmdW5jdGlvbiBhcHBlbmRFc2NhcGVkKCkge1xyXG5cdCAgICB0aGlzLnB1c2hTb3VyY2UodGhpcy5hcHBlbmRUb0J1ZmZlcihbdGhpcy5hbGlhc2FibGUoJ2NvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uJyksICcoJywgdGhpcy5wb3BTdGFjaygpLCAnKSddKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtnZXRDb250ZXh0XVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cclxuXHQgIC8vIENvbXBpbGVyIHZhbHVlLCBhZnRlcjogbGFzdENvbnRleHQ9ZGVwdGhcclxuXHQgIC8vXHJcblx0ICAvLyBTZXQgdGhlIHZhbHVlIG9mIHRoZSBgbGFzdENvbnRleHRgIGNvbXBpbGVyIHZhbHVlIHRvIHRoZSBkZXB0aFxyXG5cdCAgZ2V0Q29udGV4dDogZnVuY3Rpb24gZ2V0Q29udGV4dChkZXB0aCkge1xyXG5cdCAgICB0aGlzLmxhc3RDb250ZXh0ID0gZGVwdGg7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtwdXNoQ29udGV4dF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogY3VycmVudENvbnRleHQsIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFB1c2hlcyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgY29udGV4dCBvbnRvIHRoZSBzdGFjay5cclxuXHQgIHB1c2hDb250ZXh0OiBmdW5jdGlvbiBwdXNoQ29udGV4dCgpIHtcclxuXHQgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMuY29udGV4dE5hbWUodGhpcy5sYXN0Q29udGV4dCkpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbbG9va3VwT25Db250ZXh0XVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiBjdXJyZW50Q29udGV4dFtuYW1lXSwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gTG9va3MgdXAgdGhlIHZhbHVlIG9mIGBuYW1lYCBvbiB0aGUgY3VycmVudCBjb250ZXh0IGFuZCBwdXNoZXNcclxuXHQgIC8vIGl0IG9udG8gdGhlIHN0YWNrLlxyXG5cdCAgbG9va3VwT25Db250ZXh0OiBmdW5jdGlvbiBsb29rdXBPbkNvbnRleHQocGFydHMsIGZhbHN5LCBzdHJpY3QsIHNjb3BlZCkge1xyXG5cdCAgICB2YXIgaSA9IDA7XHJcblxyXG5cdCAgICBpZiAoIXNjb3BlZCAmJiB0aGlzLm9wdGlvbnMuY29tcGF0ICYmICF0aGlzLmxhc3RDb250ZXh0KSB7XHJcblx0ICAgICAgLy8gVGhlIGRlcHRoZWQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGFuZGxlIHRoZSB1bmRlZmluZWQgbG9naWMgZm9yIHRoZSByb290IGxldmVsIHRoYXRcclxuXHQgICAgICAvLyBpcyBpbXBsZW1lbnRlZCBiZWxvdywgc28gd2UgZXZhbHVhdGUgdGhhdCBkaXJlY3RseSBpbiBjb21wYXQgbW9kZVxyXG5cdCAgICAgIHRoaXMucHVzaCh0aGlzLmRlcHRoZWRMb29rdXAocGFydHNbaSsrXSkpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMucHVzaENvbnRleHQoKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5yZXNvbHZlUGF0aCgnY29udGV4dCcsIHBhcnRzLCBpLCBmYWxzeSwgc3RyaWN0KTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2xvb2t1cEJsb2NrUGFyYW1dXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGJsb2NrUGFyYW1bbmFtZV0sIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIExvb2tzIHVwIHRoZSB2YWx1ZSBvZiBgcGFydHNgIG9uIHRoZSBnaXZlbiBibG9jayBwYXJhbSBhbmQgcHVzaGVzXHJcblx0ICAvLyBpdCBvbnRvIHRoZSBzdGFjay5cclxuXHQgIGxvb2t1cEJsb2NrUGFyYW06IGZ1bmN0aW9uIGxvb2t1cEJsb2NrUGFyYW0oYmxvY2tQYXJhbUlkLCBwYXJ0cykge1xyXG5cdCAgICB0aGlzLnVzZUJsb2NrUGFyYW1zID0gdHJ1ZTtcclxuXHJcblx0ICAgIHRoaXMucHVzaChbJ2Jsb2NrUGFyYW1zWycsIGJsb2NrUGFyYW1JZFswXSwgJ11bJywgYmxvY2tQYXJhbUlkWzFdLCAnXSddKTtcclxuXHQgICAgdGhpcy5yZXNvbHZlUGF0aCgnY29udGV4dCcsIHBhcnRzLCAxKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2xvb2t1cERhdGFdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGRhdGEsIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFB1c2ggdGhlIGRhdGEgbG9va3VwIG9wZXJhdG9yXHJcblx0ICBsb29rdXBEYXRhOiBmdW5jdGlvbiBsb29rdXBEYXRhKGRlcHRoLCBwYXJ0cywgc3RyaWN0KSB7XHJcblx0ICAgIGlmICghZGVwdGgpIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ2RhdGEnKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ2NvbnRhaW5lci5kYXRhKGRhdGEsICcgKyBkZXB0aCArICcpJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMucmVzb2x2ZVBhdGgoJ2RhdGEnLCBwYXJ0cywgMCwgdHJ1ZSwgc3RyaWN0KTtcclxuXHQgIH0sXHJcblxyXG5cdCAgcmVzb2x2ZVBhdGg6IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHR5cGUsIHBhcnRzLCBpLCBmYWxzeSwgc3RyaWN0KSB7XHJcblx0ICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XHJcblxyXG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QgfHwgdGhpcy5vcHRpb25zLmFzc3VtZU9iamVjdHMpIHtcclxuXHQgICAgICB0aGlzLnB1c2goc3RyaWN0TG9va3VwKHRoaXMub3B0aW9ucy5zdHJpY3QgJiYgc3RyaWN0LCB0aGlzLCBwYXJ0cywgdHlwZSkpO1xyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aDtcclxuXHQgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xyXG5cdCAgICAgIHRoaXMucmVwbGFjZVN0YWNrKGZ1bmN0aW9uIChjdXJyZW50KSB7XHJcblx0ICAgICAgICB2YXIgbG9va3VwID0gX3RoaXMubmFtZUxvb2t1cChjdXJyZW50LCBwYXJ0c1tpXSwgdHlwZSk7XHJcblx0ICAgICAgICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IHplcm8gYW5kIGZhbHNlIGFyZSBoYW5kbGVkIHByb3Blcmx5IGlmIHRoZSBjb250ZXh0IChmYWxzeSBmbGFnKVxyXG5cdCAgICAgICAgLy8gbmVlZHMgdG8gaGF2ZSB0aGUgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlc2UgdmFsdWVzLlxyXG5cdCAgICAgICAgaWYgKCFmYWxzeSkge1xyXG5cdCAgICAgICAgICByZXR1cm4gWycgIT0gbnVsbCA/ICcsIGxvb2t1cCwgJyA6ICcsIGN1cnJlbnRdO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiB1c2UgZ2VuZXJpYyBmYWxzeSBoYW5kbGluZ1xyXG5cdCAgICAgICAgICByZXR1cm4gWycgJiYgJywgbG9va3VwXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9KTtcclxuXHQgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtyZXNvbHZlUG9zc2libGVMYW1iZGFdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXNvbHZlZCB2YWx1ZSwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gSWYgdGhlIGB2YWx1ZWAgaXMgYSBsYW1iZGEsIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGJ5XHJcblx0ICAvLyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBsYW1iZGFcclxuXHQgIHJlc29sdmVQb3NzaWJsZUxhbWJkYTogZnVuY3Rpb24gcmVzb2x2ZVBvc3NpYmxlTGFtYmRhKCkge1xyXG5cdCAgICB0aGlzLnB1c2goW3RoaXMuYWxpYXNhYmxlKCdjb250YWluZXIubGFtYmRhJyksICcoJywgdGhpcy5wb3BTdGFjaygpLCAnLCAnLCB0aGlzLmNvbnRleHROYW1lKDApLCAnKSddKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW3B1c2hTdHJpbmdQYXJhbV1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogc3RyaW5nLCBjdXJyZW50Q29udGV4dCwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGNvZGUgaXMgZGVzaWduZWQgZm9yIHVzZSBpbiBzdHJpbmcgbW9kZSwgd2hpY2hcclxuXHQgIC8vIHByb3ZpZGVzIHRoZSBzdHJpbmcgdmFsdWUgb2YgYSBwYXJhbWV0ZXIgYWxvbmcgd2l0aCBpdHNcclxuXHQgIC8vIGRlcHRoIHJhdGhlciB0aGFuIHJlc29sdmluZyBpdCBpbW1lZGlhdGVseS5cclxuXHQgIHB1c2hTdHJpbmdQYXJhbTogZnVuY3Rpb24gcHVzaFN0cmluZ1BhcmFtKHN0cmluZywgdHlwZSkge1xyXG5cdCAgICB0aGlzLnB1c2hDb250ZXh0KCk7XHJcblx0ICAgIHRoaXMucHVzaFN0cmluZyh0eXBlKTtcclxuXHJcblx0ICAgIC8vIElmIGl0J3MgYSBzdWJleHByZXNzaW9uLCB0aGUgc3RyaW5nIHJlc3VsdFxyXG5cdCAgICAvLyB3aWxsIGJlIHB1c2hlZCBhZnRlciB0aGlzIG9wY29kZS5cclxuXHQgICAgaWYgKHR5cGUgIT09ICdTdWJFeHByZXNzaW9uJykge1xyXG5cdCAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgdGhpcy5wdXNoU3RyaW5nKHN0cmluZyk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChzdHJpbmcpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBlbXB0eUhhc2g6IGZ1bmN0aW9uIGVtcHR5SGFzaChvbWl0RW1wdHkpIHtcclxuXHQgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hJZHNcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hDb250ZXh0c1xyXG5cdCAgICAgIHRoaXMucHVzaCgne30nKTsgLy8gaGFzaFR5cGVzXHJcblx0ICAgIH1cclxuXHQgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKG9taXRFbXB0eSA/ICd1bmRlZmluZWQnIDogJ3t9Jyk7XHJcblx0ICB9LFxyXG5cdCAgcHVzaEhhc2g6IGZ1bmN0aW9uIHB1c2hIYXNoKCkge1xyXG5cdCAgICBpZiAodGhpcy5oYXNoKSB7XHJcblx0ICAgICAgdGhpcy5oYXNoZXMucHVzaCh0aGlzLmhhc2gpO1xyXG5cdCAgICB9XHJcblx0ICAgIHRoaXMuaGFzaCA9IHsgdmFsdWVzOiBbXSwgdHlwZXM6IFtdLCBjb250ZXh0czogW10sIGlkczogW10gfTtcclxuXHQgIH0sXHJcblx0ICBwb3BIYXNoOiBmdW5jdGlvbiBwb3BIYXNoKCkge1xyXG5cdCAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaDtcclxuXHQgICAgdGhpcy5oYXNoID0gdGhpcy5oYXNoZXMucG9wKCk7XHJcblxyXG5cdCAgICBpZiAodGhpcy50cmFja0lkcykge1xyXG5cdCAgICAgIHRoaXMucHVzaCh0aGlzLm9iamVjdExpdGVyYWwoaGFzaC5pZHMpKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2guY29udGV4dHMpKTtcclxuXHQgICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2gudHlwZXMpKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5wdXNoKHRoaXMub2JqZWN0TGl0ZXJhbChoYXNoLnZhbHVlcykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbcHVzaFN0cmluZ11cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcXVvdGVkU3RyaW5nKHN0cmluZyksIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFB1c2ggYSBxdW90ZWQgdmVyc2lvbiBvZiBgc3RyaW5nYCBvbnRvIHRoZSBzdGFja1xyXG5cdCAgcHVzaFN0cmluZzogZnVuY3Rpb24gcHVzaFN0cmluZyhzdHJpbmcpIHtcclxuXHQgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMucXVvdGVkU3RyaW5nKHN0cmluZykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbcHVzaExpdGVyYWxdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHZhbHVlLCAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBQdXNoZXMgYSB2YWx1ZSBvbnRvIHRoZSBzdGFjay4gVGhpcyBvcGVyYXRpb24gcHJldmVudHNcclxuXHQgIC8vIHRoZSBjb21waWxlciBmcm9tIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGhvbGRcclxuXHQgIC8vIGl0LlxyXG5cdCAgcHVzaExpdGVyYWw6IGZ1bmN0aW9uIHB1c2hMaXRlcmFsKHZhbHVlKSB7XHJcblx0ICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh2YWx1ZSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtwdXNoUHJvZ3JhbV1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcHJvZ3JhbShndWlkKSwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gUHVzaCBhIHByb2dyYW0gZXhwcmVzc2lvbiBvbnRvIHRoZSBzdGFjay4gVGhpcyB0YWtlc1xyXG5cdCAgLy8gYSBjb21waWxlLXRpbWUgZ3VpZCBhbmQgY29udmVydHMgaXQgaW50byBhIHJ1bnRpbWUtYWNjZXNzaWJsZVxyXG5cdCAgLy8gZXhwcmVzc2lvbi5cclxuXHQgIHB1c2hQcm9ncmFtOiBmdW5jdGlvbiBwdXNoUHJvZ3JhbShndWlkKSB7XHJcblx0ICAgIGlmIChndWlkICE9IG51bGwpIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwodGhpcy5wcm9ncmFtRXhwcmVzc2lvbihndWlkKSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKG51bGwpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtyZWdpc3RlckRlY29yYXRvcl1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBQb3BzIG9mZiB0aGUgZGVjb3JhdG9yJ3MgcGFyYW1ldGVycywgaW52b2tlcyB0aGUgZGVjb3JhdG9yLFxyXG5cdCAgLy8gYW5kIGluc2VydHMgdGhlIGRlY29yYXRvciBpbnRvIHRoZSBkZWNvcmF0b3JzIGxpc3QuXHJcblx0ICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gcmVnaXN0ZXJEZWNvcmF0b3IocGFyYW1TaXplLCBuYW1lKSB7XHJcblx0ICAgIHZhciBmb3VuZERlY29yYXRvciA9IHRoaXMubmFtZUxvb2t1cCgnZGVjb3JhdG9ycycsIG5hbWUsICdkZWNvcmF0b3InKSxcclxuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLnNldHVwSGVscGVyQXJncyhuYW1lLCBwYXJhbVNpemUpO1xyXG5cclxuXHQgICAgdGhpcy5kZWNvcmF0b3JzLnB1c2goWydmbiA9ICcsIHRoaXMuZGVjb3JhdG9ycy5mdW5jdGlvbkNhbGwoZm91bmREZWNvcmF0b3IsICcnLCBbJ2ZuJywgJ3Byb3BzJywgJ2NvbnRhaW5lcicsIG9wdGlvbnNdKSwgJyB8fCBmbjsnXSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtpbnZva2VIZWxwZXJdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzdWx0IG9mIGhlbHBlciBpbnZvY2F0aW9uXHJcblx0ICAvL1xyXG5cdCAgLy8gUG9wcyBvZmYgdGhlIGhlbHBlcidzIHBhcmFtZXRlcnMsIGludm9rZXMgdGhlIGhlbHBlcixcclxuXHQgIC8vIGFuZCBwdXNoZXMgdGhlIGhlbHBlcidzIHJldHVybiB2YWx1ZSBvbnRvIHRoZSBzdGFjay5cclxuXHQgIC8vXHJcblx0ICAvLyBJZiB0aGUgaGVscGVyIGlzIG5vdCBmb3VuZCwgYGhlbHBlck1pc3NpbmdgIGlzIGNhbGxlZC5cclxuXHQgIGludm9rZUhlbHBlcjogZnVuY3Rpb24gaW52b2tlSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSwgaXNTaW1wbGUpIHtcclxuXHQgICAgdmFyIG5vbkhlbHBlciA9IHRoaXMucG9wU3RhY2soKSxcclxuXHQgICAgICAgIGhlbHBlciA9IHRoaXMuc2V0dXBIZWxwZXIocGFyYW1TaXplLCBuYW1lKSxcclxuXHQgICAgICAgIHNpbXBsZSA9IGlzU2ltcGxlID8gW2hlbHBlci5uYW1lLCAnIHx8ICddIDogJyc7XHJcblxyXG5cdCAgICB2YXIgbG9va3VwID0gWycoJ10uY29uY2F0KHNpbXBsZSwgbm9uSGVscGVyKTtcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XHJcblx0ICAgICAgbG9va3VwLnB1c2goJyB8fCAnLCB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5oZWxwZXJNaXNzaW5nJykpO1xyXG5cdCAgICB9XHJcblx0ICAgIGxvb2t1cC5wdXNoKCcpJyk7XHJcblxyXG5cdCAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGxvb2t1cCwgJ2NhbGwnLCBoZWxwZXIuY2FsbFBhcmFtcykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbaW52b2tlS25vd25IZWxwZXJdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzdWx0IG9mIGhlbHBlciBpbnZvY2F0aW9uXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGVyYXRpb24gaXMgdXNlZCB3aGVuIHRoZSBoZWxwZXIgaXMga25vd24gdG8gZXhpc3QsXHJcblx0ICAvLyBzbyBhIGBoZWxwZXJNaXNzaW5nYCBmYWxsYmFjayBpcyBub3QgcmVxdWlyZWQuXHJcblx0ICBpbnZva2VLbm93bkhlbHBlcjogZnVuY3Rpb24gaW52b2tlS25vd25IZWxwZXIocGFyYW1TaXplLCBuYW1lKSB7XHJcblx0ICAgIHZhciBoZWxwZXIgPSB0aGlzLnNldHVwSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSk7XHJcblx0ICAgIHRoaXMucHVzaCh0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoaGVscGVyLm5hbWUsICdjYWxsJywgaGVscGVyLmNhbGxQYXJhbXMpKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2ludm9rZUFtYmlndW91c11cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXN1bHQgb2YgZGlzYW1iaWd1YXRpb25cclxuXHQgIC8vXHJcblx0ICAvLyBUaGlzIG9wZXJhdGlvbiBpcyB1c2VkIHdoZW4gYW4gZXhwcmVzc2lvbiBsaWtlIGB7e2Zvb319YFxyXG5cdCAgLy8gaXMgcHJvdmlkZWQsIGJ1dCB3ZSBkb24ndCBrbm93IGF0IGNvbXBpbGUtdGltZSB3aGV0aGVyIGl0XHJcblx0ICAvLyBpcyBhIGhlbHBlciBvciBhIHBhdGguXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGVyYXRpb24gZW1pdHMgbW9yZSBjb2RlIHRoYW4gdGhlIG90aGVyIG9wdGlvbnMsXHJcblx0ICAvLyBhbmQgY2FuIGJlIGF2b2lkZWQgYnkgcGFzc2luZyB0aGUgYGtub3duSGVscGVyc2AgYW5kXHJcblx0ICAvLyBga25vd25IZWxwZXJzT25seWAgZmxhZ3MgYXQgY29tcGlsZS10aW1lLlxyXG5cdCAgaW52b2tlQW1iaWd1b3VzOiBmdW5jdGlvbiBpbnZva2VBbWJpZ3VvdXMobmFtZSwgaGVscGVyQ2FsbCkge1xyXG5cdCAgICB0aGlzLnVzZVJlZ2lzdGVyKCdoZWxwZXInKTtcclxuXHJcblx0ICAgIHZhciBub25IZWxwZXIgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblxyXG5cdCAgICB0aGlzLmVtcHR5SGFzaCgpO1xyXG5cdCAgICB2YXIgaGVscGVyID0gdGhpcy5zZXR1cEhlbHBlcigwLCBuYW1lLCBoZWxwZXJDYWxsKTtcclxuXHJcblx0ICAgIHZhciBoZWxwZXJOYW1lID0gdGhpcy5sYXN0SGVscGVyID0gdGhpcy5uYW1lTG9va3VwKCdoZWxwZXJzJywgbmFtZSwgJ2hlbHBlcicpO1xyXG5cclxuXHQgICAgdmFyIGxvb2t1cCA9IFsnKCcsICcoaGVscGVyID0gJywgaGVscGVyTmFtZSwgJyB8fCAnLCBub25IZWxwZXIsICcpJ107XHJcblx0ICAgIGlmICghdGhpcy5vcHRpb25zLnN0cmljdCkge1xyXG5cdCAgICAgIGxvb2t1cFswXSA9ICcoaGVscGVyID0gJztcclxuXHQgICAgICBsb29rdXAucHVzaCgnICE9IG51bGwgPyBoZWxwZXIgOiAnLCB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5oZWxwZXJNaXNzaW5nJykpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLnB1c2goWycoJywgbG9va3VwLCBoZWxwZXIucGFyYW1zSW5pdCA/IFsnKSwoJywgaGVscGVyLnBhcmFtc0luaXRdIDogW10sICcpLCcsICcodHlwZW9mIGhlbHBlciA9PT0gJywgdGhpcy5hbGlhc2FibGUoJ1wiZnVuY3Rpb25cIicpLCAnID8gJywgdGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKCdoZWxwZXInLCAnY2FsbCcsIGhlbHBlci5jYWxsUGFyYW1zKSwgJyA6IGhlbHBlcikpJ10pO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbaW52b2tlUGFydGlhbF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiBjb250ZXh0LCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrIGFmdGVyOiByZXN1bHQgb2YgcGFydGlhbCBpbnZvY2F0aW9uXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGVyYXRpb24gcG9wcyBvZmYgYSBjb250ZXh0LCBpbnZva2VzIGEgcGFydGlhbCB3aXRoIHRoYXQgY29udGV4dCxcclxuXHQgIC8vIGFuZCBwdXNoZXMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2NhdGlvbiBiYWNrLlxyXG5cdCAgaW52b2tlUGFydGlhbDogZnVuY3Rpb24gaW52b2tlUGFydGlhbChpc0R5bmFtaWMsIG5hbWUsIGluZGVudCkge1xyXG5cdCAgICB2YXIgcGFyYW1zID0gW10sXHJcblx0ICAgICAgICBvcHRpb25zID0gdGhpcy5zZXR1cFBhcmFtcyhuYW1lLCAxLCBwYXJhbXMpO1xyXG5cclxuXHQgICAgaWYgKGlzRHluYW1pYykge1xyXG5cdCAgICAgIG5hbWUgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgICAgZGVsZXRlIG9wdGlvbnMubmFtZTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKGluZGVudCkge1xyXG5cdCAgICAgIG9wdGlvbnMuaW5kZW50ID0gSlNPTi5zdHJpbmdpZnkoaW5kZW50KTtcclxuXHQgICAgfVxyXG5cdCAgICBvcHRpb25zLmhlbHBlcnMgPSAnaGVscGVycyc7XHJcblx0ICAgIG9wdGlvbnMucGFydGlhbHMgPSAncGFydGlhbHMnO1xyXG5cdCAgICBvcHRpb25zLmRlY29yYXRvcnMgPSAnY29udGFpbmVyLmRlY29yYXRvcnMnO1xyXG5cclxuXHQgICAgaWYgKCFpc0R5bmFtaWMpIHtcclxuXHQgICAgICBwYXJhbXMudW5zaGlmdCh0aGlzLm5hbWVMb29rdXAoJ3BhcnRpYWxzJywgbmFtZSwgJ3BhcnRpYWwnKSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcGFyYW1zLnVuc2hpZnQobmFtZSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0KSB7XHJcblx0ICAgICAgb3B0aW9ucy5kZXB0aHMgPSAnZGVwdGhzJztcclxuXHQgICAgfVxyXG5cdCAgICBvcHRpb25zID0gdGhpcy5vYmplY3RMaXRlcmFsKG9wdGlvbnMpO1xyXG5cdCAgICBwYXJhbXMucHVzaChvcHRpb25zKTtcclxuXHJcblx0ICAgIHRoaXMucHVzaCh0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoJ2NvbnRhaW5lci5pbnZva2VQYXJ0aWFsJywgJycsIHBhcmFtcykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbYXNzaWduVG9IYXNoXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi4sIGhhc2gsIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi4sIGhhc2gsIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFBvcHMgYSB2YWx1ZSBvZmYgdGhlIHN0YWNrIGFuZCBhc3NpZ25zIGl0IHRvIHRoZSBjdXJyZW50IGhhc2hcclxuXHQgIGFzc2lnblRvSGFzaDogZnVuY3Rpb24gYXNzaWduVG9IYXNoKGtleSkge1xyXG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLnBvcFN0YWNrKCksXHJcblx0ICAgICAgICBjb250ZXh0ID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgdHlwZSA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGlkID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICBpZCA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICB0eXBlID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIGNvbnRleHQgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBoYXNoID0gdGhpcy5oYXNoO1xyXG5cdCAgICBpZiAoY29udGV4dCkge1xyXG5cdCAgICAgIGhhc2guY29udGV4dHNba2V5XSA9IGNvbnRleHQ7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHR5cGUpIHtcclxuXHQgICAgICBoYXNoLnR5cGVzW2tleV0gPSB0eXBlO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChpZCkge1xyXG5cdCAgICAgIGhhc2guaWRzW2tleV0gPSBpZDtcclxuXHQgICAgfVxyXG5cdCAgICBoYXNoLnZhbHVlc1trZXldID0gdmFsdWU7XHJcblx0ICB9LFxyXG5cclxuXHQgIHB1c2hJZDogZnVuY3Rpb24gcHVzaElkKHR5cGUsIG5hbWUsIGNoaWxkKSB7XHJcblx0ICAgIGlmICh0eXBlID09PSAnQmxvY2tQYXJhbScpIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ2Jsb2NrUGFyYW1zWycgKyBuYW1lWzBdICsgJ10ucGF0aFsnICsgbmFtZVsxXSArICddJyArIChjaGlsZCA/ICcgKyAnICsgSlNPTi5zdHJpbmdpZnkoJy4nICsgY2hpbGQpIDogJycpKTtcclxuXHQgICAgfSBlbHNlIGlmICh0eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoU3RyaW5nKG5hbWUpO1xyXG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdTdWJFeHByZXNzaW9uJykge1xyXG5cdCAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgndHJ1ZScpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgnbnVsbCcpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIEhFTFBFUlNcclxuXHJcblx0ICBjb21waWxlcjogSmF2YVNjcmlwdENvbXBpbGVyLFxyXG5cclxuXHQgIGNvbXBpbGVDaGlsZHJlbjogZnVuY3Rpb24gY29tcGlsZUNoaWxkcmVuKGVudmlyb25tZW50LCBvcHRpb25zKSB7XHJcblx0ICAgIHZhciBjaGlsZHJlbiA9IGVudmlyb25tZW50LmNoaWxkcmVuLFxyXG5cdCAgICAgICAgY2hpbGQgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBjb21waWxlciA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuXHQgICAgICBjb21waWxlciA9IG5ldyB0aGlzLmNvbXBpbGVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxyXG5cclxuXHQgICAgICB2YXIgaW5kZXggPSB0aGlzLm1hdGNoRXhpc3RpbmdQcm9ncmFtKGNoaWxkKTtcclxuXHJcblx0ICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5wcm9ncmFtcy5wdXNoKCcnKTsgLy8gUGxhY2Vob2xkZXIgdG8gcHJldmVudCBuYW1lIGNvbmZsaWN0cyBmb3IgbmVzdGVkIGNoaWxkcmVuXHJcblx0ICAgICAgICBpbmRleCA9IHRoaXMuY29udGV4dC5wcm9ncmFtcy5sZW5ndGg7XHJcblx0ICAgICAgICBjaGlsZC5pbmRleCA9IGluZGV4O1xyXG5cdCAgICAgICAgY2hpbGQubmFtZSA9ICdwcm9ncmFtJyArIGluZGV4O1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LnByb2dyYW1zW2luZGV4XSA9IGNvbXBpbGVyLmNvbXBpbGUoY2hpbGQsIG9wdGlvbnMsIHRoaXMuY29udGV4dCwgIXRoaXMucHJlY29tcGlsZSk7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZGVjb3JhdG9yc1tpbmRleF0gPSBjb21waWxlci5kZWNvcmF0b3JzO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmVudmlyb25tZW50c1tpbmRleF0gPSBjaGlsZDtcclxuXHJcblx0ICAgICAgICB0aGlzLnVzZURlcHRocyA9IHRoaXMudXNlRGVwdGhzIHx8IGNvbXBpbGVyLnVzZURlcHRocztcclxuXHQgICAgICAgIHRoaXMudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IGNvbXBpbGVyLnVzZUJsb2NrUGFyYW1zO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBjaGlsZC5pbmRleCA9IGluZGV4O1xyXG5cdCAgICAgICAgY2hpbGQubmFtZSA9ICdwcm9ncmFtJyArIGluZGV4O1xyXG5cclxuXHQgICAgICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgY2hpbGQudXNlRGVwdGhzO1xyXG5cdCAgICAgICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgY2hpbGQudXNlQmxvY2tQYXJhbXM7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgbWF0Y2hFeGlzdGluZ1Byb2dyYW06IGZ1bmN0aW9uIG1hdGNoRXhpc3RpbmdQcm9ncmFtKGNoaWxkKSB7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgdmFyIGVudmlyb25tZW50ID0gdGhpcy5jb250ZXh0LmVudmlyb25tZW50c1tpXTtcclxuXHQgICAgICBpZiAoZW52aXJvbm1lbnQgJiYgZW52aXJvbm1lbnQuZXF1YWxzKGNoaWxkKSkge1xyXG5cdCAgICAgICAgcmV0dXJuIGk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIHByb2dyYW1FeHByZXNzaW9uOiBmdW5jdGlvbiBwcm9ncmFtRXhwcmVzc2lvbihndWlkKSB7XHJcblx0ICAgIHZhciBjaGlsZCA9IHRoaXMuZW52aXJvbm1lbnQuY2hpbGRyZW5bZ3VpZF0sXHJcblx0ICAgICAgICBwcm9ncmFtUGFyYW1zID0gW2NoaWxkLmluZGV4LCAnZGF0YScsIGNoaWxkLmJsb2NrUGFyYW1zXTtcclxuXHJcblx0ICAgIGlmICh0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IHRoaXMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgcHJvZ3JhbVBhcmFtcy5wdXNoKCdibG9ja1BhcmFtcycpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0aGlzLnVzZURlcHRocykge1xyXG5cdCAgICAgIHByb2dyYW1QYXJhbXMucHVzaCgnZGVwdGhzJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiAnY29udGFpbmVyLnByb2dyYW0oJyArIHByb2dyYW1QYXJhbXMuam9pbignLCAnKSArICcpJztcclxuXHQgIH0sXHJcblxyXG5cdCAgdXNlUmVnaXN0ZXI6IGZ1bmN0aW9uIHVzZVJlZ2lzdGVyKG5hbWUpIHtcclxuXHQgICAgaWYgKCF0aGlzLnJlZ2lzdGVyc1tuYW1lXSkge1xyXG5cdCAgICAgIHRoaXMucmVnaXN0ZXJzW25hbWVdID0gdHJ1ZTtcclxuXHQgICAgICB0aGlzLnJlZ2lzdGVycy5saXN0LnB1c2gobmFtZSk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgcHVzaDogZnVuY3Rpb24gcHVzaChleHByKSB7XHJcblx0ICAgIGlmICghKGV4cHIgaW5zdGFuY2VvZiBMaXRlcmFsKSkge1xyXG5cdCAgICAgIGV4cHIgPSB0aGlzLnNvdXJjZS53cmFwKGV4cHIpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLmlubGluZVN0YWNrLnB1c2goZXhwcik7XHJcblx0ICAgIHJldHVybiBleHByO1xyXG5cdCAgfSxcclxuXHJcblx0ICBwdXNoU3RhY2tMaXRlcmFsOiBmdW5jdGlvbiBwdXNoU3RhY2tMaXRlcmFsKGl0ZW0pIHtcclxuXHQgICAgdGhpcy5wdXNoKG5ldyBMaXRlcmFsKGl0ZW0pKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgcHVzaFNvdXJjZTogZnVuY3Rpb24gcHVzaFNvdXJjZShzb3VyY2UpIHtcclxuXHQgICAgaWYgKHRoaXMucGVuZGluZ0NvbnRlbnQpIHtcclxuXHQgICAgICB0aGlzLnNvdXJjZS5wdXNoKHRoaXMuYXBwZW5kVG9CdWZmZXIodGhpcy5zb3VyY2UucXVvdGVkU3RyaW5nKHRoaXMucGVuZGluZ0NvbnRlbnQpLCB0aGlzLnBlbmRpbmdMb2NhdGlvbikpO1xyXG5cdCAgICAgIHRoaXMucGVuZGluZ0NvbnRlbnQgPSB1bmRlZmluZWQ7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmIChzb3VyY2UpIHtcclxuXHQgICAgICB0aGlzLnNvdXJjZS5wdXNoKHNvdXJjZSk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgcmVwbGFjZVN0YWNrOiBmdW5jdGlvbiByZXBsYWNlU3RhY2soY2FsbGJhY2spIHtcclxuXHQgICAgdmFyIHByZWZpeCA9IFsnKCddLFxyXG5cdCAgICAgICAgc3RhY2sgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBjcmVhdGVkU3RhY2sgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICB1c2VkTGl0ZXJhbCA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgIGlmICghdGhpcy5pc0lubGluZSgpKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ3JlcGxhY2VTdGFjayBvbiBub24taW5saW5lJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIFdlIHdhbnQgdG8gbWVyZ2UgdGhlIGlubGluZSBzdGF0ZW1lbnQgaW50byB0aGUgcmVwbGFjZW1lbnQgc3RhdGVtZW50IHZpYSAnLCdcclxuXHQgICAgdmFyIHRvcCA9IHRoaXMucG9wU3RhY2sodHJ1ZSk7XHJcblxyXG5cdCAgICBpZiAodG9wIGluc3RhbmNlb2YgTGl0ZXJhbCkge1xyXG5cdCAgICAgIC8vIExpdGVyYWxzIGRvIG5vdCBuZWVkIHRvIGJlIGlubGluZWRcclxuXHQgICAgICBzdGFjayA9IFt0b3AudmFsdWVdO1xyXG5cdCAgICAgIHByZWZpeCA9IFsnKCcsIHN0YWNrXTtcclxuXHQgICAgICB1c2VkTGl0ZXJhbCA9IHRydWU7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBzdGFjayBuYW1lIGZvciB1c2UgYnkgdGhlIGlubGluZVxyXG5cdCAgICAgIGNyZWF0ZWRTdGFjayA9IHRydWU7XHJcblx0ICAgICAgdmFyIF9uYW1lID0gdGhpcy5pbmNyU3RhY2soKTtcclxuXHJcblx0ICAgICAgcHJlZml4ID0gWycoKCcsIHRoaXMucHVzaChfbmFtZSksICcgPSAnLCB0b3AsICcpJ107XHJcblx0ICAgICAgc3RhY2sgPSB0aGlzLnRvcFN0YWNrKCk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBpdGVtID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdGFjayk7XHJcblxyXG5cdCAgICBpZiAoIXVzZWRMaXRlcmFsKSB7XHJcblx0ICAgICAgdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChjcmVhdGVkU3RhY2spIHtcclxuXHQgICAgICB0aGlzLnN0YWNrU2xvdC0tO1xyXG5cdCAgICB9XHJcblx0ICAgIHRoaXMucHVzaChwcmVmaXguY29uY2F0KGl0ZW0sICcpJykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBpbmNyU3RhY2s6IGZ1bmN0aW9uIGluY3JTdGFjaygpIHtcclxuXHQgICAgdGhpcy5zdGFja1Nsb3QrKztcclxuXHQgICAgaWYgKHRoaXMuc3RhY2tTbG90ID4gdGhpcy5zdGFja1ZhcnMubGVuZ3RoKSB7XHJcblx0ICAgICAgdGhpcy5zdGFja1ZhcnMucHVzaCgnc3RhY2snICsgdGhpcy5zdGFja1Nsb3QpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiB0aGlzLnRvcFN0YWNrTmFtZSgpO1xyXG5cdCAgfSxcclxuXHQgIHRvcFN0YWNrTmFtZTogZnVuY3Rpb24gdG9wU3RhY2tOYW1lKCkge1xyXG5cdCAgICByZXR1cm4gJ3N0YWNrJyArIHRoaXMuc3RhY2tTbG90O1xyXG5cdCAgfSxcclxuXHQgIGZsdXNoSW5saW5lOiBmdW5jdGlvbiBmbHVzaElubGluZSgpIHtcclxuXHQgICAgdmFyIGlubGluZVN0YWNrID0gdGhpcy5pbmxpbmVTdGFjaztcclxuXHQgICAgdGhpcy5pbmxpbmVTdGFjayA9IFtdO1xyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5saW5lU3RhY2subGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICB2YXIgZW50cnkgPSBpbmxpbmVTdGFja1tpXTtcclxuXHQgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuXHQgICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBMaXRlcmFsKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbXBpbGVTdGFjay5wdXNoKGVudHJ5KTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5pbmNyU3RhY2soKTtcclxuXHQgICAgICAgIHRoaXMucHVzaFNvdXJjZShbc3RhY2ssICcgPSAnLCBlbnRyeSwgJzsnXSk7XHJcblx0ICAgICAgICB0aGlzLmNvbXBpbGVTdGFjay5wdXNoKHN0YWNrKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblx0ICBpc0lubGluZTogZnVuY3Rpb24gaXNJbmxpbmUoKSB7XHJcblx0ICAgIHJldHVybiB0aGlzLmlubGluZVN0YWNrLmxlbmd0aDtcclxuXHQgIH0sXHJcblxyXG5cdCAgcG9wU3RhY2s6IGZ1bmN0aW9uIHBvcFN0YWNrKHdyYXBwZWQpIHtcclxuXHQgICAgdmFyIGlubGluZSA9IHRoaXMuaXNJbmxpbmUoKSxcclxuXHQgICAgICAgIGl0ZW0gPSAoaW5saW5lID8gdGhpcy5pbmxpbmVTdGFjayA6IHRoaXMuY29tcGlsZVN0YWNrKS5wb3AoKTtcclxuXHJcblx0ICAgIGlmICghd3JhcHBlZCAmJiBpdGVtIGluc3RhbmNlb2YgTGl0ZXJhbCkge1xyXG5cdCAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIGlmICghaW5saW5lKSB7XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgICAgaWYgKCF0aGlzLnN0YWNrU2xvdCkge1xyXG5cdCAgICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnSW52YWxpZCBzdGFjayBwb3AnKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHRoaXMuc3RhY2tTbG90LS07XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHJldHVybiBpdGVtO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIHRvcFN0YWNrOiBmdW5jdGlvbiB0b3BTdGFjaygpIHtcclxuXHQgICAgdmFyIHN0YWNrID0gdGhpcy5pc0lubGluZSgpID8gdGhpcy5pbmxpbmVTdGFjayA6IHRoaXMuY29tcGlsZVN0YWNrLFxyXG5cdCAgICAgICAgaXRlbSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG5cclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcblx0ICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTGl0ZXJhbCkge1xyXG5cdCAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiBpdGVtO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIGNvbnRleHROYW1lOiBmdW5jdGlvbiBjb250ZXh0TmFtZShjb250ZXh0KSB7XHJcblx0ICAgIGlmICh0aGlzLnVzZURlcHRocyAmJiBjb250ZXh0KSB7XHJcblx0ICAgICAgcmV0dXJuICdkZXB0aHNbJyArIGNvbnRleHQgKyAnXSc7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuICdkZXB0aCcgKyBjb250ZXh0O1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIHF1b3RlZFN0cmluZzogZnVuY3Rpb24gcXVvdGVkU3RyaW5nKHN0cikge1xyXG5cdCAgICByZXR1cm4gdGhpcy5zb3VyY2UucXVvdGVkU3RyaW5nKHN0cik7XHJcblx0ICB9LFxyXG5cclxuXHQgIG9iamVjdExpdGVyYWw6IGZ1bmN0aW9uIG9iamVjdExpdGVyYWwob2JqKSB7XHJcblx0ICAgIHJldHVybiB0aGlzLnNvdXJjZS5vYmplY3RMaXRlcmFsKG9iaik7XHJcblx0ICB9LFxyXG5cclxuXHQgIGFsaWFzYWJsZTogZnVuY3Rpb24gYWxpYXNhYmxlKG5hbWUpIHtcclxuXHQgICAgdmFyIHJldCA9IHRoaXMuYWxpYXNlc1tuYW1lXTtcclxuXHQgICAgaWYgKHJldCkge1xyXG5cdCAgICAgIHJldC5yZWZlcmVuY2VDb3VudCsrO1xyXG5cdCAgICAgIHJldHVybiByZXQ7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldCA9IHRoaXMuYWxpYXNlc1tuYW1lXSA9IHRoaXMuc291cmNlLndyYXAobmFtZSk7XHJcblx0ICAgIHJldC5hbGlhc2FibGUgPSB0cnVlO1xyXG5cdCAgICByZXQucmVmZXJlbmNlQ291bnQgPSAxO1xyXG5cclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH0sXHJcblxyXG5cdCAgc2V0dXBIZWxwZXI6IGZ1bmN0aW9uIHNldHVwSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSwgYmxvY2tIZWxwZXIpIHtcclxuXHQgICAgdmFyIHBhcmFtcyA9IFtdLFxyXG5cdCAgICAgICAgcGFyYW1zSW5pdCA9IHRoaXMuc2V0dXBIZWxwZXJBcmdzKG5hbWUsIHBhcmFtU2l6ZSwgcGFyYW1zLCBibG9ja0hlbHBlcik7XHJcblx0ICAgIHZhciBmb3VuZEhlbHBlciA9IHRoaXMubmFtZUxvb2t1cCgnaGVscGVycycsIG5hbWUsICdoZWxwZXInKSxcclxuXHQgICAgICAgIGNhbGxDb250ZXh0ID0gdGhpcy5hbGlhc2FibGUodGhpcy5jb250ZXh0TmFtZSgwKSArICcgIT0gbnVsbCA/ICcgKyB0aGlzLmNvbnRleHROYW1lKDApICsgJyA6IHt9Jyk7XHJcblxyXG5cdCAgICByZXR1cm4ge1xyXG5cdCAgICAgIHBhcmFtczogcGFyYW1zLFxyXG5cdCAgICAgIHBhcmFtc0luaXQ6IHBhcmFtc0luaXQsXHJcblx0ICAgICAgbmFtZTogZm91bmRIZWxwZXIsXHJcblx0ICAgICAgY2FsbFBhcmFtczogW2NhbGxDb250ZXh0XS5jb25jYXQocGFyYW1zKVxyXG5cdCAgICB9O1xyXG5cdCAgfSxcclxuXHJcblx0ICBzZXR1cFBhcmFtczogZnVuY3Rpb24gc2V0dXBQYXJhbXMoaGVscGVyLCBwYXJhbVNpemUsIHBhcmFtcykge1xyXG5cdCAgICB2YXIgb3B0aW9ucyA9IHt9LFxyXG5cdCAgICAgICAgY29udGV4dHMgPSBbXSxcclxuXHQgICAgICAgIHR5cGVzID0gW10sXHJcblx0ICAgICAgICBpZHMgPSBbXSxcclxuXHQgICAgICAgIG9iamVjdEFyZ3MgPSAhcGFyYW1zLFxyXG5cdCAgICAgICAgcGFyYW0gPSB1bmRlZmluZWQ7XHJcblxyXG5cdCAgICBpZiAob2JqZWN0QXJncykge1xyXG5cdCAgICAgIHBhcmFtcyA9IFtdO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBvcHRpb25zLm5hbWUgPSB0aGlzLnF1b3RlZFN0cmluZyhoZWxwZXIpO1xyXG5cdCAgICBvcHRpb25zLmhhc2ggPSB0aGlzLnBvcFN0YWNrKCk7XHJcblxyXG5cdCAgICBpZiAodGhpcy50cmFja0lkcykge1xyXG5cdCAgICAgIG9wdGlvbnMuaGFzaElkcyA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICBvcHRpb25zLmhhc2hUeXBlcyA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgICBvcHRpb25zLmhhc2hDb250ZXh0cyA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGludmVyc2UgPSB0aGlzLnBvcFN0YWNrKCksXHJcblx0ICAgICAgICBwcm9ncmFtID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cclxuXHQgICAgLy8gQXZvaWQgc2V0dGluZyBmbiBhbmQgaW52ZXJzZSBpZiBuZWl0aGVyIGFyZSBzZXQuIFRoaXMgYWxsb3dzXHJcblx0ICAgIC8vIGhlbHBlcnMgdG8gZG8gYSBjaGVjayBmb3IgYGlmIChvcHRpb25zLmZuKWBcclxuXHQgICAgaWYgKHByb2dyYW0gfHwgaW52ZXJzZSkge1xyXG5cdCAgICAgIG9wdGlvbnMuZm4gPSBwcm9ncmFtIHx8ICdjb250YWluZXIubm9vcCc7XHJcblx0ICAgICAgb3B0aW9ucy5pbnZlcnNlID0gaW52ZXJzZSB8fCAnY29udGFpbmVyLm5vb3AnO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBUaGUgcGFyYW1ldGVycyBnbyBvbiB0byB0aGUgc3RhY2sgaW4gb3JkZXIgKG1ha2luZyBzdXJlIHRoYXQgdGhleSBhcmUgZXZhbHVhdGVkIGluIG9yZGVyKVxyXG5cdCAgICAvLyBzbyB3ZSBuZWVkIHRvIHBvcCB0aGVtIG9mZiB0aGUgc3RhY2sgaW4gcmV2ZXJzZSBvcmRlclxyXG5cdCAgICB2YXIgaSA9IHBhcmFtU2l6ZTtcclxuXHQgICAgd2hpbGUgKGktLSkge1xyXG5cdCAgICAgIHBhcmFtID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIHBhcmFtc1tpXSA9IHBhcmFtO1xyXG5cclxuXHQgICAgICBpZiAodGhpcy50cmFja0lkcykge1xyXG5cdCAgICAgICAgaWRzW2ldID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICAgIHR5cGVzW2ldID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgICAgY29udGV4dHNbaV0gPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAob2JqZWN0QXJncykge1xyXG5cdCAgICAgIG9wdGlvbnMuYXJncyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkocGFyYW1zKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICBvcHRpb25zLmlkcyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkoaWRzKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICBvcHRpb25zLnR5cGVzID0gdGhpcy5zb3VyY2UuZ2VuZXJhdGVBcnJheSh0eXBlcyk7XHJcblx0ICAgICAgb3B0aW9ucy5jb250ZXh0cyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkoY29udGV4dHMpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmRhdGEpIHtcclxuXHQgICAgICBvcHRpb25zLmRhdGEgPSAnZGF0YSc7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMudXNlQmxvY2tQYXJhbXMpIHtcclxuXHQgICAgICBvcHRpb25zLmJsb2NrUGFyYW1zID0gJ2Jsb2NrUGFyYW1zJztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gb3B0aW9ucztcclxuXHQgIH0sXHJcblxyXG5cdCAgc2V0dXBIZWxwZXJBcmdzOiBmdW5jdGlvbiBzZXR1cEhlbHBlckFyZ3MoaGVscGVyLCBwYXJhbVNpemUsIHBhcmFtcywgdXNlUmVnaXN0ZXIpIHtcclxuXHQgICAgdmFyIG9wdGlvbnMgPSB0aGlzLnNldHVwUGFyYW1zKGhlbHBlciwgcGFyYW1TaXplLCBwYXJhbXMpO1xyXG5cdCAgICBvcHRpb25zID0gdGhpcy5vYmplY3RMaXRlcmFsKG9wdGlvbnMpO1xyXG5cdCAgICBpZiAodXNlUmVnaXN0ZXIpIHtcclxuXHQgICAgICB0aGlzLnVzZVJlZ2lzdGVyKCdvcHRpb25zJyk7XHJcblx0ICAgICAgcGFyYW1zLnB1c2goJ29wdGlvbnMnKTtcclxuXHQgICAgICByZXR1cm4gWydvcHRpb25zPScsIG9wdGlvbnNdO1xyXG5cdCAgICB9IGVsc2UgaWYgKHBhcmFtcykge1xyXG5cdCAgICAgIHBhcmFtcy5wdXNoKG9wdGlvbnMpO1xyXG5cdCAgICAgIHJldHVybiAnJztcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gb3B0aW9ucztcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICB2YXIgcmVzZXJ2ZWRXb3JkcyA9ICgnYnJlYWsgZWxzZSBuZXcgdmFyJyArICcgY2FzZSBmaW5hbGx5IHJldHVybiB2b2lkJyArICcgY2F0Y2ggZm9yIHN3aXRjaCB3aGlsZScgKyAnIGNvbnRpbnVlIGZ1bmN0aW9uIHRoaXMgd2l0aCcgKyAnIGRlZmF1bHQgaWYgdGhyb3cnICsgJyBkZWxldGUgaW4gdHJ5JyArICcgZG8gaW5zdGFuY2VvZiB0eXBlb2YnICsgJyBhYnN0cmFjdCBlbnVtIGludCBzaG9ydCcgKyAnIGJvb2xlYW4gZXhwb3J0IGludGVyZmFjZSBzdGF0aWMnICsgJyBieXRlIGV4dGVuZHMgbG9uZyBzdXBlcicgKyAnIGNoYXIgZmluYWwgbmF0aXZlIHN5bmNocm9uaXplZCcgKyAnIGNsYXNzIGZsb2F0IHBhY2thZ2UgdGhyb3dzJyArICcgY29uc3QgZ290byBwcml2YXRlIHRyYW5zaWVudCcgKyAnIGRlYnVnZ2VyIGltcGxlbWVudHMgcHJvdGVjdGVkIHZvbGF0aWxlJyArICcgZG91YmxlIGltcG9ydCBwdWJsaWMgbGV0IHlpZWxkIGF3YWl0JyArICcgbnVsbCB0cnVlIGZhbHNlJykuc3BsaXQoJyAnKTtcclxuXHJcblx0ICB2YXIgY29tcGlsZXJXb3JkcyA9IEphdmFTY3JpcHRDb21waWxlci5SRVNFUlZFRF9XT1JEUyA9IHt9O1xyXG5cclxuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gcmVzZXJ2ZWRXb3Jkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgY29tcGlsZXJXb3Jkc1tyZXNlcnZlZFdvcmRzW2ldXSA9IHRydWU7XHJcblx0ICB9XHJcblx0fSkoKTtcclxuXHJcblx0SmF2YVNjcmlwdENvbXBpbGVyLmlzVmFsaWRKYXZhU2NyaXB0VmFyaWFibGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuXHQgIHJldHVybiAhSmF2YVNjcmlwdENvbXBpbGVyLlJFU0VSVkVEX1dPUkRTW25hbWVdICYmIC9eW2EtekEtWl8kXVswLTlhLXpBLVpfJF0qJC8udGVzdChuYW1lKTtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzdHJpY3RMb29rdXAocmVxdWlyZVRlcm1pbmFsLCBjb21waWxlciwgcGFydHMsIHR5cGUpIHtcclxuXHQgIHZhciBzdGFjayA9IGNvbXBpbGVyLnBvcFN0YWNrKCksXHJcblx0ICAgICAgaSA9IDAsXHJcblx0ICAgICAgbGVuID0gcGFydHMubGVuZ3RoO1xyXG5cdCAgaWYgKHJlcXVpcmVUZXJtaW5hbCkge1xyXG5cdCAgICBsZW4tLTtcclxuXHQgIH1cclxuXHJcblx0ICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgIHN0YWNrID0gY29tcGlsZXIubmFtZUxvb2t1cChzdGFjaywgcGFydHNbaV0sIHR5cGUpO1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChyZXF1aXJlVGVybWluYWwpIHtcclxuXHQgICAgcmV0dXJuIFtjb21waWxlci5hbGlhc2FibGUoJ2NvbnRhaW5lci5zdHJpY3QnKSwgJygnLCBzdGFjaywgJywgJywgY29tcGlsZXIucXVvdGVkU3RyaW5nKHBhcnRzW2ldKSwgJyknXTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJldHVybiBzdGFjaztcclxuXHQgIH1cclxuXHR9XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IEphdmFTY3JpcHRDb21waWxlcjtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0sXHJcbi8qIDI5ICovXHJcbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvKiBnbG9iYWwgZGVmaW5lICovXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0dmFyIFNvdXJjZU5vZGUgPSB1bmRlZmluZWQ7XHJcblxyXG5cdHRyeSB7XHJcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgaWYgKGZhbHNlKSB7XHJcblx0ICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgdGhpcyBpbiBBTUQgZW52aXJvbm1lbnRzLiBGb3IgdGhlc2UgZW52aXJvbm1lbnRzLCB3ZSBhc3VzbWUgdGhhdFxyXG5cdCAgICAvLyB0aGV5IGFyZSBydW5uaW5nIG9uIHRoZSBicm93c2VyIGFuZCB0aHVzIGhhdmUgbm8gbmVlZCBmb3IgdGhlIHNvdXJjZS1tYXAgbGlicmFyeS5cclxuXHQgICAgdmFyIFNvdXJjZU1hcCA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKTtcclxuXHQgICAgU291cmNlTm9kZSA9IFNvdXJjZU1hcC5Tb3VyY2VOb2RlO1xyXG5cdCAgfVxyXG5cdH0gY2F0Y2ggKGVycikge31cclxuXHQvKiBOT1AgKi9cclxuXHJcblx0LyogaXN0YW5idWwgaWdub3JlIGlmOiB0ZXN0ZWQgYnV0IG5vdCBjb3ZlcmVkIGluIGlzdGFuYnVsIGR1ZSB0byBkaXN0IGJ1aWxkICAqL1xyXG5cdGlmICghU291cmNlTm9kZSkge1xyXG5cdCAgU291cmNlTm9kZSA9IGZ1bmN0aW9uIChsaW5lLCBjb2x1bW4sIHNyY0ZpbGUsIGNodW5rcykge1xyXG5cdCAgICB0aGlzLnNyYyA9ICcnO1xyXG5cdCAgICBpZiAoY2h1bmtzKSB7XHJcblx0ICAgICAgdGhpcy5hZGQoY2h1bmtzKTtcclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICBTb3VyY2VOb2RlLnByb3RvdHlwZSA9IHtcclxuXHQgICAgYWRkOiBmdW5jdGlvbiBhZGQoY2h1bmtzKSB7XHJcblx0ICAgICAgaWYgKF91dGlscy5pc0FycmF5KGNodW5rcykpIHtcclxuXHQgICAgICAgIGNodW5rcyA9IGNodW5rcy5qb2luKCcnKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgdGhpcy5zcmMgKz0gY2h1bmtzO1xyXG5cdCAgICB9LFxyXG5cdCAgICBwcmVwZW5kOiBmdW5jdGlvbiBwcmVwZW5kKGNodW5rcykge1xyXG5cdCAgICAgIGlmIChfdXRpbHMuaXNBcnJheShjaHVua3MpKSB7XHJcblx0ICAgICAgICBjaHVua3MgPSBjaHVua3Muam9pbignJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHRoaXMuc3JjID0gY2h1bmtzICsgdGhpcy5zcmM7XHJcblx0ICAgIH0sXHJcblx0ICAgIHRvU3RyaW5nV2l0aFNvdXJjZU1hcDogZnVuY3Rpb24gdG9TdHJpbmdXaXRoU291cmNlTWFwKCkge1xyXG5cdCAgICAgIHJldHVybiB7IGNvZGU6IHRoaXMudG9TdHJpbmcoKSB9O1xyXG5cdCAgICB9LFxyXG5cdCAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMuc3JjO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY2FzdENodW5rKGNodW5rLCBjb2RlR2VuLCBsb2MpIHtcclxuXHQgIGlmIChfdXRpbHMuaXNBcnJheShjaHVuaykpIHtcclxuXHQgICAgdmFyIHJldCA9IFtdO1xyXG5cclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgcmV0LnB1c2goY29kZUdlbi53cmFwKGNodW5rW2ldLCBsb2MpKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gcmV0O1xyXG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgY2h1bmsgPT09ICdudW1iZXInKSB7XHJcblx0ICAgIC8vIEhhbmRsZSBwcmltaXRpdmVzIHRoYXQgdGhlIFNvdXJjZU5vZGUgd2lsbCB0aHJvdyB1cCBvblxyXG5cdCAgICByZXR1cm4gY2h1bmsgKyAnJztcclxuXHQgIH1cclxuXHQgIHJldHVybiBjaHVuaztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIENvZGVHZW4oc3JjRmlsZSkge1xyXG5cdCAgdGhpcy5zcmNGaWxlID0gc3JjRmlsZTtcclxuXHQgIHRoaXMuc291cmNlID0gW107XHJcblx0fVxyXG5cclxuXHRDb2RlR2VuLnByb3RvdHlwZSA9IHtcclxuXHQgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XHJcblx0ICAgIHJldHVybiAhdGhpcy5zb3VyY2UubGVuZ3RoO1xyXG5cdCAgfSxcclxuXHQgIHByZXBlbmQ6IGZ1bmN0aW9uIHByZXBlbmQoc291cmNlLCBsb2MpIHtcclxuXHQgICAgdGhpcy5zb3VyY2UudW5zaGlmdCh0aGlzLndyYXAoc291cmNlLCBsb2MpKTtcclxuXHQgIH0sXHJcblx0ICBwdXNoOiBmdW5jdGlvbiBwdXNoKHNvdXJjZSwgbG9jKSB7XHJcblx0ICAgIHRoaXMuc291cmNlLnB1c2godGhpcy53cmFwKHNvdXJjZSwgbG9jKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZSgpIHtcclxuXHQgICAgdmFyIHNvdXJjZSA9IHRoaXMuZW1wdHkoKTtcclxuXHQgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChsaW5lKSB7XHJcblx0ICAgICAgc291cmNlLmFkZChbJyAgJywgbGluZSwgJ1xcbiddKTtcclxuXHQgICAgfSk7XHJcblx0ICAgIHJldHVybiBzb3VyY2U7XHJcblx0ICB9LFxyXG5cclxuXHQgIGVhY2g6IGZ1bmN0aW9uIGVhY2goaXRlcikge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICBpdGVyKHRoaXMuc291cmNlW2ldKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XHJcblx0ICAgIHZhciBsb2MgPSB0aGlzLmN1cnJlbnRMb2NhdGlvbiB8fCB7IHN0YXJ0OiB7fSB9O1xyXG5cdCAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobG9jLnN0YXJ0LmxpbmUsIGxvYy5zdGFydC5jb2x1bW4sIHRoaXMuc3JjRmlsZSk7XHJcblx0ICB9LFxyXG5cdCAgd3JhcDogZnVuY3Rpb24gd3JhcChjaHVuaykge1xyXG5cdCAgICB2YXIgbG9jID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5jdXJyZW50TG9jYXRpb24gfHwgeyBzdGFydDoge30gfSA6IGFyZ3VtZW50c1sxXTtcclxuXHJcblx0ICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUpIHtcclxuXHQgICAgICByZXR1cm4gY2h1bms7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGNodW5rID0gY2FzdENodW5rKGNodW5rLCB0aGlzLCBsb2MpO1xyXG5cclxuXHQgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKGxvYy5zdGFydC5saW5lLCBsb2Muc3RhcnQuY29sdW1uLCB0aGlzLnNyY0ZpbGUsIGNodW5rKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgZnVuY3Rpb25DYWxsOiBmdW5jdGlvbiBmdW5jdGlvbkNhbGwoZm4sIHR5cGUsIHBhcmFtcykge1xyXG5cdCAgICBwYXJhbXMgPSB0aGlzLmdlbmVyYXRlTGlzdChwYXJhbXMpO1xyXG5cdCAgICByZXR1cm4gdGhpcy53cmFwKFtmbiwgdHlwZSA/ICcuJyArIHR5cGUgKyAnKCcgOiAnKCcsIHBhcmFtcywgJyknXSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIHF1b3RlZFN0cmluZzogZnVuY3Rpb24gcXVvdGVkU3RyaW5nKHN0cikge1xyXG5cdCAgICByZXR1cm4gJ1wiJyArIChzdHIgKyAnJykucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKS5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKSAvLyBQZXIgRWNtYS0yNjIgNy4zICsgNy44LjRcclxuXHQgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpICsgJ1wiJztcclxuXHQgIH0sXHJcblxyXG5cdCAgb2JqZWN0TGl0ZXJhbDogZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbChvYmopIHtcclxuXHQgICAgdmFyIHBhaXJzID0gW107XHJcblxyXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcblx0ICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBjYXN0Q2h1bmsob2JqW2tleV0sIHRoaXMpO1xyXG5cdCAgICAgICAgaWYgKHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICBwYWlycy5wdXNoKFt0aGlzLnF1b3RlZFN0cmluZyhrZXkpLCAnOicsIHZhbHVlXSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgcmV0ID0gdGhpcy5nZW5lcmF0ZUxpc3QocGFpcnMpO1xyXG5cdCAgICByZXQucHJlcGVuZCgneycpO1xyXG5cdCAgICByZXQuYWRkKCd9Jyk7XHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9LFxyXG5cclxuXHQgIGdlbmVyYXRlTGlzdDogZnVuY3Rpb24gZ2VuZXJhdGVMaXN0KGVudHJpZXMpIHtcclxuXHQgICAgdmFyIHJldCA9IHRoaXMuZW1wdHkoKTtcclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgaWYgKGkpIHtcclxuXHQgICAgICAgIHJldC5hZGQoJywnKTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHJldC5hZGQoY2FzdENodW5rKGVudHJpZXNbaV0sIHRoaXMpKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH0sXHJcblxyXG5cdCAgZ2VuZXJhdGVBcnJheTogZnVuY3Rpb24gZ2VuZXJhdGVBcnJheShlbnRyaWVzKSB7XHJcblx0ICAgIHZhciByZXQgPSB0aGlzLmdlbmVyYXRlTGlzdChlbnRyaWVzKTtcclxuXHQgICAgcmV0LnByZXBlbmQoJ1snKTtcclxuXHQgICAgcmV0LmFkZCgnXScpO1xyXG5cclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBDb2RlR2VuO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfVxyXG4vKioqKioqLyBdKVxyXG59KTtcclxuOyJdLCJmaWxlIjoiaGFuZGxlYmFycy9oYW5kbGViYXJzLXY0LjAuNS5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9

/**
 * Mattias Johansson
 * @author www.verodella.se
 * @copyright Mattias Johansson
 * License http://opensource.org/licenses/MIT
 */

var MOS = window.MOS || {};
MOS.inView = (function() {

    var c = (console) ? console : {
        log: function() {}
    };
    c.l = c.log;

    var _watchList = [];

    function _onEventDone(event, fn, wait) {

        var tm;
        $(window).on(event, function() {
            if (tm) {
                window.clearTimeout(tm);
            }
            tm = window.setTimeout(fn, wait);
        });

    }

    function _trace(label, value) {

        if (!MOS.inView.doTrace) return;

        value += ' ';
        if (!window.traceOut) {
            window.traceOut = {
                container: $('<div id="traceOut" style="border: 1px solid #eee;text-align: left; z-index: 9999; position: fixed; right:10px; top: 10px; width: 280px; padding:10px; background-color: #fff;font-family:sans-serif;font-size:12px; color:#000;"></div>'),
                outs: {}
            };
            $(document.body).append(window.traceOut.container);
        }
        var propName = label,
            outStr = label,
            currOut;
        if (value) outStr = label + ': ' + value;
        currOut = window.traceOut.outs[propName];
        if (!currOut) {
            window.traceOut.container.append($('<div class="' + propName + '">' + outStr + '</div>'));
            window.traceOut.outs[propName] = $('#traceOut .' + propName);
        } else {
            window.traceOut.outs[propName].html(outStr);
        }
    }


    function _checkBoundery($target, boundsSize) {

        boundsSize = boundsSize || 1;

        var boundingRect = $target[0].getBoundingClientRect(),
            outerHeight = $target.outerHeight(),
            outerWidth = $target.outerWidth();

        if (
            boundingRect.top >= -1 * (outerHeight * boundsSize) &&
            boundingRect.bottom <= window.innerHeight + (outerHeight * boundsSize) &&
            boundingRect.left >= -1 * (outerWidth * boundsSize) &&
            boundingRect.right <= window.innerWidth + (outerWidth * boundsSize)
        ) {
            return true;
        } else {
            return false;
        }

    }

    function _whatsVisible() {

        var len = _watchList.length,
            i,
            curr,
            isVisible = [],
            isClose = [],
            notVisible = [],
            fn;

        fn = function(index) {

            curr = $(this);

            if (_checkBoundery(curr, 1)) {
                isVisible.push(curr);
                curr.addClass('isVisible');
            } else {
                notVisible.push(curr);
                curr.removeClass('isVisible');
            }

            if (_checkBoundery(curr, MOS.inView.outOfBoundsSize)) {
                if (!curr.hasClass('isVisible')) {
                    isClose.push(curr);
                }
            }

        };

        for (i = 0; i < len; i += 1) {
            _watchList[i].each(fn);

        }

        return {
            isVisible: isVisible,
            notVisible: notVisible,
            isClose: isClose
        };

    }

    function _onChecked(res) {

        var len = res.isVisible.length,
            i,
            strVisible = '';


        for (i = 0; i < len; i += 1) {
            strVisible += res.isVisible[i].attr('id') + ', ';
        }

        $.event.trigger({
            type: 'MOS.inViewCheck',
            states: res
        });

        if (MOS.inView.doTrace) _trace('Visible', strVisible);

        return res;

    }

    function _init() {

        _onEventDone('scroll', function(e) {
            _onChecked(_whatsVisible());
        }, 300);

        _onEventDone('resize', function(e) {
            _onChecked(_whatsVisible());
        }, 300);

        _init = function() {};

    }

    function _add(it) {

        _init();
        _watchList.push(it);

    }

    function _clear() {
        _watchList.length = 0;
    }

    function _check() {
        return _onChecked(_whatsVisible());
    }

    return {
        add: _add,
        outOfBoundsSize: 2,
        whatsVisible: _whatsVisible,
        check: _check,
        doTrace: false,
        clear: _clear
    };
}());

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJNT1MvaW5WaWV3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBNYXR0aWFzIEpvaGFuc3NvblxyXG4gKiBAYXV0aG9yIHd3dy52ZXJvZGVsbGEuc2VcclxuICogQGNvcHlyaWdodCBNYXR0aWFzIEpvaGFuc3NvblxyXG4gKiBMaWNlbnNlIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuICovXHJcblxyXG52YXIgTU9TID0gd2luZG93Lk1PUyB8fCB7fTtcclxuTU9TLmluVmlldyA9IChmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGMgPSAoY29uc29sZSkgPyBjb25zb2xlIDoge2xvZzogZnVuY3Rpb24gKCkge319OyBjLmwgPSBjLmxvZztcclxuXHJcblx0dmFyIF93YXRjaExpc3QgPSBbXTtcclxuXHJcblx0ZnVuY3Rpb24gX29uRXZlbnREb25lKGV2ZW50LCBmbiwgd2FpdCkge1xyXG5cclxuXHRcdHZhciB0bTtcclxuXHRcdCQod2luZG93KS5vbihldmVudCwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmICh0bSkge1xyXG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodG0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRtID0gd2luZG93LnNldFRpbWVvdXQoZm4sIHdhaXQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gX3RyYWNlKGxhYmVsLCB2YWx1ZSkge1xyXG5cclxuXHRcdGlmICghTU9TLmluVmlldy5kb1RyYWNlKSByZXR1cm47XHJcblxyXG5cdFx0dmFsdWUgKz0gJyAnO1xyXG5cdFx0aWYgKCF3aW5kb3cudHJhY2VPdXQpIHtcclxuXHRcdFx0d2luZG93LnRyYWNlT3V0ID0ge1xyXG5cdFx0XHRcdGNvbnRhaW5lcjogJCgnPGRpdiBpZD1cInRyYWNlT3V0XCIgc3R5bGU9XCJib3JkZXI6IDFweCBzb2xpZCAjZWVlO3RleHQtYWxpZ246IGxlZnQ7IHotaW5kZXg6IDk5OTk7IHBvc2l0aW9uOiBmaXhlZDsgcmlnaHQ6MTBweDsgdG9wOiAxMHB4OyB3aWR0aDogMjgwcHg7IHBhZGRpbmc6MTBweDsgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMnB4OyBjb2xvcjojMDAwO1wiPjwvZGl2PicpLFxyXG5cdFx0XHRcdG91dHM6IHt9XHJcblx0XHRcdH07XHJcblx0XHRcdCQoZG9jdW1lbnQuYm9keSkuYXBwZW5kKHdpbmRvdy50cmFjZU91dC5jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHByb3BOYW1lID0gbGFiZWwsXHJcblx0XHRcdG91dFN0ciA9IGxhYmVsLFxyXG5cdFx0XHRjdXJyT3V0O1xyXG5cdFx0aWYgKHZhbHVlKSBvdXRTdHIgPSBsYWJlbCArICc6ICcgKyB2YWx1ZTtcclxuXHRcdGN1cnJPdXQgPSB3aW5kb3cudHJhY2VPdXQub3V0c1twcm9wTmFtZV07XHJcblx0XHRpZiAoIWN1cnJPdXQpIHtcclxuXHRcdFx0d2luZG93LnRyYWNlT3V0LmNvbnRhaW5lci5hcHBlbmQoJCgnPGRpdiBjbGFzcz1cIicgKyBwcm9wTmFtZSArICdcIj4nICsgb3V0U3RyICsgJzwvZGl2PicpKTtcclxuXHRcdFx0d2luZG93LnRyYWNlT3V0Lm91dHNbcHJvcE5hbWVdID0gJCgnI3RyYWNlT3V0IC4nICsgcHJvcE5hbWUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2luZG93LnRyYWNlT3V0Lm91dHNbcHJvcE5hbWVdLmh0bWwob3V0U3RyKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBfY2hlY2tCb3VuZGVyeSAoJHRhcmdldCwgYm91bmRzU2l6ZSkge1xyXG5cclxuXHRcdGJvdW5kc1NpemUgPSBib3VuZHNTaXplIHx8IDE7XHJcblxyXG5cdFx0dmFyIGJvdW5kaW5nUmVjdCA9ICR0YXJnZXRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcblx0XHRcdG91dGVySGVpZ2h0ID0gJHRhcmdldC5vdXRlckhlaWdodCgpLFxyXG5cdFx0XHRvdXRlcldpZHRoID0gJHRhcmdldC5vdXRlcldpZHRoKCk7XHJcblxyXG5cdFx0aWYgKFxyXG5cdFx0XHRib3VuZGluZ1JlY3QudG9wID49IC0xICogKG91dGVySGVpZ2h0ICogYm91bmRzU2l6ZSkgJiZcclxuXHRcdFx0Ym91bmRpbmdSZWN0LmJvdHRvbSA8PSB3aW5kb3cuaW5uZXJIZWlnaHQgKyAob3V0ZXJIZWlnaHQgKiBib3VuZHNTaXplKSAmJlxyXG5cdFx0XHRib3VuZGluZ1JlY3QubGVmdCA+PSAtMSAqIChvdXRlcldpZHRoICogYm91bmRzU2l6ZSkgJiZcclxuXHRcdFx0Ym91bmRpbmdSZWN0LnJpZ2h0IDw9IHdpbmRvdy5pbm5lcldpZHRoICsgKG91dGVyV2lkdGggKiBib3VuZHNTaXplKVxyXG5cdFx0XHQpXHJcblx0XHR7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIF93aGF0c1Zpc2libGUoKSB7XHJcblxyXG5cdFx0dmFyIGxlbiA9IF93YXRjaExpc3QubGVuZ3RoLFxyXG5cdFx0XHRpLFxyXG5cdFx0XHRjdXJyLFxyXG5cdFx0XHRpc1Zpc2libGUgPSBbXSxcclxuXHRcdFx0aXNDbG9zZSA9IFtdLFxyXG5cdFx0XHRub3RWaXNpYmxlID0gW10sXHJcblx0XHRcdGZuO1xyXG5cclxuXHRcdGZuID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuXHJcblx0XHRcdGN1cnIgPSAkKHRoaXMpO1xyXG5cclxuXHRcdFx0aWYgKF9jaGVja0JvdW5kZXJ5IChjdXJyLCAxKSkge1xyXG5cdFx0XHRcdGlzVmlzaWJsZS5wdXNoKGN1cnIpO1xyXG5cdFx0XHRcdGN1cnIuYWRkQ2xhc3MoJ2lzVmlzaWJsZScpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG5vdFZpc2libGUucHVzaChjdXJyKTtcclxuXHRcdFx0XHRjdXJyLnJlbW92ZUNsYXNzKCdpc1Zpc2libGUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKF9jaGVja0JvdW5kZXJ5IChjdXJyLCBNT1MuaW5WaWV3Lm91dE9mQm91bmRzU2l6ZSkpIHtcclxuXHRcdFx0XHRpZiAoIWN1cnIuaGFzQ2xhc3MoJ2lzVmlzaWJsZScpKSB7XHJcblx0XHRcdFx0XHRpc0Nsb3NlLnB1c2goY3Vycik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuXHRcdFx0X3dhdGNoTGlzdFtpXS5lYWNoKGZuKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0aXNWaXNpYmxlOiBpc1Zpc2libGUsXHJcblx0XHRcdG5vdFZpc2libGU6IG5vdFZpc2libGUsXHJcblx0XHRcdGlzQ2xvc2U6IGlzQ2xvc2VcclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gX29uQ2hlY2tlZChyZXMpIHtcclxuXHJcblx0XHR2YXIgbGVuID0gcmVzLmlzVmlzaWJsZS5sZW5ndGgsXHJcblx0XHRcdGksXHJcblx0XHRcdHN0clZpc2libGUgPSAnJztcclxuXHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcblx0XHRcdHN0clZpc2libGUgKz0gcmVzLmlzVmlzaWJsZVtpXS5hdHRyKCdpZCcpICsgJywgJztcclxuXHRcdH1cclxuXHJcblx0XHQkLmV2ZW50LnRyaWdnZXIoe1xyXG5cdFx0XHR0eXBlOiAnTU9TLmluVmlld0NoZWNrJyxcclxuXHRcdFx0c3RhdGVzOiByZXNcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChNT1MuaW5WaWV3LmRvVHJhY2UpIF90cmFjZSgnVmlzaWJsZScsIHN0clZpc2libGUpO1xyXG5cclxuXHRcdHJldHVybiByZXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gX2luaXQoKSB7XHJcblxyXG5cdFx0X29uRXZlbnREb25lKCdzY3JvbGwnLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdF9vbkNoZWNrZWQoX3doYXRzVmlzaWJsZSgpKTtcclxuXHRcdH0sIDMwMCk7XHJcblxyXG5cdFx0X29uRXZlbnREb25lKCdyZXNpemUnLCBmdW5jdGlvbihlKSB7XHJcblx0XHRcdF9vbkNoZWNrZWQoX3doYXRzVmlzaWJsZSgpKTtcclxuXHRcdH0sIDMwMCk7XHJcblxyXG5cdFx0X2luaXQgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblx0fVxyXG5cclxuICBcdGZ1bmN0aW9uIF9hZGQgKGl0KSB7XHJcblxyXG4gIFx0XHRfaW5pdCgpO1xyXG5cdFx0X3dhdGNoTGlzdC5wdXNoKGl0KTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBfY2xlYXIoKSB7XHJcblx0XHRfd2F0Y2hMaXN0Lmxlbmd0aCA9IDA7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBfY2hlY2soKSB7XHJcblx0XHRyZXR1cm4gX29uQ2hlY2tlZChfd2hhdHNWaXNpYmxlKCkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGFkZDogX2FkZCxcclxuXHRcdG91dE9mQm91bmRzU2l6ZTogMixcclxuXHRcdHdoYXRzVmlzaWJsZTogX3doYXRzVmlzaWJsZSxcclxuXHRcdGNoZWNrOiBfY2hlY2ssXHJcblx0XHRkb1RyYWNlOiBmYWxzZSxcclxuXHRcdGNsZWFyOiBfY2xlYXJcclxuXHR9O1xyXG59KCkpO1xyXG4iXSwiZmlsZSI6Ik1PUy9pblZpZXcuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==

/**
 * Drag 1.0
 * 
 * @version 1
 * @author http://www.lbi.com/se/
 * Copyright 2013, Licensed GPL & MIT
 *  
 */
var NIBS = NIBS || {};
(function(ns) {
    var MOUSE_DOWN = "mousedown";
    var MOUSE_MOVE = "mousemove";
    var MOUSE_UP = "mouseup";
    var mousedownStartTime;
    var mousedownStartPosition;
    var mouseUpEndTime;
    var onHandleClickFn;
    var oldMSPointerStyle = (function() {
        if (window.navigator.pointerEnabled) {
            return false;
        } else if (window.navigator.msPointerEnabled) {
            return true;
        }
    })();

    if (window.navigator.msPointerEnabled) {
        if (oldMSPointerStyle) {
            MOUSE_DOWN = "MSPointerDown";
            MOUSE_MOVE = "MSPointerMove";
            MOUSE_UP = "MSPointerUp";
        } else {
            MOUSE_DOWN = "pointerdown";
            MOUSE_MOVE = "pointermove";
            MOUSE_UP = "pointerup";
        }
    }
    var eventAddListener = function(element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent("on" + type, handler);
        }
    };
    var eventRemoveListener = function(element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler);
        } else if (element.detachEvent) {
            element.detachEvent("on" + type, handler);
        }
    };
    var eventPreventDefault = function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    };
    var eventStopPropagation = function(event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    };
    var documentListeners = [];
    var documentHandler = function(event) {
        var listeners = documentListeners.slice();
        for (var i = 0; i < listeners.length; i++) {
            if (listeners[i].listener(event)) {
                return;
            }
        }
    };
    var setupDocumentHandler = function() {
        eventAddListener(document, MOUSE_MOVE, documentHandler);
        eventAddListener(document, MOUSE_UP, documentHandler);
    };
    var disposeDocumentHandler = function() {
        eventRemoveListener(document, MOUSE_MOVE, documentHandler);
        eventRemoveListener(document, MOUSE_UP, documentHandler);
    };
    var addDocumentListener = function(gesture) {
        removeDocumentListener(gesture);
        documentListeners.push(gesture);
        if (documentListeners.length == 1) {
            setupDocumentHandler();
        }
    };
    var removeDocumentListener = function(gesture) {
        for (var i = 0; i < documentListeners.length; i++) {
            if (documentListeners[i] == gesture) {
                documentListeners.splice(i, 1);
                if (documentListeners.length === 0) {
                    disposeDocumentHandler();
                }
                return;
            }
        }
    };

    function Drag(element, delegate) {
        this.element = element;
        if ("mozUserSelect" in this.element.style) {
            this.element.style.mozUserSelect = "none";
        } else if ("webkitUserSelect" in this.element.style) {
            this.element.style.webkitUserSelect = "none";
        } else if ("msUserSelect" in this.element.style) {
            this.element.style.msUserSelect = "none";
        } else if ("userSelect" in this.element.style) {
            this.element.style.userSelect = "none";
        }
        this.delegate = delegate;
        this.location = {
            x: 0,
            y: 0
        };
        this.translation = {
            x: 0,
            y: 0
        };
        this.offset = {
            x: 0,
            y: 0
        };
        this.canceled = false;
        this.stopped = false;
        var scope = this;
        this.listener = function(event) {
            scope.stopped = false;
            scope.event = event || window.event;
            scope.target = event.srcElement || event.target;
            scope.handler(event.type);
            scope.event = scope.target = null;
            return scope.stopped;
        };
        if ("ontouchstart" in window) {
            this.addEvent(this.element, "touchstart");
            this.addEvent(this.element, "touchmove");
            this.addEvent(this.element, "touchend");
            this.addEvent(this.element, "touchcancel");
        } else {
            this.element.ondragstart = function() {
                return false;
            };
            this.addEvent(this.element, MOUSE_DOWN);
        }
        this.addEvent(this.element, "click");
    }
    Drag.prototype.dispose = function() {
        if ("ontouchstart" in window) {
            this.removeEvent(this.element, "touchstart");
            this.removeEvent(this.element, "touchmove");
            this.removeEvent(this.element, "touchend");
            this.removeEvent(this.element, "touchcancel");
        } else {
            this.element.ondragstart = null;
            this.removeEvent(this.element, MOUSE_DOWN);
            removeDocumentListener(this);
        }
        this.removeEvent(this.element, "click");
        this.element = null;
        this.delegate = null;
    };
    Drag.prototype.addEvent = function(element, type) {
        eventAddListener(element, type, this.listener);
    };
    Drag.prototype.removeEvent = function(element, type) {
        eventRemoveListener(element, type, this.listener);
    };
    Drag.prototype.preventDefault = function() {
        if (this.event) {
            eventPreventDefault(this.event);
        }
    };
    Drag.prototype.stopPropagation = function() {
        if (this.event) {
            this.stopped = true;
            eventStopPropagation(this.event);
        }
    };
    Drag.prototype.locationInElement = function(element) {
        if (!this.event) {
            return {
                x: 0,
                y: 0
            };
        }
        var x = this.location.x,
            y = this.location.y;
        while (element) {
            x -= element.offsetLeft;
            y -= element.offsetTop;
            element = element.offsetParent;
        }
        return {
            x: x,
            y: y
        };
    };
    Drag.prototype.updateLocation = function() {
        if ("touches" in this.event && this.event.touches.length > 0) {
            this.location.x = this.event.touches[0].pageX;
            this.location.y = this.event.touches[0].pageY;
        } else if ("pageX" in this.event) {
            this.location.x = this.event.pageX;
            this.location.y = this.event.pageY;
        } else if ("clientX" in this.event) {
            var d = document.documentElement,
                b = document.body;
            this.location.x = this.event.clientX + (d && d.scrollLeft || b && b.scrollLeft || 0) - (d && d.clientLeft || b && b.clientLeft || 0);
            this.location.y = this.event.clientY + (d && d.scrollTop || b && b.scrollTop || 0) - (d && d.clientTop || b && b.clientTop || 0);
        }
    };
    Drag.prototype.updateTranslation = function(reset) {
        if (reset) {
            this.offset.x = this.location.x;
            this.offset.y = this.location.y;
        }
        this.translation.x = this.location.x - this.offset.x;
        this.translation.y = this.location.y - this.offset.y;
    };
    Drag.prototype.cancel = function() {
        this.canceled = true;
    };
    Drag.prototype.notify = function(name) {
        if (this.delegate && this.delegate[name]) {
            this.delegate[name](this);
        }
    };
    Drag.prototype.doOnHandleClick = function(callback) {
        onHandleClickFn = callback;
    };
    Drag.prototype.handler = function(type) {
        switch (type) {
            case "click":
                this.notify("click");
                break;
            case "touchstart":
                this.canceled = false;
                this.mousedownStartTime = (new Date()).getTime();
                this.updateLocation();
                this.updateTranslation(true);
                this.mousedownStartPosition = {
                    x: this.location.x,
                    y: this.location.y
                };
                this.notify("dragDidStart");
                break;
            case MOUSE_DOWN:
                this.canceled = false;
                this.mousedownStartTime = (new Date()).getTime();
                this.updateLocation();
                this.updateTranslation(true);
                this.mousedownStartPosition = {
                    x: this.location.x,
                    y: this.location.y
                };
                this.notify("dragDidStart");
                addDocumentListener(this);
                break;
            case MOUSE_MOVE:
            case "touchmove":
                if (!this.canceled) {
                    this.updateLocation();
                    this.updateTranslation(false);
                    this.notify("dragDidMove");
                }
                break;
            case MOUSE_UP:
                removeDocumentListener(this);
                if (!this.canceled) {
                    this.mouseUpEndTime = (new Date()).getTime();

                    var posTest = function(gesture) {
                        var lim = 5,
                            xtest = (gesture.location.x - gesture.mousedownStartPosition.x < lim) && (gesture.location.x - gesture.mousedownStartPosition.x > lim * -1),
                            ytest = (gesture.location.y - gesture.mousedownStartPosition.y < lim) && (gesture.location.y - gesture.mousedownStartPosition.y > lim * -1);
                        return ytest && xtest;
                    };

                    if (onHandleClickFn) {
                        if ((new Date()).getTime() - this.mousedownStartTime < 160 && posTest(this)) {
                            onHandleClickFn(this);
                        }
                    }
                    this.notify("dragDidStop");
                }
                break;
            case "touchend":
            case "touchcancel":
                if (!this.canceled) {
                    this.notify("dragDidStop");
                }
                break;
        }
    };
    this.NIBS.Drag = Drag;


})(this.NIBS || {});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJOSUJTL0RyYWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiIC8qKlxyXG4gKiBEcmFnIDEuMFxyXG4gKiBcclxuICogQHZlcnNpb24gMVxyXG4gKiBAYXV0aG9yIGh0dHA6Ly93d3cubGJpLmNvbS9zZS9cclxuICogQ29weXJpZ2h0IDIwMTMsIExpY2Vuc2VkIEdQTCAmIE1JVFxyXG4gKiAgXHJcbiovXHJcbnZhciBOSUJTID0gTklCUyB8fCB7fTtcclxuKGZ1bmN0aW9uKG5zKXtcclxuXHR2YXIgTU9VU0VfRE9XTiA9IFwibW91c2Vkb3duXCI7XHJcblx0dmFyIE1PVVNFX01PVkUgPSBcIm1vdXNlbW92ZVwiO1xyXG5cdHZhciBNT1VTRV9VUCA9IFwibW91c2V1cFwiO1xyXG5cdHZhciBtb3VzZWRvd25TdGFydFRpbWU7XHJcblx0dmFyIG1vdXNlZG93blN0YXJ0UG9zaXRpb247XHJcblx0dmFyIG1vdXNlVXBFbmRUaW1lO1xyXG5cdHZhciBvbkhhbmRsZUNsaWNrRm47XHJcblx0dmFyIG9sZE1TUG9pbnRlclN0eWxlID0gKGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0gZWxzZSBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH0pKCk7XHJcblxyXG5cdGlmKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xyXG5cdFx0aWYgKG9sZE1TUG9pbnRlclN0eWxlKSB7XHJcblx0XHRcdE1PVVNFX0RPV04gPSBcIk1TUG9pbnRlckRvd25cIjtcclxuXHRcdFx0TU9VU0VfTU9WRSA9IFwiTVNQb2ludGVyTW92ZVwiO1xyXG5cdFx0XHRNT1VTRV9VUCA9IFwiTVNQb2ludGVyVXBcIjtcdFxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TU9VU0VfRE9XTiA9IFwicG9pbnRlcmRvd25cIjtcclxuXHRcdFx0TU9VU0VfTU9WRSA9IFwicG9pbnRlcm1vdmVcIjtcclxuXHRcdFx0TU9VU0VfVVAgPSBcInBvaW50ZXJ1cFwiO1x0XHJcblx0XHR9XHJcblx0fVxyXG5cdHZhciBldmVudEFkZExpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xyXG5cdFx0aWYoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XHJcblx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcclxuXHRcdFx0ZWxlbWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdHZhciBldmVudFJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xyXG5cdFx0aWYoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XHJcblx0XHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoZWxlbWVudC5kZXRhY2hFdmVudCkge1xyXG5cdFx0XHRlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dmFyIGV2ZW50UHJldmVudERlZmF1bHQgPSBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0aWYoZXZlbnQucHJldmVudERlZmF1bHQpIHtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dmFyIGV2ZW50U3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdGlmKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dmFyIGRvY3VtZW50TGlzdGVuZXJzID0gW107XHJcblx0dmFyIGRvY3VtZW50SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gZG9jdW1lbnRMaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGk8bGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKGxpc3RlbmVyc1tpXS5saXN0ZW5lcihldmVudCkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHZhciBzZXR1cERvY3VtZW50SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0ZXZlbnRBZGRMaXN0ZW5lcihkb2N1bWVudCwgTU9VU0VfTU9WRSwgZG9jdW1lbnRIYW5kbGVyKTtcclxuXHRcdGV2ZW50QWRkTGlzdGVuZXIoZG9jdW1lbnQsIE1PVVNFX1VQLCBkb2N1bWVudEhhbmRsZXIpO1xyXG5cdH07XHJcblx0dmFyIGRpc3Bvc2VEb2N1bWVudEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdGV2ZW50UmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIE1PVVNFX01PVkUsIGRvY3VtZW50SGFuZGxlcik7XHJcblx0XHRldmVudFJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBNT1VTRV9VUCwgZG9jdW1lbnRIYW5kbGVyKTtcclxuXHR9O1xyXG5cdHZhciBhZGREb2N1bWVudExpc3RlbmVyID0gZnVuY3Rpb24oZ2VzdHVyZSkge1xyXG5cdFx0cmVtb3ZlRG9jdW1lbnRMaXN0ZW5lcihnZXN0dXJlKTtcclxuXHRcdGRvY3VtZW50TGlzdGVuZXJzLnB1c2goZ2VzdHVyZSk7XHJcblx0XHRpZihkb2N1bWVudExpc3RlbmVycy5sZW5ndGggPT0gMSkge1xyXG5cdFx0XHRzZXR1cERvY3VtZW50SGFuZGxlcigpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dmFyIHJlbW92ZURvY3VtZW50TGlzdGVuZXIgPSBmdW5jdGlvbihnZXN0dXJlKSB7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpPGRvY3VtZW50TGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKGRvY3VtZW50TGlzdGVuZXJzW2ldID09IGdlc3R1cmUpIHtcclxuXHRcdFx0XHRkb2N1bWVudExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0aWYoZG9jdW1lbnRMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRkaXNwb3NlRG9jdW1lbnRIYW5kbGVyKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIERyYWcoZWxlbWVudCwgZGVsZWdhdGUpIHtcclxuXHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHRpZihcIm1velVzZXJTZWxlY3RcIiBpbiB0aGlzLmVsZW1lbnQuc3R5bGUpIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50LnN0eWxlLm1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoXCJ3ZWJraXRVc2VyU2VsZWN0XCIgaW4gdGhpcy5lbGVtZW50LnN0eWxlKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gXCJub25lXCI7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKFwibXNVc2VyU2VsZWN0XCIgaW4gdGhpcy5lbGVtZW50LnN0eWxlKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS5tc1VzZXJTZWxlY3QgPSBcIm5vbmVcIjtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoXCJ1c2VyU2VsZWN0XCIgaW4gdGhpcy5lbGVtZW50LnN0eWxlKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gXCJub25lXCI7XHJcblx0XHR9XHJcblx0XHR0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0XHR0aGlzLmxvY2F0aW9uID0ge3g6MCwgeTowfTtcclxuXHRcdHRoaXMudHJhbnNsYXRpb24gPSB7eDowLCB5OjB9O1xyXG5cdFx0dGhpcy5vZmZzZXQgPSB7eDowLCB5OjB9O1xyXG5cdFx0dGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5zdG9wcGVkID0gZmFsc2U7XHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0dGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHNjb3BlLnN0b3BwZWQgPSBmYWxzZTtcclxuXHRcdFx0c2NvcGUuZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRcdHNjb3BlLnRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQudGFyZ2V0O1xyXG5cdFx0XHRzY29wZS5oYW5kbGVyKGV2ZW50LnR5cGUpO1xyXG5cdFx0XHRzY29wZS5ldmVudCA9IHNjb3BlLnRhcmdldCA9IG51bGw7XHJcblx0XHRcdHJldHVybiBzY29wZS5zdG9wcGVkO1xyXG5cdFx0fTtcclxuXHRcdGlmKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93KSB7XHJcblx0XHRcdHRoaXMuYWRkRXZlbnQodGhpcy5lbGVtZW50LCBcInRvdWNoc3RhcnRcIik7XHJcblx0XHRcdHRoaXMuYWRkRXZlbnQodGhpcy5lbGVtZW50LCBcInRvdWNobW92ZVwiKTtcclxuXHRcdFx0dGhpcy5hZGRFdmVudCh0aGlzLmVsZW1lbnQsIFwidG91Y2hlbmRcIik7XHJcblx0XHRcdHRoaXMuYWRkRXZlbnQodGhpcy5lbGVtZW50LCBcInRvdWNoY2FuY2VsXCIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKCkge3JldHVybiBmYWxzZTt9O1xyXG5cdFx0XHR0aGlzLmFkZEV2ZW50KHRoaXMuZWxlbWVudCwgTU9VU0VfRE9XTik7XHJcblx0XHR9XHJcblx0XHR0aGlzLmFkZEV2ZW50KHRoaXMuZWxlbWVudCwgXCJjbGlja1wiKTtcclxuXHR9XHJcblx0RHJhZy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIFwidG91Y2hzdGFydFwiKTtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIFwidG91Y2htb3ZlXCIpO1xyXG5cdFx0XHR0aGlzLnJlbW92ZUV2ZW50KHRoaXMuZWxlbWVudCwgXCJ0b3VjaGVuZFwiKTtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIFwidG91Y2hjYW5jZWxcIik7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50Lm9uZHJhZ3N0YXJ0ID0gbnVsbDtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIE1PVVNFX0RPV04pO1xyXG5cdFx0XHRyZW1vdmVEb2N1bWVudExpc3RlbmVyKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIFwiY2xpY2tcIik7XHJcblx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xyXG5cdFx0dGhpcy5kZWxlZ2F0ZSA9IG51bGw7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcclxuXHRcdGV2ZW50QWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgdGhpcy5saXN0ZW5lcik7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcclxuXHRcdGV2ZW50UmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgdGhpcy5saXN0ZW5lcik7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYodGhpcy5ldmVudCkge1xyXG5cdFx0XHRldmVudFByZXZlbnREZWZhdWx0KHRoaXMuZXZlbnQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0RHJhZy5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZih0aGlzLmV2ZW50KSB7XHJcblx0XHRcdHRoaXMuc3RvcHBlZCA9IHRydWU7XHJcblx0XHRcdGV2ZW50U3RvcFByb3BhZ2F0aW9uKHRoaXMuZXZlbnQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0RHJhZy5wcm90b3R5cGUubG9jYXRpb25JbkVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRpZighdGhpcy5ldmVudCkge1xyXG5cdFx0XHRyZXR1cm4ge3g6MCwgeTowfTtcclxuXHRcdH1cclxuXHRcdHZhciB4ID0gdGhpcy5sb2NhdGlvbi54LCB5ID0gdGhpcy5sb2NhdGlvbi55O1xyXG5cdFx0d2hpbGUoZWxlbWVudCkge1xyXG5cdFx0XHR4IC09IGVsZW1lbnQub2Zmc2V0TGVmdDtcclxuXHRcdFx0eSAtPSBlbGVtZW50Lm9mZnNldFRvcDtcclxuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHt4OngsIHk6eX07XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS51cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYoXCJ0b3VjaGVzXCIgaW4gdGhpcy5ldmVudCAmJiB0aGlzLmV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHR0aGlzLmxvY2F0aW9uLnggPSB0aGlzLmV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XHJcblx0XHRcdHRoaXMubG9jYXRpb24ueSA9IHRoaXMuZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoXCJwYWdlWFwiIGluIHRoaXMuZXZlbnQpIHtcclxuXHRcdFx0dGhpcy5sb2NhdGlvbi54ID0gdGhpcy5ldmVudC5wYWdlWDtcclxuXHRcdFx0dGhpcy5sb2NhdGlvbi55ID0gdGhpcy5ldmVudC5wYWdlWTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoXCJjbGllbnRYXCIgaW4gdGhpcy5ldmVudCkge1xyXG5cdFx0XHR2YXIgZCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgYiA9IGRvY3VtZW50LmJvZHk7XHJcblx0XHRcdHRoaXMubG9jYXRpb24ueCA9IHRoaXMuZXZlbnQuY2xpZW50WCArIChkICYmIGQuc2Nyb2xsTGVmdCB8fCBiICYmIGIuc2Nyb2xsTGVmdCB8fCAwKSAtIChkICYmIGQuY2xpZW50TGVmdCB8fCBiICYmIGIuY2xpZW50TGVmdCB8fCAwKTtcclxuXHRcdFx0dGhpcy5sb2NhdGlvbi55ID0gdGhpcy5ldmVudC5jbGllbnRZICsgKGQgJiYgZC5zY3JvbGxUb3AgfHwgYiAmJiBiLnNjcm9sbFRvcCB8fCAwKSAtIChkICYmIGQuY2xpZW50VG9wIHx8IGIgJiYgYi5jbGllbnRUb3AgfHwgMCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS51cGRhdGVUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHRpZihyZXNldCkge1xyXG5cdFx0XHR0aGlzLm9mZnNldC54ID0gdGhpcy5sb2NhdGlvbi54O1xyXG5cdFx0XHR0aGlzLm9mZnNldC55ID0gdGhpcy5sb2NhdGlvbi55O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy50cmFuc2xhdGlvbi54ID0gdGhpcy5sb2NhdGlvbi54IC0gdGhpcy5vZmZzZXQueDtcclxuXHRcdHRoaXMudHJhbnNsYXRpb24ueSA9IHRoaXMubG9jYXRpb24ueSAtIHRoaXMub2Zmc2V0Lnk7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xyXG5cdH07XHJcblx0RHJhZy5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdFx0aWYodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlW25hbWVdKSB7XHJcblx0XHRcdHRoaXMuZGVsZWdhdGVbbmFtZV0odGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5kb09uSGFuZGxlQ2xpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0b25IYW5kbGVDbGlja0ZuID0gY2FsbGJhY2s7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0c3dpdGNoKHR5cGUpIHtcclxuXHRcdFx0Y2FzZSBcImNsaWNrXCI6XHJcblx0XHRcdFx0dGhpcy5ub3RpZnkoXCJjbGlja1wiKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInRvdWNoc3RhcnRcIjpcclxuXHRcdFx0XHR0aGlzLmNhbmNlbGVkID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5tb3VzZWRvd25TdGFydFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlTG9jYXRpb24oKTtcclxuXHRcdFx0XHR0aGlzLnVwZGF0ZVRyYW5zbGF0aW9uKHRydWUpO1xyXG5cdFx0XHRcdHRoaXMubW91c2Vkb3duU3RhcnRQb3NpdGlvbiA9IHt4OiB0aGlzLmxvY2F0aW9uLngsIHk6IHRoaXMubG9jYXRpb24ueX07XHJcblx0XHRcdFx0dGhpcy5ub3RpZnkoXCJkcmFnRGlkU3RhcnRcIik7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgTU9VU0VfRE9XTiA6XHJcblx0XHRcdFx0dGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMubW91c2Vkb3duU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcclxuXHRcdFx0XHR0aGlzLnVwZGF0ZUxvY2F0aW9uKCk7XHJcblx0XHRcdFx0dGhpcy51cGRhdGVUcmFuc2xhdGlvbih0cnVlKTtcclxuXHRcdFx0XHR0aGlzLm1vdXNlZG93blN0YXJ0UG9zaXRpb24gPSB7eDogdGhpcy5sb2NhdGlvbi54LCB5OiB0aGlzLmxvY2F0aW9uLnl9O1xyXG5cdFx0XHRcdHRoaXMubm90aWZ5KFwiZHJhZ0RpZFN0YXJ0XCIpO1xyXG5cdFx0XHRcdGFkZERvY3VtZW50TGlzdGVuZXIodGhpcyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgTU9VU0VfTU9WRSA6XHJcblx0XHRcdGNhc2UgXCJ0b3VjaG1vdmVcIiA6XHJcblx0XHRcdFx0aWYoIXRoaXMuY2FuY2VsZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMudXBkYXRlTG9jYXRpb24oKTtcclxuXHRcdFx0XHRcdHRoaXMudXBkYXRlVHJhbnNsYXRpb24oZmFsc2UpO1xyXG5cdFx0XHRcdFx0dGhpcy5ub3RpZnkoXCJkcmFnRGlkTW92ZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgTU9VU0VfVVAgOlxyXG5cdFx0XHRcdHJlbW92ZURvY3VtZW50TGlzdGVuZXIodGhpcyk7XHJcblx0XHRcdFx0aWYoIXRoaXMuY2FuY2VsZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMubW91c2VVcEVuZFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHR2YXIgcG9zVGVzdCA9IGZ1bmN0aW9uIChnZXN0dXJlKSB7XHJcblx0XHRcdFx0XHRcdHZhciBsaW0gPSA1LFxyXG5cdFx0XHRcdFx0XHRcdHh0ZXN0ID0gKGdlc3R1cmUubG9jYXRpb24ueCAtIGdlc3R1cmUubW91c2Vkb3duU3RhcnRQb3NpdGlvbi54IDwgbGltKSAmJiAoZ2VzdHVyZS5sb2NhdGlvbi54IC0gZ2VzdHVyZS5tb3VzZWRvd25TdGFydFBvc2l0aW9uLnggPiBsaW0gKiAtMSksXHJcblx0XHRcdFx0XHRcdFx0eXRlc3QgPSAoZ2VzdHVyZS5sb2NhdGlvbi55IC0gZ2VzdHVyZS5tb3VzZWRvd25TdGFydFBvc2l0aW9uLnkgPCBsaW0pICYmIChnZXN0dXJlLmxvY2F0aW9uLnkgLSBnZXN0dXJlLm1vdXNlZG93blN0YXJ0UG9zaXRpb24ueSA+IGxpbSAqIC0xKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHl0ZXN0ICYmIHh0ZXN0O1xyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHRpZiAob25IYW5kbGVDbGlja0ZuKSB7XHJcblx0XHRcdFx0XHRcdGlmICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdGhpcy5tb3VzZWRvd25TdGFydFRpbWUgPCAxNjAgJiYgcG9zVGVzdCh0aGlzKSkge1xyXG5cdFx0XHRcdFx0XHRcdG9uSGFuZGxlQ2xpY2tGbih0aGlzKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy5ub3RpZnkoXCJkcmFnRGlkU3RvcFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJ0b3VjaGVuZFwiOlxyXG5cdFx0XHRjYXNlIFwidG91Y2hjYW5jZWxcIjpcclxuXHRcdFx0XHRpZighdGhpcy5jYW5jZWxlZCkge1xyXG5cdFx0XHRcdFx0dGhpcy5ub3RpZnkoXCJkcmFnRGlkU3RvcFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fTtcclxuXHR0aGlzLk5JQlMuRHJhZyA9IERyYWc7XHJcblx0XHJcblx0XHJcbn0pKHRoaXMuTklCUyB8fCB7fSk7XHJcbiJdLCJmaWxlIjoiTklCUy9EcmFnLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=

/*
 * Slider 1.0
 *
 * Mattias Johansson
 * Copyright 2015, Licensed GPL & MIT
 */

var c = (console) ? console : {
    log: function() {}
};
c.l = c.log;

var NIBS = NIBS || {};
NIBS.Slider = function(data) {


    var init = function() {

        var cssCode = '		.slider-wrapper {\n' +
            '			position: relative;\n' +
            '			width: 100%;\n' +
            '			overflow: hidden;\n' +
            '			box-sizing: border-box;\n' +
            '			height: 50px;\n' +
            '			background-color: #D6D6D6;\n' +
            '		}\n\n' +

            '		.slider-handle {\n' +
            '			position: absolute;\n' +
            '			left: 0px;\n' +
            '			top: 0px;\n' +
            '			height: 100%;\n' +
            '			cursor: w-resize;\n' +
            '			box-sizing: border-box;\n' +
            '			width: 30px;\n' +
            '			background-color: #B5B5B5;\n' +
            '		}',
            style;

        style = document.createElement('style');
        style.type = 'text/css';
        style.innerHTML = cssCode;
        document.getElementsByTagName('head')[0].appendChild(style);

        window.addEventListener('resize', function() {
            for (var id in NIBS.Slider.all) {
                NIBS.Slider.all[id].resize();
            }
        }, true);

        init = function() {};

    };

    var that = this;
    that.id = NIBS.Slider.getUniqueId();
    that.data = data;
    that.info = {
        empty: true,
        handle: {}
    };
    that.data.backgroundColor = that.data.backgroundColor || '#D6D6D6';
    that.data.handleColor = that.data.handleColor || '#B5B5B5';
    that.data.onSlide = that.data.onSlide || function() {
        //trace('progress', this.info.progress);
    };
    that.gesture = {};

    init();

    that.get = {
        $1: document.querySelector.bind(document), // Direct reference, usage: var alArr = $2('.my-class');
        $2: document.querySelectorAll.bind(document), //Node array, usage: var el = $1('.one-time-class');
        child: function(parent, className) {
            var notes = null;
            for (var i = 0; i < parent.childNodes.length; i++) {
                if (parent.childNodes[i].className == className) {
                    notes = parent.childNodes[i];
                    return notes;
                }
            }
        }
    };
    that.info.state = 'init';
    that.target = that.get.$1(that.data.target);
    that.selector = that.data.target;
    that.target.className += that.target.className ? ' slider-wrapper' : 'slider-wrapper';
    that.target.innerHTML = '<div class="slider-handle"></div>';
    that.handle = that.get.child(that.target, 'slider-handle');
    that.refresh();
    that.actions = {
        dragDidStart: function(gesture) {
            that.info.state = 'started';
            that.gesture = gesture;
            gesture.dragStartPos = {
                x: gesture.element.offsetLeft,
                y: gesture.element.offsetTop
            };
            that.target.ontouchstart = function(e) {
                e.preventDefault();
            };

            if (window.jQuery) {
                $.event.trigger({
                    type: 'slider.sliding.started',
                    that: that
                });
            }
        },
        dragDidMove: function(gesture) {

            that.gesture = gesture;
            var newPos = gesture.dragStartPos.x + gesture.translation.x;
            that.info.state = 'sliding';
            if (newPos < 0) newPos = 0;
            if (newPos > that.info.width) newPos = that.info.width;

            that.handle.style.left = newPos + 'px';
            that.info.handle.left = newPos;
            that.getProgress();

            if (window.jQuery) {
                $.event.trigger({
                    type: 'slider.sliding',
                    that: that
                });
            }
            that.data.onSlide.call(that);

        },
        dragDidStop: function(gesture) {

            that.gesture = gesture;
            that.target.ontouchstart = function(e) {};
            that.info.state = 'ended';
            if (window.jQuery) {
                $.event.trigger({
                    type: 'slider.sliding.ended',
                    that: that
                });
            }

        }
    };
    that.drag = new NIBS.Drag(that.handle, that.actions);
    that.target.style.msTouchAction = 'none';

    NIBS.Slider.all['id' + that.id] = that;

};

NIBS.Slider.all = {};

NIBS.Slider.getUniqueId = function() {
    var d = new Date().getTime();
    d += (parseInt(Math.random() * 100)).toString();
    return d;
};

NIBS.Slider.prototype = {};

NIBS.Slider.prototype.resize = function() {

    var that = this,
        newPos,
        wrapperInfo,
        handleInfo;

    wrapperInfo = that.target.getBoundingClientRect();
    handleInfo = that.handle.getBoundingClientRect();
    newPos = (wrapperInfo.width - that.info.handle.width) * that.info.progress;

    that.handle.style.left = newPos + 'px';
    that.info.handle.left = newPos;

    that.refresh();

};

NIBS.Slider.prototype.refresh = function() {

    var that = this,
        wrapperInfo,
        handleInfo;

    delete that.info.empty;

    wrapperInfo = that.target.getBoundingClientRect();
    handleInfo = that.handle.getBoundingClientRect();
    that.info.wrapperWidth = wrapperInfo.width;
    that.info.left = (that.info.left) ? that.info.left : 0;
    that.info.right = wrapperInfo.right;
    that.info.handle.width = handleInfo.width;
    that.info.width = that.info.wrapperWidth - that.info.handle.width;

    if (!that.info.handle.left) that.info.handle.left = 0;
    if (!that.info.progress) that.info.progress = 0;

};

NIBS.Slider.prototype.getProgress = function() {

    var that = this;

    if (that.info.empty) {
        that.refresh();
    }

    that.info.progress = that.info.handle.left / that.info.width;

    return that.info.progress;

};

NIBS.Slider.prototype.setProgress = function(newProgress) {

    var that = this;

    if (that.info.empty) {
        that.refresh();
    }
    that.info.progress = newProgress;
    that.info.handle.left = that.info.progress * that.info.width;
    that.handle.style.left = that.info.handle.left + 'px';

};

NIBS.Slider.prototype.destroy = function() {

    var that = this;
    delete NIBS.Slider.all[that.id];
    that.drag.dispose();

};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJOSUJTL1NsaWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBTbGlkZXIgMS4wXHJcbiAqXHJcbiAqIE1hdHRpYXMgSm9oYW5zc29uXHJcbiAqIENvcHlyaWdodCAyMDE1LCBMaWNlbnNlZCBHUEwgJiBNSVRcclxuICovXHJcblxyXG52YXIgYyA9IChjb25zb2xlKSA/IGNvbnNvbGUgOiB7bG9nOiBmdW5jdGlvbiAoKSB7fX07IGMubCA9IGMubG9nO1xyXG5cclxudmFyIE5JQlMgPSBOSUJTIHx8IHt9O1xyXG5OSUJTLlNsaWRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG5cclxuICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgY3NzQ29kZSA9XHQnXHRcdC5zbGlkZXItd3JhcHBlciB7XFxuJyArXHJcbiAgICAgICAgICAgIFx0XHRcdCdcdFx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XFxuJyArXHJcbiAgICAgICAgICAgIFx0XHRcdCdcdFx0XHR3aWR0aDogMTAwJTtcXG4nICtcclxuICAgICAgICAgICAgXHRcdFx0J1x0XHRcdG92ZXJmbG93OiBoaWRkZW47XFxuJyArXHJcbiAgICAgICAgICAgIFx0XHRcdCdcdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbicgK1xyXG4gICAgICAgICAgICBcdFx0XHQnXHRcdFx0aGVpZ2h0OiA1MHB4O1xcbicgK1xyXG4gICAgICAgICAgICBcdFx0XHQnXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogI0Q2RDZENjtcXG4nICtcclxuICAgICAgICAgICAgXHRcdFx0J1x0XHR9XFxuXFxuJyArXHJcblxyXG4gICAgICAgICAgICBcdFx0XHQnXHRcdC5zbGlkZXItaGFuZGxlIHtcXG4nICtcclxuICAgICAgICAgICAgXHRcdFx0J1x0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4nICtcclxuICAgICAgICAgICAgXHRcdFx0J1x0XHRcdGxlZnQ6IDBweDtcXG4nICtcclxuICAgICAgICAgICAgXHRcdFx0J1x0XHRcdHRvcDogMHB4O1xcbicgK1xyXG4gICAgICAgICAgICBcdFx0XHQnXHRcdFx0aGVpZ2h0OiAxMDAlO1xcbicgK1xyXG4gICAgICAgICAgICBcdFx0XHQnXHRcdFx0Y3Vyc29yOiB3LXJlc2l6ZTtcXG4nICtcclxuICAgICAgICAgICAgXHRcdFx0J1x0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuJyArXHJcbiAgICAgICAgICAgIFx0XHRcdCdcdFx0XHR3aWR0aDogMzBweDtcXG4nICtcclxuICAgICAgICAgICAgXHRcdFx0J1x0XHRcdGJhY2tncm91bmQtY29sb3I6ICNCNUI1QjU7XFxuJyArXHJcbiAgICAgICAgICAgIFx0XHRcdCdcdFx0fScsXHJcbiAgICAgICAgICAgIHN0eWxlO1xyXG5cclxuICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcbiAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gY3NzQ29kZTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBOSUJTLlNsaWRlci5hbGwpIHtcclxuICAgICAgICAgICAgXHROSUJTLlNsaWRlci5hbGxbaWRdLnJlc2l6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGluaXQgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHRoYXQuaWQgPSBOSUJTLlNsaWRlci5nZXRVbmlxdWVJZCgpO1xyXG5cdHRoYXQuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGF0LmluZm8gPSB7XHJcbiAgICAgICAgZW1wdHk6IHRydWUsXHJcbiAgICAgICAgaGFuZGxlOiB7fVxyXG4gICAgfTtcclxuICAgIHRoYXQuZGF0YS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGF0LmRhdGEuYmFja2dyb3VuZENvbG9yIHx8ICcjRDZENkQ2JztcclxuICAgIHRoYXQuZGF0YS5oYW5kbGVDb2xvciA9IHRoYXQuZGF0YS5oYW5kbGVDb2xvciB8fCAnI0I1QjVCNSc7XHJcbiAgICB0aGF0LmRhdGEub25TbGlkZSA9IHRoYXQuZGF0YS5vblNsaWRlIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3RyYWNlKCdwcm9ncmVzcycsIHRoaXMuaW5mby5wcm9ncmVzcyk7XHJcbiAgICB9O1xyXG4gICAgdGhhdC5nZXN0dXJlID0ge307XHJcblxyXG4gICAgaW5pdCgpO1xyXG5cclxuICAgIHRoYXQuZ2V0ID0ge1xyXG4gICAgICAgICQxOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yLmJpbmQoZG9jdW1lbnQpLCAvLyBEaXJlY3QgcmVmZXJlbmNlLCB1c2FnZTogdmFyIGFsQXJyID0gJDIoJy5teS1jbGFzcycpO1xyXG4gICAgICAgICQyOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsLmJpbmQoZG9jdW1lbnQpLCAvL05vZGUgYXJyYXksIHVzYWdlOiB2YXIgZWwgPSAkMSgnLm9uZS10aW1lLWNsYXNzJyk7XHJcbiAgICAgICAgY2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgbm90ZXMgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lID09IGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICBub3RlcyA9IHBhcmVudC5jaGlsZE5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbm90ZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhhdC5pbmZvLnN0YXRlID0gJ2luaXQnO1xyXG4gICAgdGhhdC50YXJnZXQgPSB0aGF0LmdldC4kMSh0aGF0LmRhdGEudGFyZ2V0KTtcclxuICAgIHRoYXQuc2VsZWN0b3IgPSB0aGF0LmRhdGEudGFyZ2V0O1xyXG4gICAgdGhhdC50YXJnZXQuY2xhc3NOYW1lICs9IHRoYXQudGFyZ2V0LmNsYXNzTmFtZSA/ICcgc2xpZGVyLXdyYXBwZXInIDogJ3NsaWRlci13cmFwcGVyJztcclxuICAgIHRoYXQudGFyZ2V0LmlubmVySFRNTCA9ICc8ZGl2IGNsYXNzPVwic2xpZGVyLWhhbmRsZVwiPjwvZGl2Pic7XHJcbiAgICB0aGF0LmhhbmRsZSA9IHRoYXQuZ2V0LmNoaWxkKHRoYXQudGFyZ2V0LCAnc2xpZGVyLWhhbmRsZScpO1xyXG4gICAgdGhhdC5yZWZyZXNoKCk7XHJcbiAgICB0aGF0LmFjdGlvbnMgPSB7XHJcbiAgICAgICAgZHJhZ0RpZFN0YXJ0OiBmdW5jdGlvbiAoZ2VzdHVyZSkge1xyXG4gICAgICAgICAgICB0aGF0LmluZm8uc3RhdGUgPSAnc3RhcnRlZCc7XHJcbiAgICAgICAgICAgIHRoYXQuZ2VzdHVyZSA9IGdlc3R1cmU7XHJcbiAgICAgICAgICAgIGdlc3R1cmUuZHJhZ1N0YXJ0UG9zID0ge3g6Z2VzdHVyZS5lbGVtZW50Lm9mZnNldExlZnQsIHk6Z2VzdHVyZS5lbGVtZW50Lm9mZnNldFRvcH07XHJcbiAgICAgICAgICAgIHRoYXQudGFyZ2V0Lm9udG91Y2hzdGFydCA9IGZ1bmN0aW9uKGUpeyBlLnByZXZlbnREZWZhdWx0KCk7IH07XHJcblxyXG4gICAgICAgICAgICBpZiAod2luZG93LmpRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgJC5ldmVudC50cmlnZ2VyKHtcclxuICAgICAgICAgICAgICAgIFx0dHlwZTogJ3NsaWRlci5zbGlkaW5nLnN0YXJ0ZWQnLFxyXG4gICAgICAgICAgICAgICAgXHR0aGF0OiB0aGF0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhZ0RpZE1vdmU6IGZ1bmN0aW9uIChnZXN0dXJlKSB7XHJcblxyXG4gICAgICAgICAgICB0aGF0Lmdlc3R1cmUgPSBnZXN0dXJlO1xyXG4gICAgICAgICAgICB2YXIgbmV3UG9zID0gZ2VzdHVyZS5kcmFnU3RhcnRQb3MueCArIGdlc3R1cmUudHJhbnNsYXRpb24ueDtcclxuICAgICAgICAgICAgdGhhdC5pbmZvLnN0YXRlID0gJ3NsaWRpbmcnO1xyXG4gICAgICAgICAgICBpZihuZXdQb3MgPCAwKSBuZXdQb3MgPSAwO1xyXG4gICAgICAgICAgICBpZihuZXdQb3MgPiB0aGF0LmluZm8ud2lkdGgpIG5ld1BvcyA9IHRoYXQuaW5mby53aWR0aDtcclxuXHJcbiAgICAgICAgICAgIHRoYXQuaGFuZGxlLnN0eWxlLmxlZnQgPSBuZXdQb3MgKyAncHgnO1xyXG4gICAgICAgICAgICB0aGF0LmluZm8uaGFuZGxlLmxlZnQgPSBuZXdQb3M7XHJcbiAgICAgICAgICAgIHRoYXQuZ2V0UHJvZ3Jlc3MoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cualF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAkLmV2ZW50LnRyaWdnZXIoe1xyXG4gICAgICAgICAgICAgICAgXHR0eXBlOiAnc2xpZGVyLnNsaWRpbmcnLFxyXG4gICAgICAgICAgICAgICAgXHR0aGF0OiB0aGF0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGF0LmRhdGEub25TbGlkZS5jYWxsKHRoYXQpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRyYWdEaWRTdG9wOiBmdW5jdGlvbiAoZ2VzdHVyZSkge1xyXG5cclxuICAgICAgICAgICAgdGhhdC5nZXN0dXJlID0gZ2VzdHVyZTtcclxuICAgICAgICAgICAgdGhhdC50YXJnZXQub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24oZSkgeyB9O1xyXG4gICAgICAgICAgICB0aGF0LmluZm8uc3RhdGUgPSAnZW5kZWQnO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmpRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgJC5ldmVudC50cmlnZ2VyKHtcclxuICAgICAgICAgICAgICAgIFx0dHlwZTogJ3NsaWRlci5zbGlkaW5nLmVuZGVkJyxcclxuICAgICAgICAgICAgICAgIFx0dGhhdDogdGhhdFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRoYXQuZHJhZyA9IG5ldyBOSUJTLkRyYWcodGhhdC5oYW5kbGUsIHRoYXQuYWN0aW9ucyk7XHJcbiAgICB0aGF0LnRhcmdldC5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xyXG5cclxuICAgIE5JQlMuU2xpZGVyLmFsbFsnaWQnICsgdGhhdC5pZF0gPSB0aGF0O1xyXG5cclxufTtcclxuXHJcbk5JQlMuU2xpZGVyLmFsbCA9IHt9O1xyXG5cclxuTklCUy5TbGlkZXIuZ2V0VW5pcXVlSWQgPSBmdW5jdGlvbiAgKCkge1xyXG4gICAgdmFyIGQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIGQgKz0gKHBhcnNlSW50KE1hdGgucmFuZG9tKCkgKiAxMDApKS50b1N0cmluZygpO1xyXG4gICAgcmV0dXJuIGQ7XHJcbn07XHJcblxyXG5OSUJTLlNsaWRlci5wcm90b3R5cGUgPSB7fTtcclxuXHJcbk5JQlMuU2xpZGVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB0aGF0ID0gdGhpcyxcclxuICAgICAgICBuZXdQb3MsXHJcbiAgICAgICAgd3JhcHBlckluZm8sXHJcbiAgICAgICAgaGFuZGxlSW5mbztcclxuXHJcbiAgICB3cmFwcGVySW5mbyAgPSB0aGF0LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGhhbmRsZUluZm8gID0gdGhhdC5oYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBuZXdQb3MgPSAod3JhcHBlckluZm8ud2lkdGggLSB0aGF0LmluZm8uaGFuZGxlLndpZHRoKSAqIHRoYXQuaW5mby5wcm9ncmVzcztcclxuXHJcbiAgICB0aGF0LmhhbmRsZS5zdHlsZS5sZWZ0ID0gbmV3UG9zICsgJ3B4JztcclxuICAgIHRoYXQuaW5mby5oYW5kbGUubGVmdCA9IG5ld1BvcztcclxuXHJcbiAgICB0aGF0LnJlZnJlc2goKTtcclxuXHJcbn07XHJcblxyXG5OSUJTLlNsaWRlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgIHdyYXBwZXJJbmZvLFxyXG4gICAgICAgIGhhbmRsZUluZm87XHJcblxyXG4gICAgZGVsZXRlIHRoYXQuaW5mby5lbXB0eTtcclxuXHJcbiAgICB3cmFwcGVySW5mbyAgPSB0aGF0LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGhhbmRsZUluZm8gID0gdGhhdC5oYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB0aGF0LmluZm8ud3JhcHBlcldpZHRoID0gd3JhcHBlckluZm8ud2lkdGg7XHJcbiAgICB0aGF0LmluZm8ubGVmdCA9ICh0aGF0LmluZm8ubGVmdCkgPyB0aGF0LmluZm8ubGVmdCA6IDA7XHJcbiAgICB0aGF0LmluZm8ucmlnaHQgPSB3cmFwcGVySW5mby5yaWdodDtcclxuICAgIHRoYXQuaW5mby5oYW5kbGUud2lkdGggPSBoYW5kbGVJbmZvLndpZHRoO1xyXG4gICAgdGhhdC5pbmZvLndpZHRoID0gdGhhdC5pbmZvLndyYXBwZXJXaWR0aCAtIHRoYXQuaW5mby5oYW5kbGUud2lkdGg7XHJcblxyXG4gICAgaWYgKCF0aGF0LmluZm8uaGFuZGxlLmxlZnQpIHRoYXQuaW5mby5oYW5kbGUubGVmdCA9IDA7XHJcbiAgICBpZiAoIXRoYXQuaW5mby5wcm9ncmVzcykgdGhhdC5pbmZvLnByb2dyZXNzID0gMDtcclxuXHJcbn07XHJcblxyXG5OSUJTLlNsaWRlci5wcm90b3R5cGUuZ2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICBpZiAodGhhdC5pbmZvLmVtcHR5KSB7XHJcbiAgICAgICAgdGhhdC5yZWZyZXNoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhhdC5pbmZvLnByb2dyZXNzID0gdGhhdC5pbmZvLmhhbmRsZS5sZWZ0IC8gdGhhdC5pbmZvLndpZHRoO1xyXG5cclxuICAgIHJldHVybiB0aGF0LmluZm8ucHJvZ3Jlc3M7XHJcblxyXG59O1xyXG5cclxuTklCUy5TbGlkZXIucHJvdG90eXBlLnNldFByb2dyZXNzID0gZnVuY3Rpb24gKG5ld1Byb2dyZXNzKSB7XHJcblxyXG5cdHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgICBpZiAodGhhdC5pbmZvLmVtcHR5KSB7XHJcbiAgICAgICAgdGhhdC5yZWZyZXNoKCk7XHJcbiAgICB9XHJcbiAgICB0aGF0LmluZm8ucHJvZ3Jlc3MgPSBuZXdQcm9ncmVzcztcclxuICAgIHRoYXQuaW5mby5oYW5kbGUubGVmdCA9IHRoYXQuaW5mby5wcm9ncmVzcyAqIHRoYXQuaW5mby53aWR0aDtcclxuICAgIHRoYXQuaGFuZGxlLnN0eWxlLmxlZnQgPSB0aGF0LmluZm8uaGFuZGxlLmxlZnQgKyAncHgnO1xyXG5cclxufTtcclxuXHJcbk5JQlMuU2xpZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBkZWxldGUgTklCUy5TbGlkZXIuYWxsW3RoYXQuaWRdO1xyXG4gICAgdGhhdC5kcmFnLmRpc3Bvc2UoKTtcclxuXHJcbn07XHJcbiJdLCJmaWxlIjoiTklCUy9TbGlkZXIuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==

/**
 * LBI
 * @version 1.3
 * @author http://www.lbi.com/se/
 * @copyright LBI 2013
 */

var NIBS = NIBS || {};
(function(ns) {
    var MOUSE_DOWN = "mousedown";
    var MOUSE_MOVE = "mousemove";
    var MOUSE_UP = "mouseup";

    var oldMSPointerStyle = (function(style) {
        if (typeof style.MSPointerDown !== 'undefined') {
            return true;
        }
        return false;
    })(document.createElement('div').style);

    if (window.navigator.msPointerEnabled) {
        if (oldMSPointerStyle) {
            MOUSE_DOWN = "MSPointerDown";
            MOUSE_MOVE = "MSPointerMove";
            MOUSE_UP = "MSPointerUp";
        } else {
            MOUSE_DOWN = "pointerdown";
            MOUSE_MOVE = "pointermove";
            MOUSE_UP = "pointerup";
        }
    }

    // IF THE BROWSER IS INTERNET EXPLORER 10
    if (navigator.appVersion.indexOf("MSIE 10") !== -1) {
        MOUSE_DOWN = "MSPointerDown";
        MOUSE_MOVE = "MSPointerMove";
        MOUSE_UP = "MSPointerUp";
    }

    var eventAddListener = function(element, type, handler) {
        if (element.addEventListener) {
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent("on" + type, handler);
        }
    };
    var eventRemoveListener = function(element, type, handler) {
        if (element.removeEventListener) {
            element.removeEventListener(type, handler);
        } else if (element.detachEvent) {
            element.detachEvent("on" + type, handler);
        }
    };
    var eventPreventDefault = function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    };
    var eventStopPropagation = function(event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    };
    var documentListeners = [];
    var documentHandler = function(event) {
        var listeners = documentListeners.slice();
        for (var i = 0; i < listeners.length; i++) {
            if (listeners[i].listener(event)) {
                return;
            }
        }
    };
    var setupDocumentHandler = function() {
        eventAddListener(document, MOUSE_MOVE, documentHandler);
        eventAddListener(document, MOUSE_UP, documentHandler);
    };
    var disposeDocumentHandler = function() {
        eventRemoveListener(document, MOUSE_MOVE, documentHandler);
        eventRemoveListener(document, MOUSE_UP, documentHandler);
    };
    var addDocumentListener = function(gesture) {
        removeDocumentListener(gesture);
        documentListeners.push(gesture);
        if (documentListeners.length == 1) {
            setupDocumentHandler();
        }
    };
    var removeDocumentListener = function(gesture) {
        for (var i = 0; i < documentListeners.length; i++) {
            if (documentListeners[i] == gesture) {
                documentListeners.splice(i, 1);
                if (documentListeners.length === 0) {
                    disposeDocumentHandler();
                }
                return;
            }
        }
    };

    function Drag(element, delegate) {
        this.element = element;
        if ("mozUserSelect" in this.element.style) {
            this.element.style.mozUserSelect = "none";
        } else if ("webkitUserSelect" in this.element.style) {
            this.element.style.webkitUserSelect = "none";
        } else if ("msUserSelect" in this.element.style) {
            this.element.style.msUserSelect = "none";
        } else if ("userSelect" in this.element.style) {
            this.element.style.userSelect = "none";
        }
        this.delegate = delegate;
        this.location = {
            x: 0,
            y: 0
        };
        this.translation = {
            x: 0,
            y: 0
        };
        this.offset = {
            x: 0,
            y: 0
        };
        this.canceled = false;
        this.stopped = false;
        var scope = this;
        this.listener = function(event) {
            scope.stopped = false;
            scope.event = event || window.event;
            scope.target = event.srcElement || event.target;
            scope.handler(event.type);
            scope.event = scope.target = null;
            return scope.stopped;
        };
        if ("ontouchstart" in window) {
            this.addEvent(this.element, "touchstart");
            this.addEvent(this.element, "touchmove");
            this.addEvent(this.element, "touchend");
            this.addEvent(this.element, "touchcancel");
        } else {
            this.element.ondragstart = function() {
                return false;
            };
            this.addEvent(this.element, MOUSE_DOWN);
        }
        this.addEvent(this.element, "click");
    }
    Drag.prototype.dispose = function() {
        if ("ontouchstart" in window) {
            this.removeEvent(this.element, "touchstart");
            this.removeEvent(this.element, "touchmove");
            this.removeEvent(this.element, "touchend");
            this.removeEvent(this.element, "touchcancel");
        } else {
            this.element.ondragstart = null;
            this.removeEvent(this.element, MOUSE_DOWN);
            removeDocumentListener(this);
        }
        this.removeEvent(this.element, "click");
        this.element = null;
        this.delegate = null;
    };
    Drag.prototype.addEvent = function(element, type) {
        eventAddListener(element, type, this.listener);
    };
    Drag.prototype.removeEvent = function(element, type) {
        eventRemoveListener(element, type, this.listener);
    };
    Drag.prototype.preventDefault = function() {
        if (this.event) {
            eventPreventDefault(this.event);
        }
    };
    Drag.prototype.stopPropagation = function() {
        if (this.event) {
            this.stopped = true;
            eventStopPropagation(this.event);
        }
    };
    Drag.prototype.locationInElement = function(element) {
        if (!this.event) {
            return {
                x: 0,
                y: 0
            };
        }
        var x = this.location.x,
            y = this.location.y;
        while (element) {
            x -= element.offsetLeft;
            y -= element.offsetTop;
            element = element.offsetParent;
        }
        return {
            x: x,
            y: y
        };
    };
    Drag.prototype.updateLocation = function() {
        if ("touches" in this.event && this.event.touches.length > 0) {
            this.location.x = this.event.touches[0].pageX;
            this.location.y = this.event.touches[0].pageY;
        } else if ("pageX" in this.event) {
            this.location.x = this.event.pageX;
            this.location.y = this.event.pageY;
        } else if ("clientX" in this.event) {
            var d = document.documentElement,
                b = document.body;
            this.location.x = this.event.clientX + (d && d.scrollLeft || b && b.scrollLeft || 0) - (d && d.clientLeft || b && b.clientLeft || 0);
            this.location.y = this.event.clientY + (d && d.scrollTop || b && b.scrollTop || 0) - (d && d.clientTop || b && b.clientTop || 0);
        }
    };
    Drag.prototype.updateTranslation = function(reset) {
        if (reset) {
            this.offset.x = this.location.x;
            this.offset.y = this.location.y;
        }
        this.translation.x = this.location.x - this.offset.x;
        this.translation.y = this.location.y - this.offset.y;
    };
    Drag.prototype.cancel = function() {
        this.canceled = true;
    };
    Drag.prototype.notify = function(name) {
        if (this.delegate && this.delegate[name]) {
            this.delegate[name](this);
        }
    };
    Drag.prototype.handler = function(type) {
        switch (type) {
            case "click":
                this.notify("click");
                break;
            case "touchstart":
                this.canceled = false;
                this.updateLocation();
                this.updateTranslation(true);
                this.notify("dragDidStart");
                break;
            case MOUSE_DOWN:
                this.canceled = false;
                this.updateLocation();
                this.updateTranslation(true);
                this.notify("dragDidStart");
                addDocumentListener(this);
                break;
            case MOUSE_MOVE:
            case "touchmove":
                if (!this.canceled) {
                    this.updateLocation();
                    this.updateTranslation(false);
                    this.notify("dragDidMove");
                }
                break;
            case MOUSE_UP:
                removeDocumentListener(this);
                if (!this.canceled) {
                    this.notify("dragDidStop");
                }
                break;
            case "touchend":
            case "touchcancel":
                if (!this.canceled) {
                    this.notify("dragDidStop");
                }
                break;
        }
    };

    function Wheel(element, delegate) {
        this.element = element;
        this.delegate = delegate;
        var scope = this;
        this.listener = function(event) {
            scope.event = event || window.event;
            scope.delta = scope.event.wheelDelta || -scope.event.detail;
            if (scope.delegate && scope.delegate.wheelDidMove) {
                scope.delegate.wheelDidMove(scope);
            }
            scope.event = null;
        };
        eventAddListener(this.element, "mousewheel", this.listener);
        eventAddListener(this.element, "DOMMouseScroll", this.listener);
    }
    Wheel.prototype.preventDefault = function() {
        if (this.event) {
            eventPreventDefault(this.event);
        }
    };
    Wheel.prototype.stopPropagation = function() {
        if (this.event) {
            this.stopped = true;
            eventStopPropagation(this.event);
        }
    };
    Wheel.prototype.dispose = function() {
        eventRemoveListener(this.element, "mousewheel", this.listener);
        eventRemoveListener(this.element, "DOMMouseScroll", this.listener);
        this.listener = null;
        this.element = null;
        this.delegate = null;
    };

    function Keystroke(element, delegate) {
        this.element = element;
        this.delegate = delegate;
        var scope = this;
        this.listener = function(event) {
            scope.event = event || window.event;
            scope.key = scope.event.keyCode;
            if (scope.event.type == "keydown") {
                if (scope.delegate && scope.delegate.keystrokeDidStart) {
                    scope.delegate.keystrokeDidStart(scope);
                }
            }
            if (scope.event.type == "keyup") {
                if (scope.delegate && scope.delegate.keystrokeDidStop) {
                    scope.delegate.keystrokeDidStop(scope);
                }
            }
            scope.event = null;
        };
        eventAddListener(this.element, "keydown", this.listener);
        eventAddListener(this.element, "keyup", this.listener);
    }
    Keystroke.prototype.preventDefault = function() {
        if (this.event) {
            eventPreventDefault(this.event);
        }
    };
    Keystroke.prototype.stopPropagation = function() {
        if (this.event) {
            this.stopped = true;
            eventStopPropagation(this.event);
        }
    };
    Keystroke.prototype.dispose = function() {
        eventRemoveListener(this.element, "keydown", this.listener);
        eventRemoveListener(this.element, "keyup", this.listener);
        this.listener = null;
        this.element = null;
        this.delegate = null;
    };

    function firstChild(element) {
        var child = element.firstChild;
        while (child !== null && child.nodeType == 3) {
            child = child.nextSibling;
        }
        return child;
    }

    function clip(min, max, value, wrap) {
        if (wrap) {
            if (value < min) {
                return max;
            }
            if (value > max) {
                return min;
            }
            return value;
        }
        return Math.min(max, Math.max(min, value));
    }

    function getTime() {
        return new Date().getTime();
    }

    function easeInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
    }

    function easeOut(k) {
        return --k * k * k + 1;
    }

    function detectTransform(value) {
        var transforms = {
            'webkitTransform': '-webkit-transform',
            'OTransform': '-o-transform',
            'msTransform': '-ms-transform',
            'MozTransform': '-moz-transform',
            'transform': 'transform'
        };
        var test = document.createElement('p');
        document.body.insertBefore(test, null);
        for (var name in transforms) {
            if (test.style[name] !== undefined) {
                test.style[name] = value;
                var style = window.getComputedStyle(test).getPropertyValue(transforms[name]);
                if (style !== undefined && style.length > 0 && style !== "none") {
                    document.body.removeChild(test);
                    return name;
                }
            }
        }
        document.body.removeChild(test);
        return null;
    }
    var REST_EPSILON = 0.01;
    var activeScroller;
    var requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) {
        window.setTimeout(function() {
            callback();
        }, 1000 / 60);
    };
    var translate;
    var translateName = detectTransform("translate3d(1px,1px,1px)");
    if (translateName) {
        translate = function(node, x, y) {
            if (!node) {
                return;
            }

            node.style[translateName] = "translate3d(" + x + "px," + y + "px,0)";
        };
    } else {
        translate = function(node, x, y) {
            node.style.left = x + "px";
            node.style.top = y + "px";
        };
    }

    function Scroller(node, delegate) {
        if (node) {
            if (node.get) {
                node = node.get(0);
            }
            this.node = node;
            this.contentNode = firstChild(node);
        } else {
            this.node = document.createElement("div");
        }

        if (this.node.tabIndex < 0) {
            this.node.tabIndex = 0;
            this.node.style.outline = "0";
        }
        this.node.style.position = "relative";
        this.node.style.overflow = "hidden";
        this.node.style.cursor = "default";

        if (!this.contentNode) {
            this.contentNode = document.createElement("div");
            this.node.appendChild(this.contentNode);
        }
        this.contentNode.style.position = "relative";

        this.delegate = delegate;

        this.elasticity = 8;
        this.friction = 0.94; //Velocity damp after drag.
        this.paging = false; //Snap.

        this.validating = false;
        this.dragging = false;
        this.disable = false;
        this.dragTime = 0;
        this.decelerating = false;
        this.animating = false;
        this.animatingTime = 0;
        this.animatingDuration = 1000;

        this.directed = false;
        this.lastDelta = 0;
        this.autoContentSize = true;

        this.vertical = new ScrollAxis();
        this.horizontal = new ScrollAxis();

        this.drag = new Drag(this.contentNode, this);
        this.wheel = new Wheel(this.node, this);
        this.keystroke = new Keystroke(this.node, this);

        translate(this.contentNode, 0, 0);
        this.layout();
    }

    Scroller.prototype.on = function() {
        this.disable = false;
        this.validate();
    };

    Scroller.prototype.off = function() {
        this.disable = true;
    };

    Scroller.prototype.dispose = function() {
        this.drag.dispose();
        this.wheel.dispose();
        if (this.trackbar) {
            this.trackbar.dispose();
        }
        this.node = null;
        this.contentNode = null;
    };
    Scroller.prototype.setTrackbarVisible = function(value) {
        if (value && !this.trackbar) {
            this.trackbar = new Trackbar(this);
            this.node.appendChild(this.trackbar.node);
        } else if (!value && this.trackbar) {
            this.node.removeChild(this.trackbar.node);
            this.trackbar.dispose();
        }
    };
    Scroller.prototype.getContentOffset = function() {
        return {
            x: this.horizontal.contentOffset,
            y: this.vertical.contentOffset
        };
    };
    Scroller.prototype.refresh = function(extraMargin) {
        this.layout();
        this.setContentSize(this.contentNode.offsetWidth, this.contentNode.offsetHeight + extraMargin);
        //this.setContentOffset(0, 0);
    };
    Scroller.prototype.resize = function(w, h, extraMargin) {
        extraMargin = extraMargin || 0;
        var content = this.contentNode;
        content.parentNode.style.width = w + 'px';
        content.parentNode.style.height = h + 'px';
        this.refresh(extraMargin);
    };
    Scroller.prototype.setContentOffset = function(x, y, duration) {
        this.dragging = false;
        this.decelerating = false;
        this.animating = !isNaN(duration);
        if (this.animating) {
            this.updateBounds();
            this.horizontal.beginAnimate(x);
            this.vertical.beginAnimate(y);
            this.animating = true;
            this.animatingTime = getTime();
            this.animatingDuration = duration;
        } else {
            this.horizontal.contentOffset = x;
            this.vertical.contentOffset = y;
        }
        this.invalidate();
    };
    Scroller.prototype.getContentSize = function() {
        return {
            width: this.horizontal.contentLength,
            height: this.vertical.contentLength
        };
    };
    Scroller.prototype.setContentSize = function(width, height) {
        this.horizontal.contentLength = width;
        this.vertical.contentLength = height;
        this.autoContentSize = false;
    };
    Scroller.prototype.setAutoContentSize = function() {
        this.autoContentSize = true;
    };
    Scroller.prototype.nudgeHorizontal = function(amount) {
        if (this.paging) {
            var pagedOffset = this.horizontal.getPagedOffset(amount, true);
            if (!this.animating || this.horizontal.animateFrom + this.horizontal.animateDelta != pagedOffset) {
                this.setContentOffset(pagedOffset, this.vertical.contentOffset, this.speed);
            }
        } else {
            this.dragging = false;
            this.decelerating = false;
            this.animating = false;
            this.horizontal.contentOffset += amount;
            this.invalidate();
        }
    };
    Scroller.prototype.nudgeVertical = function(amount) {

        if (this.paging) {
            var pagedOffset = this.vertical.getPagedOffset(amount, true);
            if (!this.animating || this.vertical.animateFrom + this.vertical.animateDelta != pagedOffset) {
                this.setContentOffset(this.horizontal.contentOffset, pagedOffset, this.speed);
            }
        } else {
            this.dragging = false;
            this.decelerating = false;
            this.animating = false;
            this.vertical.contentOffset += amount;
            this.invalidate();
        }
    };
    Scroller.prototype.keystrokeDidStart = function(keystroke) {

        if (keystroke.key == 40 && this.vertical.getScrollable()) {
            keystroke.preventDefault();
            this.nudgeVertical(20);
        } else if (keystroke.key == 38 && this.vertical.getScrollable()) {
            keystroke.preventDefault();
            this.nudgeVertical(-20);
        } else if (keystroke.key == 37 && this.horizontal.getScrollable()) {
            keystroke.preventDefault();
            this.nudgeHorizontal(-20);
        } else if (keystroke.key == 39 && this.horizontal.getScrollable()) {
            keystroke.preventDefault();
            this.nudgeHorizontal(20);
        }

    };
    Scroller.prototype.trackbarDidMove = function(trackbar) {
        this.setContentOffset(0, trackbar.position * (this.vertical.contentLength - this.vertical.parentLength));
    };
    Scroller.prototype.wheelDidMove = function(gesture) {
        this.updateBounds();
        if (!this.vertical.getScrollable()) {
            return;
        }

        gesture.preventDefault();
        gesture.stopPropagation();

        if (this.paging) {

            //Mac mouse wheel fix
            // var wTime = new Date().getTime();
            // trace('wDelta', (wTime - window.lastWTime));
            // window.lastWTime = wTime;
            //http://stackoverflow.com/questions/26326958/stopping-mousewheel-event-from-happening-twice-in-osx
            //http://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers
            //console.log(gesture.delta);

            if (Math.abs(gesture.delta) < 119) return;

            var pagedOffset = this.vertical.getPagedOffset(clip(-1, 1, -gesture.delta));
            if (!this.animating || this.vertical.animateFrom + this.vertical.animateDelta != pagedOffset) {
                this.setContentOffset(this.horizontal.contentOffset, pagedOffset, this.speed);
            }
        } else {
            this.dragging = false;
            this.decelerating = false;
            this.animating = false;
            this.vertical.contentOffset -= gesture.delta * 0.2;
            this.invalidate();
        }
    };
    Scroller.prototype.dragDidStart = function(gesture) {

        if (this.delegate && this.delegate.onScrollStart) {
            this.delegate.onScrollStart(this);
        }

        this.node.focus();
        this.updateBounds();

        gesture.offset.x += this.horizontal.contentOffset;
        gesture.offset.y += this.vertical.contentOffset;
        gesture.updateTranslation();

        this.horizontal.dragOffset = -gesture.translation.x;
        this.horizontal.velocity = 0;

        this.vertical.dragOffset = -gesture.translation.y;
        this.vertical.velocity = 0;

        this.dragTime = getTime();

        this.dragging = true;
        this.decelerating = false;
        this.animating = false;
        this.directed = false;

        activeScroller = null;
    };
    Scroller.prototype.dragDidMove = function(gesture) {
        var velocityX = -gesture.translation.x - this.horizontal.dragOffset;
        var velocityY = -gesture.translation.y - this.vertical.dragOffset;

        if (!activeScroller) {
            var horizontalMove = Math.abs(velocityX) > Math.abs(velocityY);
            if ((horizontalMove && this.horizontal.getScrollable()) || (!horizontalMove && this.vertical.getScrollable())) {
                activeScroller = this;
                this.directed = true;
                this.invalidate();
            }
        } else if (activeScroller != this) {
            gesture.cancel();
            return;
        }

        if (this.directed) {
            gesture.preventDefault();
        }

        this.horizontal.velocity = velocityX;
        this.horizontal.dragOffset = -gesture.translation.x;

        this.vertical.velocity = velocityY;
        this.vertical.dragOffset = -gesture.translation.y;

        this.dragTime = getTime();
    };
    Scroller.prototype.dragDidStop = function(gesture) {

        if (this.delegate && this.delegate.onDragEnd) {
            this.delegate.onDragEnd(this);
        }

        var time = getTime();
        if (time - this.dragTime > 100) {
            this.horizontal.velocity = 0;
            this.vertical.velocity = 0;
        }
        this.dragging = false;
        if (this.paging) {
            this.setContentOffset(this.horizontal.getPagedOffset(this.horizontal.velocity), this.vertical.getPagedOffset(this.vertical.velocity), this.speed);
        } else {
            this.decelerating = true;
        }
    };
    Scroller.prototype.click = function(gesture) {
        if (this.directed) {
            gesture.preventDefault();
            gesture.stopPropagation();
        }
    };
    Scroller.prototype.layout = function() {
        this.invalidate();
        this.needsLayout = true;
    };
    Scroller.prototype.invalidate = function() {
        if (!this.validating) {
            this.validating = true;
            var scope = this;
            requestFrame(function() {
                scope.validate();
            });
        }
    };
    Scroller.prototype.validate = function() {

        if (this.disable) return;

        if (this.needsLayout) {
            this.updateBounds();
            this.needsLayout = false;
        }
        this.resolve();
        if (this.delegate && this.delegate.scrollerDidScroll) {
            this.delegate.scrollerDidScroll(this);
        }
        if (!this.dragging && !this.decelerating && !this.animating) {
            this.validating = false;
        } else {
            this.validating = true;
            var scope = this;
            requestFrame(function() {
                scope.validate();
            });
        }

    };
    Scroller.prototype.resolve = function() {
        if (this.dragging) {
            this.horizontal.drag();
            this.vertical.drag();
        } else if (this.animating) {
            var t = (getTime() - this.animatingTime) / this.animatingDuration;
            if (t > 1) {
                t = 1;
                this.animating = false;
            } else {
                t = easeOut(t);
            }
            this.horizontal.animate(t);
            this.vertical.animate(t);
        } else if (this.decelerating) {
            this.decelerating = this.horizontal.decelerate(this.friction, this.elasticity) + this.vertical.decelerate(this.friction, this.elasticity) > 0;
        } else {
            this.horizontal.constrain();
            this.vertical.constrain();
        }

        translate(this.contentNode, -this.horizontal.contentOffset, -this.vertical.contentOffset);

        if (this.trackbar) {
            this.trackbar.setPosition(this.vertical.contentOffset / (this.vertical.contentLength - this.vertical.parentLength));
        }
    };
    Scroller.prototype.updateBounds = function() {
        if (!this.node) {
            return;
        }
        this.horizontal.parentLength = this.node.offsetWidth;
        this.vertical.parentLength = this.node.offsetHeight;
        if (this.autoContentSize) {
            this.horizontal.contentLength = this.contentNode.offsetWidth;
            this.vertical.contentLength = this.contentNode.offsetHeight;
        }

        if ("msTouchAction" in this.node.style) {
            if (this.vertical.contentLength > this.vertical.parentLength && this.horizontal.contentLength > this.horizontal.parentLength) {
                this.node.style.msTouchAction = "none";
            } else if (this.horizontal.contentLength > this.horizontal.parentLength) {
                this.node.style.msTouchAction = "pan-y";
            } else if (this.vertical.contentLength > this.vertical.parentLength) {
                this.node.style.msTouchAction = "pan-x";
            } else {
                this.node.style.msTouchAction = "auto";
            }
        }

        if (this.trackbar) {
            if (this.vertical.contentLength > this.vertical.parentLength) {
                this.trackbar.node.style.visibility = "";
                this.trackbar.setLength(this.vertical.parentLength, this.vertical.parentLength / this.vertical.contentLength);
                this.trackbar.align(this.horizontal.parentLength);
            } else {
                this.trackbar.node.style.visibility = "hidden";
            }
        }
    };
    Scroller.prototype.speed = 400;

    function ScrollAxis() {
        this.velocity = 0;
        this.parentLength = 0;
        this.contentLength = 0;
        this.contentOffset = 0;
        this.dragOffset = 0;
        this.animateFrom = 0;
        this.animateDelta = 0;
    }
    ScrollAxis.prototype.getScrollable = function() {
        return this.contentLength - this.parentLength > 0;
    };
    ScrollAxis.prototype.getPagedOffset = function(direction, wrap) {
        var min = 0;
        var max = Math.max(0, this.contentLength - this.parentLength);
        if (direction < 0) {
            return clip(min, max, Math.floor((this.contentOffset + direction) / this.parentLength) * this.parentLength, wrap);
        }
        if (direction > 0) {
            return clip(min, max, Math.ceil((this.contentOffset + direction) / this.parentLength) * this.parentLength, wrap);
        }
        return clip(min, max, Math.round(this.contentOffset / this.parentLength) * this.parentLength, wrap);
    };
    ScrollAxis.prototype.drag = function() {
        var min = 0;
        var max = Math.max(0, this.contentLength - this.parentLength);
        this.contentOffset = this.dragOffset;

        if (this.contentOffset < min) {
            if (max === min) {
                this.contentOffset = min;
            } else {
                this.contentOffset += (min - this.contentOffset) / 1.5;
            }
        } else if (this.contentOffset > max) {
            if (max === min) {
                this.contentOffset = max;
            } else {
                this.contentOffset += (max - this.contentOffset) / 1.5;
            }
        }
    };
    ScrollAxis.prototype.beginAnimate = function(value) {
        if (isNaN(this.contentOffset)) return;
        this.animateFrom = this.contentOffset;
        this.animateDelta = value - this.contentOffset;
    };
    ScrollAxis.prototype.animate = function(t) {
        this.contentOffset = this.animateFrom + this.animateDelta * t;
    };
    ScrollAxis.prototype.decelerate = function(friction, elasticity) {
        var min = 0;
        var max = Math.max(0, this.contentLength - this.parentLength);
        this.velocity *= friction;
        this.contentOffset += this.velocity;
        if (this.contentOffset < min) {
            if (max === min) {
                this.velocity = 0;
                this.contentOffset = min;
            } else if (this.velocity < 0) {
                this.velocity += (min - this.contentOffset) / elasticity;
            } else {
                this.velocity = (min - this.contentOffset) / elasticity;
            }
        } else if (this.contentOffset > max) {
            if (min === max) {
                this.velocity = 0;
                this.contentOffset = min;
            } else if (this.velocity > 0) {
                this.velocity += (max - this.contentOffset) / elasticity;
            } else {
                this.velocity = (max - this.contentOffset) / elasticity;
            }
        }
        return Math.abs(this.velocity) < REST_EPSILON ? 0 : 1;
    };
    ScrollAxis.prototype.constrain = function() {
        var max = Math.max(0, this.contentLength - this.parentLength);
        this.contentOffset = clip(0, max, this.contentOffset);
    };


    function Trackbar(delegate) {
        this.delegate = delegate;
        this.node = document.createElement("div");
        this.node.className = "nibs-trackbar nibs-trackbar-y";
        this.node.style.position = "absolute";
        this.node.style.top = "0px";

        this.nodeLength = 0;
        this.thumbLength = 50;
        this.length = 0;

        this.thumb = document.createElement("div");
        this.thumb.className = "nibs-trackbar-thumb nibs-trackbar-thumb-y";
        this.thumb.style.position = "relative";
        this.node.appendChild(this.thumb);

        this.position = 0;
        this.axis = "y";
        this.drag = new Drag(this.node, this);
    }
    Trackbar.prototype.setLength = function(value, ratio) {
        this.nodeLength = value;
        this.thumbLength = Math.max(Math.round(value * ratio), 20);

        this.node.style.height = this.nodeLength + "px";
        this.thumb.style.height = this.thumbLength + "px";

        this.length = this.nodeLength - this.thumb.offsetHeight;
    };
    Trackbar.prototype.align = function(value) {
        this.node.style.left = (value - this.node.offsetWidth) + "px";
    };
    Trackbar.prototype.setPosition = function(value) {
        this.position = clip(0, 1, value);
        this.update();
    };
    Trackbar.prototype.dragDidStart = function(gesture) {
        if (gesture.target == this.thumb) {
            gesture.stopPropagation();
            this.notify("trackbarDidStart");
            gesture.offset[this.axis] -= this.position * this.length;
            gesture.updateTranslation();
        } else {
            gesture.cancel();
        }
    };
    Trackbar.prototype.dragDidMove = function(gesture) {
        gesture.stopPropagation();
        this.position = clip(0, 1, gesture.translation[this.axis] / this.length);
        this.notify("trackbarDidMove");
    };
    Trackbar.prototype.dragDidStop = function(gesture) {
        this.notify("trackbarDidStop");
    };
    Trackbar.prototype.layout = function() {
        this.update();
    };
    Trackbar.prototype.update = function() {
        var value = Math.round(this.position * this.length);
        if (this.axis == "y") {
            translate(this.thumb, 0, value);
        } else {
            translate(this.thumb, value, 0);
        }
    };
    Trackbar.prototype.notify = function(selector) {
        if (this.delegate && this.delegate[selector]) {
            this.delegate[selector](this);
        }
    };
    Trackbar.prototype.dispose = function() {
        this.drag.dispose();
    };

    this.NIBS.Scroller = Scroller;

})(this.NIBS || {});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJwYXJhZG94L1Njcm9sbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBMQklcclxuICogQHZlcnNpb24gMS4zXHJcbiAqIEBhdXRob3IgaHR0cDovL3d3dy5sYmkuY29tL3NlL1xyXG4gKiBAY29weXJpZ2h0IExCSSAyMDEzXHJcbiovXHJcblxyXG52YXIgTklCUyA9IE5JQlMgfHwge307XHJcbihmdW5jdGlvbihucyl7XHJcblx0dmFyIE1PVVNFX0RPV04gPSBcIm1vdXNlZG93blwiO1xyXG5cdHZhciBNT1VTRV9NT1ZFID0gXCJtb3VzZW1vdmVcIjtcclxuXHR2YXIgTU9VU0VfVVAgPSBcIm1vdXNldXBcIjtcclxuXHJcblx0dmFyIG9sZE1TUG9pbnRlclN0eWxlID0gKGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBzdHlsZS5NU1BvaW50ZXJEb3duICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9KShkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZSk7XHJcblxyXG5cdGlmKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xyXG5cdFx0aWYgKG9sZE1TUG9pbnRlclN0eWxlKSB7XHJcblx0XHRcdE1PVVNFX0RPV04gPSBcIk1TUG9pbnRlckRvd25cIjtcclxuXHRcdFx0TU9VU0VfTU9WRSA9IFwiTVNQb2ludGVyTW92ZVwiO1xyXG5cdFx0XHRNT1VTRV9VUCA9IFwiTVNQb2ludGVyVXBcIjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdE1PVVNFX0RPV04gPSBcInBvaW50ZXJkb3duXCI7XHJcblx0XHRcdE1PVVNFX01PVkUgPSBcInBvaW50ZXJtb3ZlXCI7XHJcblx0XHRcdE1PVVNFX1VQID0gXCJwb2ludGVydXBcIjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZhciBldmVudEFkZExpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xyXG5cdFx0aWYoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XHJcblx0XHRcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcclxuXHRcdFx0ZWxlbWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdHZhciBldmVudFJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xyXG5cdFx0aWYoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XHJcblx0XHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoZWxlbWVudC5kZXRhY2hFdmVudCkge1xyXG5cdFx0XHRlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dmFyIGV2ZW50UHJldmVudERlZmF1bHQgPSBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0aWYoZXZlbnQucHJldmVudERlZmF1bHQpIHtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dmFyIGV2ZW50U3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdGlmKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xyXG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dmFyIGRvY3VtZW50TGlzdGVuZXJzID0gW107XHJcblx0dmFyIGRvY3VtZW50SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gZG9jdW1lbnRMaXN0ZW5lcnMuc2xpY2UoKTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGk8bGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKGxpc3RlbmVyc1tpXS5saXN0ZW5lcihldmVudCkpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHZhciBzZXR1cERvY3VtZW50SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0ZXZlbnRBZGRMaXN0ZW5lcihkb2N1bWVudCwgTU9VU0VfTU9WRSwgZG9jdW1lbnRIYW5kbGVyKTtcclxuXHRcdGV2ZW50QWRkTGlzdGVuZXIoZG9jdW1lbnQsIE1PVVNFX1VQLCBkb2N1bWVudEhhbmRsZXIpO1xyXG5cdH07XHJcblx0dmFyIGRpc3Bvc2VEb2N1bWVudEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdGV2ZW50UmVtb3ZlTGlzdGVuZXIoZG9jdW1lbnQsIE1PVVNFX01PVkUsIGRvY3VtZW50SGFuZGxlcik7XHJcblx0XHRldmVudFJlbW92ZUxpc3RlbmVyKGRvY3VtZW50LCBNT1VTRV9VUCwgZG9jdW1lbnRIYW5kbGVyKTtcclxuXHR9O1xyXG5cdHZhciBhZGREb2N1bWVudExpc3RlbmVyID0gZnVuY3Rpb24oZ2VzdHVyZSkge1xyXG5cdFx0cmVtb3ZlRG9jdW1lbnRMaXN0ZW5lcihnZXN0dXJlKTtcclxuXHRcdGRvY3VtZW50TGlzdGVuZXJzLnB1c2goZ2VzdHVyZSk7XHJcblx0XHRpZihkb2N1bWVudExpc3RlbmVycy5sZW5ndGggPT0gMSkge1xyXG5cdFx0XHRzZXR1cERvY3VtZW50SGFuZGxlcigpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0dmFyIHJlbW92ZURvY3VtZW50TGlzdGVuZXIgPSBmdW5jdGlvbihnZXN0dXJlKSB7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpPGRvY3VtZW50TGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKGRvY3VtZW50TGlzdGVuZXJzW2ldID09IGdlc3R1cmUpIHtcclxuXHRcdFx0XHRkb2N1bWVudExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0aWYoZG9jdW1lbnRMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRkaXNwb3NlRG9jdW1lbnRIYW5kbGVyKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIERyYWcoZWxlbWVudCwgZGVsZWdhdGUpIHtcclxuXHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHRpZihcIm1velVzZXJTZWxlY3RcIiBpbiB0aGlzLmVsZW1lbnQuc3R5bGUpIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50LnN0eWxlLm1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoXCJ3ZWJraXRVc2VyU2VsZWN0XCIgaW4gdGhpcy5lbGVtZW50LnN0eWxlKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gXCJub25lXCI7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKFwibXNVc2VyU2VsZWN0XCIgaW4gdGhpcy5lbGVtZW50LnN0eWxlKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS5tc1VzZXJTZWxlY3QgPSBcIm5vbmVcIjtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoXCJ1c2VyU2VsZWN0XCIgaW4gdGhpcy5lbGVtZW50LnN0eWxlKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gXCJub25lXCI7XHJcblx0XHR9XHJcblx0XHR0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0XHR0aGlzLmxvY2F0aW9uID0ge3g6MCwgeTowfTtcclxuXHRcdHRoaXMudHJhbnNsYXRpb24gPSB7eDowLCB5OjB9O1xyXG5cdFx0dGhpcy5vZmZzZXQgPSB7eDowLCB5OjB9O1xyXG5cdFx0dGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5zdG9wcGVkID0gZmFsc2U7XHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0dGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHNjb3BlLnN0b3BwZWQgPSBmYWxzZTtcclxuXHRcdFx0c2NvcGUuZXZlbnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XHJcblx0XHRcdHNjb3BlLnRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQudGFyZ2V0O1xyXG5cdFx0XHRzY29wZS5oYW5kbGVyKGV2ZW50LnR5cGUpO1xyXG5cdFx0XHRzY29wZS5ldmVudCA9IHNjb3BlLnRhcmdldCA9IG51bGw7XHJcblx0XHRcdHJldHVybiBzY29wZS5zdG9wcGVkO1xyXG5cdFx0fTtcclxuXHRcdGlmKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93KSB7XHJcblx0XHRcdHRoaXMuYWRkRXZlbnQodGhpcy5lbGVtZW50LCBcInRvdWNoc3RhcnRcIik7XHJcblx0XHRcdHRoaXMuYWRkRXZlbnQodGhpcy5lbGVtZW50LCBcInRvdWNobW92ZVwiKTtcclxuXHRcdFx0dGhpcy5hZGRFdmVudCh0aGlzLmVsZW1lbnQsIFwidG91Y2hlbmRcIik7XHJcblx0XHRcdHRoaXMuYWRkRXZlbnQodGhpcy5lbGVtZW50LCBcInRvdWNoY2FuY2VsXCIpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKCkge3JldHVybiBmYWxzZTt9O1xyXG5cdFx0XHR0aGlzLmFkZEV2ZW50KHRoaXMuZWxlbWVudCwgTU9VU0VfRE9XTik7XHJcblx0XHR9XHJcblx0XHR0aGlzLmFkZEV2ZW50KHRoaXMuZWxlbWVudCwgXCJjbGlja1wiKTtcclxuXHR9XHJcblx0RHJhZy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3cpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIFwidG91Y2hzdGFydFwiKTtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIFwidG91Y2htb3ZlXCIpO1xyXG5cdFx0XHR0aGlzLnJlbW92ZUV2ZW50KHRoaXMuZWxlbWVudCwgXCJ0b3VjaGVuZFwiKTtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIFwidG91Y2hjYW5jZWxcIik7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50Lm9uZHJhZ3N0YXJ0ID0gbnVsbDtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIE1PVVNFX0RPV04pO1xyXG5cdFx0XHRyZW1vdmVEb2N1bWVudExpc3RlbmVyKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5yZW1vdmVFdmVudCh0aGlzLmVsZW1lbnQsIFwiY2xpY2tcIik7XHJcblx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xyXG5cdFx0dGhpcy5kZWxlZ2F0ZSA9IG51bGw7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcclxuXHRcdGV2ZW50QWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgdGhpcy5saXN0ZW5lcik7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcclxuXHRcdGV2ZW50UmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgdGhpcy5saXN0ZW5lcik7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYodGhpcy5ldmVudCkge1xyXG5cdFx0XHRldmVudFByZXZlbnREZWZhdWx0KHRoaXMuZXZlbnQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0RHJhZy5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZih0aGlzLmV2ZW50KSB7XHJcblx0XHRcdHRoaXMuc3RvcHBlZCA9IHRydWU7XHJcblx0XHRcdGV2ZW50U3RvcFByb3BhZ2F0aW9uKHRoaXMuZXZlbnQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0RHJhZy5wcm90b3R5cGUubG9jYXRpb25JbkVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRpZighdGhpcy5ldmVudCkge1xyXG5cdFx0XHRyZXR1cm4ge3g6MCwgeTowfTtcclxuXHRcdH1cclxuXHRcdHZhciB4ID0gdGhpcy5sb2NhdGlvbi54LCB5ID0gdGhpcy5sb2NhdGlvbi55O1xyXG5cdFx0d2hpbGUoZWxlbWVudCkge1xyXG5cdFx0XHR4IC09IGVsZW1lbnQub2Zmc2V0TGVmdDtcclxuXHRcdFx0eSAtPSBlbGVtZW50Lm9mZnNldFRvcDtcclxuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHt4OngsIHk6eX07XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS51cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYoXCJ0b3VjaGVzXCIgaW4gdGhpcy5ldmVudCAmJiB0aGlzLmV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHR0aGlzLmxvY2F0aW9uLnggPSB0aGlzLmV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XHJcblx0XHRcdHRoaXMubG9jYXRpb24ueSA9IHRoaXMuZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoXCJwYWdlWFwiIGluIHRoaXMuZXZlbnQpIHtcclxuXHRcdFx0dGhpcy5sb2NhdGlvbi54ID0gdGhpcy5ldmVudC5wYWdlWDtcclxuXHRcdFx0dGhpcy5sb2NhdGlvbi55ID0gdGhpcy5ldmVudC5wYWdlWTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoXCJjbGllbnRYXCIgaW4gdGhpcy5ldmVudCkge1xyXG5cdFx0XHR2YXIgZCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgYiA9IGRvY3VtZW50LmJvZHk7XHJcblx0XHRcdHRoaXMubG9jYXRpb24ueCA9IHRoaXMuZXZlbnQuY2xpZW50WCArIChkICYmIGQuc2Nyb2xsTGVmdCB8fCBiICYmIGIuc2Nyb2xsTGVmdCB8fCAwKSAtIChkICYmIGQuY2xpZW50TGVmdCB8fCBiICYmIGIuY2xpZW50TGVmdCB8fCAwKTtcclxuXHRcdFx0dGhpcy5sb2NhdGlvbi55ID0gdGhpcy5ldmVudC5jbGllbnRZICsgKGQgJiYgZC5zY3JvbGxUb3AgfHwgYiAmJiBiLnNjcm9sbFRvcCB8fCAwKSAtIChkICYmIGQuY2xpZW50VG9wIHx8IGIgJiYgYi5jbGllbnRUb3AgfHwgMCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS51cGRhdGVUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKHJlc2V0KSB7XHJcblx0XHRpZihyZXNldCkge1xyXG5cdFx0XHR0aGlzLm9mZnNldC54ID0gdGhpcy5sb2NhdGlvbi54O1xyXG5cdFx0XHR0aGlzLm9mZnNldC55ID0gdGhpcy5sb2NhdGlvbi55O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy50cmFuc2xhdGlvbi54ID0gdGhpcy5sb2NhdGlvbi54IC0gdGhpcy5vZmZzZXQueDtcclxuXHRcdHRoaXMudHJhbnNsYXRpb24ueSA9IHRoaXMubG9jYXRpb24ueSAtIHRoaXMub2Zmc2V0Lnk7XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xyXG5cdH07XHJcblx0RHJhZy5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdFx0aWYodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlW25hbWVdKSB7XHJcblx0XHRcdHRoaXMuZGVsZWdhdGVbbmFtZV0odGhpcyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHREcmFnLnByb3RvdHlwZS5oYW5kbGVyID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0c3dpdGNoKHR5cGUpIHtcclxuXHRcdFx0Y2FzZSBcImNsaWNrXCI6XHJcblx0XHRcdFx0dGhpcy5ub3RpZnkoXCJjbGlja1wiKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInRvdWNoc3RhcnRcIjpcclxuXHRcdFx0XHR0aGlzLmNhbmNlbGVkID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy51cGRhdGVMb2NhdGlvbigpO1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlVHJhbnNsYXRpb24odHJ1ZSk7XHJcblx0XHRcdFx0dGhpcy5ub3RpZnkoXCJkcmFnRGlkU3RhcnRcIik7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgTU9VU0VfRE9XTiA6XHJcblx0XHRcdFx0dGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlTG9jYXRpb24oKTtcclxuXHRcdFx0XHR0aGlzLnVwZGF0ZVRyYW5zbGF0aW9uKHRydWUpO1xyXG5cdFx0XHRcdHRoaXMubm90aWZ5KFwiZHJhZ0RpZFN0YXJ0XCIpO1xyXG5cdFx0XHRcdGFkZERvY3VtZW50TGlzdGVuZXIodGhpcyk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgTU9VU0VfTU9WRSA6XHJcblx0XHRcdGNhc2UgXCJ0b3VjaG1vdmVcIiA6XHJcblx0XHRcdFx0aWYoIXRoaXMuY2FuY2VsZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMudXBkYXRlTG9jYXRpb24oKTtcclxuXHRcdFx0XHRcdHRoaXMudXBkYXRlVHJhbnNsYXRpb24oZmFsc2UpO1xyXG5cdFx0XHRcdFx0dGhpcy5ub3RpZnkoXCJkcmFnRGlkTW92ZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgTU9VU0VfVVAgOlxyXG5cdFx0XHRcdHJlbW92ZURvY3VtZW50TGlzdGVuZXIodGhpcyk7XHJcblx0XHRcdFx0aWYoIXRoaXMuY2FuY2VsZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMubm90aWZ5KFwiZHJhZ0RpZFN0b3BcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwidG91Y2hlbmRcIjpcclxuXHRcdFx0Y2FzZSBcInRvdWNoY2FuY2VsXCI6XHJcblx0XHRcdFx0aWYoIXRoaXMuY2FuY2VsZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMubm90aWZ5KFwiZHJhZ0RpZFN0b3BcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0ZnVuY3Rpb24gV2hlZWwoZWxlbWVudCwgZGVsZWdhdGUpIHtcclxuXHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0dGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHNjb3BlLmV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRzY29wZS5kZWx0YSA9IHNjb3BlLmV2ZW50LndoZWVsRGVsdGEgfHwgLXNjb3BlLmV2ZW50LmRldGFpbDtcclxuXHRcdFx0aWYoc2NvcGUuZGVsZWdhdGUgJiYgc2NvcGUuZGVsZWdhdGUud2hlZWxEaWRNb3ZlKSB7XHJcblx0XHRcdFx0c2NvcGUuZGVsZWdhdGUud2hlZWxEaWRNb3ZlKHNjb3BlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzY29wZS5ldmVudCA9IG51bGw7XHJcblx0XHR9O1xyXG5cdFx0ZXZlbnRBZGRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIFwibW91c2V3aGVlbFwiLCB0aGlzLmxpc3RlbmVyKTtcclxuXHRcdGV2ZW50QWRkTGlzdGVuZXIodGhpcy5lbGVtZW50LCBcIkRPTU1vdXNlU2Nyb2xsXCIsIHRoaXMubGlzdGVuZXIpO1xyXG5cdH1cclxuXHRXaGVlbC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMuZXZlbnQpIHtcclxuXHRcdFx0ZXZlbnRQcmV2ZW50RGVmYXVsdCh0aGlzLmV2ZW50KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFdoZWVsLnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMuZXZlbnQpIHtcclxuXHRcdFx0dGhpcy5zdG9wcGVkID0gdHJ1ZTtcclxuXHRcdFx0ZXZlbnRTdG9wUHJvcGFnYXRpb24odGhpcy5ldmVudCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRXaGVlbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0ZXZlbnRSZW1vdmVMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIFwibW91c2V3aGVlbFwiLCB0aGlzLmxpc3RlbmVyKTtcclxuXHRcdGV2ZW50UmVtb3ZlTGlzdGVuZXIodGhpcy5lbGVtZW50LCBcIkRPTU1vdXNlU2Nyb2xsXCIsIHRoaXMubGlzdGVuZXIpO1xyXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGw7XHJcblx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xyXG5cdFx0dGhpcy5kZWxlZ2F0ZSA9IG51bGw7XHJcblx0fTtcclxuXHRmdW5jdGlvbiBLZXlzdHJva2UoZWxlbWVudCwgZGVsZWdhdGUpIHtcclxuXHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0dGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRcdHNjb3BlLmV2ZW50ID0gZXZlbnQgfHwgd2luZG93LmV2ZW50O1xyXG5cdFx0XHRzY29wZS5rZXkgPSBzY29wZS5ldmVudC5rZXlDb2RlO1xyXG5cdFx0XHRpZihzY29wZS5ldmVudC50eXBlID09IFwia2V5ZG93blwiKSB7XHJcblx0XHRcdFx0aWYoc2NvcGUuZGVsZWdhdGUgJiYgc2NvcGUuZGVsZWdhdGUua2V5c3Ryb2tlRGlkU3RhcnQpIHtcclxuXHRcdFx0XHRcdHNjb3BlLmRlbGVnYXRlLmtleXN0cm9rZURpZFN0YXJ0KHNjb3BlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoc2NvcGUuZXZlbnQudHlwZSA9PSBcImtleXVwXCIpIHtcclxuXHRcdFx0XHRpZihzY29wZS5kZWxlZ2F0ZSAmJiBzY29wZS5kZWxlZ2F0ZS5rZXlzdHJva2VEaWRTdG9wKSB7XHJcblx0XHRcdFx0XHRzY29wZS5kZWxlZ2F0ZS5rZXlzdHJva2VEaWRTdG9wKHNjb3BlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0c2NvcGUuZXZlbnQgPSBudWxsO1xyXG5cdFx0fTtcclxuXHRcdGV2ZW50QWRkTGlzdGVuZXIodGhpcy5lbGVtZW50LCBcImtleWRvd25cIiwgdGhpcy5saXN0ZW5lcik7XHJcblx0XHRldmVudEFkZExpc3RlbmVyKHRoaXMuZWxlbWVudCwgXCJrZXl1cFwiLCB0aGlzLmxpc3RlbmVyKTtcclxuXHR9XHJcblx0S2V5c3Ryb2tlLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYodGhpcy5ldmVudCkge1xyXG5cdFx0XHRldmVudFByZXZlbnREZWZhdWx0KHRoaXMuZXZlbnQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0S2V5c3Ryb2tlLnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMuZXZlbnQpIHtcclxuXHRcdFx0dGhpcy5zdG9wcGVkID0gdHJ1ZTtcclxuXHRcdFx0ZXZlbnRTdG9wUHJvcGFnYXRpb24odGhpcy5ldmVudCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRLZXlzdHJva2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdGV2ZW50UmVtb3ZlTGlzdGVuZXIodGhpcy5lbGVtZW50LCBcImtleWRvd25cIiwgdGhpcy5saXN0ZW5lcik7XHJcblx0XHRldmVudFJlbW92ZUxpc3RlbmVyKHRoaXMuZWxlbWVudCwgXCJrZXl1cFwiLCB0aGlzLmxpc3RlbmVyKTtcclxuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5lbGVtZW50ID0gbnVsbDtcclxuXHRcdHRoaXMuZGVsZWdhdGUgPSBudWxsO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGZpcnN0Q2hpbGQoZWxlbWVudCkge1xyXG5cdFx0dmFyIGNoaWxkID0gZWxlbWVudC5maXJzdENoaWxkO1xyXG5cdFx0d2hpbGUoY2hpbGQgIT09IG51bGwgJiYgY2hpbGQubm9kZVR5cGUgPT0gMykge1xyXG5cdFx0XHRjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNoaWxkO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBjbGlwKG1pbiwgbWF4LCB2YWx1ZSwgd3JhcCkge1xyXG5cdFx0aWYod3JhcCkge1xyXG5cdFx0XHRpZih2YWx1ZSA8IG1pbikge1xyXG5cdFx0XHRcdHJldHVybiBtYXg7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodmFsdWUgPiBtYXgpIHtcclxuXHRcdFx0XHRyZXR1cm4gbWluO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWUpKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gZ2V0VGltZSgpIHtcclxuXHRcdHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gZWFzZUluT3V0KGspIHtpZigoayAqPSAyKSA8IDEpIHtyZXR1cm4gMC41ICogayAqIGsgKiBrO30gcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7fVxyXG5cdGZ1bmN0aW9uIGVhc2VPdXQoaykge3JldHVybiAtLWsgKiBrICogayArIDE7fVxyXG5cdGZ1bmN0aW9uIGRldGVjdFRyYW5zZm9ybSh2YWx1ZSkge1xyXG5cdFx0dmFyIHRyYW5zZm9ybXMgPSB7XHJcblx0XHRcdCd3ZWJraXRUcmFuc2Zvcm0nOictd2Via2l0LXRyYW5zZm9ybScsXHJcblx0XHRcdCdPVHJhbnNmb3JtJzonLW8tdHJhbnNmb3JtJyxcclxuXHRcdFx0J21zVHJhbnNmb3JtJzonLW1zLXRyYW5zZm9ybScsXHJcblx0XHRcdCdNb3pUcmFuc2Zvcm0nOictbW96LXRyYW5zZm9ybScsXHJcblx0XHRcdCd0cmFuc2Zvcm0nOid0cmFuc2Zvcm0nXHJcblx0XHR9O1xyXG5cdFx0dmFyIHRlc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XHJcblx0XHRkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZSh0ZXN0LCBudWxsKTtcclxuXHRcdGZvcih2YXIgbmFtZSBpbiB0cmFuc2Zvcm1zKSB7XHJcblx0XHRcdGlmKHRlc3Quc3R5bGVbbmFtZV0gIT09IHVuZGVmaW5lZCApe1xyXG5cdFx0XHRcdHRlc3Quc3R5bGVbbmFtZV0gPSB2YWx1ZTtcclxuXHRcdFx0XHR2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0ZXN0KS5nZXRQcm9wZXJ0eVZhbHVlKHRyYW5zZm9ybXNbbmFtZV0pO1xyXG5cdFx0XHRcdGlmKHN0eWxlICE9PSB1bmRlZmluZWQgJiYgc3R5bGUubGVuZ3RoID4gMCAmJiBzdHlsZSAhPT0gXCJub25lXCIpIHtcclxuXHRcdFx0XHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVzdCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmFtZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVzdCk7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0dmFyIFJFU1RfRVBTSUxPTiA9IDAuMDE7XHJcblx0dmFyIGFjdGl2ZVNjcm9sbGVyO1xyXG5cdHZhciByZXF1ZXN0RnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24oY2FsbGJhY2spIHt3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe2NhbGxiYWNrKCk7fSwgMTAwMCAvIDYwKTt9O1xyXG5cdHZhciB0cmFuc2xhdGU7XHJcblx0dmFyIHRyYW5zbGF0ZU5hbWUgPSBkZXRlY3RUcmFuc2Zvcm0oXCJ0cmFuc2xhdGUzZCgxcHgsMXB4LDFweClcIik7XHJcblx0aWYodHJhbnNsYXRlTmFtZSkge1xyXG5cdFx0dHJhbnNsYXRlID0gZnVuY3Rpb24obm9kZSwgeCwgeSkge1xyXG5cdFx0XHRpZiAoIW5vZGUpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vZGUuc3R5bGVbdHJhbnNsYXRlTmFtZV0gPSBcInRyYW5zbGF0ZTNkKFwiK3grXCJweCxcIit5K1wicHgsMClcIjtcclxuXHRcdH07XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0dHJhbnNsYXRlID0gZnVuY3Rpb24obm9kZSwgeCwgeSkge1xyXG5cdFx0XHRub2RlLnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xyXG5cdFx0XHRub2RlLnN0eWxlLnRvcCA9IHkgKyBcInB4XCI7XHJcblx0XHR9O1xyXG5cdH1cclxuXHRmdW5jdGlvbiBTY3JvbGxlcihub2RlLCBkZWxlZ2F0ZSkge1xyXG5cdFx0aWYobm9kZSkge1xyXG5cdFx0XHRpZihub2RlLmdldCkge1xyXG5cdFx0XHRcdG5vZGUgPSBub2RlLmdldCgwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLm5vZGUgPSBub2RlO1xyXG5cdFx0XHR0aGlzLmNvbnRlbnROb2RlID0gZmlyc3RDaGlsZChub2RlKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMubm9kZS50YWJJbmRleCA8IDApIHtcclxuXHRcdFx0dGhpcy5ub2RlLnRhYkluZGV4ID0gMDtcclxuXHRcdFx0dGhpcy5ub2RlLnN0eWxlLm91dGxpbmUgPSBcIjBcIjtcclxuXHRcdH1cclxuXHRcdHRoaXMubm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcclxuXHRcdHRoaXMubm9kZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcblx0XHR0aGlzLm5vZGUuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XHJcblxyXG5cdFx0aWYoIXRoaXMuY29udGVudE5vZGUpIHtcclxuXHRcdFx0dGhpcy5jb250ZW50Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblx0XHRcdHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnROb2RlKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuY29udGVudE5vZGUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcblxyXG5cdFx0dGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG5cclxuXHRcdHRoaXMuZWxhc3RpY2l0eSA9IDg7XHJcblx0XHR0aGlzLmZyaWN0aW9uID0gMC45NDsvL1ZlbG9jaXR5IGRhbXAgYWZ0ZXIgZHJhZy5cclxuXHRcdHRoaXMucGFnaW5nID0gZmFsc2U7Ly9TbmFwLlxyXG5cclxuXHRcdHRoaXMudmFsaWRhdGluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5kaXNhYmxlID0gZmFsc2U7XHJcblx0XHR0aGlzLmRyYWdUaW1lID0gMDtcclxuXHRcdHRoaXMuZGVjZWxlcmF0aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5hbmltYXRpbmdUaW1lID0gMDtcclxuXHRcdHRoaXMuYW5pbWF0aW5nRHVyYXRpb24gPSAxMDAwO1xyXG5cclxuXHRcdHRoaXMuZGlyZWN0ZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMubGFzdERlbHRhID0gMDtcclxuXHRcdHRoaXMuYXV0b0NvbnRlbnRTaXplID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2FsID0gbmV3IFNjcm9sbEF4aXMoKTtcclxuXHRcdHRoaXMuaG9yaXpvbnRhbCA9IG5ldyBTY3JvbGxBeGlzKCk7XHJcblxyXG5cdFx0dGhpcy5kcmFnID0gbmV3IERyYWcodGhpcy5jb250ZW50Tm9kZSwgdGhpcyk7XHJcblx0XHR0aGlzLndoZWVsID0gbmV3IFdoZWVsKHRoaXMubm9kZSwgdGhpcyk7XHJcblx0XHR0aGlzLmtleXN0cm9rZSA9IG5ldyBLZXlzdHJva2UodGhpcy5ub2RlLCB0aGlzKTtcclxuXHJcblx0XHR0cmFuc2xhdGUodGhpcy5jb250ZW50Tm9kZSwgMCwgMCk7XHJcblx0XHR0aGlzLmxheW91dCgpO1xyXG5cdH1cclxuXHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmRpc2FibGUgPSBmYWxzZTtcclxuXHRcdHRoaXMudmFsaWRhdGUoKTtcclxuXHR9O1xyXG5cclxuXHRTY3JvbGxlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmRpc2FibGUgPSB0cnVlO1xyXG5cdH07XHJcblxyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmRyYWcuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy53aGVlbC5kaXNwb3NlKCk7XHJcblx0XHRpZih0aGlzLnRyYWNrYmFyKSB7XHJcblx0XHRcdHRoaXMudHJhY2tiYXIuZGlzcG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5ub2RlID0gbnVsbDtcclxuXHRcdHRoaXMuY29udGVudE5vZGUgPSBudWxsO1xyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLnNldFRyYWNrYmFyVmlzaWJsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHRpZih2YWx1ZSAmJiAhdGhpcy50cmFja2Jhcikge1xyXG5cdFx0XHR0aGlzLnRyYWNrYmFyID0gbmV3IFRyYWNrYmFyKHRoaXMpO1xyXG5cdFx0XHR0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy50cmFja2Jhci5ub2RlKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoIXZhbHVlICYmIHRoaXMudHJhY2tiYXIpIHtcclxuXHRcdFx0dGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMudHJhY2tiYXIubm9kZSk7XHJcblx0XHRcdHRoaXMudHJhY2tiYXIuZGlzcG9zZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLmdldENvbnRlbnRPZmZzZXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7eDp0aGlzLmhvcml6b250YWwuY29udGVudE9mZnNldCwgeTp0aGlzLnZlcnRpY2FsLmNvbnRlbnRPZmZzZXR9O1xyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihleHRyYU1hcmdpbikge1xyXG5cdFx0dGhpcy5sYXlvdXQoKTtcclxuXHRcdHRoaXMuc2V0Q29udGVudFNpemUodGhpcy5jb250ZW50Tm9kZS5vZmZzZXRXaWR0aCwgdGhpcy5jb250ZW50Tm9kZS5vZmZzZXRIZWlnaHQgKyBleHRyYU1hcmdpbik7XHJcblx0XHQvL3RoaXMuc2V0Q29udGVudE9mZnNldCgwLCAwKTtcclxuXHR9O1xyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3LCBoLCBleHRyYU1hcmdpbikge1xyXG5cdFx0ZXh0cmFNYXJnaW4gPSBleHRyYU1hcmdpbiB8fCAwO1xyXG5cdFx0dmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnROb2RlO1xyXG5cdFx0Y29udGVudC5wYXJlbnROb2RlLnN0eWxlLndpZHRoID0gdyArICdweCc7XHJcblx0XHRjb250ZW50LnBhcmVudE5vZGUuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XHJcblx0XHR0aGlzLnJlZnJlc2goZXh0cmFNYXJnaW4pO1xyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLnNldENvbnRlbnRPZmZzZXQgPSBmdW5jdGlvbih4LCB5LCBkdXJhdGlvbikge1xyXG5cdFx0dGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5kZWNlbGVyYXRpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMuYW5pbWF0aW5nID0gIWlzTmFOKGR1cmF0aW9uKTtcclxuXHRcdGlmKHRoaXMuYW5pbWF0aW5nKSB7XHJcblx0XHRcdHRoaXMudXBkYXRlQm91bmRzKCk7XHJcblx0XHRcdHRoaXMuaG9yaXpvbnRhbC5iZWdpbkFuaW1hdGUoeCk7XHJcblx0XHRcdHRoaXMudmVydGljYWwuYmVnaW5BbmltYXRlKHkpO1xyXG5cdFx0XHR0aGlzLmFuaW1hdGluZyA9IHRydWU7XHJcblx0XHRcdHRoaXMuYW5pbWF0aW5nVGltZSA9IGdldFRpbWUoKTtcclxuXHRcdFx0dGhpcy5hbmltYXRpbmdEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuaG9yaXpvbnRhbC5jb250ZW50T2Zmc2V0ID0geDtcclxuXHRcdFx0dGhpcy52ZXJ0aWNhbC5jb250ZW50T2Zmc2V0ID0geTtcclxuXHRcdH1cclxuXHRcdHRoaXMuaW52YWxpZGF0ZSgpO1xyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLmdldENvbnRlbnRTaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4ge3dpZHRoOnRoaXMuaG9yaXpvbnRhbC5jb250ZW50TGVuZ3RoLCBoZWlnaHQ6dGhpcy52ZXJ0aWNhbC5jb250ZW50TGVuZ3RofTtcclxuXHR9O1xyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5zZXRDb250ZW50U2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuXHRcdHRoaXMuaG9yaXpvbnRhbC5jb250ZW50TGVuZ3RoID0gd2lkdGg7XHJcblx0XHR0aGlzLnZlcnRpY2FsLmNvbnRlbnRMZW5ndGggPSBoZWlnaHQ7XHJcblx0XHR0aGlzLmF1dG9Db250ZW50U2l6ZSA9IGZhbHNlO1xyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLnNldEF1dG9Db250ZW50U2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5hdXRvQ29udGVudFNpemUgPSB0cnVlO1xyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLm51ZGdlSG9yaXpvbnRhbCA9IGZ1bmN0aW9uKGFtb3VudCkge1xyXG5cdFx0aWYodGhpcy5wYWdpbmcpIHtcclxuXHRcdFx0dmFyIHBhZ2VkT2Zmc2V0ID0gdGhpcy5ob3Jpem9udGFsLmdldFBhZ2VkT2Zmc2V0KGFtb3VudCwgdHJ1ZSk7XHJcblx0XHRcdGlmKCF0aGlzLmFuaW1hdGluZyB8fCB0aGlzLmhvcml6b250YWwuYW5pbWF0ZUZyb20gKyB0aGlzLmhvcml6b250YWwuYW5pbWF0ZURlbHRhICE9IHBhZ2VkT2Zmc2V0KSB7XHJcblx0XHRcdFx0dGhpcy5zZXRDb250ZW50T2Zmc2V0KHBhZ2VkT2Zmc2V0LCB0aGlzLnZlcnRpY2FsLmNvbnRlbnRPZmZzZXQsIHRoaXMuc3BlZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmRlY2VsZXJhdGluZyA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmhvcml6b250YWwuY29udGVudE9mZnNldCArPSBhbW91bnQ7XHJcblx0XHRcdHRoaXMuaW52YWxpZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLm51ZGdlVmVydGljYWwgPSBmdW5jdGlvbihhbW91bnQpIHtcclxuXHJcblx0XHRpZih0aGlzLnBhZ2luZykge1xyXG5cdFx0XHR2YXIgcGFnZWRPZmZzZXQgPSB0aGlzLnZlcnRpY2FsLmdldFBhZ2VkT2Zmc2V0KGFtb3VudCwgdHJ1ZSk7XHJcblx0XHRcdGlmKCF0aGlzLmFuaW1hdGluZyB8fCB0aGlzLnZlcnRpY2FsLmFuaW1hdGVGcm9tICsgdGhpcy52ZXJ0aWNhbC5hbmltYXRlRGVsdGEgIT0gcGFnZWRPZmZzZXQpIHtcclxuXHRcdFx0XHR0aGlzLnNldENvbnRlbnRPZmZzZXQodGhpcy5ob3Jpem9udGFsLmNvbnRlbnRPZmZzZXQsIHBhZ2VkT2Zmc2V0LCB0aGlzLnNwZWVkKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5kZWNlbGVyYXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy52ZXJ0aWNhbC5jb250ZW50T2Zmc2V0ICs9IGFtb3VudDtcclxuXHRcdFx0dGhpcy5pbnZhbGlkYXRlKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRTY3JvbGxlci5wcm90b3R5cGUua2V5c3Ryb2tlRGlkU3RhcnQgPSBmdW5jdGlvbihrZXlzdHJva2UpIHtcclxuXHJcblx0XHRpZihrZXlzdHJva2Uua2V5ID09IDQwICYmIHRoaXMudmVydGljYWwuZ2V0U2Nyb2xsYWJsZSgpKSB7XHJcblx0XHRcdGtleXN0cm9rZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHR0aGlzLm51ZGdlVmVydGljYWwoMjApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZihrZXlzdHJva2Uua2V5ID09IDM4ICYmIHRoaXMudmVydGljYWwuZ2V0U2Nyb2xsYWJsZSgpKSB7XHJcblx0XHRcdGtleXN0cm9rZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHR0aGlzLm51ZGdlVmVydGljYWwoLTIwKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYoa2V5c3Ryb2tlLmtleSA9PSAzNyAmJiB0aGlzLmhvcml6b250YWwuZ2V0U2Nyb2xsYWJsZSgpKSB7XHJcblx0XHRcdGtleXN0cm9rZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHR0aGlzLm51ZGdlSG9yaXpvbnRhbCgtMjApO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZihrZXlzdHJva2Uua2V5ID09IDM5ICYmIHRoaXMuaG9yaXpvbnRhbC5nZXRTY3JvbGxhYmxlKCkpIHtcclxuXHRcdFx0a2V5c3Ryb2tlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdHRoaXMubnVkZ2VIb3Jpem9udGFsKDIwKTtcclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHRTY3JvbGxlci5wcm90b3R5cGUudHJhY2tiYXJEaWRNb3ZlID0gZnVuY3Rpb24odHJhY2tiYXIpIHtcclxuXHRcdHRoaXMuc2V0Q29udGVudE9mZnNldCgwLCB0cmFja2Jhci5wb3NpdGlvbiAqICh0aGlzLnZlcnRpY2FsLmNvbnRlbnRMZW5ndGggLSB0aGlzLnZlcnRpY2FsLnBhcmVudExlbmd0aCkpO1xyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLndoZWVsRGlkTW92ZSA9IGZ1bmN0aW9uKGdlc3R1cmUpIHtcclxuXHRcdHRoaXMudXBkYXRlQm91bmRzKCk7XHJcblx0XHRpZighdGhpcy52ZXJ0aWNhbC5nZXRTY3JvbGxhYmxlKCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdGdlc3R1cmUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0aWYodGhpcy5wYWdpbmcpIHtcclxuXHJcblx0XHRcdC8vTWFjIG1vdXNlIHdoZWVsIGZpeFxyXG5cdFx0XHQvLyB2YXIgd1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHRcdFx0Ly8gdHJhY2UoJ3dEZWx0YScsICh3VGltZSAtIHdpbmRvdy5sYXN0V1RpbWUpKTtcclxuXHRcdFx0Ly8gd2luZG93Lmxhc3RXVGltZSA9IHdUaW1lO1xyXG5cdFx0XHQvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjYzMjY5NTgvc3RvcHBpbmctbW91c2V3aGVlbC1ldmVudC1mcm9tLWhhcHBlbmluZy10d2ljZS1pbi1vc3hcclxuXHRcdFx0Ly9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU1Mjc2MDEvbm9ybWFsaXppbmctbW91c2V3aGVlbC1zcGVlZC1hY3Jvc3MtYnJvd3NlcnNcclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhnZXN0dXJlLmRlbHRhKTtcclxuXHJcblx0XHRcdGlmIChNYXRoLmFicyhnZXN0dXJlLmRlbHRhKSA8IDExOSkgcmV0dXJuO1xyXG5cclxuXHRcdFx0dmFyIHBhZ2VkT2Zmc2V0ID0gdGhpcy52ZXJ0aWNhbC5nZXRQYWdlZE9mZnNldChjbGlwKC0xLCAxLCAtZ2VzdHVyZS5kZWx0YSkpO1xyXG5cdFx0XHRpZighdGhpcy5hbmltYXRpbmcgfHwgdGhpcy52ZXJ0aWNhbC5hbmltYXRlRnJvbSArIHRoaXMudmVydGljYWwuYW5pbWF0ZURlbHRhICE9IHBhZ2VkT2Zmc2V0KSB7XHJcblx0XHRcdFx0dGhpcy5zZXRDb250ZW50T2Zmc2V0KHRoaXMuaG9yaXpvbnRhbC5jb250ZW50T2Zmc2V0LCBwYWdlZE9mZnNldCwgdGhpcy5zcGVlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZGVjZWxlcmF0aW5nID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XHJcblx0XHRcdHRoaXMudmVydGljYWwuY29udGVudE9mZnNldCAtPSBnZXN0dXJlLmRlbHRhICogMC4yO1xyXG5cdFx0XHR0aGlzLmludmFsaWRhdGUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5kcmFnRGlkU3RhcnQgPSBmdW5jdGlvbihnZXN0dXJlKSB7XHJcblxyXG5cdFx0aWYodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uU2Nyb2xsU3RhcnQpIHtcclxuXHRcdFx0dGhpcy5kZWxlZ2F0ZS5vblNjcm9sbFN0YXJ0KHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubm9kZS5mb2N1cygpO1xyXG5cdFx0dGhpcy51cGRhdGVCb3VuZHMoKTtcclxuXHJcblx0XHRnZXN0dXJlLm9mZnNldC54ICs9IHRoaXMuaG9yaXpvbnRhbC5jb250ZW50T2Zmc2V0O1xyXG5cdFx0Z2VzdHVyZS5vZmZzZXQueSArPSB0aGlzLnZlcnRpY2FsLmNvbnRlbnRPZmZzZXQ7XHJcblx0XHRnZXN0dXJlLnVwZGF0ZVRyYW5zbGF0aW9uKCk7XHJcblxyXG5cdFx0dGhpcy5ob3Jpem9udGFsLmRyYWdPZmZzZXQgPSAtZ2VzdHVyZS50cmFuc2xhdGlvbi54O1xyXG5cdFx0dGhpcy5ob3Jpem9udGFsLnZlbG9jaXR5ID0gMDtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2FsLmRyYWdPZmZzZXQgPSAtZ2VzdHVyZS50cmFuc2xhdGlvbi55O1xyXG5cdFx0dGhpcy52ZXJ0aWNhbC52ZWxvY2l0eSA9IDA7XHJcblxyXG5cdFx0dGhpcy5kcmFnVGltZSA9IGdldFRpbWUoKTtcclxuXHJcblx0XHR0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcclxuXHRcdHRoaXMuZGVjZWxlcmF0aW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5kaXJlY3RlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGFjdGl2ZVNjcm9sbGVyID0gbnVsbDtcclxuXHR9O1xyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5kcmFnRGlkTW92ZSA9IGZ1bmN0aW9uKGdlc3R1cmUpIHtcclxuXHRcdHZhciB2ZWxvY2l0eVggPSAtZ2VzdHVyZS50cmFuc2xhdGlvbi54IC0gdGhpcy5ob3Jpem9udGFsLmRyYWdPZmZzZXQ7XHJcblx0XHR2YXIgdmVsb2NpdHlZID0gLWdlc3R1cmUudHJhbnNsYXRpb24ueSAtIHRoaXMudmVydGljYWwuZHJhZ09mZnNldDtcclxuXHJcblx0XHRpZighYWN0aXZlU2Nyb2xsZXIpIHtcclxuXHRcdFx0dmFyIGhvcml6b250YWxNb3ZlID0gTWF0aC5hYnModmVsb2NpdHlYKSA+IE1hdGguYWJzKHZlbG9jaXR5WSk7XHJcblx0XHRcdGlmKChob3Jpem9udGFsTW92ZSAmJiB0aGlzLmhvcml6b250YWwuZ2V0U2Nyb2xsYWJsZSgpKSB8fCAoIWhvcml6b250YWxNb3ZlICYmIHRoaXMudmVydGljYWwuZ2V0U2Nyb2xsYWJsZSgpKSkge1xyXG5cdFx0XHRcdGFjdGl2ZVNjcm9sbGVyID0gdGhpcztcclxuXHRcdFx0XHR0aGlzLmRpcmVjdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR0aGlzLmludmFsaWRhdGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZihhY3RpdmVTY3JvbGxlciAhPSB0aGlzKSB7XHJcblx0XHRcdGdlc3R1cmUuY2FuY2VsKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0aGlzLmRpcmVjdGVkKSB7XHJcblx0XHRcdGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmhvcml6b250YWwudmVsb2NpdHkgPSB2ZWxvY2l0eVg7XHJcblx0XHR0aGlzLmhvcml6b250YWwuZHJhZ09mZnNldCA9IC1nZXN0dXJlLnRyYW5zbGF0aW9uLng7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNhbC52ZWxvY2l0eSA9IHZlbG9jaXR5WTtcclxuXHRcdHRoaXMudmVydGljYWwuZHJhZ09mZnNldCA9IC1nZXN0dXJlLnRyYW5zbGF0aW9uLnk7XHJcblxyXG5cdFx0dGhpcy5kcmFnVGltZSA9IGdldFRpbWUoKTtcclxuXHR9O1xyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5kcmFnRGlkU3RvcCA9IGZ1bmN0aW9uKGdlc3R1cmUpIHtcclxuXHJcblx0XHRpZih0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25EcmFnRW5kKSB7XHJcblx0XHRcdHRoaXMuZGVsZWdhdGUub25EcmFnRW5kKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0aW1lID0gZ2V0VGltZSgpO1xyXG5cdFx0aWYodGltZSAtIHRoaXMuZHJhZ1RpbWUgPiAxMDApIHtcclxuXHRcdFx0dGhpcy5ob3Jpem9udGFsLnZlbG9jaXR5ID0gMDtcclxuXHRcdFx0dGhpcy52ZXJ0aWNhbC52ZWxvY2l0eSA9IDA7XHJcblx0XHR9XHJcblx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcblx0XHRpZih0aGlzLnBhZ2luZykge1xyXG5cdFx0XHR0aGlzLnNldENvbnRlbnRPZmZzZXQodGhpcy5ob3Jpem9udGFsLmdldFBhZ2VkT2Zmc2V0KHRoaXMuaG9yaXpvbnRhbC52ZWxvY2l0eSksIHRoaXMudmVydGljYWwuZ2V0UGFnZWRPZmZzZXQodGhpcy52ZXJ0aWNhbC52ZWxvY2l0eSksIHRoaXMuc3BlZWQpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdHRoaXMuZGVjZWxlcmF0aW5nID0gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uKGdlc3R1cmUpIHtcclxuXHRcdGlmKHRoaXMuZGlyZWN0ZWQpIHtcclxuXHRcdFx0Z2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRnZXN0dXJlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5pbnZhbGlkYXRlKCk7XHJcblx0XHR0aGlzLm5lZWRzTGF5b3V0ID0gdHJ1ZTtcclxuXHR9O1xyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZighdGhpcy52YWxpZGF0aW5nKSB7XHJcblx0XHRcdHRoaXMudmFsaWRhdGluZyA9IHRydWU7XHJcblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblx0XHRcdHJlcXVlc3RGcmFtZShmdW5jdGlvbigpe3Njb3BlLnZhbGlkYXRlKCk7fSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRTY3JvbGxlci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZiAodGhpcy5kaXNhYmxlKSByZXR1cm47XHJcblxyXG5cdFx0aWYodGhpcy5uZWVkc0xheW91dCkge1xyXG5cdFx0XHR0aGlzLnVwZGF0ZUJvdW5kcygpO1xyXG5cdFx0XHR0aGlzLm5lZWRzTGF5b3V0ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHR0aGlzLnJlc29sdmUoKTtcclxuXHRcdGlmKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5zY3JvbGxlckRpZFNjcm9sbCkge1xyXG5cdFx0XHR0aGlzLmRlbGVnYXRlLnNjcm9sbGVyRGlkU2Nyb2xsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0aWYoIXRoaXMuZHJhZ2dpbmcgJiYgIXRoaXMuZGVjZWxlcmF0aW5nICYmICF0aGlzLmFuaW1hdGluZykge1xyXG5cdFx0XHR0aGlzLnZhbGlkYXRpbmcgPSBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLnZhbGlkYXRpbmcgPSB0cnVlO1xyXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0XHRyZXF1ZXN0RnJhbWUoZnVuY3Rpb24oKXtzY29wZS52YWxpZGF0ZSgpO30pO1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cdFNjcm9sbGVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZih0aGlzLmRyYWdnaW5nKSB7XHJcblx0XHRcdHRoaXMuaG9yaXpvbnRhbC5kcmFnKCk7XHJcblx0XHRcdHRoaXMudmVydGljYWwuZHJhZygpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZih0aGlzLmFuaW1hdGluZykge1xyXG5cdFx0XHR2YXIgdCA9IChnZXRUaW1lKCkgLSB0aGlzLmFuaW1hdGluZ1RpbWUpIC8gdGhpcy5hbmltYXRpbmdEdXJhdGlvbjtcclxuXHRcdFx0aWYodCA+IDEpIHtcclxuXHRcdFx0XHR0ID0gMTtcclxuXHRcdFx0XHR0aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHQgPSBlYXNlT3V0KHQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuaG9yaXpvbnRhbC5hbmltYXRlKHQpO1xyXG5cdFx0XHR0aGlzLnZlcnRpY2FsLmFuaW1hdGUodCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKHRoaXMuZGVjZWxlcmF0aW5nKSB7XHJcblx0XHRcdHRoaXMuZGVjZWxlcmF0aW5nID0gdGhpcy5ob3Jpem9udGFsLmRlY2VsZXJhdGUodGhpcy5mcmljdGlvbiwgdGhpcy5lbGFzdGljaXR5KSArIHRoaXMudmVydGljYWwuZGVjZWxlcmF0ZSh0aGlzLmZyaWN0aW9uLCB0aGlzLmVsYXN0aWNpdHkpID4gMDtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0aGlzLmhvcml6b250YWwuY29uc3RyYWluKCk7XHJcblx0XHRcdHRoaXMudmVydGljYWwuY29uc3RyYWluKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dHJhbnNsYXRlKHRoaXMuY29udGVudE5vZGUsIC10aGlzLmhvcml6b250YWwuY29udGVudE9mZnNldCwgLXRoaXMudmVydGljYWwuY29udGVudE9mZnNldCk7XHJcblxyXG5cdFx0aWYodGhpcy50cmFja2Jhcikge1xyXG5cdFx0XHR0aGlzLnRyYWNrYmFyLnNldFBvc2l0aW9uKHRoaXMudmVydGljYWwuY29udGVudE9mZnNldCAvICh0aGlzLnZlcnRpY2FsLmNvbnRlbnRMZW5ndGggLSB0aGlzLnZlcnRpY2FsLnBhcmVudExlbmd0aCkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKCF0aGlzLm5vZGUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5ob3Jpem9udGFsLnBhcmVudExlbmd0aCA9IHRoaXMubm9kZS5vZmZzZXRXaWR0aDtcclxuXHRcdHRoaXMudmVydGljYWwucGFyZW50TGVuZ3RoID0gdGhpcy5ub2RlLm9mZnNldEhlaWdodDtcclxuXHRcdGlmKHRoaXMuYXV0b0NvbnRlbnRTaXplKSB7XHJcblx0XHRcdHRoaXMuaG9yaXpvbnRhbC5jb250ZW50TGVuZ3RoID0gdGhpcy5jb250ZW50Tm9kZS5vZmZzZXRXaWR0aDtcclxuXHRcdFx0dGhpcy52ZXJ0aWNhbC5jb250ZW50TGVuZ3RoID0gdGhpcy5jb250ZW50Tm9kZS5vZmZzZXRIZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoXCJtc1RvdWNoQWN0aW9uXCIgaW4gdGhpcy5ub2RlLnN0eWxlKSB7XHJcblx0XHRcdGlmKHRoaXMudmVydGljYWwuY29udGVudExlbmd0aCA+IHRoaXMudmVydGljYWwucGFyZW50TGVuZ3RoICYmIHRoaXMuaG9yaXpvbnRhbC5jb250ZW50TGVuZ3RoID4gdGhpcy5ob3Jpem9udGFsLnBhcmVudExlbmd0aCkge1xyXG5cdFx0XHRcdHRoaXMubm9kZS5zdHlsZS5tc1RvdWNoQWN0aW9uID0gXCJub25lXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZih0aGlzLmhvcml6b250YWwuY29udGVudExlbmd0aCA+IHRoaXMuaG9yaXpvbnRhbC5wYXJlbnRMZW5ndGgpIHtcclxuXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwicGFuLXlcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmKHRoaXMudmVydGljYWwuY29udGVudExlbmd0aCA+IHRoaXMudmVydGljYWwucGFyZW50TGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcInBhbi14XCI7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcImF1dG9cIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMudHJhY2tiYXIpIHtcclxuXHRcdFx0aWYodGhpcy52ZXJ0aWNhbC5jb250ZW50TGVuZ3RoID4gdGhpcy52ZXJ0aWNhbC5wYXJlbnRMZW5ndGgpIHtcclxuXHRcdFx0XHR0aGlzLnRyYWNrYmFyLm5vZGUuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XHJcblx0XHRcdFx0dGhpcy50cmFja2Jhci5zZXRMZW5ndGgodGhpcy52ZXJ0aWNhbC5wYXJlbnRMZW5ndGgsIHRoaXMudmVydGljYWwucGFyZW50TGVuZ3RoIC8gdGhpcy52ZXJ0aWNhbC5jb250ZW50TGVuZ3RoKTtcclxuXHRcdFx0XHR0aGlzLnRyYWNrYmFyLmFsaWduKHRoaXMuaG9yaXpvbnRhbC5wYXJlbnRMZW5ndGgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMudHJhY2tiYXIubm9kZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0U2Nyb2xsZXIucHJvdG90eXBlLnNwZWVkID0gNDAwO1xyXG5cclxuXHRmdW5jdGlvbiBTY3JvbGxBeGlzKCkge1xyXG5cdFx0dGhpcy52ZWxvY2l0eSA9IDA7XHJcblx0XHR0aGlzLnBhcmVudExlbmd0aCA9IDA7XHJcblx0XHR0aGlzLmNvbnRlbnRMZW5ndGggPSAwO1xyXG5cdFx0dGhpcy5jb250ZW50T2Zmc2V0ID0gMDtcclxuXHRcdHRoaXMuZHJhZ09mZnNldCA9IDA7XHJcblx0XHR0aGlzLmFuaW1hdGVGcm9tID0gMDtcclxuXHRcdHRoaXMuYW5pbWF0ZURlbHRhID0gMDtcclxuXHR9XHJcblx0U2Nyb2xsQXhpcy5wcm90b3R5cGUuZ2V0U2Nyb2xsYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udGVudExlbmd0aCAtIHRoaXMucGFyZW50TGVuZ3RoID4gMDtcclxuXHR9O1xyXG5cdFNjcm9sbEF4aXMucHJvdG90eXBlLmdldFBhZ2VkT2Zmc2V0ID0gZnVuY3Rpb24oZGlyZWN0aW9uLCB3cmFwKSB7XHJcblx0XHR2YXIgbWluID0gMDtcclxuXHRcdHZhciBtYXggPSBNYXRoLm1heCgwLCB0aGlzLmNvbnRlbnRMZW5ndGggLSB0aGlzLnBhcmVudExlbmd0aCk7XHJcblx0XHRpZihkaXJlY3Rpb24gPCAwKSB7XHJcblx0XHRcdHJldHVybiBjbGlwKG1pbiwgbWF4LCBNYXRoLmZsb29yKCh0aGlzLmNvbnRlbnRPZmZzZXQgKyBkaXJlY3Rpb24pIC8gdGhpcy5wYXJlbnRMZW5ndGgpICogdGhpcy5wYXJlbnRMZW5ndGgsIHdyYXApO1xyXG5cdFx0fVxyXG5cdFx0aWYoZGlyZWN0aW9uID4gMCkge1xyXG5cdFx0XHRyZXR1cm4gY2xpcChtaW4sIG1heCwgTWF0aC5jZWlsKCh0aGlzLmNvbnRlbnRPZmZzZXQgKyBkaXJlY3Rpb24pIC8gdGhpcy5wYXJlbnRMZW5ndGgpICogdGhpcy5wYXJlbnRMZW5ndGgsIHdyYXApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNsaXAobWluLCBtYXgsIE1hdGgucm91bmQodGhpcy5jb250ZW50T2Zmc2V0IC8gdGhpcy5wYXJlbnRMZW5ndGgpICogdGhpcy5wYXJlbnRMZW5ndGgsIHdyYXApO1xyXG5cdH07XHJcblx0U2Nyb2xsQXhpcy5wcm90b3R5cGUuZHJhZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1pbiA9IDA7XHJcblx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoMCwgdGhpcy5jb250ZW50TGVuZ3RoIC0gdGhpcy5wYXJlbnRMZW5ndGgpO1xyXG5cdFx0dGhpcy5jb250ZW50T2Zmc2V0ID0gdGhpcy5kcmFnT2Zmc2V0O1xyXG5cclxuXHRcdGlmKHRoaXMuY29udGVudE9mZnNldCA8IG1pbikge1xyXG5cdFx0XHRpZihtYXggPT09IG1pbikge1xyXG5cdFx0XHRcdHRoaXMuY29udGVudE9mZnNldCA9IG1pbjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmNvbnRlbnRPZmZzZXQgKz0gKG1pbiAtIHRoaXMuY29udGVudE9mZnNldCkgLyAxLjU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgaWYodGhpcy5jb250ZW50T2Zmc2V0ID4gbWF4KSB7XHJcblx0XHRcdGlmKG1heCA9PT0gbWluKSB7XHJcblx0XHRcdFx0dGhpcy5jb250ZW50T2Zmc2V0ID0gbWF4O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuY29udGVudE9mZnNldCArPSAobWF4IC0gdGhpcy5jb250ZW50T2Zmc2V0KSAvIDEuNTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0U2Nyb2xsQXhpcy5wcm90b3R5cGUuYmVnaW5BbmltYXRlID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdGlmIChpc05hTih0aGlzLmNvbnRlbnRPZmZzZXQpKSByZXR1cm47XHJcblx0XHR0aGlzLmFuaW1hdGVGcm9tID0gdGhpcy5jb250ZW50T2Zmc2V0O1xyXG5cdFx0dGhpcy5hbmltYXRlRGVsdGEgPSB2YWx1ZSAtIHRoaXMuY29udGVudE9mZnNldDtcclxuXHR9O1xyXG5cdFNjcm9sbEF4aXMucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbih0KSB7XHJcblx0XHR0aGlzLmNvbnRlbnRPZmZzZXQgPSB0aGlzLmFuaW1hdGVGcm9tICsgdGhpcy5hbmltYXRlRGVsdGEgKiB0O1xyXG5cdH07XHJcblx0U2Nyb2xsQXhpcy5wcm90b3R5cGUuZGVjZWxlcmF0ZSA9IGZ1bmN0aW9uKGZyaWN0aW9uLCBlbGFzdGljaXR5KSB7XHJcblx0XHR2YXIgbWluID0gMDtcclxuXHRcdHZhciBtYXggPSBNYXRoLm1heCgwLCB0aGlzLmNvbnRlbnRMZW5ndGggLSB0aGlzLnBhcmVudExlbmd0aCk7XHJcblx0XHR0aGlzLnZlbG9jaXR5ICo9IGZyaWN0aW9uO1xyXG5cdFx0dGhpcy5jb250ZW50T2Zmc2V0ICs9IHRoaXMudmVsb2NpdHk7XHJcblx0XHRpZih0aGlzLmNvbnRlbnRPZmZzZXQgPCBtaW4pIHtcclxuXHRcdFx0aWYobWF4ID09PSBtaW4pIHtcclxuXHRcdFx0XHR0aGlzLnZlbG9jaXR5ID0gMDtcclxuXHRcdFx0XHR0aGlzLmNvbnRlbnRPZmZzZXQgPSBtaW47XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZih0aGlzLnZlbG9jaXR5IDwgMCkge1xyXG5cdFx0XHRcdHRoaXMudmVsb2NpdHkgKz0gKG1pbiAtIHRoaXMuY29udGVudE9mZnNldCkgLyBlbGFzdGljaXR5O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMudmVsb2NpdHkgPSAobWluIC0gdGhpcy5jb250ZW50T2Zmc2V0KSAvIGVsYXN0aWNpdHk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGVsc2UgaWYodGhpcy5jb250ZW50T2Zmc2V0ID4gbWF4KSB7XHJcblx0XHRcdGlmKG1pbiA9PT0gbWF4KSB7XHJcblx0XHRcdFx0dGhpcy52ZWxvY2l0eSA9IDA7XHJcblx0XHRcdFx0dGhpcy5jb250ZW50T2Zmc2V0ID0gbWluO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYodGhpcy52ZWxvY2l0eSA+IDApIHtcclxuXHRcdFx0XHR0aGlzLnZlbG9jaXR5ICs9IChtYXggLSB0aGlzLmNvbnRlbnRPZmZzZXQpIC8gZWxhc3RpY2l0eTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnZlbG9jaXR5ID0gKG1heCAtIHRoaXMuY29udGVudE9mZnNldCkgLyBlbGFzdGljaXR5O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy52ZWxvY2l0eSkgPCBSRVNUX0VQU0lMT04gPyAwIDogMTtcclxuXHR9O1xyXG5cdFNjcm9sbEF4aXMucHJvdG90eXBlLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1heCA9IE1hdGgubWF4KDAsIHRoaXMuY29udGVudExlbmd0aCAtIHRoaXMucGFyZW50TGVuZ3RoKTtcclxuXHRcdHRoaXMuY29udGVudE9mZnNldCA9IGNsaXAoMCwgbWF4LCB0aGlzLmNvbnRlbnRPZmZzZXQpO1xyXG5cdH07XHJcblxyXG5cclxuXHRmdW5jdGlvbiBUcmFja2JhcihkZWxlZ2F0ZSkge1xyXG5cdFx0dGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG5cdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuXHRcdHRoaXMubm9kZS5jbGFzc05hbWUgPSBcIm5pYnMtdHJhY2tiYXIgbmlicy10cmFja2Jhci15XCI7XHJcblx0XHR0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcblx0XHR0aGlzLm5vZGUuc3R5bGUudG9wID0gXCIwcHhcIjtcclxuXHJcblx0XHR0aGlzLm5vZGVMZW5ndGggPSAwO1xyXG5cdFx0dGhpcy50aHVtYkxlbmd0aCA9IDUwO1xyXG5cdFx0dGhpcy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdHRoaXMudGh1bWIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cdFx0dGhpcy50aHVtYi5jbGFzc05hbWUgPSBcIm5pYnMtdHJhY2tiYXItdGh1bWIgbmlicy10cmFja2Jhci10aHVtYi15XCI7XHJcblx0XHR0aGlzLnRodW1iLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xyXG5cdFx0dGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMudGh1bWIpO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24gPSAwO1xyXG5cdFx0dGhpcy5heGlzID0gXCJ5XCI7XHJcblx0XHR0aGlzLmRyYWcgPSBuZXcgRHJhZyh0aGlzLm5vZGUsIHRoaXMpO1xyXG5cdH1cclxuXHRUcmFja2Jhci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24odmFsdWUsIHJhdGlvKSB7XHJcblx0XHR0aGlzLm5vZGVMZW5ndGggPSB2YWx1ZTtcclxuXHRcdHRoaXMudGh1bWJMZW5ndGggPSBNYXRoLm1heChNYXRoLnJvdW5kKHZhbHVlICogcmF0aW8pLCAyMCk7XHJcblxyXG5cdFx0dGhpcy5ub2RlLnN0eWxlLmhlaWdodCA9IHRoaXMubm9kZUxlbmd0aCArIFwicHhcIjtcclxuXHRcdHRoaXMudGh1bWIuc3R5bGUuaGVpZ2h0ID0gdGhpcy50aHVtYkxlbmd0aCArIFwicHhcIjtcclxuXHJcblx0XHR0aGlzLmxlbmd0aCA9IHRoaXMubm9kZUxlbmd0aCAtIHRoaXMudGh1bWIub2Zmc2V0SGVpZ2h0O1xyXG5cdH07XHJcblx0VHJhY2tiYXIucHJvdG90eXBlLmFsaWduID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdHRoaXMubm9kZS5zdHlsZS5sZWZ0ID0gKHZhbHVlIC0gdGhpcy5ub2RlLm9mZnNldFdpZHRoKSArIFwicHhcIjtcclxuXHR9O1xyXG5cdFRyYWNrYmFyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0XHR0aGlzLnBvc2l0aW9uID0gY2xpcCgwLCAxLCB2YWx1ZSk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdH07XHJcblx0VHJhY2tiYXIucHJvdG90eXBlLmRyYWdEaWRTdGFydCA9IGZ1bmN0aW9uKGdlc3R1cmUpIHtcclxuXHRcdGlmKGdlc3R1cmUudGFyZ2V0ID09IHRoaXMudGh1bWIpIHtcclxuXHRcdFx0Z2VzdHVyZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0dGhpcy5ub3RpZnkoXCJ0cmFja2JhckRpZFN0YXJ0XCIpO1xyXG5cdFx0XHRnZXN0dXJlLm9mZnNldFt0aGlzLmF4aXNdIC09IHRoaXMucG9zaXRpb24gKiB0aGlzLmxlbmd0aDtcclxuXHRcdFx0Z2VzdHVyZS51cGRhdGVUcmFuc2xhdGlvbigpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGdlc3R1cmUuY2FuY2VsKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRUcmFja2Jhci5wcm90b3R5cGUuZHJhZ0RpZE1vdmUgPSBmdW5jdGlvbihnZXN0dXJlKSB7XHJcblx0XHRnZXN0dXJlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0dGhpcy5wb3NpdGlvbiA9IGNsaXAoMCwgMSwgZ2VzdHVyZS50cmFuc2xhdGlvblt0aGlzLmF4aXNdIC8gdGhpcy5sZW5ndGgpO1xyXG5cdFx0dGhpcy5ub3RpZnkoXCJ0cmFja2JhckRpZE1vdmVcIik7XHJcblx0fTtcclxuXHRUcmFja2Jhci5wcm90b3R5cGUuZHJhZ0RpZFN0b3AgPSBmdW5jdGlvbihnZXN0dXJlKSB7XHJcblx0XHR0aGlzLm5vdGlmeShcInRyYWNrYmFyRGlkU3RvcFwiKTtcclxuXHR9O1xyXG5cdFRyYWNrYmFyLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0fTtcclxuXHRUcmFja2Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdmFsdWUgPSBNYXRoLnJvdW5kKHRoaXMucG9zaXRpb24gKiB0aGlzLmxlbmd0aCk7XHJcblx0XHRpZih0aGlzLmF4aXMgPT0gXCJ5XCIpIHtcclxuXHRcdFx0dHJhbnNsYXRlKHRoaXMudGh1bWIsIDAsIHZhbHVlKTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHR0cmFuc2xhdGUodGhpcy50aHVtYiwgdmFsdWUsIDApO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0VHJhY2tiYXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcblx0XHRpZih0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGVbc2VsZWN0b3JdKSB7XHJcblx0XHRcdHRoaXMuZGVsZWdhdGVbc2VsZWN0b3JdKHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0VHJhY2tiYXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuZHJhZy5kaXNwb3NlKCk7XHJcblx0fTtcclxuXHJcblx0dGhpcy5OSUJTLlNjcm9sbGVyID0gU2Nyb2xsZXI7XHJcblxyXG59KSh0aGlzLk5JQlMgfHwge30pO1xyXG4iXSwiZmlsZSI6InBhcmFkb3gvU2Nyb2xsZXIuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==

/**
 * Horizontal 1.0
 * DigitasLBI
 * @version 0.1
 * @author www.digitaslbi.com/se
 * @copyright DigitasLBI 2016
 */

window.requestFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) {
    window.setTimeout(function() {
        callback();
    }, 1000 / 60);
};

var NIBS = NIBS || {};
NIBS.Horizontal = function(data) {

    var that = this;
    that.data = data;
    that.speed = 1000;
    that.info = {};
    that.lastLeft = 0;
    that.doTriggerScrollEnded = true;
    that.totalWidth = 0;
    that.wrapperWidth = 0;
    that.$target = data.target;
    that.$target.css('visibility', 'visible');
    that.delegate = {
        onScrollStart: that.data.onScrollStart || that.onScrollStart,
        onDragEnd: that.data.onDragEnd || that.onDragEnd,
        scrollerDidScroll: that.data.scrollerDidScroll || that.scrollerDidScroll
    };
    that.scroller = new NIBS.Scroller(that.$target, that.delegate);
    that.refresh();
    window.requestFrame(function() {
        that.actions(that);
    });
    that.scroller.id = that.id = 'id' + that.getUniqueId();
    NIBS.Horizontal.global[that.id] = that;

    $(window).resize(function() {
        that.refresh(that.scroller);
    });

};

NIBS.Horizontal.prototype = {};

NIBS.Horizontal.global = {};

NIBS.Horizontal.prototype.getUniqueId = function() {
    var d = new Date().getTime();
    d += (parseInt(Math.random() * 100)).toString();
    return d;
};

NIBS.Horizontal.prototype.actions = function(that) {

    window.requestFrame(function() {
        that.actions(that);
    });

    var progress;
    that.info.scollLeft = that.getScollLeft();
    that.info.totalWidth = that.totalWidth;
    that.info.targetWidth = that.targetWidth;
    that.info.targetHeight = that.targetHeight;

    progress = that.getScollLeft() / (that.totalWidth - that.info.targetWidth);
    if (progress < 0) progress = 0;
    if (progress > 1) progress = 1;

    that.info.progress = progress;

    var diff = that.lastLeft - that.info.scollLeft;

    if (Math.abs(diff) < 0.018 && that.info.state !== 'stopped') {

        that.info.state = 'stopped';
        $.event.trigger({
            type: 'scrolling.ended',
            that: that,
            info: that.info
        });


    } else if (Math.abs(diff) > 0.018 && that.info.state === 'stopped') {
        that.info.state = 'scrolling';
        $.event.trigger({
            type: 'scrolling.started',
            that: that,
            info: that.info
        });
    }

    if (that.info.state === 'scrolling') {
        $.event.trigger({
            type: 'scrolling.in.action',
            that: that,
            info: that.info
        });
    }

    that.lastLeft = that.info.scollLeft;

    $.event.trigger({
        type: 'scrolling.tick',
        that: that,
        info: that.info
    });

};

NIBS.Horizontal.prototype.refresh = function(scroller) {

    var that = this;
    that.totalWidth = that.$target.find('.nibs-scroller-content').outerWidth();
    that.targetWidth = that.$target.outerWidth();
    that.targetHeight = that.$target.outerHeight();
    that.scroller.setContentSize(that.totalWidth, 0);
    that.scroller.layout();

};

NIBS.Horizontal.prototype.getScollTop = function() {

    var that = this;
    return that.scroller.vertical.contentOffset;

};

NIBS.Horizontal.prototype.getScollLeft = function() {

    var that = this;
    return that.scroller.horizontal.contentOffset;

};

NIBS.Horizontal.prototype.onScrollStart = function(scroller) {
    var that = this;
};

NIBS.Horizontal.prototype.onDragEnd = function(scroller) {
    var that = this;
};

NIBS.Horizontal.prototype.scrollerDidScroll = function(scroller) {
    var that = this;
};

NIBS.Horizontal.prototype.calcScrollTo = function(what, align) {

    var that = this,
        offsetVal,
        objWidth = 0,
        n = 0,
        $obj, position;

    align = align || 'left';

    if (!isNaN(what)) {
        n = what;
    } else if (typeof(what) === 'string') {
        $obj = that.$target.find(what);
        position = $obj.position();
        objWidth = $obj.outerWidth();
        n = position.left;
    } else if (what.position) {
        $obj = what;
        position = $obj.position();
        objWidth = $obj.outerWidth();
        n = position.left;
    }

    if (align === 'right') {
        n = n - that.targetWidth + objWidth;
    }

    offsetVal = that.totalWidth - that.targetWidth - n;
    if (offsetVal < 0) n = n + offsetVal;
    if (n < 0) n = 0;

    return n;

};

NIBS.Horizontal.prototype.scrollTo = function(what, speed, align) {

    var that = this,
        n;

    if (typeof(speed) === 'string') {
        align = speed;
        speed = that.speed;
    }

    n = that.calcScrollTo(what, align);
    that.scroller.setContentOffset(n, 0, speed);

};

NIBS.Horizontal.prototype.getAlign = function($obj) {

    var that = this,
        offset,
        pitch,
        rv,
        position;

    offset = $obj.offset();
    position = $obj.position();
    objWidth = $obj.outerWidth();

    if (position.left + objWidth / 2 < that.targetWidth / 2) {
        pitch = 'left';
    } else {
        pitch = 'right';
    }

    rv = pitch;

    var test = that.calcScrollTo($obj, pitch),
        newPitch,
        newTest;

    if (test === 0) {
        if (pitch === 'left') {
            newTest = that.calcScrollTo($obj, 'right');
            newPitch = 'right';
        }
        if (pitch === 'right') {
            newTest = that.calcScrollTo($obj, 'left');
            newPitch = 'left';
        }

        if (newTest > 0) {
            rv = newPitch;
        }
    }

    return rv;

};



NIBS.Horizontal.prototype.scrollToProgress = function(progress, speed) {

    //trace('progress', progress);

    var that = this,
        scollLeft;
    scollLeft = (that.totalWidth - that.targetWidth) * progress;
    that.scrollTo(scollLeft, speed);

};

NIBS.Horizontal.prototype.destroy = function() {

    var that = this;
    that.scroller.dispose();
    delete NIBS.Horizontal.global[that.id];

};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJwYXJhZG94L0hvcml6b250YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEhvcml6b250YWwgMS4wXHJcbiAqIERpZ2l0YXNMQklcclxuICogQHZlcnNpb24gMC4xXHJcbiAqIEBhdXRob3Igd3d3LmRpZ2l0YXNsYmkuY29tL3NlXHJcbiAqIEBjb3B5cmlnaHQgRGlnaXRhc0xCSSAyMDE2XHJcbiovXHJcblxyXG53aW5kb3cucmVxdWVzdEZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKSB7d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjYWxsYmFjaygpO30sIDEwMDAgLyA2MCk7fTtcclxuXHJcbnZhciBOSUJTID0gTklCUyB8fCB7fTtcclxuTklCUy5Ib3Jpem9udGFsID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuXHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblx0dGhhdC5kYXRhID0gZGF0YTtcclxuICAgIHRoYXQuc3BlZWQgPSAxMDAwO1xyXG4gICAgdGhhdC5pbmZvID0ge307XHJcbiAgICB0aGF0Lmxhc3RMZWZ0ID0gMDtcclxuICAgIHRoYXQuZG9UcmlnZ2VyU2Nyb2xsRW5kZWQgPSB0cnVlO1xyXG4gICAgdGhhdC50b3RhbFdpZHRoID0gMDtcclxuICAgIHRoYXQud3JhcHBlcldpZHRoID0gMDtcclxuICAgIHRoYXQuJHRhcmdldCA9IGRhdGEudGFyZ2V0O1xyXG4gICAgdGhhdC4kdGFyZ2V0LmNzcygndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XHJcbiAgICB0aGF0LmRlbGVnYXRlID0ge1xyXG4gICAgICAgIG9uU2Nyb2xsU3RhcnQ6IHRoYXQuZGF0YS5vblNjcm9sbFN0YXJ0IHx8IHRoYXQub25TY3JvbGxTdGFydCxcclxuICAgICAgICBvbkRyYWdFbmQ6IHRoYXQuZGF0YS5vbkRyYWdFbmQgfHwgdGhhdC5vbkRyYWdFbmQsXHJcbiAgICAgICAgc2Nyb2xsZXJEaWRTY3JvbGw6IHRoYXQuZGF0YS5zY3JvbGxlckRpZFNjcm9sbCB8fCB0aGF0LnNjcm9sbGVyRGlkU2Nyb2xsXHJcbiAgICB9O1xyXG4gICAgdGhhdC5zY3JvbGxlciA9IG5ldyBOSUJTLlNjcm9sbGVyKHRoYXQuJHRhcmdldCwgdGhhdC5kZWxlZ2F0ZSk7XHJcbiAgICB0aGF0LnJlZnJlc2goKTtcclxuICAgIHdpbmRvdy5yZXF1ZXN0RnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoYXQuYWN0aW9ucyh0aGF0KTtcclxuICAgIH0pO1xyXG4gICAgdGhhdC5zY3JvbGxlci5pZCA9IHRoYXQuaWQgPSAnaWQnICsgdGhhdC5nZXRVbmlxdWVJZCgpO1xyXG4gICAgTklCUy5Ib3Jpem9udGFsLmdsb2JhbFt0aGF0LmlkXSA9IHRoYXQ7XHJcblxyXG4gICAgJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhhdC5yZWZyZXNoKHRoYXQuc2Nyb2xsZXIpO1xyXG4gICAgfSk7XHJcblxyXG59O1xyXG5cclxuTklCUy5Ib3Jpem9udGFsLnByb3RvdHlwZSA9IHt9O1xyXG5cclxuTklCUy5Ib3Jpem9udGFsLmdsb2JhbCA9IHt9O1xyXG5cclxuTklCUy5Ib3Jpem9udGFsLnByb3RvdHlwZS5nZXRVbmlxdWVJZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICBkICs9IChwYXJzZUludChNYXRoLnJhbmRvbSgpICogMTAwKSkudG9TdHJpbmcoKTtcclxuICAgIHJldHVybiBkO1xyXG59O1xyXG5cclxuTklCUy5Ib3Jpem9udGFsLnByb3RvdHlwZS5hY3Rpb25zID0gZnVuY3Rpb24gKHRoYXQpIHtcclxuXHJcbiAgICB3aW5kb3cucmVxdWVzdEZyYW1lKGZ1bmN0aW9uICgpIHsgdGhhdC5hY3Rpb25zKHRoYXQpOyB9KTtcclxuXHJcbiAgICB2YXIgcHJvZ3Jlc3M7XHJcbiAgICB0aGF0LmluZm8uc2NvbGxMZWZ0ID0gdGhhdC5nZXRTY29sbExlZnQoKTtcclxuICAgIHRoYXQuaW5mby50b3RhbFdpZHRoID0gdGhhdC50b3RhbFdpZHRoO1xyXG4gICAgdGhhdC5pbmZvLnRhcmdldFdpZHRoID0gdGhhdC50YXJnZXRXaWR0aDtcclxuICAgIHRoYXQuaW5mby50YXJnZXRIZWlnaHQgPSB0aGF0LnRhcmdldEhlaWdodDtcclxuXHJcbiAgICBwcm9ncmVzcyA9IHRoYXQuZ2V0U2NvbGxMZWZ0KCkgLyAodGhhdC50b3RhbFdpZHRoIC0gdGhhdC5pbmZvLnRhcmdldFdpZHRoKTtcclxuICAgIGlmIChwcm9ncmVzcyA8IDApIHByb2dyZXNzID0gMDtcclxuICAgIGlmIChwcm9ncmVzcyA+IDEpIHByb2dyZXNzID0gMTtcclxuXHJcbiAgICB0aGF0LmluZm8ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuXHJcbiAgICB2YXIgZGlmZiA9IHRoYXQubGFzdExlZnQgLSB0aGF0LmluZm8uc2NvbGxMZWZ0O1xyXG5cclxuICAgIGlmIChNYXRoLmFicyhkaWZmKSA8IDAuMDE4ICYmIHRoYXQuaW5mby5zdGF0ZSAhPT0gJ3N0b3BwZWQnKSB7XHJcblxyXG4gICAgICAgIHRoYXQuaW5mby5zdGF0ZSA9ICdzdG9wcGVkJztcclxuICAgICAgICAkLmV2ZW50LnRyaWdnZXIoe1xyXG4gICAgICAgICAgICB0eXBlOiAnc2Nyb2xsaW5nLmVuZGVkJyxcclxuICAgICAgICAgICAgdGhhdDogdGhhdCxcclxuICAgICAgICAgICAgaW5mbzogdGhhdC5pbmZvXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGlmZikgPiAwLjAxOCAmJiB0aGF0LmluZm8uc3RhdGUgPT09ICdzdG9wcGVkJykge1xyXG4gICAgICAgIHRoYXQuaW5mby5zdGF0ZSA9ICdzY3JvbGxpbmcnO1xyXG4gICAgICAgICQuZXZlbnQudHJpZ2dlcih7XHJcbiAgICAgICAgICAgIHR5cGU6ICdzY3JvbGxpbmcuc3RhcnRlZCcsXHJcbiAgICAgICAgICAgIHRoYXQ6IHRoYXQsXHJcbiAgICAgICAgICAgIGluZm86IHRoYXQuaW5mb1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGF0LmluZm8uc3RhdGUgPT09ICdzY3JvbGxpbmcnKSB7XHJcbiAgICAgICAgJC5ldmVudC50cmlnZ2VyKHtcclxuICAgICAgICAgICAgdHlwZTogJ3Njcm9sbGluZy5pbi5hY3Rpb24nLFxyXG4gICAgICAgICAgICB0aGF0OiB0aGF0LFxyXG4gICAgICAgICAgICBpbmZvOiB0aGF0LmluZm9cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGF0Lmxhc3RMZWZ0ID0gdGhhdC5pbmZvLnNjb2xsTGVmdDtcclxuXHJcbiAgICAkLmV2ZW50LnRyaWdnZXIoe1xyXG4gICAgICAgIHR5cGU6ICdzY3JvbGxpbmcudGljaycsXHJcbiAgICAgICAgdGhhdDogdGhhdCxcclxuICAgICAgICBpbmZvOiB0aGF0LmluZm9cclxuICAgIH0pO1xyXG5cclxufTtcclxuXHJcbk5JQlMuSG9yaXpvbnRhbC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIChzY3JvbGxlcikge1xyXG5cclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGF0LnRvdGFsV2lkdGggPSB0aGF0LiR0YXJnZXQuZmluZCgnLm5pYnMtc2Nyb2xsZXItY29udGVudCcpLm91dGVyV2lkdGgoKTtcclxuICAgIHRoYXQudGFyZ2V0V2lkdGggPSB0aGF0LiR0YXJnZXQub3V0ZXJXaWR0aCgpO1xyXG4gICAgdGhhdC50YXJnZXRIZWlnaHQgPSB0aGF0LiR0YXJnZXQub3V0ZXJIZWlnaHQoKTtcclxuICAgIHRoYXQuc2Nyb2xsZXIuc2V0Q29udGVudFNpemUodGhhdC50b3RhbFdpZHRoLCAwKTtcclxuICAgIHRoYXQuc2Nyb2xsZXIubGF5b3V0KCk7XHJcblxyXG59O1xyXG5cclxuTklCUy5Ib3Jpem9udGFsLnByb3RvdHlwZS5nZXRTY29sbFRvcCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICByZXR1cm4gdGhhdC5zY3JvbGxlci52ZXJ0aWNhbC5jb250ZW50T2Zmc2V0O1xyXG5cclxufTtcclxuXHJcbk5JQlMuSG9yaXpvbnRhbC5wcm90b3R5cGUuZ2V0U2NvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiB0aGF0LnNjcm9sbGVyLmhvcml6b250YWwuY29udGVudE9mZnNldDtcclxuXHJcbn07XHJcblxyXG5OSUJTLkhvcml6b250YWwucHJvdG90eXBlLm9uU2Nyb2xsU3RhcnQgPSBmdW5jdGlvbiAoc2Nyb2xsZXIpIHtcclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcbn07XHJcblxyXG5OSUJTLkhvcml6b250YWwucHJvdG90eXBlLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uIChzY3JvbGxlcikge1xyXG5cdHZhciB0aGF0ID0gdGhpcztcclxufTtcclxuXHJcbk5JQlMuSG9yaXpvbnRhbC5wcm90b3R5cGUuc2Nyb2xsZXJEaWRTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsZXIpIHtcclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcbn07XHJcblxyXG5OSUJTLkhvcml6b250YWwucHJvdG90eXBlLmNhbGNTY3JvbGxUbyA9IGZ1bmN0aW9uICh3aGF0LCBhbGlnbikge1xyXG5cclxuXHR2YXIgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgb2Zmc2V0VmFsLFxyXG4gICAgICAgIG9ialdpZHRoID0gMCxcclxuICAgICAgICBuID0gMCxcclxuICAgICAgICAkb2JqLCBwb3NpdGlvbjtcclxuXHJcbiAgICBhbGlnbiA9IGFsaWduIHx8ICdsZWZ0JztcclxuXHJcbiAgICBpZiAoIWlzTmFOKHdoYXQpKSB7XHJcbiAgICAgICAgbiA9IHdoYXQ7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZih3aGF0KSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAkb2JqID0gdGhhdC4kdGFyZ2V0LmZpbmQod2hhdCk7XHJcbiAgICAgICAgcG9zaXRpb24gPSAkb2JqLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgb2JqV2lkdGggPSAkb2JqLm91dGVyV2lkdGgoKTtcclxuICAgICAgICBuID0gcG9zaXRpb24ubGVmdDtcclxuICAgIH0gZWxzZSBpZih3aGF0LnBvc2l0aW9uKSB7XHJcbiAgICAgICAgJG9iaiA9IHdoYXQ7XHJcbiAgICAgICAgcG9zaXRpb24gPSAkb2JqLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgb2JqV2lkdGggPSAkb2JqLm91dGVyV2lkdGgoKTtcclxuICAgICAgICBuID0gcG9zaXRpb24ubGVmdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcclxuICAgICAgICBuID0gbiAtIHRoYXQudGFyZ2V0V2lkdGggKyBvYmpXaWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBvZmZzZXRWYWwgPSB0aGF0LnRvdGFsV2lkdGggLSB0aGF0LnRhcmdldFdpZHRoIC0gbjtcclxuICAgIGlmIChvZmZzZXRWYWwgPCAwKSBuID0gbiArIG9mZnNldFZhbDtcclxuICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgcmV0dXJuIG47XHJcblxyXG59O1xyXG5cclxuTklCUy5Ib3Jpem9udGFsLnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uICh3aGF0LCBzcGVlZCwgYWxpZ24pIHtcclxuXHJcbiAgICB2YXIgdGhhdCA9IHRoaXMsXHJcbiAgICAgICAgbjtcclxuXHJcbiAgICBpZiAodHlwZW9mKHNwZWVkKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBhbGlnbiA9IHNwZWVkO1xyXG4gICAgICAgIHNwZWVkID0gdGhhdC5zcGVlZDtcclxuICAgIH1cclxuXHJcbiAgICBuID0gdGhhdC5jYWxjU2Nyb2xsVG8od2hhdCwgYWxpZ24pO1xyXG4gICAgdGhhdC5zY3JvbGxlci5zZXRDb250ZW50T2Zmc2V0KG4sIDAsIHNwZWVkKTtcclxuXHJcbn07XHJcblxyXG5OSUJTLkhvcml6b250YWwucHJvdG90eXBlLmdldEFsaWduID0gZnVuY3Rpb24gKCRvYmopIHtcclxuXHJcblx0dmFyIHRoYXQgPSB0aGlzLFxyXG4gICAgICAgIG9mZnNldCxcclxuICAgICAgICBwaXRjaCxcclxuICAgICAgICBydixcclxuICAgICAgICBwb3NpdGlvbjtcclxuXHJcbiAgICBvZmZzZXQgPSAkb2JqLm9mZnNldCgpO1xyXG4gICAgcG9zaXRpb24gPSAkb2JqLnBvc2l0aW9uKCk7XHJcbiAgICBvYmpXaWR0aCA9ICRvYmoub3V0ZXJXaWR0aCgpO1xyXG5cclxuICAgIGlmIChwb3NpdGlvbi5sZWZ0ICsgb2JqV2lkdGggLyAyIDwgdGhhdC50YXJnZXRXaWR0aCAvIDIpIHtcclxuICAgICAgICBwaXRjaCA9ICdsZWZ0JztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGl0Y2ggPSAncmlnaHQnO1xyXG4gICAgfVxyXG5cclxuICAgIHJ2ID0gcGl0Y2g7XHJcblxyXG4gICAgdmFyIHRlc3QgPSB0aGF0LmNhbGNTY3JvbGxUbygkb2JqLCBwaXRjaCksXHJcbiAgICAgICAgbmV3UGl0Y2gsXHJcbiAgICAgICAgbmV3VGVzdDtcclxuXHJcbiAgICBpZiAodGVzdCA9PT0gMCkge1xyXG4gICAgICAgIGlmIChwaXRjaCA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgIG5ld1Rlc3QgPSB0aGF0LmNhbGNTY3JvbGxUbygkb2JqLCAncmlnaHQnKTtcclxuICAgICAgICAgICAgbmV3UGl0Y2ggPSAncmlnaHQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGl0Y2ggPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgbmV3VGVzdCA9IHRoYXQuY2FsY1Njcm9sbFRvKCRvYmosICdsZWZ0Jyk7XHJcbiAgICAgICAgICAgIG5ld1BpdGNoID0gJ2xlZnQnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5ld1Rlc3QgPiAwKSB7XHJcbiAgICAgICAgICAgIHJ2ID0gbmV3UGl0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBydjtcclxuXHJcbn07XHJcblxyXG5cclxuXHJcbk5JQlMuSG9yaXpvbnRhbC5wcm90b3R5cGUuc2Nyb2xsVG9Qcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzcywgc3BlZWQpIHtcclxuXHJcbiAgICAvL3RyYWNlKCdwcm9ncmVzcycsIHByb2dyZXNzKTtcclxuXHJcblx0dmFyIHRoYXQgPSB0aGlzLCBzY29sbExlZnQ7XHJcbiAgICBzY29sbExlZnQgPSAodGhhdC50b3RhbFdpZHRoIC0gdGhhdC50YXJnZXRXaWR0aCkgKiBwcm9ncmVzcztcclxuICAgIHRoYXQuc2Nyb2xsVG8oc2NvbGxMZWZ0LCBzcGVlZCk7XHJcblxyXG59O1xyXG5cclxuTklCUy5Ib3Jpem9udGFsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB0aGF0LnNjcm9sbGVyLmRpc3Bvc2UoKTtcclxuICAgIGRlbGV0ZSBOSUJTLkhvcml6b250YWwuZ2xvYmFsW3RoYXQuaWRdO1xyXG5cclxufTtcclxuIl0sImZpbGUiOiJwYXJhZG94L0hvcml6b250YWwuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==

var VCC = window.VCC || {};
VCC.timelineMain = (function() {

    // Private methods & properties ***
    var _mainObj;

    function _load(path) {


        _u.loadJSON(path, function(tldata) {
            _dataManager(tldata);
        });

    }

    function _dataManager(tldata) {

        for (var i = 0; i < tldata.events.length; i += 1) {
            var dateDate = _u.parseDate(tldata.events[i].date, _mainObj.mounthArray);
            tldata.events[i].year = dateDate.year;
            tldata.events[i].mounth = dateDate.mounth;
            tldata.events[i].mountName = dateDate.mountName;
            tldata.events[i].day = dateDate.day;
            tldata.events[i].dateLabel = dateDate.mountName.toUpperCase() + ' ' + dateDate.year;
        }
        _mainObj.$target.find('.blockGrid').html(VCC.Timeline.render('#block-tmpl', tldata));
        _mainObj.timeline = new VCC.Timeline({
            target: _mainObj.targetSelector,
            targetSelector: _mainObj.targetSelector,
            maxHeightPercent: 80,
            minHeight: 270,
            rows: parseInt($('.interactive-timeline .rowsInTimeline').text()) || 1,
            tldata: tldata,
            mediaPatterns: ['/~/media/', '.mp4', '.wemb']
        });

    }

    function _run(targetSelector) {

        var $target = $(targetSelector);
        $target.data('tlid', _u.pathToId(targetSelector));

        _mainObj = {
            targetSelector: targetSelector,
            $target: $target,
            mounthArray: $target.find('.mountNames').text().split(',')
        };

        var useInlineJSON = true;
        if (useInlineJSON) {
            var tldata = window[$target.closest('.interactive-timeline').data('tldata')];
            _dataManager(tldata);
        } else {
            _load('/Static/scripts/timeline-js/data/timeline.js');
        }

    }

    // Public methods & properties ***
    return {
        run: _run
    };
}());

var VCC = VCC || {};

VCC.Timeline = function(data) {

    if (!data.target) return;

    var that = this;
    that.data = data;
    that.tldata = that.data.tldata;
    that.data.maxHeightPercent = that.data.orgMaxHeightPercent = (typeof(that.data.maxHeightPercent) !== 'undefined') ? that.data.maxHeightPercent : 80;
    that.data.minHeight = (typeof(that.data.minHeight) !== 'undefined') ? that.data.minHeight : 300;
    that.data.$target = $(that.data.target);
    that.data.$timlineControl = that.data.$target.find('.timline-control-wrapper');
    that.visbibleBlocks = null;
    that.data.rows = (that.data.rows > 2) ? 2 : that.data.rows; //Max value is 2
    that.rows = that.data.rows;
    that.blockWidth = 100;
    that.heightOfMax = 0.7; //This is how much of the total height of the acticle that the scrollbar should have. It define the margon top and bottom of it.
    that.labelCount = 0;
    that.lastProgress = 0;

    that.bigPlane = null;
    that.bigVideo = null;

    that.imgWidth = null;
    that.wrapperWidth = null;
    that.wrapperWidthP = null;
    that.imgWidthP = null;
    that.articleMarginTop = null;

    that.deviceSize = 'large';
    that.timelineControlSlider = null;
    that.slideColors = ['darker', 'lighter', 'default'];
    that.slideColorsIndex = 0;
    that.nextPrevDisable = false;
    that.allInlineScroller = [];
    that.naxtPrevArticleDims = null;
    that.articleData = null;
    that.resizeTimer = null;
    that.doSync = true;
    that.timer1 = null;
    that.currentArticleId = null;
    that.openArticleTL = null;

    that.checkDim();
    that.setSize();

    window.doReset = function() {
        that.setSize();
        that.resize();
        that.scrollerH.refresh();
        return 'Done';
    };

    that.timelineControlSlider = new NIBS.Slider({
        target: that.data.targetSelector + ' .timline-control'
    });
    $(that.timelineControlSlider.target).find('.slider-handle').append($('<div class="play-head down"></div>'));

    that.data.$target.find('.gridBox').first().addClass('selctedBlock');
    TweenMax.to(that.data.target + ' .closeArticle', 0, {
        x: -100,
        opacity: 0
    });

    that.data.$target.find('.grid-timeline .left-label div').html(that.tldata.events[0].year);
    that.data.$target.find('.grid-timeline .right-label div').html(that.tldata.events[that.tldata.events.length - 1].year);

    that.scrollerH = new NIBS.Horizontal({
        target: $('.nibs-scroller'),
        onScrollStart: function() {
            that.doSync = false;
            if (that.timer1) clearTimeout(that.timer1);
        },
        onDragEnd: function() {
            that.doSync = false;
            if (that.timer1) clearTimeout(that.timer1);
            that.timer1 = setTimeout(function() {
                that.doSync = true;
            }, that.scrollerH.speed * 1.1);
        }
    });

    MOS.inView.add($('.gridBox'));
    MOS.inView.doTrace = false;
    MOS.inView.outOfBoundsSize = 2;
    MOS.inView.check();
    that.imgToLoadCheck();

    if (!window.ontouchstart && !navigator.MaxTouchPoints && !navigator.msMaxTouchPoints) {
        that.data.$target.addClass('notouch');
    }

    $(window).on('resize orientationchange', function() {

        that.setSize();
        that.resize();
        that.scrollerH.refresh();

        setTimeout(function() {
            that.setSize();
            that.resize();
            that.scrollerH.refresh();
        }, 300);

    });

    $(document.body).on('click', that.data.target + ' .gridBox', function(e) {
        that.data.$target.find('.article').removeClass('lighter');
        that.data.$target.find('.article').removeClass('darker');
        that.data.$target.find('.closeArticle').removeClass('bluer');
        that.openArticle($(this).attr('id'));
    });

    $(document).on('scrolling.in.action', function(e) {

        that.imgToLoadCheck();
        that.timelineControlSlider.setProgress(that.scrollerH.info.progress);
        that.lastProgress = that.scrollerH.info.progress;

    });

    $(document).on('slider.sliding', function(e) {

        if (e.that.id === that.timelineControlSlider.id) {
            that.scrollerH.scrollToProgress(e.that.info.progress, 0);
        }

    });

    $(document.body).on('click', that.data.target + ' .videoLink', function(e) {

        e.preventDefault();
        that.playBigVideo($(this).data('videolinks'));

    });

    $(document.body).on('mouseover', that.data.target + '.notouch .gridBox', function(e) {
        e.stopPropagation();

        if (VCC.Timeline.winDim.height < 400) return;

        $(this).find('.short_text').stop(true, false).delay(200).slideDown(180);
    });

    $(document.body).on('mouseout', that.data.target + '.notouch .gridBox', function(e) {
        e.stopPropagation();
        $(this).find('.short_text').stop(true, false).slideUp(350);
    });

    $(document.body).on('click', that.data.target + ' .closeArticle', function(e) {

        if (!that.openArticleTL) return;
        TweenMax.to(that.data.target + ' .closeArticle', 0.3, {
            opacity: 0,
            x: -100
        });

        var npw = that.data.$target.find('.next-prev-articles .next-prev-article-wrapper'),
            firstContainer = that.data.$target.find('.first-container').closest('.article');

        if (npw.hasClass('darker')) {
            firstContainer.addClass('darker');
            firstContainer.removeClass('lighter');
        } else if (npw.hasClass('lighter')) {
            firstContainer.addClass('lighter');
            firstContainer.removeClass('darker');
        } else {
            firstContainer.removeClass('lighter');
            firstContainer.removeClass('darker');
        }
        that.slideColorsIndex = 0;
        npw.remove();

        that.data.$target.find('.timline-control').removeClass('display-none-important');
        that.openArticleTL.timeScale(1);
        that.naxtPrevArticleDims = null;

        that.closeArticle();

        TweenMax.to(that.data.$target.find('.play-head'), 0.6, {
            y: 0,
            ease: Elastic.easeOut.config(1, 0.5)
        });
        TweenMax.to(that.data.$target.find('.timline-control-content .article-timeline, .timline-control-content .grid-timeline'), 0.5, {
            y: 0,
            ease: Power1.easeInOut,
            onComplete: function() {}
        });

        that.data.$target.find('.prev-next-btn.prev-btn').fadeTo(500, 1);
        that.data.$target.find('.prev-next-btn.next-btn').fadeTo(500, 1);

    });

    $(document.body).on('click', that.data.target + ' .timline-control', function(e) {

        var offset = $(this).offset(),
            prg = (e.pageX - offset.left) / $(this).outerWidth();
        that.scrollerH.scrollToProgress(prg, 300);

    });

    $(document.body).on('click', that.data.target + ' .prev-next-btn', function(e) {

        var $currBlock = that.data.$target.find('.selctedBlock'),
            $targetBlock,
            checkObj = MOS.inView.check();

        if ($(this).hasClass('prev-btn')) {

            if (that.data.$target.hasClass('expanded')) {
                $targetBlock = $currBlock.prev();
                if ($targetBlock.length) {
                    that.openNextPrevArticle($targetBlock.attr('id'), 'prev');
                }
            } else {
                that.scrollerH.scrollTo(checkObj.isVisible[0], 500, 'right');
            }

        } else {

            if (that.data.$target.hasClass('expanded')) {
                $targetBlock = $currBlock.next();
                if ($targetBlock.length) {
                    that.openNextPrevArticle($targetBlock.attr('id'), 'next');
                }
            } else {
                that.scrollerH.scrollTo(checkObj.isVisible[checkObj.isVisible.length - 1], 500, 'left');
            }

        }

    });

    $(window).keydown(function(e) {
        switch (e.keyCode) {
            case 27: //Esc
                $(that.data.target + ' .closeArticle').click();
                break;
            default:
                return true;
        }
    });

};

VCC.Timeline.prototype = {};

VCC.Timeline.prototype.playBigVideo = function(videolinksStr) {

    'use strict';

    var that = this,
        tmpArr = JSON.parse(unescape(videolinksStr)),
        poster,
        videosArr = [];

    for (var i = 0; i < tmpArr.length; i++) {
        if (tmpArr[i].type === 'poster') {
            poster = tmpArr[i].url;
        } else {
            videosArr.push(tmpArr[i]);
        }
    }

    that.bigPlane = $('<div id="my-big-plane" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: #000; z-index: 10000;"><div id="big-video-player-target"></div></div>');
    $(document.body).append(that.bigPlane);

    that.bigPlane.fadeIn(400, function() {

        that.bigVideo = new VCC.CustomVideoPlayer({
            selector: '#big-video-player-target',
            poster: poster,
            videos: videosArr,
            autoplay: true,
            muted: false,
            fullscreen: true,
            fullscreenExitPlayer: true,
            controls: true,
            customControls: true,
            loop: false,
            fit: false,
            scale: true,
            onExit: function() {
                var bigPlane = $('#my-big-plane');
                bigPlane.delay(0.5).fadeOut(700, function() {
                    bigPlane.remove();
                });
            }
        });


    });

};

VCC.Timeline.prototype.getAnimation = function($block, timeScale) {

    'use strict';

    var that = this,
        id = $block.attr('id'),
        articleDataArr = that.tldata.events.filter(function(el) {
            return el.id === id;
        }),
        $rowParBlock,
        $visibleBlocksToTheRight,
        $visibleBlocksToTheLeft,
        tl = new TimelineMax(),
        aniDur = 0.35,
        aniDurK = 1.5,
        checkObj = MOS.inView.check(),
        align = that.scrollerH.getAlign($block),
        currCol = $block.data('col'),
        offsetX = that.data.$target.offset().left + 1,
        curr,
        blockWidth,
        blockHeight,
        imgWidth,
        label,
        playHead = 0;

    that.articleData = articleDataArr[0];
    tl.timeScale(timeScale);

    if (articleDataArr.length === 1) {

        var className = '.colRows_' + $block.data('col') + '_' + (($block.data('row') % 2) ? 0 : 1),
            rowParBlockY;

        $rowParBlock = that.data.$target.find(className);
        rowParBlockY = $block.outerHeight();
        blockWidth = $block.outerWidth();
        blockHeight = $block.outerHeight();

        if (that.deviceSize === 'small') {
            blockWidth *= 1;
        } else if (that.deviceSize === 'medium') {
            blockWidth *= 0.5;
        }

        if (blockWidth * that.rows > VCC.Timeline.winDim.width * 0.5) {
            blockWidth = VCC.Timeline.winDim.width * (0.5 / that.rows);
        }

        if ($block.data('row') % 2) {
            rowParBlockY *= -1;
        }

        for (var i = 0; i < checkObj.isVisible.length; i += 1) {

            curr = checkObj.isVisible[i];

            if (currCol < curr.data('col')) {
                curr.addClass('visibleBlocksToTheRight');
            }
            if (currCol > curr.data('col')) {
                curr.addClass('visibleBlocksToTheLeft');
            }

        }

        $visibleBlocksToTheRight = that.data.$target.find('.visibleBlocksToTheRight');
        $visibleBlocksToTheLeft = that.data.$target.find('.visibleBlocksToTheLeft');

        if (that.rows === 2) {

            label = that.getLabel(playHead, tl);
            tl.add((new TweenMax.to($block.find('.blockText'), aniDur, {
                immediateRender: false,
                autoAlpha: 0,
                ease: Power2.easeIn
            })), label);
            tl.add((new TweenMax.to($block.find('.gridBoxBg'), aniDur * aniDurK, {
                immediateRender: false,
                opacity: 1,
                ease: Power2.easeOut
            })), label);
            tl.add((new TweenMax.to($block, aniDur, {
                immediateRender: false,
                height: $block.outerHeight() * 2,
                ease: Power2.easeIn
            })), label);
            tl.add((new TweenMax.to($rowParBlock, aniDur, {
                immediateRender: false,
                y: String(rowParBlockY),
                ease: Power2.easeIn
            })), label);

            playHead += aniDur;
            label = that.getLabel(playHead, tl);
            tl.add((new TweenMax.to($rowParBlock, aniDur, {
                immediateRender: false,
                y: String(rowParBlockY),
                ease: Power2.easeIn
            })), label);
            $block.data('targetwidth', blockWidth * 2);
            tl.add((new TweenMax.to($block, aniDur, {
                immediateRender: false,
                width: blockWidth * 2,
                ease: Power2.easeOut
            })), label);
            tl.add((new TweenMax.to($visibleBlocksToTheRight, aniDur, {
                immediateRender: false,
                x: blockWidth,
                ease: Power0.easeNone
            })), label);
            tl.add((new TweenMax.to($block.find('.video-play-button'), aniDur, {
                delay: aniDur,
                immediateRender: false,
                opacity: 1,
                ease: Power2.easeIn
            })), label);

            //if (that.deviceSize === 'large') {
            tl.add((new TweenMax.to($block, aniDur * aniDurK, {
                immediateRender: false,
                x: that.scrollerH.info.targetWidth - blockWidth * 2 - $block.offset().left + offsetX,
                ease: Power2.easeOut
            })), label);
            //} else {
            tl.add((new TweenMax.to($block, aniDur * aniDurK, {
                immediateRender: false,
                x: that.scrollerH.info.targetWidth - blockWidth * 2 - $block.offset().left + offsetX,
                ease: Power2.easeOut
            })), label);
            //}
            tl.add((new TweenMax.to($visibleBlocksToTheRight, aniDur * aniDurK, {
                immediateRender: false,
                x: that.scrollerH.info.targetWidth - blockWidth * 1 - $block.offset().left + offsetX,
                ease: Power2.easeOut
            })), label);
            tl.add((new TweenMax.to($visibleBlocksToTheLeft, aniDur * aniDurK, {
                immediateRender: false,
                x: String($block.offset().left * -1 + offsetX),
                ease: Power2.easeOut
            })), label);

        } else {

            label = that.getLabel(playHead, tl);
            tl.add((new TweenMax.to($block.find('.blockText'), aniDur / 2, {
                immediateRender: false,
                autoAlpha: 0,
                ease: Power2.easeIn
            })), label);
            tl.add((new TweenMax.to($block.find('.gridBoxBg'), aniDur * aniDurK, {
                immediateRender: false,
                opacity: 1,
                ease: Power2.easeOut
            })), label);
            tl.add((new TweenMax.to($block.find('.video-play-button'), aniDur, {
                delay: aniDur,
                immediateRender: false,
                opacity: 1,
                ease: Power2.easeIn
            })), label);

            if (that.deviceSize === 'large') {

                $block.data('targetwidth', blockWidth);
                tl.add((new TweenMax.to($block, aniDur * aniDurK, {
                    immediateRender: false,
                    x: that.scrollerH.info.targetWidth - blockWidth - $block.offset().left + offsetX,
                    width: blockWidth,
                    ease: Power2.easeOut
                })), label);
            } else {
                $block.data('targetwidth', $block.outerWidth());
                tl.add((new TweenMax.to($block, aniDur * aniDurK, {
                    immediateRender: false,
                    x: that.scrollerH.info.targetWidth - $block.offset().left + offsetX,
                    ease: Power2.easeOut
                })), label);
            }

            tl.add((new TweenMax.to($visibleBlocksToTheRight, aniDur * aniDurK, {
                immediateRender: false,
                x: that.scrollerH.info.targetWidth - blockWidth * 1 - $block.offset().left + offsetX,
                ease: Power2.easeOut
            })), label);
            tl.add((new TweenMax.to($visibleBlocksToTheLeft, aniDur * aniDurK, {
                immediateRender: false,
                x: String($block.offset().left * -1 + offsetX),
                ease: Power2.easeOut
            })), label);
        }

        tl.addCallback(function() {
            that.data.$target.addClass('articleVisible');
        }, tl.duration()); //At the end

        tl.addCallback(function() {
            if (tl.beenReversed) { //At the start
                that.openArticleTL = null;
                that.data.$target.removeClass('expanded');
                $('.visibleBlocksToTheRight').removeClass('visibleBlocksToTheRight');
                $('.visibleBlocksToTheLeft').removeClass('visibleBlocksToTheLeft');
            }
        }, 0);

        return tl;

    } else {
        return null;
    }


};

VCC.Timeline.prototype.getLabel = function(at, tl) {

    var that = this,
        label = 'label' + that.labelCount;

    tl.add(label, at);
    that.labelCount++;
    return label;

};

VCC.Timeline.prototype.widthManager = function($articleContent) {

    var that = this;

    if ($articleContent.find('.gridBoxBg').length) {
        that.imgWidth = $articleContent.find('.gridBoxBg').outerWidth();
    } else {
        that.imgWidth = that.data.$target.find('.gridBox.selctedBlock').data('targetwidth');
    }
    that.articleMarginTop = ($articleContent.closest('.article').eq(0).outerHeight() * that.heightOfMax - $articleContent.find('.nibs-innerScroll').outerHeight()) / 2;
    that.wrapperWidth = that.data.$target.outerWidth() - that.imgWidth;
    that.wrapperWidthP = (that.wrapperWidth / that.data.$target.outerWidth()) * 100;
    that.imgWidthP = (that.imgWidth / that.data.$target.outerWidth()) * 100;

};

VCC.Timeline.prototype.openArticle = function(id, timeScale) {

    timeScale = timeScale || 1;

    var that = this,
        $block = that.data.$target.find('#' + id);

    that.data.$target.find('.selctedBlock').removeClass('selctedBlock');
    $block.addClass('selctedBlock');

    if ($(that.data.target + ' .closeArticle').css('opacity') < 1) {
        var dly = (that.rows === 1) ? 0.2 : 0.7;
        TweenMax.to(that.data.target + ' .closeArticle', 0.3, {
            opacity: 1,
            x: 0,
            delay: dly
        });
    }

    if ($block.length < 1) return;

    that.currentArticleId = id;

    if (that.data.$target.hasClass('expanded')) return;
    that.data.$target.addClass('expanded');

    this.scrollerH.scroller.off();
    that.openArticleTL = that.getAnimation($block, timeScale);

    var videoButtonDefined = false;
    for (var i = 1; i < 4; i++) {
        var arr = that.articleData['link' + i + '_url'];
        if (arr instanceof Array) {
            if (!arr.poster && !videoButtonDefined) {
                videoButtonDefined = true;
                that.articleData['link' + i + '_url'] = arr.src;
            }
            that.articleData['videolinks' + i] = escape(JSON.stringify(arr));
        }
    }

    var clonedArticleData = JSON.parse(JSON.stringify(that.articleData));
    clonedArticleData = that.fixVideoLinks(clonedArticleData);

    var html = VCC.Timeline.render('#article-content-tmpl', clonedArticleData),
        $articleContent = that.data.$target.find('.article-content').not('.not-active-scroller');

    var prevEvent, nextEvent, aniTime = 300,
        $yearLabelPrev, $yearLabelNext;

    for (i = 0; i < that.data.tldata.events.length; i += 1) {
        if (that.data.tldata.events[i].id === id) {

            nextEvent = that.data.tldata.events[i + 1];
            if (nextEvent) {
                $yearLabelPrev = that.data.$target.find('.article-timeline .right-label');
                that.data.$target.find('.prev-next-btn.next-btn').fadeTo(aniTime, 1);
                $yearLabelPrev.fadeOut(aniTime, function() {
                    $yearLabelPrev.find('h4').html(nextEvent.year + ' ' + nextEvent.label);
                    $yearLabelPrev.fadeIn(aniTime);
                });
            } else {
                that.data.$target.find('.article-timeline .right-label').fadeOut(aniTime);
                that.data.$target.find('.prev-next-btn.next-btn').fadeTo(aniTime, 0.3);
            }

            if (prevEvent) {
                var labeltext = prevEvent.year + ' ' + prevEvent.label;
                $yearLabelNext = that.data.$target.find('.article-timeline .left-label');
                that.data.$target.find('.prev-next-btn.prev-btn').fadeTo(aniTime, 1);
                $yearLabelNext.fadeOut(aniTime, function() {
                    $yearLabelNext.find('h4').html(labeltext);
                    $yearLabelNext.fadeIn(aniTime);
                });
            } else {
                that.data.$target.find('.article-timeline .left-label').fadeOut(aniTime);
                that.data.$target.find('.prev-next-btn.prev-btn').fadeTo(aniTime, 0.3);
            }

        }
        prevEvent = that.data.tldata.events[i];
    }

    $articleContent.html(html);
    that.widthManager($articleContent);

    //Turn video links into videoplay buttons
    that.videoCheck($articleContent, $block);
    that.inlineScrollCheck($articleContent);

    var yVal = that.data.$target.find('.timline-control-content-inner').outerHeight();
    TweenMax.to(that.data.$target.find('.play-head'), 0.3, {
        y: String(yVal * 1.3),
        ease: Power1.easeInOut
    });
    TweenMax.to(that.data.$target.find('.timline-control-content .article-timeline, .timline-control-content .grid-timeline'), 0.3, {
        y: String(yVal * -1),
        ease: Power1.easeInOut
    });

};

VCC.Timeline.prototype.inlineScrollCheck = function($articleContent) {

    var that = this,
        $wrapper = $articleContent.closest('.article-content-wrapper');

    if (that.deviceSize === 'large') {
        $wrapper.css('width', that.wrapperWidthP + '%');
    } else {
        $wrapper.css('width', 'auto');
    }

    $articleContent.find('.nibs-scroller').each(function(index) {

        var $article = $articleContent.closest('.article');

        //Set height of scrollbar container
        $article.find('.nibs-scroller').css('height', $article.outerHeight() * that.heightOfMax);
        //Center the scrollbar container in needed
        if ($articleContent.find('.nibs-innerScroll').outerHeight() < $article.outerHeight() * that.heightOfMax) {
            var mtop = ($article.outerHeight() * that.heightOfMax - $articleContent.find('.nibs-innerScroll').outerHeight()) / 2;
            $article.find('.nibs-scroller .nibs-innerScroll ').css('margin-top', mtop).addClass('not-active-scroller');
        }


        $article.find('.nibs-innerScroll').addClass('active');
        var scroller = new NIBS.Scroller($(this));
        scroller.setTrackbarVisible(true); //Show scrollbar
        if (!that.allInlineScroller) that.allInlineScroller = [];
        that.allInlineScroller.push(scroller);

    });

};

VCC.Timeline.prototype.videoCheck = function($articleContent, $block) {

    var that = this,
        $links,
        $curr,
        href,
        i;

    //Turn video links into videoplay buttons
    $links = $articleContent.find('.link-block a');
    $links.each(function(index) {
        $curr = $(this);
        href = $curr.attr('href');

        if ($curr.data('videolinks')) {
            $curr.addClass('videoLink');
            var $vbtn = $block.find('.video-play-button');

            $vbtn.css('left', 0).attr('href', href);
            $vbtn.addClass('videoLink');

            $vbtn.data('videolinks', $curr.data('videolinks'));

            if ($vbtn.closest('.next-prev-article-wrapper').length) {
                $vbtn.css('opacity', 1);
            }
        }

    });

};

VCC.Timeline.prototype.fixVideoLinks = function(data) {

    for (var i = 1; i < 4; i++) {
        var arr = data['link' + i + '_url'];
        if (arr instanceof Array) {
            data['videolinks' + i] = escape(JSON.stringify(arr));
            data['link' + i + '_url'] = 'javascript:';
        }
    }

    return data;

};

VCC.Timeline.prototype.openNextPrevArticle = function(id, dir) {

    var that = this,
        articleData = that.tldata.events.filter(function(el) {
            return el.id === id;
        })[0],
        clonedArticleData = JSON.parse(JSON.stringify(articleData));

    clonedArticleData = that.fixVideoLinks(clonedArticleData);

    clonedArticleData.imgWidthP = that.imgWidthP;
    clonedArticleData.articleWidthP = that.wrapperWidthP;

    if (that.deviceSize === 'small' || that.deviceSize === 'medium') {
        clonedArticleData.articleWidthP = 100;
    }

    clonedArticleData.bgClass = that.slideColors[that.slideColorsIndex];
    that.slideColorsIndex++;

    if (clonedArticleData.bgClass === 'lighter') {
        that.data.$target.find('.closeArticle').addClass('bluer');
    } else {
        that.data.$target.find('.closeArticle').removeClass('bluer');
    }

    if (that.slideColorsIndex > that.slideColors.length - 1) that.slideColorsIndex = 0;
    if (that.nextPrevDisable) return;

    var html = VCC.Timeline.render('#next-prev-article-tmpl', clonedArticleData),
        $it = $(html),
        tweenVal = '-100';

    //Turn video links into videoplay buttons
    that.videoCheck($it, $it);

    //that.data.$target.find('.timline-control').addClass('display-none-important');
    that.nextPrevDisable = true;
    that.data.$target.find('.next-prev-articles').append($it);
    that.data.$target.find('.selctedBlock').removeClass('selctedBlock');
    that.currentArticleId = id;

    if (dir === 'prev') {
        $it.addClass('prev-placed');
        tweenVal = '100';
    }
    that.inlineScrollCheck($it);

    var removeActoveClass = false;

    setTimeout(function() {
        var trackbar = $it.find('.nibs-trackbar');
        if (trackbar.length) {

            if (trackbar.css('visibility') === 'hidden') {
                $it.find('.nibs-innerScroll').removeClass('active');
                $it.find('.article-content').addClass('not-active-scroller');
                removeActoveClass = true;
            }
        }
    }, 100);

    TweenMax.to($it, 0.5, {
        xPercent: tweenVal,
        ease: Power1.easeInOut,
        onComplete: function() {

            that.data.$target.find('.next-prev-articles .next-prev-article-wrapper:not(:last-child)').remove();

            if (!that.openArticleTL) return;

            var timeScale = 100,
                waitTime = that.openArticleTL.duration() / timeScale;

            setTimeout(function() {
                that.openArticleTL.timeScale(timeScale);
                that.closeArticle();
                setTimeout(function() {
                    that.scrollerH.scrollTo(that.data.$target.find('#' + id), 0, 'right');
                    setTimeout(function() {
                        that.openArticle(that.currentArticleId, timeScale);
                        that.nextPrevDisable = false;
                        that.data.$target.find('.article').removeClass('darker, lighter, default').addClass(clonedArticleData.bgClass);
                        that.setImages([that.data.$target.find('.selctedBlock')]);

                        if (removeActoveClass) {
                            that.data.$target.find('.first-container').closest('.article').find('.nibs-innerScroll').removeClass('active');
                        }

                    }, 100);
                }, waitTime * 1000 + 50);
            }, 100);

        }
    });

};

VCC.Timeline.prototype.setImages = function(arr) {

    var el, img;
    for (var i = 0; i < arr.length; i += 1) {
        el = arr[i].find('.gridBoxBg');
        if (!el.hasClass('imageAdded')) {
            img = el.data('img');
            el.css('background-image', 'url(' + img + ')');
            el.addClass('imageAdded');
        }
    }

};

VCC.Timeline.prototype.closeArticle = function() {

    this.scrollerH.scroller.on();
    var that = this;

    if (that.openArticleTL) {
        that.data.$target.removeClass('articleVisible');
        that.openArticleTL.beenReversed = true;
        that.openArticleTL.reverse();
    }

    for (var i = 0; i < that.allInlineScroller.length; i++) {
        if (that.allInlineScroller[i]) that.allInlineScroller[i].dispose();
        that.allInlineScroller[i] = null;
        delete that.allInlineScroller[i];
    }
    that.allInlineScroller = 0;

};

VCC.Timeline.prototype.checkDim = function() {

    var that = this;
    //Always use rows = 1 on small screens

    VCC.Timeline.winDim = {
        width: window.innerWidth || document.body.clientWidth,
        height: window.innerHeight || document.body.clientHeight
    };

    if (VCC.Timeline.winDim.width <= 400) {
        that.maxHeightPercent = 60;
        that.deviceSize = 'small';
        that.rows = 1;

    } else if (VCC.Timeline.winDim.width <= 601) {
        that.maxHeightPercent = 60;
        that.deviceSize = 'medium';
        that.rows = 1;
    } else if (VCC.Timeline.winDim.width <= 700) {
        that.maxHeightPercent = 70;
        that.deviceSize = 'medium';
        that.rows = 1;
    } else if (VCC.Timeline.winDim.width <= 735) {
        that.maxHeightPercent = 65;
        that.deviceSize = 'medium';
        that.rows = 1;
    } else {
        that.deviceSize = 'large';
        that.maxHeightPercent = that.data.orgMaxHeightPercent;
        that.rows = that.data.rows;
    }

    if (VCC.Timeline.winDim.width <= 700) {
        that.rows = 1;
    }

    if (VCC.Timeline.winDim.height <= 700) {
        that.rows = 1;
    }

    if (that.rows === 1) {
        that.data.$target.addClass('layoutRow1');
        that.data.$target.removeClass('layoutRow2');
    }
    if (that.rows === 2) {
        that.data.$target.addClass('layoutRow2');
        that.data.$target.removeClass('layoutRow1');
    }

};

VCC.Timeline.prototype.resize = function(at, tl) {

    //Close, resize and open the article again very fast.
    var that = this,
        onResizingDoneFn,
        timeScale = 100,
        bigCover,
        waitTime;

    that.checkDim();

    that.timelineControlSlider.setProgress(that.lastProgress);
    that.scrollerH.scrollToProgress(that.lastProgress, 0);
    that.slideColorsIndex = 0;

    that.data.$target.find('.article').removeClass('lighter');
    that.data.$target.find('.article').removeClass('darker');
    that.data.$target.find('.closeArticle').removeClass('bluer');

    if (!that.data.$target.hasClass('expanded')) {
        return;
    }

    waitTime = that.openArticleTL.duration() / timeScale;
    bigCover = that.data.$target.find('.big-cover');

    onResizingDoneFn = function() {

        if (that.openArticleTL) that.openArticleTL.timeScale(timeScale);
        that.closeArticle();

        setTimeout(function() {
            that.setSize();
            that.openArticle(that.currentArticleId, timeScale);

            TweenMax.to(bigCover, 0.2, {
                opacity: 0,
                ease: Power1.easeInOut,
                onComplete: function() {
                    that.data.$target.find('.next-prev-articles .next-prev-article-wrapper').remove();
                    bigCover.css('display', 'none');
                    bigCover.css('opacity', 1);
                    if (that.openArticleTL) that.openArticleTL.timeScale(1);
                }
            });
        }, waitTime * 1000 + 50);

        that.resizeTimer = null;

    };

    if (that.resizeTimer) {
        window.clearTimeout(that.resizeTimer);
    } else {
        bigCover.css('display', 'block');
    }
    that.resizeTimer = window.setTimeout(onResizingDoneFn, 300);


};

VCC.Timeline.prototype.imgToLoadCheck = function(arr) {

    var that = this,
        checkObj = MOS.inView.check();

    that.visbibleBlocks = checkObj.isVisible;
    that.setImages(that.visbibleBlocks);
    that.setImages(checkObj.isClose);

};

VCC.Timeline.prototype.setImages = function(arr) {

    var el, img;
    for (var i = 0; i < arr.length; i += 1) {
        el = arr[i].find('.gridBoxBg');
        if (!el.hasClass('imageAdded')) {
            img = el.data('img');
            el.css('background-image', 'url(' + img + ')');
            el.addClass('imageAdded');
        }
    }

};

VCC.Timeline.prototype.setSize = function() {

    VCC.Timeline.winDim = {
        width: window.innerWidth || document.body.clientWidth,
        height: window.innerHeight || document.body.clientHeight
    };

    var wrapHeight = VCC.Timeline.winDim.height * (this.maxHeightPercent / 100),
        blockWidth,
        that = this,
        gbox,
        curr;

    wrapHeight = Math.floor(wrapHeight) - 2;

    if (wrapHeight < this.data.minHeight) {
        wrapHeight = this.data.minHeight;
    }

    blockWidth = (wrapHeight - this.data.$timlineControl.outerHeight()) / this.rows;
    this.blockWidth = blockWidth;
    this.data.$target.find('.nibs-scroller-content').css('height', wrapHeight);
    this.data.$target.css('height', wrapHeight);

    gbox = this.data.$target.find('.gridBox');
    gbox.css('width', blockWidth + 'px');
    gbox.css('height', blockWidth + 'px');

    var currLeft = 0,
        colCount = 0,
        rowCount = 0;
    gbox.each(function(index) {

        curr = $(this);
        curr.css('left', (blockWidth * Math.floor(index / that.rows)) + 'px');
        currLeft = (blockWidth * Math.floor(index / that.rows));

        if (index % that.rows) {
            curr.css('bottom', that.data.$timlineControl.outerHeight());
            rowCount = 1;
        } else {
            curr.css('bottom', 'auto');
            rowCount = 0;
        }
        curr.data('col', colCount);
        curr.data('row', rowCount);
        curr.addClass('colRows_' + colCount + '_' + rowCount);

        if (that.rows === 2 && index % that.rows) {
            colCount++;
        }
        if (that.rows === 1) {
            colCount++;
        }

    });

    if (that.rows === 1) {
        that.data.$target.addClass('layoutRow1');
        that.data.$target.removeClass('layoutRow2');
    }
    if (that.rows === 2) {
        that.data.$target.addClass('layoutRow2');
        that.data.$target.removeClass('layoutRow1');
    }

    that.data.$target.find('.nibs-scroller-content').css('width', currLeft + blockWidth);
    that.imgToLoadCheck();

};



VCC.Timeline.render = function(tmpl, data) {

    var source, template, html;
    if (tmpl.indexOf('#') > -1) source = $(tmpl).html();
    source = source.split('_this_').join('this');
    source = source.split('_if_').join('if');
    source = source.split('[*').join('{{');
    source = source.split('*]').join('}}');

    template = Handlebars.compile(source);
    return template(data);

};

var VCC = window.VCC || {};
VCC.utils = (function() {

    // Private methods & properties ***
    var c = (console) ? console : {
        log: function() {}
    };
    c.l = c.log;

    function _loadJSON(file, callback) {

        $.getJSON(file).done(function(response, status, XHR) {
            callback(response);
        }).fail(function(XHR, status, error) {
            console.log('Can\'t load JSON file.');
        });

    }

    function _pathToId(val) {
        val = val.toLowerCase();
        val = val.replace(/[^a-zA-Z 0-9]+/g, '');
        val = val.replace(/^\s+|\s+$/gm, '');
        return val;
    }

    function _parseDate(dateStr, mountArr) {

        mountArr = mountArr || ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        var that = this,
            arr,
            rv;

        arr = dateStr.split('-');
        rv = {
            year: parseInt(arr[0]),
            mounth: parseInt(arr[1]),
            mountName: mountArr[parseInt(arr[1]) - 1],
            day: parseInt(arr[2])
        };

        return rv;

    }



    // Public methods & properties ***
    return {
        loadJSON: _loadJSON,
        pathToId: _pathToId,
        parseDate: _parseDate
    };
}());

window._u = VCC.utils;

/*
 * CustomVideoPlayer 1.0
 *
 Usage:

<div id="video-player-target"></div>

 _cvp = new VCC.CustomVideoPlayer({
     selector: '#video-player-target',
     poster: 'http://assets.volvocars.com/intl/~/media/shared-assets/master/images/video-images/inside/our-innovation-brands/intellisafe/whatisautonomusdriving_videoimage_1.jpg',
     videos: [
         {
             type: 'mp4',
             url: 'http://www.volvocars.com/~/media/92639dd2c12844ffb8d9443ea4df06ff.ashx'
         },
         {
             type: 'webm',
             url: 'http://www.volvocars.com/~/media/92639dd2c12844ffb8d9443ea4df06ff.ashx'
         }
     ],
     autoplay: true,
     muted: true,
     fullscreen: true,
     controls: true,
     customControls: true,
     loop: true,
     fit: false,
     scale: true
 });

 //_cvp.destroy();
 */

var VCC = VCC || {};
VCC.CustomVideoPlayer = function(data) {

    'use strict';

    var that = this;
    that.data = data;
    that.id = 'vid' + VCC.CustomVideoPlayer.getUniqueId();
    that.$target = VCC.CustomVideoPlayer.get.$1(that.data.selector);
    that.$wrapper = null;
    that.isFullscreen = (typeof(that.data.fullscreen) === 'undefined') ? false : that.data.fullscreen;
    that.fullscreenExitPlayer = (typeof(that.data.fullscreenExitPlayer) === 'undefined') ? false : that.data.fullscreenExitPlayer;
    that.$body = VCC.CustomVideoPlayer.get.$1('body');
    that.$overlay = null;
    that.offset = that.getOffset(that.$target);
    that.$pausePlayBtn = null;
    that.$muteBtn = null;
    that.$volumeSlide = null;
    that.video = null;
    that.$customControl = null;
    that.$videoTime = null;
    that.timeDisplay = null;
    that.$progress = null;
    that.$buffer = null;
    that.controls = (that.data.controls) ? 'controls' : '';
    that.customControls = (that.data.customControls) ? true : false;
    if (that.customControls) {
        that.controls = '';
    }
    that.poster = (that.data.poster) ? that.data.poster : '';
    that.muted = (that.data.muted) ? 'muted' : '';
    that.loop = (that.data.loop) ? 'loop' : '';
    that.autoplay = (that.data.autoplay) ? 'autoplay' : '';
    that.fit = (that.data.fit) ? 'video-cover' : '';
    that.scale = (that.data.scale) ? true : false;
    that.ratio = 9 / 16;
    that.loaded = 0;
    that.track = null;
    that.width = null;
    that.height = null;
    that.duration = 0;
    that.notSupportedMessage = (that.data.notSupportedMessage) ? that.data.notSupportedMessage : 'Your browserdoes not support the video tag.';
    that.mousePressed = false;

    that.onResizeFn = function(e) {
        that.offset = that.getOffset(that.$target);
    };

    that.setup(that.data);
    VCC.CustomVideoPlayer.all[that.id] = that;

};

VCC.CustomVideoPlayer.prototype = {};
VCC.CustomVideoPlayer.prototype.data = {};

VCC.CustomVideoPlayer.prototype.setup = function() {

    var that = this,
        code,
        tmpl,
        videoSources = '',
        tData;

    tmpl = '<div class="custom-video-player [*fullscreen*]">' +
        '	<video id="[*id*]" preload="none" [*controls*] [*muted*] [*loop*] [*autoplay*] class="[*fit*]" poster="[*poster*]">' +
        '		[*videoSources*]' +
        '		[*notSupportedMessage*]' +
        '	</video>' +
        '	<div class="custom-video-overlay-wrapper">' +
        '		<div class="custom-video-overlay-button-wrapper plat-button"></div>' +
        '	</div>' +
        '	<div class="custom-video-volume-slider"></div>' +
        '	<div class="custom-video-mute-button"></div>' +
        '	<div class="custom-video-fullscreen-button"></div>' +
        '	<div class="custom-controler">' +
        '		<span class="custom-video-time-float">' +
        '			<span class="custom-video-time-float-current">00:00</span><span class="custom-video-time-float-corner"></span>' +
        '		</span>' +
        '		<div class="buffer"></div>' +
        '		<div class="progress"></div>' +
        '	</div>' +
        '</div>';

    tData = {
        'id': that.id,
        'controls': that.controls,
        'muted': that.muted,
        'loop': that.loop,
        'autoplay': that.autoplay,
        'fit': that.fit,
        'videoSources': '',
        'poster': that.poster,
        'notSupportedMessage': that.notSupportedMessage,
        'fullscreen': (that.isFullscreen) ? 'fullscreen' : ''
    };

    for (var i = 0; i < that.data.videos.length; i += 1) {
        videoSources += '<source title="' + that.data.videos[i].title + '" src="' + that.data.videos[i].url + '" type="video/' + that.data.videos[i].type + '">\n';
    }

    if (that.isFullscreen) {
        VCC.CustomVideoPlayer.onFullscreenExit = that.data.onExit;
    } else {
        VCC.CustomVideoPlayer.onFullscreenExit = function() {};
    }

    tData.videoSources = videoSources;
    code = VCC.CustomVideoPlayer.tmpl.render(tmpl, tData);

    if (that.scale && !that.fit) {
        that.$target.style.height = 'auto';
    }

    that.$target.innerHTML = code;

    that.$pausePlayBtn = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-video-overlay-button-wrapper.plat-button');
    that.$muteBtn = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-video-mute-button');
    that.$volumeSlide = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-video-volume-slider');
    that.$overlay = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-video-overlay-wrapper');
    that.$videoTime = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-video-time-float');
    that.timeDisplay = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-video-time-float-current');
    that.$wrapper = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-video-player');

    //Temp hide the mute buttons
    that.$muteBtn.style.left = '-9999px';


    // that.volumeSlider = new MOS.Slider({
    //     selector: that.data.selector + ' .custom-video-volume-slider',
    //     direction: 'v',
    //     onChange: function (n) {
    //         that.video.volume = n;
    //         if (n === 0) {
    //             that.$muteBtn.classList.add('unmute');
    //             that.video.muted = true;
    //         } else {
    //             that.$muteBtn.classList.remove('unmute');
    //             that.video.muted = false;
    //         }
    //     }
    // });

    that.$volumeSlide.classList.add('hidden');
    that.video = VCC.CustomVideoPlayer.get.$1('video');
    that.video.addEventListener('loadedmetadata', that.gotMetaData);
    that.video.addEventListener('canplay', that.clipCanplay);
    that.video.addEventListener('progress', that.onProgress);
    that.video.addEventListener('timeupdate', that.onTimeupdate);
    that.video.addEventListener('pause', that.stateChange);
    that.video.addEventListener('play', that.stateChange);

    // if (that.video.muted) {
    //     that.$muteBtn.classList.add('unmute');
    //     that.volumeSlider.setValue(0);
    // } else {
    //     that.volumeSlider.setValue(that.video.volume);
    // }

    that.$overlay.addEventListener('click', function(e) {

        if (that.video.paused) {
            that.video.play();
        } else {
            that.video.pause();
        }

    });

    if (that.customControls) {
        that.$customControl = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-controler');
        that.$progress = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .progress');
        that.$buffer = VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .buffer');
    }

    that.$customControl.addEventListener('mousedown', function(e) {

        that.offset = that.getOffset(that.$target);
        that.video.currentTime = that.duration * (e.clientX - that.offset.left) / that.$customControl.offsetWidth;

        that.mousePressed = true;

        that.$body.addEventListener('mousemove', onMouseMove);

    });

    that.$customControl.addEventListener('mouseover', function(e) {
        that.$videoTime.classList.add('active');
    });

    that.$customControl.addEventListener('mousemove', function(e) {

        var time = that.duration * (e.clientX - that.offset.left) / that.$customControl.offsetWidth;

        if (time < 0 || time > that.duration) {
            that.$videoTime.style.visibility = 'hidden';
        } else {
            that.$videoTime.style.visibility = 'visible';
        }

        that.timeDisplay.innerHTML = VCC.CustomVideoPlayer.getTimeString(time);
        that.$videoTime.style.left = (e.clientX - that.offset.left) + 'px';
    });

    that.$customControl.addEventListener('mouseout', function(e) {
        that.$videoTime.classList.remove('active');
    });

    that.$body.addEventListener('mouseup', function(e) {
        that.mousePressed = false;
        that.$body.removeEventListener('mousemove', onMouseMove);

    });

    that.$body.addEventListener("keydown", function(event) {

        if (event.keyCode === 27 && that.isFullscreen) {
            that.toggleFullscreen();
        }

    });

    that.$muteBtn.addEventListener('click', function(e) {

        // if (that.video.muted) {
        //     that.$muteBtn.classList.remove('unmute');
        //     that.volumeSlider.setValue(0.5);
        // } else {
        //     that.$muteBtn.classList.add('unmute');
        //     that.volumeSlider.setValue(0);
        // }
        that.video.muted = !that.video.muted;

    });

    that.$muteBtn.addEventListener('mouseover', function(e) {

        var mouseMove = function(e) {

            var xVal = (e.clientX - that.offset.left - that.video.offsetWidth) * -1,
                yVal = that.video.offsetHeight - e.clientY - that.offset.top;

            if (yVal < 20 || yVal > 175 || xVal < 65 || xVal > 90) {
                that.$volumeSlide.classList.add('hidden');
                that.$target.removeEventListener('mousemove', mouseMove);
            }
        };

        that.$volumeSlide.classList.remove('hidden');
        that.$target.addEventListener('mousemove', mouseMove);

    });

    VCC.CustomVideoPlayer.get.$1(that.data.selector + ' .custom-video-fullscreen-button').addEventListener('click', function(e) {
        that.toggleFullscreen();
    });


    window.addEventListener('resize', that.onResizeFn);
    var onMouseMove = function(e) {

        if (that.mousePressed) {
            that.video.currentTime = that.duration * (e.clientX - that.offset.left) / that.$customControl.offsetWidth;
        }

    };

};

VCC.CustomVideoPlayer.prototype.toggleFullscreen = function(e) {

    var that = this;

    if (that.fullscreenExitPlayer) {

        that.destroy();
        VCC.CustomVideoPlayer.onFullscreenExit();

        return;

    }

    that.$wrapper.classList.toggle('fullscreen');
    that.isFullscreen = that.$wrapper.classList.contains('fullscreen');
    that.offset = that.getOffset(that.$target);
    that.onExit();

};

VCC.CustomVideoPlayer.prototype.fullscreenExitPlayer = false;

VCC.CustomVideoPlayer.prototype.onExit = function(e) {

    var that = this;

};

VCC.CustomVideoPlayer.prototype.stateChange = function(e) {

    var that = VCC.CustomVideoPlayer.all[this.id];

    if (!that) return;

    if (that.video.paused) {
        that.$pausePlayBtn.style.display = 'block';
    } else {
        that.$pausePlayBtn.style.display = 'none';
    }

};


VCC.CustomVideoPlayer.prototype.onTimeupdate = function(e) {

    var that = VCC.CustomVideoPlayer.all[this.id];

    if (!that) return;

    if (that.customControls) {
        that.$progress.style.width = ((that.video.currentTime / that.duration) * 100) + '%';
    }

};

VCC.CustomVideoPlayer.prototype.onProgress = function(e) {

    var that = VCC.CustomVideoPlayer.all[this.id];
    if (!that) return;

    try {
        that.loaded = that.video.buffered.end(0) / that.video.duration;
    } catch (ev) {}

    if (that.customControls) {
        that.$buffer.style.width = (that.loaded * 100) + '%';
    }
};


VCC.CustomVideoPlayer.prototype.gotMetaData = function(e) {

    var that = VCC.CustomVideoPlayer.all[this.id];
    that.width = e.target.videoWidth;
    that.height = e.target.videoHeight;
    that.ratio = that.height / that.width;
    that.duration = e.target.duration;

    //Subtitles
    // that.track = e.target.addTextTrack('captions', 'English', 'en');
    // that.track.mode = 'showing';
    // e.target.textTracks[0].mode = "showing"; // thanks Firefox
    // that.track.addCue(new VTTCue(1, 5, 'Welcome to the beginning of this film.'));
    // that.track.addCue(new VTTCue(7, 13, 'This blade has a dark past.'));
    // that.track.addCue(new VTTCue(15, 22, 'It has shed much innocent blood.'));

};

VCC.CustomVideoPlayer.prototype.clipCanplay = function() {

    var that = this;

};

VCC.CustomVideoPlayer.prototype.play = function() {

    var that = this;

};

VCC.CustomVideoPlayer.prototype.destroy = function() {

    var that = this,
        it = VCC.CustomVideoPlayer.all[that.id];

    //it.volumeSlider.destroy();

    window.removeEventListener('resize', that.onResizeFn);

    that.$target.innerHTML = '';
    that.video.pause();
    delete that.video;
    // for (var prop in it) {
    //     if (it.hasOwnProperty(prop)) {
    //         MOS.Slider.removeEvents(it[prop]);
    //         delete it[prop];
    //     }
    // }
    delete VCC.CustomVideoPlayer.all[that.id];

};

VCC.CustomVideoPlayer.prototype.getOffset = function(el) {

    var that = this;

    if (that.isFullscreen) {
        return {
            top: 0,
            left: 0
        };
    }

    var rect = el.getBoundingClientRect();
    return {
        top: rect.top + document.body.scrollTop,
        left: rect.left + document.body.scrollLeft
    };

};


VCC.CustomVideoPlayer.all = {};

VCC.CustomVideoPlayer.getUniqueId = function() {

    var d = new Date().getTime();
    d += (parseInt(Math.random() * 100)).toString();
    return d;

};

VCC.CustomVideoPlayer.get = {
    $1: document.querySelector.bind(document), //Node array, usage: var el = $1('.one-time-class');
    $2: document.querySelectorAll.bind(document) // Direct reference, usage: var alArr = $2('.my-class');
};

VCC.CustomVideoPlayer.getTimeString = function(time) {

    var hours = Math.floor(time / 3600);
    time -= hours * 3600;

    var minutes = Math.floor(time / 60);
    time -= minutes * 60;

    var seconds = parseInt(time % 60, 10);

    var withHours = hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    var withoutHours = (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);

    return withoutHours;

};

VCC.CustomVideoPlayer.tmpl = {
    startTag: '[*',
    endTag: '*]',
    get: function(id) {
        return document.getElementById(id).innerHTML;
    },
    put: function(pattern, inserts) {
        var rv = pattern,
            prop;
        for (prop in inserts) {
            rv = rv.split(this.startTag + prop + this.endTag).join(inserts[prop]);
        }
        return rv;
    },
    render: function(input, inserts) {

        var pattern = input;
        if (input.indexOf(this.startTag) === -1) {
            pattern = this.get(input);
        }

        var rv = '';
        if (inserts instanceof Array) {
            var len = inserts.length,
                i;
            for (i = 0; i < len; i += 1) {
                rv += this.put(pattern, inserts[i]);
            }
        } else {
            rv = this.put(pattern, inserts);
        }
        return rv;
    }
};


var MOS = MOS || {};
MOS.Slider = function(data) {

    var that = this;
    that.data = data;
    that.direction = that.data.direction || 'h';
    that.onChange = that.data.onChange || function() {};
    that.width = that.data.width || 'h';
    that.id = 'slider' + MOS.Slider.getId();
    that.touch = MOS.Slider.isTouchDevice();
    that.$target = MOS.Slider.get.$1(that.data.selector);
    that.$body = MOS.Slider.get.$1('body');
    that.$target.id = that.id;
    that.$handle = null;
    that.size = null;
    that.value = 0;
    that.pointerStartPos = {
        x: 0,
        y: 0
    };
    that.handleSize = null;
    that.mousePressed = false;

    if (that.touch) {
        that.pointer = {
            down: 'touchstart',
            move: 'touchmove',
            up: 'touchend'
        };
    } else {
        that.pointer = {
            down: 'mousedown',
            move: 'mousemove',
            up: 'mouseup'
        };
    }

    that.setup(that.data);

};

MOS.Slider.prototype = {};

MOS.Slider.prototype.setup = function() {

    var that = this;

    that.$target.innerHTML = '<div class="slider-handle"></div>';
    that.$target.classList.add('slider-wrapper');
    that.$handle = MOS.Slider.get.$1(that.data.selector + ' .slider-handle');

    if (that.direction === 'h') {
        that.size = that.video.offsetWidth;
        that.handleSize = that.$handle.offsetWidth;
    } else {
        that.size = that.$target.offsetHeight;
        that.handleSize = that.$handle.offsetHeight;
    }

    var onMouseMove = function(e) {

        var newPos;

        if (that.mousePressed) {
            if (that.direction === 'h') {
                that.$handle.style.left = (that.$handle.startX + (that.pointerStartPos.x - e.clientX) * -1) + 'px';
            } else {

                newPos = that.$handle.startY + that.pointerStartPos.y - e.clientY;
                if (newPos < 0) {
                    that.$handle.style.bottom = 0 + 'px';
                } else if (newPos > that.size - that.handleSize) {
                    that.$handle.style.bottom = that.size - that.handleSize + 'px';
                } else {
                    that.$handle.style.bottom = newPos + 'px';
                }

                that.value = parseInt(that.$handle.style.bottom) / (that.size - that.handleSize);
                that.onChange(that.value);
            }
        }

    };

    that.$handle.addEventListener(that.pointer.down, function(e) {

        that.$handle.startY = parseInt(that.$handle.style.bottom || 0);
        that.$handle.startX = parseInt(that.$handle.style.left || 0);
        that.pointerStartPos.x = parseInt(e.clientX);
        that.pointerStartPos.y = parseInt(e.clientY);

        that.mousePressed = true;
        that.$body.addEventListener(that.pointer.move, onMouseMove);

    });

    that.$body.addEventListener(that.pointer.up, function(e) {
        that.mousePressed = false;
        that.$body.removeEventListener(that.pointer.move, onMouseMove);

    });

    MOS.Slider.all[that.id] = that;

};

MOS.Slider.prototype.getValue = function() {

    var that = this;
    return that.value;

};

MOS.Slider.prototype.setValue = function(n) {

    var that = this,
        b;

    b = n * (that.size - that.handleSize);
    that.$handle.style.bottom = b + 'px';

};

MOS.Slider.prototype.destroy = function() {

    var that = this;
    delete MOS.Slider.all[that.id];

};

MOS.Slider.prototype.getOffset = function(el) {

    var that = this,
        rect = el.getBoundingClientRect();

    return {
        top: rect.top + document.body.scrollTop,
        left: rect.left + document.body.scrollLeft
    };

};


MOS.Slider.all = {};

MOS.Slider.getId = function() {
    return (new Date().getTime()) + (parseInt(Math.random() * 100)).toString();
};

MOS.Slider.removeEvents = function(el) {

    if (el && el.cloneNode) {
        var elClone = el.cloneNode(true);
        if (el.parentNode) {
            el.parentNode.replaceChild(elClone, el);
        }
    }

};

MOS.Slider.isTouchDevice = function() {
    var el = document.createElement('div');
    el.setAttribute('ongesturestart', 'return;'); // or try "ontouchstart"
    return typeof el.ongesturestart === "function";
};

MOS.Slider.get = {
    $1: document.querySelector.bind(document), //Node array, usage: var el = $1('.one-time-class');
    $2: document.querySelectorAll.bind(document) // Direct reference, usage: var alArr = $2('.my-class');
};

/*!
 * Isotope PACKAGED v2.2.2
 *
 * Licensed GPLv3 for open source use
 * or Isotope Commercial License for commercial use
 *
 * http://isotope.metafizzy.co
 * Copyright 2015 Metafizzy
 */

/**
 * Bridget makes jQuery widgets
 * v1.1.0
 * MIT license
 */

(function(window) {



    // -------------------------- utils -------------------------- //

    var slice = Array.prototype.slice;

    function noop() {}

    // -------------------------- definition -------------------------- //

    function defineBridget($) {

        // bail if no jQuery
        if (!$) {
            return;
        }

        // -------------------------- addOptionMethod -------------------------- //

        /**
         * adds option method -> $().plugin('option', {...})
         * @param {Function} PluginClass - constructor class
         */
        function addOptionMethod(PluginClass) {
            // don't overwrite original option method
            if (PluginClass.prototype.option) {
                return;
            }

            // option setter
            PluginClass.prototype.option = function(opts) {
                // bail out if not an object
                if (!$.isPlainObject(opts)) {
                    return;
                }
                this.options = $.extend(true, this.options, opts);
            };
        }

        // -------------------------- plugin bridge -------------------------- //

        // helper function for logging errors
        // $.error breaks jQuery chaining
        var logError = typeof console === 'undefined' ? noop :
            function(message) {
                console.error(message);
            };

        /**
         * jQuery plugin bridge, access methods like $elem.plugin('method')
         * @param {String} namespace - plugin name
         * @param {Function} PluginClass - constructor class
         */
        function bridge(namespace, PluginClass) {
            // add to jQuery fn namespace
            $.fn[namespace] = function(options) {
                if (typeof options === 'string') {
                    // call plugin method when first argument is a string
                    // get arguments for method
                    var args = slice.call(arguments, 1);

                    for (var i = 0, len = this.length; i < len; i++) {
                        var elem = this[i];
                        var instance = $.data(elem, namespace);
                        if (!instance) {
                            logError("cannot call methods on " + namespace + " prior to initialization; " +
                                "attempted to call '" + options + "'");
                            continue;
                        }
                        if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
                            logError("no such method '" + options + "' for " + namespace + " instance");
                            continue;
                        }

                        // trigger method with arguments
                        var returnValue = instance[options].apply(instance, args);

                        // break look and return first value if provided
                        if (returnValue !== undefined) {
                            return returnValue;
                        }
                    }
                    // return this if no return value
                    return this;
                } else {
                    return this.each(function() {
                        var instance = $.data(this, namespace);
                        if (instance) {
                            // apply options & init
                            instance.option(options);
                            instance._init();
                        } else {
                            // initialize new instance
                            instance = new PluginClass(this, options);
                            $.data(this, namespace, instance);
                        }
                    });
                }
            };

        }

        // -------------------------- bridget -------------------------- //

        /**
         * converts a Prototypical class into a proper jQuery plugin
         *   the class must have a ._init method
         * @param {String} namespace - plugin name, used in $().pluginName
         * @param {Function} PluginClass - constructor class
         */
        $.bridget = function(namespace, PluginClass) {
            addOptionMethod(PluginClass);
            bridge(namespace, PluginClass);
        };

        return $.bridget;

    }

    // transport
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('jquery-bridget/jquery.bridget', ['jquery'], defineBridget);
    } else if (typeof exports === 'object') {
        defineBridget(require('jquery'));
    } else {
        // get jquery from browser global
        defineBridget(window.jQuery);
    }

})(window);

/*!
 * eventie v1.0.6
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false, module: false */

(function(window) {



    var docElem = document.documentElement;

    var bind = function() {};

    function getIEEvent(obj) {
        var event = window.event;
        // add event.target
        event.target = event.target || event.srcElement || obj;
        return event;
    }

    if (docElem.addEventListener) {
        bind = function(obj, type, fn) {
            obj.addEventListener(type, fn, false);
        };
    } else if (docElem.attachEvent) {
        bind = function(obj, type, fn) {
            obj[type + fn] = fn.handleEvent ?
                function() {
                    var event = getIEEvent(obj);
                    fn.handleEvent.call(fn, event);
                } :
                function() {
                    var event = getIEEvent(obj);
                    fn.call(obj, event);
                };
            obj.attachEvent("on" + type, obj[type + fn]);
        };
    }

    var unbind = function() {};

    if (docElem.removeEventListener) {
        unbind = function(obj, type, fn) {
            obj.removeEventListener(type, fn, false);
        };
    } else if (docElem.detachEvent) {
        unbind = function(obj, type, fn) {
            obj.detachEvent("on" + type, obj[type + fn]);
            try {
                delete obj[type + fn];
            } catch (err) {
                // can't delete window object properties
                obj[type + fn] = undefined;
            }
        };
    }

    var eventie = {
        bind: bind,
        unbind: unbind
    };

    // ----- module definition ----- //

    if (typeof define === 'function' && define.amd) {
        // AMD
        define('eventie/eventie', eventie);
    } else if (typeof exports === 'object') {
        // CommonJS
        module.exports = eventie;
    } else {
        // browser global
        window.eventie = eventie;
    }

})(window);

/*!
 * EventEmitter v4.2.11 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - http://oli.me.uk/
 * @preserve
 */

;
(function() {
    'use strict';

    /**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */
    function EventEmitter() {}

    // Shortcuts to improve speed and size
    var proto = EventEmitter.prototype;
    var exports = this;
    var originalGlobalValue = exports.EventEmitter;

    /**
     * Finds the index of the listener for the event in its storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */
    function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
            if (listeners[i].listener === listener) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */
    function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }

    /**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */
    proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;

        // Return a concatenated array of all matching events if
        // the selector is a regular expression.
        if (evt instanceof RegExp) {
            response = {};
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                }
            }
        } else {
            response = events[evt] || (events[evt] = []);
        }

        return response;
    };

    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */
    proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;

        for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
        }

        return flatListeners;
    };

    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */
    proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;

        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }

        return response || listeners;
    };

    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListener = function addListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === 'object';
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                listeners[key].push(listenerIsWrapped ? listener : {
                    listener: listener,
                    once: false
                });
            }
        }

        return this;
    };

    /**
     * Alias of addListener
     */
    proto.on = alias('addListener');

    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after its first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };

    /**
     * Alias of addOnceListener.
     */
    proto.once = alias('addOnceListener');

    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };

    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
        }
        return this;
    };

    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                index = indexOfListener(listeners[key], listener);

                if (index !== -1) {
                    listeners[key].splice(index, 1);
                }
            }
        }

        return this;
    };

    /**
     * Alias of removeListener
     */
    proto.off = alias('removeListener');

    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListeners = function addListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(false, evt, listeners);
    };

    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListeners = function removeListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(true, evt, listeners);
    };

    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;

        // If evt is an object then pass each of its properties to this method
        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
                if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    // Pass the single listener straight through to the singular method
                    if (typeof value === 'function') {
                        single.call(this, i, value);
                    } else {
                        // Otherwise pass back to the multiple function
                        multiple.call(this, i, value);
                    }
                }
            }
        } else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;
            while (i--) {
                single.call(this, evt, listeners[i]);
            }
        }

        return this;
    };

    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;

        // Remove different things depending on the state of evt
        if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt];
        } else if (evt instanceof RegExp) {
            // Remove all events matching the regex.
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                }
            }
        } else {
            // Remove all listeners in all events
            delete this._events;
        }

        return this;
    };

    /**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */
    proto.removeAllListeners = alias('removeEvent');

    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emitEvent = function emitEvent(evt, args) {
        var listeners = this.getListenersAsObject(evt);
        var listener;
        var i;
        var key;
        var response;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                i = listeners[key].length;

                while (i--) {
                    // If the listener returns true then it shall be removed from the event
                    // The function is executed either with a basic call or an apply if there is an args array
                    listener = listeners[key][i];

                    if (listener.once === true) {
                        this.removeListener(evt, listener.listener);
                    }

                    response = listener.listener.apply(this, args || []);

                    if (response === this._getOnceReturnValue()) {
                        this.removeListener(evt, listener.listener);
                    }
                }
            }
        }

        return this;
    };

    /**
     * Alias of emitEvent
     */
    proto.trigger = alias('emitEvent');

    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };

    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };

    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */
    proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue;
        } else {
            return true;
        }
    };

    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */
    proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };

    /**
     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
     *
     * @return {Function} Non conflicting EventEmitter class.
     */
    EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
    };

    // Expose the class either via AMD, CommonJS or the global object
    if (typeof define === 'function' && define.amd) {
        define('eventEmitter/EventEmitter', [], function() {
            return EventEmitter;
        });
    } else if (typeof module === 'object' && module.exports) {
        module.exports = EventEmitter;
    } else {
        exports.EventEmitter = EventEmitter;
    }
}.call(this));

/*!
 * getStyleProperty v1.0.4
 * original by kangax
 * http://perfectionkills.com/feature-testing-css-properties/
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true */
/*global define: false, exports: false, module: false */

(function(window) {



    var prefixes = 'Webkit Moz ms Ms O'.split(' ');
    var docElemStyle = document.documentElement.style;

    function getStyleProperty(propName) {
        if (!propName) {
            return;
        }

        // test standard property first
        if (typeof docElemStyle[propName] === 'string') {
            return propName;
        }

        // capitalize
        propName = propName.charAt(0).toUpperCase() + propName.slice(1);

        // test vendor specific properties
        var prefixed;
        for (var i = 0, len = prefixes.length; i < len; i++) {
            prefixed = prefixes[i] + propName;
            if (typeof docElemStyle[prefixed] === 'string') {
                return prefixed;
            }
        }
    }

    // transport
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('get-style-property/get-style-property', [], function() {
            return getStyleProperty;
        });
    } else if (typeof exports === 'object') {
        // CommonJS for Component
        module.exports = getStyleProperty;
    } else {
        // browser global
        window.getStyleProperty = getStyleProperty;
    }

})(window);

/*!
 * getSize v1.2.2
 * measure size of elements
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, exports: false, require: false, module: false, console: false */

(function(window, undefined) {



    // -------------------------- helpers -------------------------- //

    // get a number from a string, not a percentage
    function getStyleSize(value) {
        var num = parseFloat(value);
        // not a percent like '100%', and a number
        var isValid = value.indexOf('%') === -1 && !isNaN(num);
        return isValid && num;
    }

    function noop() {}

    var logError = typeof console === 'undefined' ? noop :
        function(message) {
            console.error(message);
        };

    // -------------------------- measurements -------------------------- //

    var measurements = [
        'paddingLeft',
        'paddingRight',
        'paddingTop',
        'paddingBottom',
        'marginLeft',
        'marginRight',
        'marginTop',
        'marginBottom',
        'borderLeftWidth',
        'borderRightWidth',
        'borderTopWidth',
        'borderBottomWidth'
    ];

    function getZeroSize() {
        var size = {
            width: 0,
            height: 0,
            innerWidth: 0,
            innerHeight: 0,
            outerWidth: 0,
            outerHeight: 0
        };
        for (var i = 0, len = measurements.length; i < len; i++) {
            var measurement = measurements[i];
            size[measurement] = 0;
        }
        return size;
    }



    function defineGetSize(getStyleProperty) {

        // -------------------------- setup -------------------------- //

        var isSetup = false;

        var getStyle, boxSizingProp, isBoxSizeOuter;

        /**
         * setup vars and functions
         * do it on initial getSize(), rather than on script load
         * For Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=548397
         */
        function setup() {
            // setup once
            if (isSetup) {
                return;
            }
            isSetup = true;

            var getComputedStyle = window.getComputedStyle;
            getStyle = (function() {
                var getStyleFn = getComputedStyle ?
                    function(elem) {
                        return getComputedStyle(elem, null);
                    } :
                    function(elem) {
                        return elem.currentStyle;
                    };

                return function getStyle(elem) {
                    var style = getStyleFn(elem);
                    if (!style) {
                        logError('Style returned ' + style +
                            '. Are you running this code in a hidden iframe on Firefox? ' +
                            'See http://bit.ly/getsizebug1');
                    }
                    return style;
                };
            })();

            // -------------------------- box sizing -------------------------- //

            boxSizingProp = getStyleProperty('boxSizing');

            /**
             * WebKit measures the outer-width on style.width on border-box elems
             * IE & Firefox measures the inner-width
             */
            if (boxSizingProp) {
                var div = document.createElement('div');
                div.style.width = '200px';
                div.style.padding = '1px 2px 3px 4px';
                div.style.borderStyle = 'solid';
                div.style.borderWidth = '1px 2px 3px 4px';
                div.style[boxSizingProp] = 'border-box';

                var body = document.body || document.documentElement;
                body.appendChild(div);
                var style = getStyle(div);

                isBoxSizeOuter = getStyleSize(style.width) === 200;
                body.removeChild(div);
            }

        }

        // -------------------------- getSize -------------------------- //

        function getSize(elem) {
            setup();

            // use querySeletor if elem is string
            if (typeof elem === 'string') {
                elem = document.querySelector(elem);
            }

            // do not proceed on non-objects
            if (!elem || typeof elem !== 'object' || !elem.nodeType) {
                return;
            }

            var style = getStyle(elem);

            // if hidden, everything is 0
            if (style.display === 'none') {
                return getZeroSize();
            }

            var size = {};
            size.width = elem.offsetWidth;
            size.height = elem.offsetHeight;

            var isBorderBox = size.isBorderBox = !!(boxSizingProp &&
                style[boxSizingProp] && style[boxSizingProp] === 'border-box');

            // get all measurements
            for (var i = 0, len = measurements.length; i < len; i++) {
                var measurement = measurements[i];
                var value = style[measurement];
                value = mungeNonPixel(elem, value);
                var num = parseFloat(value);
                // any 'auto', 'medium' value will be 0
                size[measurement] = !isNaN(num) ? num : 0;
            }

            var paddingWidth = size.paddingLeft + size.paddingRight;
            var paddingHeight = size.paddingTop + size.paddingBottom;
            var marginWidth = size.marginLeft + size.marginRight;
            var marginHeight = size.marginTop + size.marginBottom;
            var borderWidth = size.borderLeftWidth + size.borderRightWidth;
            var borderHeight = size.borderTopWidth + size.borderBottomWidth;

            var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

            // overwrite width and height if we can get it from style
            var styleWidth = getStyleSize(style.width);
            if (styleWidth !== false) {
                size.width = styleWidth +
                    // add padding and border unless it's already including it
                    (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
            }

            var styleHeight = getStyleSize(style.height);
            if (styleHeight !== false) {
                size.height = styleHeight +
                    // add padding and border unless it's already including it
                    (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
            }

            size.innerWidth = size.width - (paddingWidth + borderWidth);
            size.innerHeight = size.height - (paddingHeight + borderHeight);

            size.outerWidth = size.width + marginWidth;
            size.outerHeight = size.height + marginHeight;

            return size;
        }

        // IE8 returns percent values, not pixels
        // taken from jQuery's curCSS
        function mungeNonPixel(elem, value) {
            // IE8 and has percent value
            if (window.getComputedStyle || value.indexOf('%') === -1) {
                return value;
            }
            var style = elem.style;
            // Remember the original values
            var left = style.left;
            var rs = elem.runtimeStyle;
            var rsLeft = rs && rs.left;

            // Put in the new values to get a computed value out
            if (rsLeft) {
                rs.left = elem.currentStyle.left;
            }
            style.left = value;
            value = style.pixelLeft;

            // Revert the changed values
            style.left = left;
            if (rsLeft) {
                rs.left = rsLeft;
            }

            return value;
        }

        return getSize;

    }

    // transport
    if (typeof define === 'function' && define.amd) {
        // AMD for RequireJS
        define('get-size/get-size', ['get-style-property/get-style-property'], defineGetSize);
    } else if (typeof exports === 'object') {
        // CommonJS for Component
        module.exports = defineGetSize(require('desandro-get-style-property'));
    } else {
        // browser global
        window.getSize = defineGetSize(window.getStyleProperty);
    }

})(window);

/*!
 * docReady v1.0.4
 * Cross browser DOMContentLoaded event emitter
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true*/
/*global define: false, require: false, module: false */

(function(window) {



    var document = window.document;
    // collection of functions to be triggered on ready
    var queue = [];

    function docReady(fn) {
        // throw out non-functions
        if (typeof fn !== 'function') {
            return;
        }

        if (docReady.isReady) {
            // ready now, hit it
            fn();
        } else {
            // queue function when ready
            queue.push(fn);
        }
    }

    docReady.isReady = false;

    // triggered on various doc ready events
    function onReady(event) {
        // bail if already triggered or IE8 document is not ready just yet
        var isIE8NotReady = event.type === 'readystatechange' && document.readyState !== 'complete';
        if (docReady.isReady || isIE8NotReady) {
            return;
        }

        trigger();
    }

    function trigger() {
        docReady.isReady = true;
        // process queue
        for (var i = 0, len = queue.length; i < len; i++) {
            var fn = queue[i];
            fn();
        }
    }

    function defineDocReady(eventie) {
        // trigger ready if page is ready
        if (document.readyState === 'complete') {
            trigger();
        } else {
            // listen for events
            eventie.bind(document, 'DOMContentLoaded', onReady);
            eventie.bind(document, 'readystatechange', onReady);
            eventie.bind(window, 'load', onReady);
        }

        return docReady;
    }

    // transport
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('doc-ready/doc-ready', ['eventie/eventie'], defineDocReady);
    } else if (typeof exports === 'object') {
        module.exports = defineDocReady(require('eventie'));
    } else {
        // browser global
        window.docReady = defineDocReady(window.eventie);
    }

})(window);

/**
 * matchesSelector v1.0.3
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, module: false */

(function(ElemProto) {

    'use strict';

    var matchesMethod = (function() {
        // check for the standard method name first
        if (ElemProto.matches) {
            return 'matches';
        }
        // check un-prefixed
        if (ElemProto.matchesSelector) {
            return 'matchesSelector';
        }
        // check vendor prefixes
        var prefixes = ['webkit', 'moz', 'ms', 'o'];

        for (var i = 0, len = prefixes.length; i < len; i++) {
            var prefix = prefixes[i];
            var method = prefix + 'MatchesSelector';
            if (ElemProto[method]) {
                return method;
            }
        }
    })();

    // ----- match ----- //

    function match(elem, selector) {
        return elem[matchesMethod](selector);
    }

    // ----- appendToFragment ----- //

    function checkParent(elem) {
        // not needed if already has parent
        if (elem.parentNode) {
            return;
        }
        var fragment = document.createDocumentFragment();
        fragment.appendChild(elem);
    }

    // ----- query ----- //

    // fall back to using QSA
    // thx @jonathantneal https://gist.github.com/3062955
    function query(elem, selector) {
        // append to fragment if no parent
        checkParent(elem);

        // match elem with all selected elems of parent
        var elems = elem.parentNode.querySelectorAll(selector);
        for (var i = 0, len = elems.length; i < len; i++) {
            // return true if match
            if (elems[i] === elem) {
                return true;
            }
        }
        // otherwise return false
        return false;
    }

    // ----- matchChild ----- //

    function matchChild(elem, selector) {
        checkParent(elem);
        return match(elem, selector);
    }

    // ----- matchesSelector ----- //

    var matchesSelector;

    if (matchesMethod) {
        // IE9 supports matchesSelector, but doesn't work on orphaned elems
        // check for that
        var div = document.createElement('div');
        var supportsOrphans = match(div, 'div');
        matchesSelector = supportsOrphans ? match : matchChild;
    } else {
        matchesSelector = query;
    }

    // transport
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('matches-selector/matches-selector', [], function() {
            return matchesSelector;
        });
    } else if (typeof exports === 'object') {
        module.exports = matchesSelector;
    } else {
        // browser global
        window.matchesSelector = matchesSelector;
    }

})(Element.prototype);

/**
 * Fizzy UI utils v1.0.1
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

(function(window, factory) {
    /*global define: false, module: false, require: false */
    'use strict';
    // universal module definition

    if (typeof define == 'function' && define.amd) {
        // AMD
        define('fizzy-ui-utils/utils', [
            'doc-ready/doc-ready',
            'matches-selector/matches-selector'
        ], function(docReady, matchesSelector) {
            return factory(window, docReady, matchesSelector);
        });
    } else if (typeof exports == 'object') {
        // CommonJS
        module.exports = factory(
            window,
            require('doc-ready'),
            require('desandro-matches-selector')
        );
    } else {
        // browser global
        window.fizzyUIUtils = factory(
            window,
            window.docReady,
            window.matchesSelector
        );
    }

}(window, function factory(window, docReady, matchesSelector) {



    var utils = {};

    // ----- extend ----- //

    // extends objects
    utils.extend = function(a, b) {
        for (var prop in b) {
            a[prop] = b[prop];
        }
        return a;
    };

    // ----- modulo ----- //

    utils.modulo = function(num, div) {
        return ((num % div) + div) % div;
    };

    // ----- isArray ----- //

    var objToString = Object.prototype.toString;
    utils.isArray = function(obj) {
        return objToString.call(obj) == '[object Array]';
    };

    // ----- makeArray ----- //

    // turn element or nodeList into an array
    utils.makeArray = function(obj) {
        var ary = [];
        if (utils.isArray(obj)) {
            // use object if already an array
            ary = obj;
        } else if (obj && typeof obj.length == 'number') {
            // convert nodeList to array
            for (var i = 0, len = obj.length; i < len; i++) {
                ary.push(obj[i]);
            }
        } else {
            // array of single index
            ary.push(obj);
        }
        return ary;
    };

    // ----- indexOf ----- //

    // index of helper cause IE8
    utils.indexOf = Array.prototype.indexOf ? function(ary, obj) {
        return ary.indexOf(obj);
    } : function(ary, obj) {
        for (var i = 0, len = ary.length; i < len; i++) {
            if (ary[i] === obj) {
                return i;
            }
        }
        return -1;
    };

    // ----- removeFrom ----- //

    utils.removeFrom = function(ary, obj) {
        var index = utils.indexOf(ary, obj);
        if (index != -1) {
            ary.splice(index, 1);
        }
    };

    // ----- isElement ----- //

    // http://stackoverflow.com/a/384380/182183
    utils.isElement = (typeof HTMLElement == 'function' || typeof HTMLElement == 'object') ?
        function isElementDOM2(obj) {
            return obj instanceof HTMLElement;
        } :
        function isElementQuirky(obj) {
            return obj && typeof obj == 'object' &&
                obj.nodeType == 1 && typeof obj.nodeName == 'string';
        };

    // ----- setText ----- //

    utils.setText = (function() {
        var setTextProperty;

        function setText(elem, text) {
            // only check setTextProperty once
            setTextProperty = setTextProperty || (document.documentElement.textContent !== undefined ? 'textContent' : 'innerText');
            elem[setTextProperty] = text;
        }
        return setText;
    })();

    // ----- getParent ----- //

    utils.getParent = function(elem, selector) {
        while (elem != document.body) {
            elem = elem.parentNode;
            if (matchesSelector(elem, selector)) {
                return elem;
            }
        }
    };

    // ----- getQueryElement ----- //

    // use element as selector string
    utils.getQueryElement = function(elem) {
        if (typeof elem == 'string') {
            return document.querySelector(elem);
        }
        return elem;
    };

    // ----- handleEvent ----- //

    // enable .ontype to trigger from .addEventListener( elem, 'type' )
    utils.handleEvent = function(event) {
        var method = 'on' + event.type;
        if (this[method]) {
            this[method](event);
        }
    };

    // ----- filterFindElements ----- //

    utils.filterFindElements = function(elems, selector) {
        // make array of elems
        elems = utils.makeArray(elems);
        var ffElems = [];

        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            // check that elem is an actual element
            if (!utils.isElement(elem)) {
                continue;
            }
            // filter & find items if we have a selector
            if (selector) {
                // filter siblings
                if (matchesSelector(elem, selector)) {
                    ffElems.push(elem);
                }
                // find children
                var childElems = elem.querySelectorAll(selector);
                // concat childElems to filterFound array
                for (var j = 0, jLen = childElems.length; j < jLen; j++) {
                    ffElems.push(childElems[j]);
                }
            } else {
                ffElems.push(elem);
            }
        }

        return ffElems;
    };

    // ----- debounceMethod ----- //

    utils.debounceMethod = function(_class, methodName, threshold) {
        // original method
        var method = _class.prototype[methodName];
        var timeoutName = methodName + 'Timeout';

        _class.prototype[methodName] = function() {
            var timeout = this[timeoutName];
            if (timeout) {
                clearTimeout(timeout);
            }
            var args = arguments;

            var _this = this;
            this[timeoutName] = setTimeout(function() {
                method.apply(_this, args);
                delete _this[timeoutName];
            }, threshold || 100);
        };
    };

    // ----- htmlInit ----- //

    // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
    utils.toDashed = function(str) {
        return str.replace(/(.)([A-Z])/g, function(match, $1, $2) {
            return $1 + '-' + $2;
        }).toLowerCase();
    };

    var console = window.console;
    /**
     * allow user to initialize classes via .js-namespace class
     * htmlInit( Widget, 'widgetName' )
     * options are parsed from data-namespace-option attribute
     */
    utils.htmlInit = function(WidgetClass, namespace) {
        docReady(function() {
            var dashedNamespace = utils.toDashed(namespace);
            var elems = document.querySelectorAll('.js-' + dashedNamespace);
            var dataAttr = 'data-' + dashedNamespace + '-options';

            for (var i = 0, len = elems.length; i < len; i++) {
                var elem = elems[i];
                var attr = elem.getAttribute(dataAttr);
                var options;
                try {
                    options = attr && JSON.parse(attr);
                } catch (error) {
                    // log error, do not initialize
                    if (console) {
                        console.error('Error parsing ' + dataAttr + ' on ' +
                            elem.nodeName.toLowerCase() + (elem.id ? '#' + elem.id : '') + ': ' +
                            error);
                    }
                    continue;
                }
                // initialize
                var instance = new WidgetClass(elem, options);
                // make available via $().data('layoutname')
                var jQuery = window.jQuery;
                if (jQuery) {
                    jQuery.data(elem, namespace, instance);
                }
            }
        });
    };

    // -----  ----- //

    return utils;

}));

/**
 * Outlayer Item
 */

(function(window, factory) {
    'use strict';
    // universal module definition
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('outlayer/item', [
                'eventEmitter/EventEmitter',
                'get-size/get-size',
                'get-style-property/get-style-property',
                'fizzy-ui-utils/utils'
            ],
            function(EventEmitter, getSize, getStyleProperty, utils) {
                return factory(window, EventEmitter, getSize, getStyleProperty, utils);
            }
        );
    } else if (typeof exports === 'object') {
        // CommonJS
        module.exports = factory(
            window,
            require('wolfy87-eventemitter'),
            require('get-size'),
            require('desandro-get-style-property'),
            require('fizzy-ui-utils')
        );
    } else {
        // browser global
        window.Outlayer = {};
        window.Outlayer.Item = factory(
            window,
            window.EventEmitter,
            window.getSize,
            window.getStyleProperty,
            window.fizzyUIUtils
        );
    }

}(window, function factory(window, EventEmitter, getSize, getStyleProperty, utils) {
    'use strict';

    // ----- helpers ----- //

    var getComputedStyle = window.getComputedStyle;
    var getStyle = getComputedStyle ?
        function(elem) {
            return getComputedStyle(elem, null);
        } :
        function(elem) {
            return elem.currentStyle;
        };


    function isEmptyObj(obj) {
        for (var prop in obj) {
            return false;
        }
        prop = null;
        return true;
    }

    // -------------------------- CSS3 support -------------------------- //

    var transitionProperty = getStyleProperty('transition');
    var transformProperty = getStyleProperty('transform');
    var supportsCSS3 = transitionProperty && transformProperty;
    var is3d = !!getStyleProperty('perspective');

    var transitionEndEvent = {
        WebkitTransition: 'webkitTransitionEnd',
        MozTransition: 'transitionend',
        OTransition: 'otransitionend',
        transition: 'transitionend'
    }[transitionProperty];

    // properties that could have vendor prefix
    var prefixableProperties = [
        'transform',
        'transition',
        'transitionDuration',
        'transitionProperty'
    ];

    // cache all vendor properties
    var vendorProperties = (function() {
        var cache = {};
        for (var i = 0, len = prefixableProperties.length; i < len; i++) {
            var prop = prefixableProperties[i];
            var supportedProp = getStyleProperty(prop);
            if (supportedProp && supportedProp !== prop) {
                cache[prop] = supportedProp;
            }
        }
        return cache;
    })();

    // -------------------------- Item -------------------------- //

    function Item(element, layout) {
        if (!element) {
            return;
        }

        this.element = element;
        // parent layout class, i.e. Masonry, Isotope, or Packery
        this.layout = layout;
        this.position = {
            x: 0,
            y: 0
        };

        this._create();
    }

    // inherit EventEmitter
    utils.extend(Item.prototype, EventEmitter.prototype);

    Item.prototype._create = function() {
        // transition objects
        this._transn = {
            ingProperties: {},
            clean: {},
            onEnd: {}
        };

        this.css({
            position: 'absolute'
        });
    };

    // trigger specified handler for event type
    Item.prototype.handleEvent = function(event) {
        var method = 'on' + event.type;
        if (this[method]) {
            this[method](event);
        }
    };

    Item.prototype.getSize = function() {
        this.size = getSize(this.element);
    };

    /**
     * apply CSS styles to element
     * @param {Object} style
     */
    Item.prototype.css = function(style) {
        var elemStyle = this.element.style;

        for (var prop in style) {
            // use vendor property if available
            var supportedProp = vendorProperties[prop] || prop;
            elemStyle[supportedProp] = style[prop];
        }
    };

    // measure position, and sets it
    Item.prototype.getPosition = function() {
        var style = getStyle(this.element);
        var layoutOptions = this.layout.options;
        var isOriginLeft = layoutOptions.isOriginLeft;
        var isOriginTop = layoutOptions.isOriginTop;
        var xValue = style[isOriginLeft ? 'left' : 'right'];
        var yValue = style[isOriginTop ? 'top' : 'bottom'];
        // convert percent to pixels
        var layoutSize = this.layout.size;
        var x = xValue.indexOf('%') != -1 ?
            (parseFloat(xValue) / 100) * layoutSize.width : parseInt(xValue, 10);
        var y = yValue.indexOf('%') != -1 ?
            (parseFloat(yValue) / 100) * layoutSize.height : parseInt(yValue, 10);

        // clean up 'auto' or other non-integer values
        x = isNaN(x) ? 0 : x;
        y = isNaN(y) ? 0 : y;
        // remove padding from measurement
        x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
        y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

        this.position.x = x;
        this.position.y = y;
    };

    // set settled position, apply padding
    Item.prototype.layoutPosition = function() {
        var layoutSize = this.layout.size;
        var layoutOptions = this.layout.options;
        var style = {};

        // x
        var xPadding = layoutOptions.isOriginLeft ? 'paddingLeft' : 'paddingRight';
        var xProperty = layoutOptions.isOriginLeft ? 'left' : 'right';
        var xResetProperty = layoutOptions.isOriginLeft ? 'right' : 'left';

        var x = this.position.x + layoutSize[xPadding];
        // set in percentage or pixels
        style[xProperty] = this.getXValue(x);
        // reset other property
        style[xResetProperty] = '';

        // y
        var yPadding = layoutOptions.isOriginTop ? 'paddingTop' : 'paddingBottom';
        var yProperty = layoutOptions.isOriginTop ? 'top' : 'bottom';
        var yResetProperty = layoutOptions.isOriginTop ? 'bottom' : 'top';

        var y = this.position.y + layoutSize[yPadding];
        // set in percentage or pixels
        style[yProperty] = this.getYValue(y);
        // reset other property
        style[yResetProperty] = '';

        this.css(style);
        this.emitEvent('layout', [this]);
    };

    Item.prototype.getXValue = function(x) {
        var layoutOptions = this.layout.options;
        return layoutOptions.percentPosition && !layoutOptions.isHorizontal ?
            ((x / this.layout.size.width) * 100) + '%' : x + 'px';
    };

    Item.prototype.getYValue = function(y) {
        var layoutOptions = this.layout.options;
        return layoutOptions.percentPosition && layoutOptions.isHorizontal ?
            ((y / this.layout.size.height) * 100) + '%' : y + 'px';
    };


    Item.prototype._transitionTo = function(x, y) {
        this.getPosition();
        // get current x & y from top/left
        var curX = this.position.x;
        var curY = this.position.y;

        var compareX = parseInt(x, 10);
        var compareY = parseInt(y, 10);
        var didNotMove = compareX === this.position.x && compareY === this.position.y;

        // save end position
        this.setPosition(x, y);

        // if did not move and not transitioning, just go to layout
        if (didNotMove && !this.isTransitioning) {
            this.layoutPosition();
            return;
        }

        var transX = x - curX;
        var transY = y - curY;
        var transitionStyle = {};
        transitionStyle.transform = this.getTranslate(transX, transY);

        this.transition({
            to: transitionStyle,
            onTransitionEnd: {
                transform: this.layoutPosition
            },
            isCleaning: true
        });
    };

    Item.prototype.getTranslate = function(x, y) {
        // flip cooridinates if origin on right or bottom
        var layoutOptions = this.layout.options;
        x = layoutOptions.isOriginLeft ? x : -x;
        y = layoutOptions.isOriginTop ? y : -y;

        if (is3d) {
            return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
        }

        return 'translate(' + x + 'px, ' + y + 'px)';
    };

    // non transition + transform support
    Item.prototype.goTo = function(x, y) {
        this.setPosition(x, y);
        this.layoutPosition();
    };

    // use transition and transforms if supported
    Item.prototype.moveTo = supportsCSS3 ?
        Item.prototype._transitionTo : Item.prototype.goTo;

    Item.prototype.setPosition = function(x, y) {
        this.position.x = parseInt(x, 10);
        this.position.y = parseInt(y, 10);
    };

    // ----- transition ----- //

    /**
     * @param {Object} style - CSS
     * @param {Function} onTransitionEnd
     */

    // non transition, just trigger callback
    Item.prototype._nonTransition = function(args) {
        this.css(args.to);
        if (args.isCleaning) {
            this._removeStyles(args.to);
        }
        for (var prop in args.onTransitionEnd) {
            args.onTransitionEnd[prop].call(this);
        }
    };

    /**
     * proper transition
     * @param {Object} args - arguments
     *   @param {Object} to - style to transition to
     *   @param {Object} from - style to start transition from
     *   @param {Boolean} isCleaning - removes transition styles after transition
     *   @param {Function} onTransitionEnd - callback
     */
    Item.prototype._transition = function(args) {
        // redirect to nonTransition if no transition duration
        if (!parseFloat(this.layout.options.transitionDuration)) {
            this._nonTransition(args);
            return;
        }

        var _transition = this._transn;
        // keep track of onTransitionEnd callback by css property
        for (var prop in args.onTransitionEnd) {
            _transition.onEnd[prop] = args.onTransitionEnd[prop];
        }
        // keep track of properties that are transitioning
        for (prop in args.to) {
            _transition.ingProperties[prop] = true;
            // keep track of properties to clean up when transition is done
            if (args.isCleaning) {
                _transition.clean[prop] = true;
            }
        }

        // set from styles
        if (args.from) {
            this.css(args.from);
            // force redraw. http://blog.alexmaccaw.com/css-transitions
            var h = this.element.offsetHeight;
            // hack for JSHint to hush about unused var
            h = null;
        }
        // enable transition
        this.enableTransition(args.to);
        // set styles that are transitioning
        this.css(args.to);

        this.isTransitioning = true;

    };

    // dash before all cap letters, including first for
    // WebkitTransform => -webkit-transform
    function toDashedAll(str) {
        return str.replace(/([A-Z])/g, function($1) {
            return '-' + $1.toLowerCase();
        });
    }

    var transitionProps = 'opacity,' +
        toDashedAll(vendorProperties.transform || 'transform');

    Item.prototype.enableTransition = function( /* style */ ) {
        // HACK changing transitionProperty during a transition
        // will cause transition to jump
        if (this.isTransitioning) {
            return;
        }

        // make `transition: foo, bar, baz` from style object
        // HACK un-comment this when enableTransition can work
        // while a transition is happening
        // var transitionValues = [];
        // for ( var prop in style ) {
        //   // dash-ify camelCased properties like WebkitTransition
        //   prop = vendorProperties[ prop ] || prop;
        //   transitionValues.push( toDashedAll( prop ) );
        // }
        // enable transition styles
        this.css({
            transitionProperty: transitionProps,
            transitionDuration: this.layout.options.transitionDuration
        });
        // listen for transition end event
        this.element.addEventListener(transitionEndEvent, this, false);
    };

    Item.prototype.transition = Item.prototype[transitionProperty ? '_transition' : '_nonTransition'];

    // ----- events ----- //

    Item.prototype.onwebkitTransitionEnd = function(event) {
        this.ontransitionend(event);
    };

    Item.prototype.onotransitionend = function(event) {
        this.ontransitionend(event);
    };

    // properties that I munge to make my life easier
    var dashedVendorProperties = {
        '-webkit-transform': 'transform',
        '-moz-transform': 'transform',
        '-o-transform': 'transform'
    };

    Item.prototype.ontransitionend = function(event) {
        // disregard bubbled events from children
        if (event.target !== this.element) {
            return;
        }
        var _transition = this._transn;
        // get property name of transitioned property, convert to prefix-free
        var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;

        // remove property that has completed transitioning
        delete _transition.ingProperties[propertyName];
        // check if any properties are still transitioning
        if (isEmptyObj(_transition.ingProperties)) {
            // all properties have completed transitioning
            this.disableTransition();
        }
        // clean style
        if (propertyName in _transition.clean) {
            // clean up style
            this.element.style[event.propertyName] = '';
            delete _transition.clean[propertyName];
        }
        // trigger onTransitionEnd callback
        if (propertyName in _transition.onEnd) {
            var onTransitionEnd = _transition.onEnd[propertyName];
            onTransitionEnd.call(this);
            delete _transition.onEnd[propertyName];
        }

        this.emitEvent('transitionEnd', [this]);
    };

    Item.prototype.disableTransition = function() {
        this.removeTransitionStyles();
        this.element.removeEventListener(transitionEndEvent, this, false);
        this.isTransitioning = false;
    };

    /**
     * removes style property from element
     * @param {Object} style
     **/
    Item.prototype._removeStyles = function(style) {
        // clean up transition styles
        var cleanStyle = {};
        for (var prop in style) {
            cleanStyle[prop] = '';
        }
        this.css(cleanStyle);
    };

    var cleanTransitionStyle = {
        transitionProperty: '',
        transitionDuration: ''
    };

    Item.prototype.removeTransitionStyles = function() {
        // remove transition
        this.css(cleanTransitionStyle);
    };

    // ----- show/hide/remove ----- //

    // remove element from DOM
    Item.prototype.removeElem = function() {
        this.element.parentNode.removeChild(this.element);
        // remove display: none
        this.css({
            display: ''
        });
        this.emitEvent('remove', [this]);
    };

    Item.prototype.remove = function() {
        // just remove element if no transition support or no transition
        if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {
            this.removeElem();
            return;
        }

        // start transition
        var _this = this;
        this.once('transitionEnd', function() {
            _this.removeElem();
        });
        this.hide();
    };

    Item.prototype.reveal = function() {
        delete this.isHidden;
        // remove display: none
        this.css({
            display: ''
        });

        var options = this.layout.options;

        var onTransitionEnd = {};
        var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
        onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;

        this.transition({
            from: options.hiddenStyle,
            to: options.visibleStyle,
            isCleaning: true,
            onTransitionEnd: onTransitionEnd
        });
    };

    Item.prototype.onRevealTransitionEnd = function() {
        // check if still visible
        // during transition, item may have been hidden
        if (!this.isHidden) {
            this.emitEvent('reveal');
        }
    };

    /**
     * get style property use for hide/reveal transition end
     * @param {String} styleProperty - hiddenStyle/visibleStyle
     * @returns {String}
     */
    Item.prototype.getHideRevealTransitionEndProperty = function(styleProperty) {
        var optionStyle = this.layout.options[styleProperty];
        // use opacity
        if (optionStyle.opacity) {
            return 'opacity';
        }
        // get first property
        for (var prop in optionStyle) {
            return prop;
        }
    };

    Item.prototype.hide = function() {
        // set flag
        this.isHidden = true;
        // remove display: none
        this.css({
            display: ''
        });

        var options = this.layout.options;

        var onTransitionEnd = {};
        var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
        onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;

        this.transition({
            from: options.visibleStyle,
            to: options.hiddenStyle,
            // keep hidden stuff hidden
            isCleaning: true,
            onTransitionEnd: onTransitionEnd
        });
    };

    Item.prototype.onHideTransitionEnd = function() {
        // check if still hidden
        // during transition, item may have been un-hidden
        if (this.isHidden) {
            this.css({
                display: 'none'
            });
            this.emitEvent('hide');
        }
    };

    Item.prototype.destroy = function() {
        this.css({
            position: '',
            left: '',
            right: '',
            top: '',
            bottom: '',
            transition: '',
            transform: ''
        });
    };

    return Item;

}));

/*!
 * Outlayer v1.4.2
 * the brains and guts of a layout library
 * MIT license
 */

(function(window, factory) {
    'use strict';
    // universal module definition

    if (typeof define == 'function' && define.amd) {
        // AMD
        define('outlayer/outlayer', [
                'eventie/eventie',
                'eventEmitter/EventEmitter',
                'get-size/get-size',
                'fizzy-ui-utils/utils',
                './item'
            ],
            function(eventie, EventEmitter, getSize, utils, Item) {
                return factory(window, eventie, EventEmitter, getSize, utils, Item);
            }
        );
    } else if (typeof exports == 'object') {
        // CommonJS
        module.exports = factory(
            window,
            require('eventie'),
            require('wolfy87-eventemitter'),
            require('get-size'),
            require('fizzy-ui-utils'),
            require('./item')
        );
    } else {
        // browser global
        window.Outlayer = factory(
            window,
            window.eventie,
            window.EventEmitter,
            window.getSize,
            window.fizzyUIUtils,
            window.Outlayer.Item
        );
    }

}(window, function factory(window, eventie, EventEmitter, getSize, utils, Item) {
    'use strict';

    // ----- vars ----- //

    var console = window.console;
    var jQuery = window.jQuery;
    var noop = function() {};

    // -------------------------- Outlayer -------------------------- //

    // globally unique identifiers
    var GUID = 0;
    // internal store of all Outlayer intances
    var instances = {};


    /**
     * @param {Element, String} element
     * @param {Object} options
     * @constructor
     */
    function Outlayer(element, options) {
        var queryElement = utils.getQueryElement(element);
        if (!queryElement) {
            if (console) {
                console.error('Bad element for ' + this.constructor.namespace +
                    ': ' + (queryElement || element));
            }
            return;
        }
        this.element = queryElement;
        // add jQuery
        if (jQuery) {
            this.$element = jQuery(this.element);
        }

        // options
        this.options = utils.extend({}, this.constructor.defaults);
        this.option(options);

        // add id for Outlayer.getFromElement
        var id = ++GUID;
        this.element.outlayerGUID = id; // expando
        instances[id] = this; // associate via id

        // kick it off
        this._create();

        if (this.options.isInitLayout) {
            this.layout();
        }
    }

    // settings are for internal use only
    Outlayer.namespace = 'outlayer';
    Outlayer.Item = Item;

    // default options
    Outlayer.defaults = {
        containerStyle: {
            position: 'relative'
        },
        isInitLayout: true,
        isOriginLeft: true,
        isOriginTop: true,
        isResizeBound: true,
        isResizingContainer: true,
        // item options
        transitionDuration: '0.4s',
        hiddenStyle: {
            opacity: 0,
            transform: 'scale(0.001)'
        },
        visibleStyle: {
            opacity: 1,
            transform: 'scale(1)'
        }
    };

    // inherit EventEmitter
    utils.extend(Outlayer.prototype, EventEmitter.prototype);

    /**
     * set options
     * @param {Object} opts
     */
    Outlayer.prototype.option = function(opts) {
        utils.extend(this.options, opts);
    };

    Outlayer.prototype._create = function() {
        // get items from children
        this.reloadItems();
        // elements that affect layout, but are not laid out
        this.stamps = [];
        this.stamp(this.options.stamp);
        // set container style
        utils.extend(this.element.style, this.options.containerStyle);

        // bind resize method
        if (this.options.isResizeBound) {
            this.bindResize();
        }
    };

    // goes through all children again and gets bricks in proper order
    Outlayer.prototype.reloadItems = function() {
        // collection of item elements
        this.items = this._itemize(this.element.children);
    };


    /**
     * turn elements into Outlayer.Items to be used in layout
     * @param {Array or NodeList or HTMLElement} elems
     * @returns {Array} items - collection of new Outlayer Items
     */
    Outlayer.prototype._itemize = function(elems) {

        var itemElems = this._filterFindItemElements(elems);
        var Item = this.constructor.Item;

        // create new Outlayer Items for collection
        var items = [];
        for (var i = 0, len = itemElems.length; i < len; i++) {
            var elem = itemElems[i];
            var item = new Item(elem, this);
            items.push(item);
        }

        return items;
    };

    /**
     * get item elements to be used in layout
     * @param {Array or NodeList or HTMLElement} elems
     * @returns {Array} items - item elements
     */
    Outlayer.prototype._filterFindItemElements = function(elems) {
        return utils.filterFindElements(elems, this.options.itemSelector);
    };

    /**
     * getter method for getting item elements
     * @returns {Array} elems - collection of item elements
     */
    Outlayer.prototype.getItemElements = function() {
        var elems = [];
        for (var i = 0, len = this.items.length; i < len; i++) {
            elems.push(this.items[i].element);
        }
        return elems;
    };

    // ----- init & layout ----- //

    /**
     * lays out all items
     */
    Outlayer.prototype.layout = function() {
        this._resetLayout();
        this._manageStamps();

        // don't animate first layout
        var isInstant = this.options.isLayoutInstant !== undefined ?
            this.options.isLayoutInstant : !this._isLayoutInited;
        this.layoutItems(this.items, isInstant);

        // flag for initalized
        this._isLayoutInited = true;
    };

    // _init is alias for layout
    Outlayer.prototype._init = Outlayer.prototype.layout;

    /**
     * logic before any new layout
     */
    Outlayer.prototype._resetLayout = function() {
        this.getSize();
    };


    Outlayer.prototype.getSize = function() {
        this.size = getSize(this.element);
    };

    /**
     * get measurement from option, for columnWidth, rowHeight, gutter
     * if option is String -> get element from selector string, & get size of element
     * if option is Element -> get size of element
     * else use option as a number
     *
     * @param {String} measurement
     * @param {String} size - width or height
     * @private
     */
    Outlayer.prototype._getMeasurement = function(measurement, size) {
        var option = this.options[measurement];
        var elem;
        if (!option) {
            // default to 0
            this[measurement] = 0;
        } else {
            // use option as an element
            if (typeof option === 'string') {
                elem = this.element.querySelector(option);
            } else if (utils.isElement(option)) {
                elem = option;
            }
            // use size of element, if element
            this[measurement] = elem ? getSize(elem)[size] : option;
        }
    };

    /**
     * layout a collection of item elements
     * @api public
     */
    Outlayer.prototype.layoutItems = function(items, isInstant) {
        items = this._getItemsForLayout(items);

        this._layoutItems(items, isInstant);

        this._postLayout();
    };

    /**
     * get the items to be laid out
     * you may want to skip over some items
     * @param {Array} items
     * @returns {Array} items
     */
    Outlayer.prototype._getItemsForLayout = function(items) {
        var layoutItems = [];
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            if (!item.isIgnored) {
                layoutItems.push(item);
            }
        }
        return layoutItems;
    };

    /**
     * layout items
     * @param {Array} items
     * @param {Boolean} isInstant
     */
    Outlayer.prototype._layoutItems = function(items, isInstant) {
        this._emitCompleteOnItems('layout', items);

        if (!items || !items.length) {
            // no items, emit event with empty array
            return;
        }

        var queue = [];

        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            // get x/y object from method
            var position = this._getItemLayoutPosition(item);
            // enqueue
            position.item = item;
            position.isInstant = isInstant || item.isLayoutInstant;
            queue.push(position);
        }

        this._processLayoutQueue(queue);
    };

    /**
     * get item layout position
     * @param {Outlayer.Item} item
     * @returns {Object} x and y position
     */
    Outlayer.prototype._getItemLayoutPosition = function( /* item */ ) {
        return {
            x: 0,
            y: 0
        };
    };

    /**
     * iterate over array and position each item
     * Reason being - separating this logic prevents 'layout invalidation'
     * thx @paul_irish
     * @param {Array} queue
     */
    Outlayer.prototype._processLayoutQueue = function(queue) {
        for (var i = 0, len = queue.length; i < len; i++) {
            var obj = queue[i];
            this._positionItem(obj.item, obj.x, obj.y, obj.isInstant);
        }
    };

    /**
     * Sets position of item in DOM
     * @param {Outlayer.Item} item
     * @param {Number} x - horizontal position
     * @param {Number} y - vertical position
     * @param {Boolean} isInstant - disables transitions
     */
    Outlayer.prototype._positionItem = function(item, x, y, isInstant) {
        if (isInstant) {
            // if not transition, just set CSS
            item.goTo(x, y);
        } else {
            item.moveTo(x, y);
        }
    };

    /**
     * Any logic you want to do after each layout,
     * i.e. size the container
     */
    Outlayer.prototype._postLayout = function() {
        this.resizeContainer();
    };

    Outlayer.prototype.resizeContainer = function() {
        if (!this.options.isResizingContainer) {
            return;
        }
        var size = this._getContainerSize();
        if (size) {
            this._setContainerMeasure(size.width, true);
            this._setContainerMeasure(size.height, false);
        }
    };

    /**
     * Sets width or height of container if returned
     * @returns {Object} size
     *   @param {Number} width
     *   @param {Number} height
     */
    Outlayer.prototype._getContainerSize = noop;

    /**
     * @param {Number} measure - size of width or height
     * @param {Boolean} isWidth
     */
    Outlayer.prototype._setContainerMeasure = function(measure, isWidth) {
        if (measure === undefined) {
            return;
        }

        var elemSize = this.size;
        // add padding and border width if border box
        if (elemSize.isBorderBox) {
            measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
                elemSize.borderLeftWidth + elemSize.borderRightWidth :
                elemSize.paddingBottom + elemSize.paddingTop +
                elemSize.borderTopWidth + elemSize.borderBottomWidth;
        }

        measure = Math.max(measure, 0);
        this.element.style[isWidth ? 'width' : 'height'] = measure + 'px';
    };

    /**
     * emit eventComplete on a collection of items events
     * @param {String} eventName
     * @param {Array} items - Outlayer.Items
     */
    Outlayer.prototype._emitCompleteOnItems = function(eventName, items) {
        var _this = this;

        function onComplete() {
            _this.dispatchEvent(eventName + 'Complete', null, [items]);
        }

        var count = items.length;
        if (!items || !count) {
            onComplete();
            return;
        }

        var doneCount = 0;

        function tick() {
            doneCount++;
            if (doneCount === count) {
                onComplete();
            }
        }

        // bind callback
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            item.once(eventName, tick);
        }
    };

    /**
     * emits events via eventEmitter and jQuery events
     * @param {String} type - name of event
     * @param {Event} event - original event
     * @param {Array} args - extra arguments
     */
    Outlayer.prototype.dispatchEvent = function(type, event, args) {
        // add original event to arguments
        var emitArgs = event ? [event].concat(args) : args;
        this.emitEvent(type, emitArgs);

        if (jQuery) {
            // set this.$element
            this.$element = this.$element || jQuery(this.element);
            if (event) {
                // create jQuery event
                var $event = jQuery.Event(event);
                $event.type = type;
                this.$element.trigger($event, args);
            } else {
                // just trigger with type if no event available
                this.$element.trigger(type, args);
            }
        }
    };

    // -------------------------- ignore & stamps -------------------------- //


    /**
     * keep item in collection, but do not lay it out
     * ignored items do not get skipped in layout
     * @param {Element} elem
     */
    Outlayer.prototype.ignore = function(elem) {
        var item = this.getItem(elem);
        if (item) {
            item.isIgnored = true;
        }
    };

    /**
     * return item to layout collection
     * @param {Element} elem
     */
    Outlayer.prototype.unignore = function(elem) {
        var item = this.getItem(elem);
        if (item) {
            delete item.isIgnored;
        }
    };

    /**
     * adds elements to stamps
     * @param {NodeList, Array, Element, or String} elems
     */
    Outlayer.prototype.stamp = function(elems) {
        elems = this._find(elems);
        if (!elems) {
            return;
        }

        this.stamps = this.stamps.concat(elems);
        // ignore
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            this.ignore(elem);
        }
    };

    /**
     * removes elements to stamps
     * @param {NodeList, Array, or Element} elems
     */
    Outlayer.prototype.unstamp = function(elems) {
        elems = this._find(elems);
        if (!elems) {
            return;
        }

        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            // filter out removed stamp elements
            utils.removeFrom(this.stamps, elem);
            this.unignore(elem);
        }

    };

    /**
     * finds child elements
     * @param {NodeList, Array, Element, or String} elems
     * @returns {Array} elems
     */
    Outlayer.prototype._find = function(elems) {
        if (!elems) {
            return;
        }
        // if string, use argument as selector string
        if (typeof elems === 'string') {
            elems = this.element.querySelectorAll(elems);
        }
        elems = utils.makeArray(elems);
        return elems;
    };

    Outlayer.prototype._manageStamps = function() {
        if (!this.stamps || !this.stamps.length) {
            return;
        }

        this._getBoundingRect();

        for (var i = 0, len = this.stamps.length; i < len; i++) {
            var stamp = this.stamps[i];
            this._manageStamp(stamp);
        }
    };

    // update boundingLeft / Top
    Outlayer.prototype._getBoundingRect = function() {
        // get bounding rect for container element
        var boundingRect = this.element.getBoundingClientRect();
        var size = this.size;
        this._boundingRect = {
            left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
            top: boundingRect.top + size.paddingTop + size.borderTopWidth,
            right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
            bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)
        };
    };

    /**
     * @param {Element} stamp
     **/
    Outlayer.prototype._manageStamp = noop;

    /**
     * get x/y position of element relative to container element
     * @param {Element} elem
     * @returns {Object} offset - has left, top, right, bottom
     */
    Outlayer.prototype._getElementOffset = function(elem) {
        var boundingRect = elem.getBoundingClientRect();
        var thisRect = this._boundingRect;
        var size = getSize(elem);
        var offset = {
            left: boundingRect.left - thisRect.left - size.marginLeft,
            top: boundingRect.top - thisRect.top - size.marginTop,
            right: thisRect.right - boundingRect.right - size.marginRight,
            bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
        };
        return offset;
    };

    // -------------------------- resize -------------------------- //

    // enable event handlers for listeners
    // i.e. resize -> onresize
    Outlayer.prototype.handleEvent = function(event) {
        var method = 'on' + event.type;
        if (this[method]) {
            this[method](event);
        }
    };

    /**
     * Bind layout to window resizing
     */
    Outlayer.prototype.bindResize = function() {
        // bind just one listener
        if (this.isResizeBound) {
            return;
        }
        eventie.bind(window, 'resize', this);
        this.isResizeBound = true;
    };

    /**
     * Unbind layout to window resizing
     */
    Outlayer.prototype.unbindResize = function() {
        if (this.isResizeBound) {
            eventie.unbind(window, 'resize', this);
        }
        this.isResizeBound = false;
    };

    // original debounce by John Hann
    // http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/

    // this fires every resize
    Outlayer.prototype.onresize = function() {
        if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
        }

        var _this = this;

        function delayed() {
            _this.resize();
            delete _this.resizeTimeout;
        }

        this.resizeTimeout = setTimeout(delayed, 100);
    };

    // debounced, layout on resize
    Outlayer.prototype.resize = function() {
        // don't trigger if size did not change
        // or if resize was unbound. See #9
        if (!this.isResizeBound || !this.needsResizeLayout()) {
            return;
        }

        this.layout();
    };

    /**
     * check if layout is needed post layout
     * @returns Boolean
     */
    Outlayer.prototype.needsResizeLayout = function() {
        var size = getSize(this.element);
        // check that this.size and size are there
        // IE8 triggers resize on body size change, so they might not be
        var hasSizes = this.size && size;
        return hasSizes && size.innerWidth !== this.size.innerWidth;
    };

    // -------------------------- methods -------------------------- //

    /**
     * add items to Outlayer instance
     * @param {Array or NodeList or Element} elems
     * @returns {Array} items - Outlayer.Items
     **/
    Outlayer.prototype.addItems = function(elems) {
        var items = this._itemize(elems);
        // add items to collection
        if (items.length) {
            this.items = this.items.concat(items);
        }
        return items;
    };

    /**
     * Layout newly-appended item elements
     * @param {Array or NodeList or Element} elems
     */
    Outlayer.prototype.appended = function(elems) {
        var items = this.addItems(elems);
        if (!items.length) {
            return;
        }
        // layout and reveal just the new items
        this.layoutItems(items, true);
        this.reveal(items);
    };

    /**
     * Layout prepended elements
     * @param {Array or NodeList or Element} elems
     */
    Outlayer.prototype.prepended = function(elems) {
        var items = this._itemize(elems);
        if (!items.length) {
            return;
        }
        // add items to beginning of collection
        var previousItems = this.items.slice(0);
        this.items = items.concat(previousItems);
        // start new layout
        this._resetLayout();
        this._manageStamps();
        // layout new stuff without transition
        this.layoutItems(items, true);
        this.reveal(items);
        // layout previous items
        this.layoutItems(previousItems);
    };

    /**
     * reveal a collection of items
     * @param {Array of Outlayer.Items} items
     */
    Outlayer.prototype.reveal = function(items) {
        this._emitCompleteOnItems('reveal', items);

        var len = items && items.length;
        for (var i = 0; len && i < len; i++) {
            var item = items[i];
            item.reveal();
        }
    };

    /**
     * hide a collection of items
     * @param {Array of Outlayer.Items} items
     */
    Outlayer.prototype.hide = function(items) {
        this._emitCompleteOnItems('hide', items);

        var len = items && items.length;
        for (var i = 0; len && i < len; i++) {
            var item = items[i];
            item.hide();
        }
    };

    /**
     * reveal item elements
     * @param {Array}, {Element}, {NodeList} items
     */
    Outlayer.prototype.revealItemElements = function(elems) {
        var items = this.getItems(elems);
        this.reveal(items);
    };

    /**
     * hide item elements
     * @param {Array}, {Element}, {NodeList} items
     */
    Outlayer.prototype.hideItemElements = function(elems) {
        var items = this.getItems(elems);
        this.hide(items);
    };

    /**
     * get Outlayer.Item, given an Element
     * @param {Element} elem
     * @param {Function} callback
     * @returns {Outlayer.Item} item
     */
    Outlayer.prototype.getItem = function(elem) {
        // loop through items to get the one that matches
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            if (item.element === elem) {
                // return item
                return item;
            }
        }
    };

    /**
     * get collection of Outlayer.Items, given Elements
     * @param {Array} elems
     * @returns {Array} items - Outlayer.Items
     */
    Outlayer.prototype.getItems = function(elems) {
        elems = utils.makeArray(elems);
        var items = [];
        for (var i = 0, len = elems.length; i < len; i++) {
            var elem = elems[i];
            var item = this.getItem(elem);
            if (item) {
                items.push(item);
            }
        }

        return items;
    };

    /**
     * remove element(s) from instance and DOM
     * @param {Array or NodeList or Element} elems
     */
    Outlayer.prototype.remove = function(elems) {
        var removeItems = this.getItems(elems);

        this._emitCompleteOnItems('remove', removeItems);

        // bail if no items to remove
        if (!removeItems || !removeItems.length) {
            return;
        }

        for (var i = 0, len = removeItems.length; i < len; i++) {
            var item = removeItems[i];
            item.remove();
            // remove item from collection
            utils.removeFrom(this.items, item);
        }
    };

    // ----- destroy ----- //

    // remove and disable Outlayer instance
    Outlayer.prototype.destroy = function() {
        // clean up dynamic styles
        var style = this.element.style;
        style.height = '';
        style.position = '';
        style.width = '';
        // destroy items
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            item.destroy();
        }

        this.unbindResize();

        var id = this.element.outlayerGUID;
        delete instances[id]; // remove reference to instance by id
        delete this.element.outlayerGUID;
        // remove data for jQuery
        if (jQuery) {
            jQuery.removeData(this.element, this.constructor.namespace);
        }

    };

    // -------------------------- data -------------------------- //

    /**
     * get Outlayer instance from element
     * @param {Element} elem
     * @returns {Outlayer}
     */
    Outlayer.data = function(elem) {
        elem = utils.getQueryElement(elem);
        var id = elem && elem.outlayerGUID;
        return id && instances[id];
    };


    // -------------------------- create Outlayer class -------------------------- //

    /**
     * create a layout class
     * @param {String} namespace
     */
    Outlayer.create = function(namespace, options) {
        // sub-class Outlayer
        function Layout() {
            Outlayer.apply(this, arguments);
        }
        // inherit Outlayer prototype, use Object.create if there
        if (Object.create) {
            Layout.prototype = Object.create(Outlayer.prototype);
        } else {
            utils.extend(Layout.prototype, Outlayer.prototype);
        }
        // set contructor, used for namespace and Item
        Layout.prototype.constructor = Layout;

        Layout.defaults = utils.extend({}, Outlayer.defaults);
        // apply new options
        utils.extend(Layout.defaults, options);
        // keep prototype.settings for backwards compatibility (Packery v1.2.0)
        Layout.prototype.settings = {};

        Layout.namespace = namespace;

        Layout.data = Outlayer.data;

        // sub-class Item
        Layout.Item = function LayoutItem() {
            Item.apply(this, arguments);
        };

        Layout.Item.prototype = new Item();

        // -------------------------- declarative -------------------------- //

        utils.htmlInit(Layout, namespace);

        // -------------------------- jQuery bridge -------------------------- //

        // make into jQuery plugin
        if (jQuery && jQuery.bridget) {
            jQuery.bridget(namespace, Layout);
        }

        return Layout;
    };

    // ----- fin ----- //

    // back in global
    Outlayer.Item = Item;

    return Outlayer;

}));


/**
 * Isotope Item
 **/

(function(window, factory) {
    'use strict';
    // universal module definition
    if (typeof define == 'function' && define.amd) {
        // AMD
        define('isotope/js/item', [
                'outlayer/outlayer'
            ],
            factory);
    } else if (typeof exports == 'object') {
        // CommonJS
        module.exports = factory(
            require('outlayer')
        );
    } else {
        // browser global
        window.Isotope = window.Isotope || {};
        window.Isotope.Item = factory(
            window.Outlayer
        );
    }

}(window, function factory(Outlayer) {
    'use strict';

    // -------------------------- Item -------------------------- //

    // sub-class Outlayer Item
    function Item() {
        Outlayer.Item.apply(this, arguments);
    }

    Item.prototype = new Outlayer.Item();

    Item.prototype._create = function() {
        // assign id, used for original-order sorting
        this.id = this.layout.itemGUID++;
        Outlayer.Item.prototype._create.call(this);
        this.sortData = {};
    };

    Item.prototype.updateSortData = function() {
        if (this.isIgnored) {
            return;
        }
        // default sorters
        this.sortData.id = this.id;
        // for backward compatibility
        this.sortData['original-order'] = this.id;
        this.sortData.random = Math.random();
        // go thru getSortData obj and apply the sorters
        var getSortData = this.layout.options.getSortData;
        var sorters = this.layout._sorters;
        for (var key in getSortData) {
            var sorter = sorters[key];
            this.sortData[key] = sorter(this.element, this);
        }
    };

    var _destroy = Item.prototype.destroy;
    Item.prototype.destroy = function() {
        // call super
        _destroy.apply(this, arguments);
        // reset display, #741
        this.css({
            display: ''
        });
    };

    return Item;

}));

/**
 * Isotope LayoutMode
 */

(function(window, factory) {
    'use strict';
    // universal module definition

    if (typeof define == 'function' && define.amd) {
        // AMD
        define('isotope/js/layout-mode', [
                'get-size/get-size',
                'outlayer/outlayer'
            ],
            factory);
    } else if (typeof exports == 'object') {
        // CommonJS
        module.exports = factory(
            require('get-size'),
            require('outlayer')
        );
    } else {
        // browser global
        window.Isotope = window.Isotope || {};
        window.Isotope.LayoutMode = factory(
            window.getSize,
            window.Outlayer
        );
    }

}(window, function factory(getSize, Outlayer) {
    'use strict';

    // layout mode class
    function LayoutMode(isotope) {
        this.isotope = isotope;
        // link properties
        if (isotope) {
            this.options = isotope.options[this.namespace];
            this.element = isotope.element;
            this.items = isotope.filteredItems;
            this.size = isotope.size;
        }
    }

    /**
     * some methods should just defer to default Outlayer method
     * and reference the Isotope instance as `this`
     **/
    (function() {
        var facadeMethods = [
            '_resetLayout',
            '_getItemLayoutPosition',
            '_manageStamp',
            '_getContainerSize',
            '_getElementOffset',
            'needsResizeLayout'
        ];

        for (var i = 0, len = facadeMethods.length; i < len; i++) {
            var methodName = facadeMethods[i];
            LayoutMode.prototype[methodName] = getOutlayerMethod(methodName);
        }

        function getOutlayerMethod(methodName) {
            return function() {
                return Outlayer.prototype[methodName].apply(this.isotope, arguments);
            };
        }
    })();

    // -----  ----- //

    // for horizontal layout modes, check vertical size
    LayoutMode.prototype.needsVerticalResizeLayout = function() {
        // don't trigger if size did not change
        var size = getSize(this.isotope.element);
        // check that this.size and size are there
        // IE8 triggers resize on body size change, so they might not be
        var hasSizes = this.isotope.size && size;
        return hasSizes && size.innerHeight != this.isotope.size.innerHeight;
    };

    // ----- measurements ----- //

    LayoutMode.prototype._getMeasurement = function() {
        this.isotope._getMeasurement.apply(this, arguments);
    };

    LayoutMode.prototype.getColumnWidth = function() {
        this.getSegmentSize('column', 'Width');
    };

    LayoutMode.prototype.getRowHeight = function() {
        this.getSegmentSize('row', 'Height');
    };

    /**
     * get columnWidth or rowHeight
     * segment: 'column' or 'row'
     * size 'Width' or 'Height'
     **/
    LayoutMode.prototype.getSegmentSize = function(segment, size) {
        var segmentName = segment + size;
        var outerSize = 'outer' + size;
        // columnWidth / outerWidth // rowHeight / outerHeight
        this._getMeasurement(segmentName, outerSize);
        // got rowHeight or columnWidth, we can chill
        if (this[segmentName]) {
            return;
        }
        // fall back to item of first element
        var firstItemSize = this.getFirstItemSize();
        this[segmentName] = firstItemSize && firstItemSize[outerSize] ||
            // or size of container
            this.isotope.size['inner' + size];
    };

    LayoutMode.prototype.getFirstItemSize = function() {
        var firstItem = this.isotope.filteredItems[0];
        return firstItem && firstItem.element && getSize(firstItem.element);
    };

    // ----- methods that should reference isotope ----- //

    LayoutMode.prototype.layout = function() {
        this.isotope.layout.apply(this.isotope, arguments);
    };

    LayoutMode.prototype.getSize = function() {
        this.isotope.getSize();
        this.size = this.isotope.size;
    };

    // -------------------------- create -------------------------- //

    LayoutMode.modes = {};

    LayoutMode.create = function(namespace, options) {

        function Mode() {
            LayoutMode.apply(this, arguments);
        }

        Mode.prototype = new LayoutMode();

        // default options
        if (options) {
            Mode.options = options;
        }

        Mode.prototype.namespace = namespace;
        // register in Isotope
        LayoutMode.modes[namespace] = Mode;

        return Mode;
    };

    return LayoutMode;

}));

/*!
 * Masonry v3.3.1
 * Cascading grid layout library
 * http://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */

(function(window, factory) {
    'use strict';
    // universal module definition
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('masonry/masonry', [
                'outlayer/outlayer',
                'get-size/get-size',
                'fizzy-ui-utils/utils'
            ],
            factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        module.exports = factory(
            require('outlayer'),
            require('get-size'),
            require('fizzy-ui-utils')
        );
    } else {
        // browser global
        window.Masonry = factory(
            window.Outlayer,
            window.getSize,
            window.fizzyUIUtils
        );
    }

}(window, function factory(Outlayer, getSize, utils) {



    // -------------------------- masonryDefinition -------------------------- //

    // create an Outlayer layout class
    var Masonry = Outlayer.create('masonry');

    Masonry.prototype._resetLayout = function() {
        this.getSize();
        this._getMeasurement('columnWidth', 'outerWidth');
        this._getMeasurement('gutter', 'outerWidth');
        this.measureColumns();

        // reset column Y
        var i = this.cols;
        this.colYs = [];
        while (i--) {
            this.colYs.push(0);
        }

        this.maxY = 0;
    };

    Masonry.prototype.measureColumns = function() {
        this.getContainerWidth();
        // if columnWidth is 0, default to outerWidth of first item
        if (!this.columnWidth) {
            var firstItem = this.items[0];
            var firstItemElem = firstItem && firstItem.element;
            // columnWidth fall back to item of first element
            this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth ||
                // if first elem has no width, default to size of container
                this.containerWidth;
        }

        var columnWidth = this.columnWidth += this.gutter;

        // calculate columns
        var containerWidth = this.containerWidth + this.gutter;
        var cols = containerWidth / columnWidth;
        // fix rounding errors, typically with gutters
        var excess = columnWidth - containerWidth % columnWidth;
        // if overshoot is less than a pixel, round up, otherwise floor it
        var mathMethod = excess && excess < 1 ? 'round' : 'floor';
        cols = Math[mathMethod](cols);
        this.cols = Math.max(cols, 1);
    };

    Masonry.prototype.getContainerWidth = function() {
        // container is parent if fit width
        var container = this.options.isFitWidth ? this.element.parentNode : this.element;
        // check that this.size and size are there
        // IE8 triggers resize on body size change, so they might not be
        var size = getSize(container);
        this.containerWidth = size && size.innerWidth;
    };

    Masonry.prototype._getItemLayoutPosition = function(item) {
        item.getSize();
        // how many columns does this brick span
        var remainder = item.size.outerWidth % this.columnWidth;
        var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
        // round if off by 1 pixel, otherwise use ceil
        var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
        colSpan = Math.min(colSpan, this.cols);

        var colGroup = this._getColGroup(colSpan);
        // get the minimum Y value from the columns
        var minimumY = Math.min.apply(Math, colGroup);
        var shortColIndex = utils.indexOf(colGroup, minimumY);

        // position the brick
        var position = {
            x: this.columnWidth * shortColIndex,
            y: minimumY
        };

        // apply setHeight to necessary columns
        var setHeight = minimumY + item.size.outerHeight;
        var setSpan = this.cols + 1 - colGroup.length;
        for (var i = 0; i < setSpan; i++) {
            this.colYs[shortColIndex + i] = setHeight;
        }

        return position;
    };

    /**
     * @param {Number} colSpan - number of columns the element spans
     * @returns {Array} colGroup
     */
    Masonry.prototype._getColGroup = function(colSpan) {
        if (colSpan < 2) {
            // if brick spans only one column, use all the column Ys
            return this.colYs;
        }

        var colGroup = [];
        // how many different places could this brick fit horizontally
        var groupCount = this.cols + 1 - colSpan;
        // for each group potential horizontal position
        for (var i = 0; i < groupCount; i++) {
            // make an array of colY values for that one group
            var groupColYs = this.colYs.slice(i, i + colSpan);
            // and get the max value of the array
            colGroup[i] = Math.max.apply(Math, groupColYs);
        }
        return colGroup;
    };

    Masonry.prototype._manageStamp = function(stamp) {
        var stampSize = getSize(stamp);
        var offset = this._getElementOffset(stamp);
        // get the columns that this stamp affects
        var firstX = this.options.isOriginLeft ? offset.left : offset.right;
        var lastX = firstX + stampSize.outerWidth;
        var firstCol = Math.floor(firstX / this.columnWidth);
        firstCol = Math.max(0, firstCol);
        var lastCol = Math.floor(lastX / this.columnWidth);
        // lastCol should not go over if multiple of columnWidth #425
        lastCol -= lastX % this.columnWidth ? 0 : 1;
        lastCol = Math.min(this.cols - 1, lastCol);
        // set colYs to bottom of the stamp
        var stampMaxY = (this.options.isOriginTop ? offset.top : offset.bottom) +
            stampSize.outerHeight;
        for (var i = firstCol; i <= lastCol; i++) {
            this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
        }
    };

    Masonry.prototype._getContainerSize = function() {
        this.maxY = Math.max.apply(Math, this.colYs);
        var size = {
            height: this.maxY
        };

        if (this.options.isFitWidth) {
            size.width = this._getContainerFitWidth();
        }

        return size;
    };

    Masonry.prototype._getContainerFitWidth = function() {
        var unusedCols = 0;
        // count unused columns
        var i = this.cols;
        while (--i) {
            if (this.colYs[i] !== 0) {
                break;
            }
            unusedCols++;
        }
        // fit container to columns that have been used
        return (this.cols - unusedCols) * this.columnWidth - this.gutter;
    };

    Masonry.prototype.needsResizeLayout = function() {
        var previousWidth = this.containerWidth;
        this.getContainerWidth();
        return previousWidth !== this.containerWidth;
    };

    return Masonry;

}));

/*!
 * Masonry layout mode
 * sub-classes Masonry
 * http://masonry.desandro.com
 */

(function(window, factory) {
    'use strict';
    // universal module definition
    if (typeof define == 'function' && define.amd) {
        // AMD
        define('isotope/js/layout-modes/masonry', [
                '../layout-mode',
                'masonry/masonry'
            ],
            factory);
    } else if (typeof exports == 'object') {
        // CommonJS
        module.exports = factory(
            require('../layout-mode'),
            require('masonry-layout')
        );
    } else {
        // browser global
        factory(
            window.Isotope.LayoutMode,
            window.Masonry
        );
    }

}(window, function factory(LayoutMode, Masonry) {
    'use strict';

    // -------------------------- helpers -------------------------- //

    // extend objects
    function extend(a, b) {
        for (var prop in b) {
            a[prop] = b[prop];
        }
        return a;
    }

    // -------------------------- masonryDefinition -------------------------- //

    // create an Outlayer layout class
    var MasonryMode = LayoutMode.create('masonry');

    // save on to these methods
    var _getElementOffset = MasonryMode.prototype._getElementOffset;
    var layout = MasonryMode.prototype.layout;
    var _getMeasurement = MasonryMode.prototype._getMeasurement;

    // sub-class Masonry
    extend(MasonryMode.prototype, Masonry.prototype);

    // set back, as it was overwritten by Masonry
    MasonryMode.prototype._getElementOffset = _getElementOffset;
    MasonryMode.prototype.layout = layout;
    MasonryMode.prototype._getMeasurement = _getMeasurement;

    var measureColumns = MasonryMode.prototype.measureColumns;
    MasonryMode.prototype.measureColumns = function() {
        // set items, used if measuring first item
        this.items = this.isotope.filteredItems;
        measureColumns.call(this);
    };

    // HACK copy over isOriginLeft/Top options
    var _manageStamp = MasonryMode.prototype._manageStamp;
    MasonryMode.prototype._manageStamp = function() {
        this.options.isOriginLeft = this.isotope.options.isOriginLeft;
        this.options.isOriginTop = this.isotope.options.isOriginTop;
        _manageStamp.apply(this, arguments);
    };

    return MasonryMode;

}));

/**
 * fitRows layout mode
 */

(function(window, factory) {
    'use strict';
    // universal module definition
    if (typeof define == 'function' && define.amd) {
        // AMD
        define('isotope/js/layout-modes/fit-rows', [
                '../layout-mode'
            ],
            factory);
    } else if (typeof exports == 'object') {
        // CommonJS
        module.exports = factory(
            require('../layout-mode')
        );
    } else {
        // browser global
        factory(
            window.Isotope.LayoutMode
        );
    }

}(window, function factory(LayoutMode) {
    'use strict';

    var FitRows = LayoutMode.create('fitRows');

    FitRows.prototype._resetLayout = function() {
        this.x = 0;
        this.y = 0;
        this.maxY = 0;
        this._getMeasurement('gutter', 'outerWidth');
    };

    FitRows.prototype._getItemLayoutPosition = function(item) {
        item.getSize();

        var itemWidth = item.size.outerWidth + this.gutter;
        // if this element cannot fit in the current row
        var containerWidth = this.isotope.size.innerWidth + this.gutter;
        if (this.x !== 0 && itemWidth + this.x > containerWidth) {
            this.x = 0;
            this.y = this.maxY;
        }

        var position = {
            x: this.x,
            y: this.y
        };

        this.maxY = Math.max(this.maxY, this.y + item.size.outerHeight);
        this.x += itemWidth;

        return position;
    };

    FitRows.prototype._getContainerSize = function() {
        return {
            height: this.maxY
        };
    };

    return FitRows;

}));

/**
 * vertical layout mode
 */

(function(window, factory) {
    'use strict';
    // universal module definition
    if (typeof define == 'function' && define.amd) {
        // AMD
        define('isotope/js/layout-modes/vertical', [
                '../layout-mode'
            ],
            factory);
    } else if (typeof exports == 'object') {
        // CommonJS
        module.exports = factory(
            require('../layout-mode')
        );
    } else {
        // browser global
        factory(
            window.Isotope.LayoutMode
        );
    }

}(window, function factory(LayoutMode) {
    'use strict';

    var Vertical = LayoutMode.create('vertical', {
        horizontalAlignment: 0
    });

    Vertical.prototype._resetLayout = function() {
        this.y = 0;
    };

    Vertical.prototype._getItemLayoutPosition = function(item) {
        item.getSize();
        var x = (this.isotope.size.innerWidth - item.size.outerWidth) *
            this.options.horizontalAlignment;
        var y = this.y;
        this.y += item.size.outerHeight;
        return {
            x: x,
            y: y
        };
    };

    Vertical.prototype._getContainerSize = function() {
        return {
            height: this.y
        };
    };

    return Vertical;

}));

/*!
 * Isotope v2.2.2
 *
 * Licensed GPLv3 for open source use
 * or Isotope Commercial License for commercial use
 *
 * http://isotope.metafizzy.co
 * Copyright 2015 Metafizzy
 */

(function(window, factory) {
    'use strict';
    // universal module definition

    if (typeof define == 'function' && define.amd) {
        // AMD
        define([
                'outlayer/outlayer',
                'get-size/get-size',
                'matches-selector/matches-selector',
                'fizzy-ui-utils/utils',
                'isotope/js/item',
                'isotope/js/layout-mode',
                // include default layout modes
                'isotope/js/layout-modes/masonry',
                'isotope/js/layout-modes/fit-rows',
                'isotope/js/layout-modes/vertical'
            ],
            function(Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {
                return factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode);
            });
    } else if (typeof exports == 'object') {
        // CommonJS
        module.exports = factory(
            window,
            require('outlayer'),
            require('get-size'),
            require('desandro-matches-selector'),
            require('fizzy-ui-utils'),
            require('./item'),
            require('./layout-mode'),
            // include default layout modes
            require('./layout-modes/masonry'),
            require('./layout-modes/fit-rows'),
            require('./layout-modes/vertical')
        );
    } else {
        // browser global
        window.Isotope = factory(
            window,
            window.Outlayer,
            window.getSize,
            window.matchesSelector,
            window.fizzyUIUtils,
            window.Isotope.Item,
            window.Isotope.LayoutMode
        );
    }

}(window, function factory(window, Outlayer, getSize, matchesSelector, utils,
    Item, LayoutMode) {



    // -------------------------- vars -------------------------- //

    var jQuery = window.jQuery;

    // -------------------------- helpers -------------------------- //

    var trim = String.prototype.trim ?
        function(str) {
            return str.trim();
        } :
        function(str) {
            return str.replace(/^\s+|\s+$/g, '');
        };

    var docElem = document.documentElement;

    var getText = docElem.textContent ?
        function(elem) {
            return elem.textContent;
        } :
        function(elem) {
            return elem.innerText;
        };

    // -------------------------- isotopeDefinition -------------------------- //

    // create an Outlayer layout class
    var Isotope = Outlayer.create('isotope', {
        layoutMode: "masonry",
        isJQueryFiltering: true,
        sortAscending: true
    });

    Isotope.Item = Item;
    Isotope.LayoutMode = LayoutMode;

    Isotope.prototype._create = function() {
        this.itemGUID = 0;
        // functions that sort items
        this._sorters = {};
        this._getSorters();
        // call super
        Outlayer.prototype._create.call(this);

        // create layout modes
        this.modes = {};
        // start filteredItems with all items
        this.filteredItems = this.items;
        // keep of track of sortBys
        this.sortHistory = ['original-order'];
        // create from registered layout modes
        for (var name in LayoutMode.modes) {
            this._initLayoutMode(name);
        }
    };

    Isotope.prototype.reloadItems = function() {
        // reset item ID counter
        this.itemGUID = 0;
        // call super
        Outlayer.prototype.reloadItems.call(this);
    };

    Isotope.prototype._itemize = function() {
        var items = Outlayer.prototype._itemize.apply(this, arguments);
        // assign ID for original-order
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            item.id = this.itemGUID++;
        }
        this._updateItemsSortData(items);
        return items;
    };


    // -------------------------- layout -------------------------- //

    Isotope.prototype._initLayoutMode = function(name) {
        var Mode = LayoutMode.modes[name];
        // set mode options
        // HACK extend initial options, back-fill in default options
        var initialOpts = this.options[name] || {};
        this.options[name] = Mode.options ?
            utils.extend(Mode.options, initialOpts) : initialOpts;
        // init layout mode instance
        this.modes[name] = new Mode(this);
    };


    Isotope.prototype.layout = function() {
        // if first time doing layout, do all magic
        if (!this._isLayoutInited && this.options.isInitLayout) {
            this.arrange();
            return;
        }
        this._layout();
    };

    // private method to be used in layout() & magic()
    Isotope.prototype._layout = function() {
        // don't animate first layout
        var isInstant = this._getIsInstant();
        // layout flow
        this._resetLayout();
        this._manageStamps();
        this.layoutItems(this.filteredItems, isInstant);

        // flag for initalized
        this._isLayoutInited = true;
    };

    // filter + sort + layout
    Isotope.prototype.arrange = function(opts) {
        // set any options pass
        this.option(opts);
        this._getIsInstant();
        // filter, sort, and layout

        // filter
        var filtered = this._filter(this.items);
        this.filteredItems = filtered.matches;

        var _this = this;

        function hideReveal() {
            _this.reveal(filtered.needReveal);
            _this.hide(filtered.needHide);
        }

        this._bindArrangeComplete();

        if (this._isInstant) {
            this._noTransition(hideReveal);
        } else {
            hideReveal();
        }

        this._sort();
        this._layout();
    };
    // alias to _init for main plugin method
    Isotope.prototype._init = Isotope.prototype.arrange;

    // HACK
    // Don't animate/transition first layout
    // Or don't animate/transition other layouts
    Isotope.prototype._getIsInstant = function() {
        var isInstant = this.options.isLayoutInstant !== undefined ?
            this.options.isLayoutInstant : !this._isLayoutInited;
        this._isInstant = isInstant;
        return isInstant;
    };

    // listen for layoutComplete, hideComplete and revealComplete
    // to trigger arrangeComplete
    Isotope.prototype._bindArrangeComplete = function() {
        // listen for 3 events to trigger arrangeComplete
        var isLayoutComplete, isHideComplete, isRevealComplete;
        var _this = this;

        function arrangeParallelCallback() {
            if (isLayoutComplete && isHideComplete && isRevealComplete) {
                _this.dispatchEvent('arrangeComplete', null, [_this.filteredItems]);
            }
        }
        this.once('layoutComplete', function() {
            isLayoutComplete = true;
            arrangeParallelCallback();
        });
        this.once('hideComplete', function() {
            isHideComplete = true;
            arrangeParallelCallback();
        });
        this.once('revealComplete', function() {
            isRevealComplete = true;
            arrangeParallelCallback();
        });
    };

    // -------------------------- filter -------------------------- //

    Isotope.prototype._filter = function(items) {
        var filter = this.options.filter;
        filter = filter || '*';
        var matches = [];
        var hiddenMatched = [];
        var visibleUnmatched = [];

        var test = this._getFilterTest(filter);

        // test each item
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            if (item.isIgnored) {
                continue;
            }
            // add item to either matched or unmatched group
            var isMatched = test(item);
            // item.isFilterMatched = isMatched;
            // add to matches if its a match
            if (isMatched) {
                matches.push(item);
            }
            // add to additional group if item needs to be hidden or revealed
            if (isMatched && item.isHidden) {
                hiddenMatched.push(item);
            } else if (!isMatched && !item.isHidden) {
                visibleUnmatched.push(item);
            }
        }

        // return collections of items to be manipulated
        return {
            matches: matches,
            needReveal: hiddenMatched,
            needHide: visibleUnmatched
        };
    };

    // get a jQuery, function, or a matchesSelector test given the filter
    Isotope.prototype._getFilterTest = function(filter) {
        if (jQuery && this.options.isJQueryFiltering) {
            // use jQuery
            return function(item) {
                return jQuery(item.element).is(filter);
            };
        }
        if (typeof filter == 'function') {
            // use filter as function
            return function(item) {
                return filter(item.element);
            };
        }
        // default, use filter as selector string
        return function(item) {
            return matchesSelector(item.element, filter);
        };
    };

    // -------------------------- sorting -------------------------- //

    /**
     * @params {Array} elems
     * @public
     */
    Isotope.prototype.updateSortData = function(elems) {
        // get items
        var items;
        if (elems) {
            elems = utils.makeArray(elems);
            items = this.getItems(elems);
        } else {
            // update all items if no elems provided
            items = this.items;
        }

        this._getSorters();
        this._updateItemsSortData(items);
    };

    Isotope.prototype._getSorters = function() {
        var getSortData = this.options.getSortData;
        for (var key in getSortData) {
            var sorter = getSortData[key];
            this._sorters[key] = mungeSorter(sorter);
        }
    };

    /**
     * @params {Array} items - of Isotope.Items
     * @private
     */
    Isotope.prototype._updateItemsSortData = function(items) {
        // do not update if no items
        var len = items && items.length;

        for (var i = 0; len && i < len; i++) {
            var item = items[i];
            item.updateSortData();
        }
    };

    // ----- munge sorter ----- //

    // encapsulate this, as we just need mungeSorter
    // other functions in here are just for munging
    var mungeSorter = (function() {
        // add a magic layer to sorters for convienent shorthands
        // `.foo-bar` will use the text of .foo-bar querySelector
        // `[foo-bar]` will use attribute
        // you can also add parser
        // `.foo-bar parseInt` will parse that as a number
        function mungeSorter(sorter) {
            // if not a string, return function or whatever it is
            if (typeof sorter != 'string') {
                return sorter;
            }
            // parse the sorter string
            var args = trim(sorter).split(' ');
            var query = args[0];
            // check if query looks like [an-attribute]
            var attrMatch = query.match(/^\[(.+)\]$/);
            var attr = attrMatch && attrMatch[1];
            var getValue = getValueGetter(attr, query);
            // use second argument as a parser
            var parser = Isotope.sortDataParsers[args[1]];
            // parse the value, if there was a parser
            sorter = parser ? function(elem) {
                    return elem && parser(getValue(elem));
                } :
                // otherwise just return value
                function(elem) {
                    return elem && getValue(elem);
                };

            return sorter;
        }

        // get an attribute getter, or get text of the querySelector
        function getValueGetter(attr, query) {
            var getValue;
            // if query looks like [foo-bar], get attribute
            if (attr) {
                getValue = function(elem) {
                    return elem.getAttribute(attr);
                };
            } else {
                // otherwise, assume its a querySelector, and get its text
                getValue = function(elem) {
                    var child = elem.querySelector(query);
                    return child && getText(child);
                };
            }
            return getValue;
        }

        return mungeSorter;
    })();

    // parsers used in getSortData shortcut strings
    Isotope.sortDataParsers = {
        'parseInt': function(val) {
            return parseInt(val, 10);
        },
        'parseFloat': function(val) {
            return parseFloat(val);
        }
    };

    // ----- sort method ----- //

    // sort filteredItem order
    Isotope.prototype._sort = function() {
        var sortByOpt = this.options.sortBy;
        if (!sortByOpt) {
            return;
        }
        // concat all sortBy and sortHistory
        var sortBys = [].concat.apply(sortByOpt, this.sortHistory);
        // sort magic
        var itemSorter = getItemSorter(sortBys, this.options.sortAscending);
        this.filteredItems.sort(itemSorter);
        // keep track of sortBy History
        if (sortByOpt != this.sortHistory[0]) {
            // add to front, oldest goes in last
            this.sortHistory.unshift(sortByOpt);
        }
    };

    // returns a function used for sorting
    function getItemSorter(sortBys, sortAsc) {
        return function sorter(itemA, itemB) {
            // cycle through all sortKeys
            for (var i = 0, len = sortBys.length; i < len; i++) {
                var sortBy = sortBys[i];
                var a = itemA.sortData[sortBy];
                var b = itemB.sortData[sortBy];
                if (a > b || a < b) {
                    // if sortAsc is an object, use the value given the sortBy key
                    var isAscending = sortAsc[sortBy] !== undefined ? sortAsc[sortBy] : sortAsc;
                    var direction = isAscending ? 1 : -1;
                    return (a > b ? 1 : -1) * direction;
                }
            }
            return 0;
        };
    }

    // -------------------------- methods -------------------------- //

    // get layout mode
    Isotope.prototype._mode = function() {
        var layoutMode = this.options.layoutMode;
        var mode = this.modes[layoutMode];
        if (!mode) {
            // TODO console.error
            throw new Error('No layout mode: ' + layoutMode);
        }
        // HACK sync mode's options
        // any options set after init for layout mode need to be synced
        mode.options = this.options[layoutMode];
        return mode;
    };

    Isotope.prototype._resetLayout = function() {
        // trigger original reset layout
        Outlayer.prototype._resetLayout.call(this);
        this._mode()._resetLayout();
    };

    Isotope.prototype._getItemLayoutPosition = function(item) {
        return this._mode()._getItemLayoutPosition(item);
    };

    Isotope.prototype._manageStamp = function(stamp) {
        this._mode()._manageStamp(stamp);
    };

    Isotope.prototype._getContainerSize = function() {
        return this._mode()._getContainerSize();
    };

    Isotope.prototype.needsResizeLayout = function() {
        return this._mode().needsResizeLayout();
    };

    // -------------------------- adding & removing -------------------------- //

    // HEADS UP overwrites default Outlayer appended
    Isotope.prototype.appended = function(elems) {
        var items = this.addItems(elems);
        if (!items.length) {
            return;
        }
        // filter, layout, reveal new items
        var filteredItems = this._filterRevealAdded(items);
        // add to filteredItems
        this.filteredItems = this.filteredItems.concat(filteredItems);
    };

    // HEADS UP overwrites default Outlayer prepended
    Isotope.prototype.prepended = function(elems) {
        var items = this._itemize(elems);
        if (!items.length) {
            return;
        }
        // start new layout
        this._resetLayout();
        this._manageStamps();
        // filter, layout, reveal new items
        var filteredItems = this._filterRevealAdded(items);
        // layout previous items
        this.layoutItems(this.filteredItems);
        // add to items and filteredItems
        this.filteredItems = filteredItems.concat(this.filteredItems);
        this.items = items.concat(this.items);
    };

    Isotope.prototype._filterRevealAdded = function(items) {
        var filtered = this._filter(items);
        this.hide(filtered.needHide);
        // reveal all new items
        this.reveal(filtered.matches);
        // layout new items, no transition
        this.layoutItems(filtered.matches, true);
        return filtered.matches;
    };

    /**
     * Filter, sort, and layout newly-appended item elements
     * @param {Array or NodeList or Element} elems
     */
    Isotope.prototype.insert = function(elems) {
        var items = this.addItems(elems);
        if (!items.length) {
            return;
        }
        // append item elements
        var i, item;
        var len = items.length;
        for (i = 0; i < len; i++) {
            item = items[i];
            this.element.appendChild(item.element);
        }
        // filter new stuff
        var filteredInsertItems = this._filter(items).matches;
        // set flag
        for (i = 0; i < len; i++) {
            items[i].isLayoutInstant = true;
        }
        this.arrange();
        // reset flag
        for (i = 0; i < len; i++) {
            delete items[i].isLayoutInstant;
        }
        this.reveal(filteredInsertItems);
    };

    var _remove = Isotope.prototype.remove;
    Isotope.prototype.remove = function(elems) {
        elems = utils.makeArray(elems);
        var removeItems = this.getItems(elems);
        // do regular thing
        _remove.call(this, elems);
        // bail if no items to remove
        var len = removeItems && removeItems.length;
        if (!len) {
            return;
        }
        // remove elems from filteredItems
        for (var i = 0; i < len; i++) {
            var item = removeItems[i];
            // remove item from collection
            utils.removeFrom(this.filteredItems, item);
        }
    };

    Isotope.prototype.shuffle = function() {
        // update random sortData
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            item.sortData.random = Math.random();
        }
        this.options.sortBy = 'random';
        this._sort();
        this._layout();
    };

    /**
     * trigger fn without transition
     * kind of hacky to have this in the first place
     * @param {Function} fn
     * @returns ret
     * @private
     */
    Isotope.prototype._noTransition = function(fn) {
        // save transitionDuration before disabling
        var transitionDuration = this.options.transitionDuration;
        // disable transition
        this.options.transitionDuration = 0;
        // do it
        var returnValue = fn.call(this);
        // re-enable transition for reveal
        this.options.transitionDuration = transitionDuration;
        return returnValue;
    };

    // ----- helper methods ----- //

    /**
     * getter method for getting filtered item elements
     * @returns {Array} elems - collection of item elements
     */
    Isotope.prototype.getFilteredItemElements = function() {
        var elems = [];
        for (var i = 0, len = this.filteredItems.length; i < len; i++) {
            elems.push(this.filteredItems[i].element);
        }
        return elems;
    };

    // -----  ----- //

    return Isotope;

}));


/*!
 * imagesLoaded PACKAGED v3.1.8
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */


/*!
 * EventEmitter v4.2.6 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function() {


    /**
     * Class for managing events.
     * Can be extended to provide event functionality in other classes.
     *
     * @class EventEmitter Manages event registering and emitting.
     */
    function EventEmitter() {}

    // Shortcuts to improve speed and size
    var proto = EventEmitter.prototype;
    var exports = this;
    var originalGlobalValue = exports.EventEmitter;

    /**
     * Finds the index of the listener for the event in it's storage array.
     *
     * @param {Function[]} listeners Array of listeners to search through.
     * @param {Function} listener Method to look for.
     * @return {Number} Index of the specified listener, -1 if not found
     * @api private
     */
    function indexOfListener(listeners, listener) {
        var i = listeners.length;
        while (i--) {
            if (listeners[i].listener === listener) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Alias a method while keeping the context correct, to allow for overwriting of target method.
     *
     * @param {String} name The name of the target method.
     * @return {Function} The aliased method
     * @api private
     */
    function alias(name) {
        return function aliasClosure() {
            return this[name].apply(this, arguments);
        };
    }

    /**
     * Returns the listener array for the specified event.
     * Will initialise the event object and listener arrays if required.
     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
     * Each property in the object response is an array of listener functions.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Function[]|Object} All listener functions for the event.
     */
    proto.getListeners = function getListeners(evt) {
        var events = this._getEvents();
        var response;
        var key;

        // Return a concatenated array of all matching events if
        // the selector is a regular expression.
        if (typeof evt === 'object') {
            response = {};
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    response[key] = events[key];
                }
            }
        } else {
            response = events[evt] || (events[evt] = []);
        }

        return response;
    };

    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */
    proto.flattenListeners = function flattenListeners(listeners) {
        var flatListeners = [];
        var i;

        for (i = 0; i < listeners.length; i += 1) {
            flatListeners.push(listeners[i].listener);
        }

        return flatListeners;
    };

    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */
    proto.getListenersAsObject = function getListenersAsObject(evt) {
        var listeners = this.getListeners(evt);
        var response;

        if (listeners instanceof Array) {
            response = {};
            response[evt] = listeners;
        }

        return response || listeners;
    };

    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListener = function addListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var listenerIsWrapped = typeof listener === 'object';
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
                listeners[key].push(listenerIsWrapped ? listener : {
                    listener: listener,
                    once: false
                });
            }
        }

        return this;
    };

    /**
     * Alias of addListener
     */
    proto.on = alias('addListener');

    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after it's first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addOnceListener = function addOnceListener(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: true
        });
    };

    /**
     * Alias of addOnceListener.
     */
    proto.once = alias('addOnceListener');

    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvent = function defineEvent(evt) {
        this.getListeners(evt);
        return this;
    };

    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.defineEvents = function defineEvents(evts) {
        for (var i = 0; i < evts.length; i += 1) {
            this.defineEvent(evts[i]);
        }
        return this;
    };

    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListener = function removeListener(evt, listener) {
        var listeners = this.getListenersAsObject(evt);
        var index;
        var key;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                index = indexOfListener(listeners[key], listener);

                if (index !== -1) {
                    listeners[key].splice(index, 1);
                }
            }
        }

        return this;
    };

    /**
     * Alias of removeListener
     */
    proto.off = alias('removeListener');

    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.addListeners = function addListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(false, evt, listeners);
    };

    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeListeners = function removeListeners(evt, listeners) {
        // Pass through to manipulateListeners
        return this.manipulateListeners(true, evt, listeners);
    };

    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
        var i;
        var value;
        var single = remove ? this.removeListener : this.addListener;
        var multiple = remove ? this.removeListeners : this.addListeners;

        // If evt is an object then pass each of it's properties to this method
        if (typeof evt === 'object' && !(evt instanceof RegExp)) {
            for (i in evt) {
                if (evt.hasOwnProperty(i) && (value = evt[i])) {
                    // Pass the single listener straight through to the singular method
                    if (typeof value === 'function') {
                        single.call(this, i, value);
                    } else {
                        // Otherwise pass back to the multiple function
                        multiple.call(this, i, value);
                    }
                }
            }
        } else {
            // So evt must be a string
            // And listeners must be an array of listeners
            // Loop over it and pass each one to the multiple method
            i = listeners.length;
            while (i--) {
                single.call(this, evt, listeners[i]);
            }
        }

        return this;
    };

    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.removeEvent = function removeEvent(evt) {
        var type = typeof evt;
        var events = this._getEvents();
        var key;

        // Remove different things depending on the state of evt
        if (type === 'string') {
            // Remove all listeners for the specified event
            delete events[evt];
        } else if (type === 'object') {
            // Remove all events matching the regex.
            for (key in events) {
                if (events.hasOwnProperty(key) && evt.test(key)) {
                    delete events[key];
                }
            }
        } else {
            // Remove all listeners in all events
            delete this._events;
        }

        return this;
    };

    /**
     * Alias of removeEvent.
     *
     * Added to mirror the node API.
     */
    proto.removeAllListeners = alias('removeEvent');

    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emitEvent = function emitEvent(evt, args) {
        var listeners = this.getListenersAsObject(evt);
        var listener;
        var i;
        var key;
        var response;

        for (key in listeners) {
            if (listeners.hasOwnProperty(key)) {
                i = listeners[key].length;

                while (i--) {
                    // If the listener returns true then it shall be removed from the event
                    // The function is executed either with a basic call or an apply if there is an args array
                    listener = listeners[key][i];

                    if (listener.once === true) {
                        this.removeListener(evt, listener.listener);
                    }

                    response = listener.listener.apply(this, args || []);

                    if (response === this._getOnceReturnValue()) {
                        this.removeListener(evt, listener.listener);
                    }
                }
            }
        }

        return this;
    };

    /**
     * Alias of emitEvent
     */
    proto.trigger = alias('emitEvent');

    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.emit = function emit(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args);
    };

    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */
    proto.setOnceReturnValue = function setOnceReturnValue(value) {
        this._onceReturnValue = value;
        return this;
    };

    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @api private
     */
    proto._getOnceReturnValue = function _getOnceReturnValue() {
        if (this.hasOwnProperty('_onceReturnValue')) {
            return this._onceReturnValue;
        } else {
            return true;
        }
    };

    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @api private
     */
    proto._getEvents = function _getEvents() {
        return this._events || (this._events = {});
    };

    /**
     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
     *
     * @return {Function} Non conflicting EventEmitter class.
     */
    EventEmitter.noConflict = function noConflict() {
        exports.EventEmitter = originalGlobalValue;
        return EventEmitter;
    };

    // Expose the class either via AMD, CommonJS or the global object
    if (typeof define === 'function' && define.amd) {
        define('eventEmitter/EventEmitter', [], function() {
            return EventEmitter;
        });
    } else if (typeof module === 'object' && module.exports) {
        module.exports = EventEmitter;
    } else {
        this.EventEmitter = EventEmitter;
    }
}.call(this));

/*!
 * eventie v1.0.4
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false */

(function(window) {



    var docElem = document.documentElement;

    var bind = function() {};

    function getIEEvent(obj) {
        var event = window.event;
        // add event.target
        event.target = event.target || event.srcElement || obj;
        return event;
    }

    if (docElem.addEventListener) {
        bind = function(obj, type, fn) {
            obj.addEventListener(type, fn, false);
        };
    } else if (docElem.attachEvent) {
        bind = function(obj, type, fn) {
            obj[type + fn] = fn.handleEvent ?
                function() {
                    var event = getIEEvent(obj);
                    fn.handleEvent.call(fn, event);
                } :
                function() {
                    var event = getIEEvent(obj);
                    fn.call(obj, event);
                };
            obj.attachEvent("on" + type, obj[type + fn]);
        };
    }

    var unbind = function() {};

    if (docElem.removeEventListener) {
        unbind = function(obj, type, fn) {
            obj.removeEventListener(type, fn, false);
        };
    } else if (docElem.detachEvent) {
        unbind = function(obj, type, fn) {
            obj.detachEvent("on" + type, obj[type + fn]);
            try {
                delete obj[type + fn];
            } catch (err) {
                // can't delete window object properties
                obj[type + fn] = undefined;
            }
        };
    }

    var eventie = {
        bind: bind,
        unbind: unbind
    };

    // transport
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('eventie/eventie', eventie);
    } else {
        // browser global
        window.eventie = eventie;
    }

})(this);

/*!
 * imagesLoaded v3.1.8
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

(function(window, factory) {
    // universal module definition

    /*global define: false, module: false, require: false */

    if (typeof define === 'function' && define.amd) {
        // AMD
        define([
            'eventEmitter/EventEmitter',
            'eventie/eventie'
        ], function(EventEmitter, eventie) {
            return factory(window, EventEmitter, eventie);
        });
    } else if (typeof exports === 'object') {
        // CommonJS
        module.exports = factory(
            window,
            require('wolfy87-eventemitter'),
            require('eventie')
        );
    } else {
        // browser global
        window.imagesLoaded = factory(
            window,
            window.EventEmitter,
            window.eventie
        );
    }

})(window,

    // --------------------------  factory -------------------------- //

    function factory(window, EventEmitter, eventie) {



        var $ = window.jQuery;
        var console = window.console;
        var hasConsole = typeof console !== 'undefined';

        // -------------------------- helpers -------------------------- //

        // extend objects
        function extend(a, b) {
            for (var prop in b) {
                a[prop] = b[prop];
            }
            return a;
        }

        var objToString = Object.prototype.toString;

        function isArray(obj) {
            return objToString.call(obj) === '[object Array]';
        }

        // turn element or nodeList into an array
        function makeArray(obj) {
            var ary = [];
            if (isArray(obj)) {
                // use object if already an array
                ary = obj;
            } else if (typeof obj.length === 'number') {
                // convert nodeList to array
                for (var i = 0, len = obj.length; i < len; i++) {
                    ary.push(obj[i]);
                }
            } else {
                // array of single index
                ary.push(obj);
            }
            return ary;
        }

        // -------------------------- imagesLoaded -------------------------- //

        /**
         * @param {Array, Element, NodeList, String} elem
         * @param {Object or Function} options - if function, use as callback
         * @param {Function} onAlways - callback function
         */
        function ImagesLoaded(elem, options, onAlways) {
            // coerce ImagesLoaded() without new, to be new ImagesLoaded()
            if (!(this instanceof ImagesLoaded)) {
                return new ImagesLoaded(elem, options);
            }
            // use elem as selector string
            if (typeof elem === 'string') {
                elem = document.querySelectorAll(elem);
            }

            this.elements = makeArray(elem);
            this.options = extend({}, this.options);

            if (typeof options === 'function') {
                onAlways = options;
            } else {
                extend(this.options, options);
            }

            if (onAlways) {
                this.on('always', onAlways);
            }

            this.getImages();

            if ($) {
                // add jQuery Deferred object
                this.jqDeferred = new $.Deferred();
            }

            // HACK check async to allow time to bind listeners
            var _this = this;
            setTimeout(function() {
                _this.check();
            });
        }

        ImagesLoaded.prototype = new EventEmitter();

        ImagesLoaded.prototype.options = {};

        ImagesLoaded.prototype.getImages = function() {
            this.images = [];

            // filter & find items if we have an item selector
            for (var i = 0, len = this.elements.length; i < len; i++) {
                var elem = this.elements[i];
                // filter siblings
                if (elem.nodeName === 'IMG') {
                    this.addImage(elem);
                }
                // find children
                // no non-element nodes, #143
                var nodeType = elem.nodeType;
                if (!nodeType || !(nodeType === 1 || nodeType === 9 || nodeType === 11)) {
                    continue;
                }
                var childElems = elem.querySelectorAll('img');
                // concat childElems to filterFound array
                for (var j = 0, jLen = childElems.length; j < jLen; j++) {
                    var img = childElems[j];
                    this.addImage(img);
                }
            }
        };

        /**
         * @param {Image} img
         */
        ImagesLoaded.prototype.addImage = function(img) {
            var loadingImage = new LoadingImage(img);
            this.images.push(loadingImage);
        };

        ImagesLoaded.prototype.check = function() {
            var _this = this;
            var checkedCount = 0;
            var length = this.images.length;
            this.hasAnyBroken = false;
            // complete if no images
            if (!length) {
                this.complete();
                return;
            }

            function onConfirm(image, message) {
                if (_this.options.debug && hasConsole) {
                    console.log('confirm', image, message);
                }

                _this.progress(image);
                checkedCount++;
                if (checkedCount === length) {
                    _this.complete();
                }
                return true; // bind once
            }

            for (var i = 0; i < length; i++) {
                var loadingImage = this.images[i];
                loadingImage.on('confirm', onConfirm);
                loadingImage.check();
            }
        };

        ImagesLoaded.prototype.progress = function(image) {
            this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
            // HACK - Chrome triggers event before object properties have changed. #83
            var _this = this;
            setTimeout(function() {
                _this.emit('progress', _this, image);
                if (_this.jqDeferred && _this.jqDeferred.notify) {
                    _this.jqDeferred.notify(_this, image);
                }
            });
        };

        ImagesLoaded.prototype.complete = function() {
            var eventName = this.hasAnyBroken ? 'fail' : 'done';
            this.isComplete = true;
            var _this = this;
            // HACK - another setTimeout so that confirm happens after progress
            setTimeout(function() {
                _this.emit(eventName, _this);
                _this.emit('always', _this);
                if (_this.jqDeferred) {
                    var jqMethod = _this.hasAnyBroken ? 'reject' : 'resolve';
                    _this.jqDeferred[jqMethod](_this);
                }
            });
        };

        // -------------------------- jquery -------------------------- //

        if ($) {
            $.fn.imagesLoaded = function(options, callback) {
                var instance = new ImagesLoaded(this, options, callback);
                return instance.jqDeferred.promise($(this));
            };
        }


        // --------------------------  -------------------------- //

        function LoadingImage(img) {
            this.img = img;
        }

        LoadingImage.prototype = new EventEmitter();

        LoadingImage.prototype.check = function() {
            // first check cached any previous images that have same src
            var resource = cache[this.img.src] || new Resource(this.img.src);
            if (resource.isConfirmed) {
                this.confirm(resource.isLoaded, 'cached was confirmed');
                return;
            }

            // If complete is true and browser supports natural sizes,
            // try to check for image status manually.
            if (this.img.complete && this.img.naturalWidth !== undefined) {
                // report based on naturalWidth
                this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');
                return;
            }

            // If none of the checks above matched, simulate loading on detached element.
            var _this = this;
            resource.on('confirm', function(resrc, message) {
                _this.confirm(resrc.isLoaded, message);
                return true;
            });

            resource.check();
        };

        LoadingImage.prototype.confirm = function(isLoaded, message) {
            this.isLoaded = isLoaded;
            this.emit('confirm', this, message);
        };

        // -------------------------- Resource -------------------------- //

        // Resource checks each src, only once
        // separate class from LoadingImage to prevent memory leaks. See #115

        var cache = {};

        function Resource(src) {
            this.src = src;
            // add to cache
            cache[src] = this;
        }

        Resource.prototype = new EventEmitter();

        Resource.prototype.check = function() {
            // only trigger checking once
            if (this.isChecked) {
                return;
            }
            // simulate loading on detached element
            var proxyImage = new Image();
            eventie.bind(proxyImage, 'load', this);
            eventie.bind(proxyImage, 'error', this);
            proxyImage.src = this.src;
            // set flag
            this.isChecked = true;
        };

        // ----- events ----- //

        // trigger specified handler for event type
        Resource.prototype.handleEvent = function(event) {
            var method = 'on' + event.type;
            if (this[method]) {
                this[method](event);
            }
        };

        Resource.prototype.onload = function(event) {
            this.confirm(true, 'onload');
            this.unbindProxyEvents(event);
        };

        Resource.prototype.onerror = function(event) {
            this.confirm(false, 'onerror');
            this.unbindProxyEvents(event);
        };

        // ----- confirm ----- //

        Resource.prototype.confirm = function(isLoaded, message) {
            this.isConfirmed = true;
            this.isLoaded = isLoaded;
            this.emit('confirm', this, message);
        };

        Resource.prototype.unbindProxyEvents = function(event) {
            eventie.unbind(event.target, 'load', this);
            eventie.unbind(event.target, 'error', this);
        };

        // -----  ----- //

        return ImagesLoaded;

    });

/**
 * jQuery CSS Customizable Scrollbar
 *
 * Copyright 2015, Yuriy Khabarov
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * If you found bug, please contact me via email <13real008@gmail.com>
 *
 * @author Yuriy Khabarov aka Gromo
 * @version 0.2.10
 * @url https://github.com/gromo/jquery.scrollbar/
 *
 */
;
(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else {
        factory(root.jQuery);
    }
}(this, function($) {
    'use strict';

    // init flags & variables
    var debug = false;

    var browser = {
        data: {
            index: 0,
            name: 'scrollbar'
        },
        macosx: /mac/i.test(navigator.platform),
        mobile: /android|webos|iphone|ipad|ipod|blackberry/i.test(navigator.userAgent),
        overlay: null,
        scroll: null,
        scrolls: [],
        webkit: /webkit/i.test(navigator.userAgent) && !/edge\/\d+/i.test(navigator.userAgent)
    };

    browser.scrolls.add = function(instance) {
        this.remove(instance).push(instance);
    };
    browser.scrolls.remove = function(instance) {
        while ($.inArray(instance, this) >= 0) {
            this.splice($.inArray(instance, this), 1);
        }
        return this;
    };

    var defaults = {
        "autoScrollSize": true, // automatically calculate scrollsize
        "autoUpdate": true, // update scrollbar if content/container size changed
        "debug": false, // debug mode
        "disableBodyScroll": false, // disable body scroll if mouse over container
        "duration": 200, // scroll animate duration in ms
        "ignoreMobile": false, // ignore mobile devices
        "ignoreOverlay": false, // ignore browsers with overlay scrollbars (mobile, MacOS)
        "scrollStep": 30, // scroll step for scrollbar arrows
        "showArrows": false, // add class to show arrows
        "stepScrolling": true, // when scrolling to scrollbar mousedown position

        "scrollx": null, // horizontal scroll element
        "scrolly": null, // vertical scroll element

        "onDestroy": null, // callback function on destroy,
        "onInit": null, // callback function on first initialization
        "onScroll": null, // callback function on content scrolling
        "onUpdate": null // callback function on init/resize (before scrollbar size calculation)
    };


    var BaseScrollbar = function(container) {

        if (!browser.scroll) {
            browser.overlay = isScrollOverlaysContent();
            browser.scroll = getBrowserScrollSize();
            updateScrollbars();

            $(window).resize(function() {
                var forceUpdate = false;
                if (browser.scroll && (browser.scroll.height || browser.scroll.width)) {
                    var scroll = getBrowserScrollSize();
                    if (scroll.height !== browser.scroll.height || scroll.width !== browser.scroll.width) {
                        browser.scroll = scroll;
                        forceUpdate = true; // handle page zoom
                    }
                }
                updateScrollbars(forceUpdate);
            });
        }

        this.container = container;
        this.namespace = '.scrollbar_' + browser.data.index++;
        this.options = $.extend({}, defaults, window.jQueryScrollbarOptions || {});
        this.scrollTo = null;
        this.scrollx = {};
        this.scrolly = {};

        container.data(browser.data.name, this);
        browser.scrolls.add(this);
    };

    BaseScrollbar.prototype = {

        destroy: function() {

            if (!this.wrapper) {
                return;
            }

            this.container.removeData(browser.data.name);
            browser.scrolls.remove(this);

            // init variables
            var scrollLeft = this.container.scrollLeft();
            var scrollTop = this.container.scrollTop();

            this.container.insertBefore(this.wrapper).css({
                    "height": "",
                    "margin": "",
                    "max-height": ""
                })
                .removeClass('scroll-content scroll-scrollx_visible scroll-scrolly_visible')
                .off(this.namespace)
                .scrollLeft(scrollLeft)
                .scrollTop(scrollTop);

            this.scrollx.scroll.removeClass('scroll-scrollx_visible').find('div').andSelf().off(this.namespace);
            this.scrolly.scroll.removeClass('scroll-scrolly_visible').find('div').andSelf().off(this.namespace);

            this.wrapper.remove();

            $(document).add('body').off(this.namespace);

            if ($.isFunction(this.options.onDestroy)) {
                this.options.onDestroy.apply(this, [this.container]);
            }
        },
        init: function(options) {

            // init variables
            var S = this,
                c = this.container,
                cw = this.containerWrapper || c,
                namespace = this.namespace,
                o = $.extend(this.options, options || {}),
                s = {
                    x: this.scrollx,
                    y: this.scrolly
                },
                w = this.wrapper;

            var initScroll = {
                "scrollLeft": c.scrollLeft(),
                "scrollTop": c.scrollTop()
            };

            // do not init if in ignorable browser
            if ((browser.mobile && o.ignoreMobile) ||
                (browser.overlay && o.ignoreOverlay) ||
                (browser.macosx && !browser.webkit) // still required to ignore nonWebKit browsers on Mac
            ) {
                return false;
            }

            // init scroll container
            if (!w) {
                this.wrapper = w = $('<div>').addClass('scroll-wrapper').addClass(c.attr('class'))
                    .css('position', c.css('position') == 'absolute' ? 'absolute' : 'relative')
                    .insertBefore(c).append(c);

                if (c.is('textarea')) {
                    this.containerWrapper = cw = $('<div>').insertBefore(c).append(c);
                    w.addClass('scroll-textarea');
                }

                cw.addClass('scroll-content').css({
                    "height": "auto",
                    "margin-bottom": browser.scroll.height * -1 + 'px',
                    "margin-right": browser.scroll.width * -1 + 'px',
                    "max-height": ""
                });

                c.on('scroll' + namespace, function(event) {
                    if ($.isFunction(o.onScroll)) {
                        o.onScroll.call(S, {
                            "maxScroll": s.y.maxScrollOffset,
                            "scroll": c.scrollTop(),
                            "size": s.y.size,
                            "visible": s.y.visible
                        }, {
                            "maxScroll": s.x.maxScrollOffset,
                            "scroll": c.scrollLeft(),
                            "size": s.x.size,
                            "visible": s.x.visible
                        });
                    }
                    s.x.isVisible && s.x.scroll.bar.css('left', c.scrollLeft() * s.x.kx + 'px');
                    s.y.isVisible && s.y.scroll.bar.css('top', c.scrollTop() * s.y.kx + 'px');
                });

                /* prevent native scrollbars to be visible on #anchor click */
                w.on('scroll' + namespace, function() {
                    w.scrollTop(0).scrollLeft(0);
                });

                if (o.disableBodyScroll) {
                    var handleMouseScroll = function(event) {
                        isVerticalScroll(event) ?
                            s.y.isVisible && s.y.mousewheel(event) :
                            s.x.isVisible && s.x.mousewheel(event);
                    };
                    w.on('MozMousePixelScroll' + namespace, handleMouseScroll);
                    w.on('mousewheel' + namespace, handleMouseScroll);

                    if (browser.mobile) {
                        w.on('touchstart' + namespace, function(event) {
                            var touch = event.originalEvent.touches && event.originalEvent.touches[0] || event;
                            var originalTouch = {
                                "pageX": touch.pageX,
                                "pageY": touch.pageY
                            };
                            var originalScroll = {
                                "left": c.scrollLeft(),
                                "top": c.scrollTop()
                            };
                            $(document).on('touchmove' + namespace, function(event) {
                                var touch = event.originalEvent.targetTouches && event.originalEvent.targetTouches[0] || event;
                                c.scrollLeft(originalScroll.left + originalTouch.pageX - touch.pageX);
                                c.scrollTop(originalScroll.top + originalTouch.pageY - touch.pageY);
                                event.preventDefault();
                            });
                            $(document).on('touchend' + namespace, function() {
                                $(document).off(namespace);
                            });
                        });
                    }
                }
                if ($.isFunction(o.onInit)) {
                    o.onInit.apply(this, [c]);
                }
            } else {
                cw.css({
                    "height": "auto",
                    "margin-bottom": browser.scroll.height * -1 + 'px',
                    "margin-right": browser.scroll.width * -1 + 'px',
                    "max-height": ""
                });
            }

            // init scrollbars & recalculate sizes
            $.each(s, function(d, scrollx) {

                var scrollCallback = null;
                var scrollForward = 1;
                var scrollOffset = (d === 'x') ? 'scrollLeft' : 'scrollTop';
                var scrollStep = o.scrollStep;
                var scrollTo = function() {
                    var currentOffset = c[scrollOffset]();
                    c[scrollOffset](currentOffset + scrollStep);
                    if (scrollForward == 1 && (currentOffset + scrollStep) >= scrollToValue)
                        currentOffset = c[scrollOffset]();
                    if (scrollForward == -1 && (currentOffset + scrollStep) <= scrollToValue)
                        currentOffset = c[scrollOffset]();
                    if (c[scrollOffset]() == currentOffset && scrollCallback) {
                        scrollCallback();
                    }
                }
                var scrollToValue = 0;

                if (!scrollx.scroll) {

                    scrollx.scroll = S._getScroll(o['scroll' + d]).addClass('scroll-' + d);

                    if (o.showArrows) {
                        scrollx.scroll.addClass('scroll-element_arrows_visible');
                    }

                    scrollx.mousewheel = function(event) {

                        if (!scrollx.isVisible || (d === 'x' && isVerticalScroll(event))) {
                            return true;
                        }
                        if (d === 'y' && !isVerticalScroll(event)) {
                            s.x.mousewheel(event);
                            return true;
                        }

                        var delta = event.originalEvent.wheelDelta * -1 || event.originalEvent.detail;
                        var maxScrollValue = scrollx.size - scrollx.visible - scrollx.offset;

                        if ((delta > 0 && scrollToValue < maxScrollValue) || (delta < 0 && scrollToValue > 0)) {
                            scrollToValue = scrollToValue + delta;
                            if (scrollToValue < 0)
                                scrollToValue = 0;
                            if (scrollToValue > maxScrollValue)
                                scrollToValue = maxScrollValue;

                            S.scrollTo = S.scrollTo || {};
                            S.scrollTo[scrollOffset] = scrollToValue;
                            setTimeout(function() {
                                if (S.scrollTo) {
                                    c.stop().animate(S.scrollTo, 240, 'linear', function() {
                                        scrollToValue = c[scrollOffset]();
                                    });
                                    S.scrollTo = null;
                                }
                            }, 1);
                        }

                        event.preventDefault();
                        return false;
                    };

                    scrollx.scroll
                        .on('MozMousePixelScroll' + namespace, scrollx.mousewheel)
                        .on('mousewheel' + namespace, scrollx.mousewheel)
                        .on('mouseenter' + namespace, function() {
                            scrollToValue = c[scrollOffset]();
                        });

                    // handle arrows & scroll inner mousedown event
                    scrollx.scroll.find('.scroll-arrow, .scroll-element_track')
                        .on('mousedown' + namespace, function(event) {

                            if (event.which != 1) // lmb
                                return true;

                            scrollForward = 1;

                            var data = {
                                "eventOffset": event[(d === 'x') ? 'pageX' : 'pageY'],
                                "maxScrollValue": scrollx.size - scrollx.visible - scrollx.offset,
                                "scrollbarOffset": scrollx.scroll.bar.offset()[(d === 'x') ? 'left' : 'top'],
                                "scrollbarSize": scrollx.scroll.bar[(d === 'x') ? 'outerWidth' : 'outerHeight']()
                            };
                            var timeout = 0,
                                timer = 0;

                            if ($(this).hasClass('scroll-arrow')) {
                                scrollForward = $(this).hasClass("scroll-arrow_more") ? 1 : -1;
                                scrollStep = o.scrollStep * scrollForward;
                                scrollToValue = scrollForward > 0 ? data.maxScrollValue : 0;
                            } else {
                                scrollForward = (data.eventOffset > (data.scrollbarOffset + data.scrollbarSize) ? 1 :
                                    (data.eventOffset < data.scrollbarOffset ? -1 : 0));
                                scrollStep = Math.round(scrollx.visible * 0.75) * scrollForward;
                                scrollToValue = (data.eventOffset - data.scrollbarOffset -
                                    (o.stepScrolling ? (scrollForward == 1 ? data.scrollbarSize : 0) :
                                        Math.round(data.scrollbarSize / 2)));
                                scrollToValue = c[scrollOffset]() + (scrollToValue / scrollx.kx);
                            }

                            S.scrollTo = S.scrollTo || {};
                            S.scrollTo[scrollOffset] = o.stepScrolling ? c[scrollOffset]() + scrollStep : scrollToValue;

                            if (o.stepScrolling) {
                                scrollCallback = function() {
                                    scrollToValue = c[scrollOffset]();
                                    clearInterval(timer);
                                    clearTimeout(timeout);
                                    timeout = 0;
                                    timer = 0;
                                };
                                timeout = setTimeout(function() {
                                    timer = setInterval(scrollTo, 40);
                                }, o.duration + 100);
                            }

                            setTimeout(function() {
                                if (S.scrollTo) {
                                    c.animate(S.scrollTo, o.duration);
                                    S.scrollTo = null;
                                }
                            }, 1);

                            return S._handleMouseDown(scrollCallback, event);
                        });

                    // handle scrollbar drag'n'drop
                    scrollx.scroll.bar.on('mousedown' + namespace, function(event) {

                        if (event.which != 1) // lmb
                            return true;

                        var eventPosition = event[(d === 'x') ? 'pageX' : 'pageY'];
                        var initOffset = c[scrollOffset]();

                        scrollx.scroll.addClass('scroll-draggable');

                        $(document).on('mousemove' + namespace, function(event) {
                            var diff = parseInt((event[(d === 'x') ? 'pageX' : 'pageY'] - eventPosition) / scrollx.kx, 10);
                            c[scrollOffset](initOffset + diff);
                        });

                        return S._handleMouseDown(function() {
                            scrollx.scroll.removeClass('scroll-draggable');
                            scrollToValue = c[scrollOffset]();
                        }, event);
                    });
                }
            });

            // remove classes & reset applied styles
            $.each(s, function(d, scrollx) {
                var scrollClass = 'scroll-scroll' + d + '_visible';
                var scrolly = (d == "x") ? s.y : s.x;

                scrollx.scroll.removeClass(scrollClass);
                scrolly.scroll.removeClass(scrollClass);
                cw.removeClass(scrollClass);
            });

            // calculate init sizes
            $.each(s, function(d, scrollx) {
                $.extend(scrollx, (d == "x") ? {
                    "offset": parseInt(c.css('left'), 10) || 0,
                    "size": c.prop('scrollWidth'),
                    "visible": w.width()
                } : {
                    "offset": parseInt(c.css('top'), 10) || 0,
                    "size": c.prop('scrollHeight'),
                    "visible": w.height()
                });
            });

            // update scrollbar visibility/dimensions
            this._updateScroll('x', this.scrollx);
            this._updateScroll('y', this.scrolly);

            if ($.isFunction(o.onUpdate)) {
                o.onUpdate.apply(this, [c]);
            }

            // calculate scroll size
            $.each(s, function(d, scrollx) {

                var cssOffset = (d === 'x') ? 'left' : 'top';
                var cssFullSize = (d === 'x') ? 'outerWidth' : 'outerHeight';
                var cssSize = (d === 'x') ? 'width' : 'height';
                var offset = parseInt(c.css(cssOffset), 10) || 0;

                var AreaSize = scrollx.size;
                var AreaVisible = scrollx.visible + offset;

                var scrollSize = scrollx.scroll.size[cssFullSize]() + (parseInt(scrollx.scroll.size.css(cssOffset), 10) || 0);

                if (o.autoScrollSize) {
                    scrollx.scrollbarSize = parseInt(scrollSize * AreaVisible / AreaSize, 10);
                    scrollx.scroll.bar.css(cssSize, scrollx.scrollbarSize + 'px');
                }

                scrollx.scrollbarSize = scrollx.scroll.bar[cssFullSize]();
                scrollx.kx = ((scrollSize - scrollx.scrollbarSize) / (AreaSize - AreaVisible)) || 1;
                scrollx.maxScrollOffset = AreaSize - AreaVisible;
            });

            c.scrollLeft(initScroll.scrollLeft).scrollTop(initScroll.scrollTop).trigger('scroll');
        },

        /**
         * Get scrollx/scrolly object
         *
         * @param {Mixed} scroll
         * @returns {jQuery} scroll object
         */
        _getScroll: function(scroll) {
            var types = {
                advanced: [
                    '<div class="scroll-element">',
                    '<div class="scroll-element_corner"></div>',
                    '<div class="scroll-arrow scroll-arrow_less"></div>',
                    '<div class="scroll-arrow scroll-arrow_more"></div>',
                    '<div class="scroll-element_outer">',
                    '<div class="scroll-element_size"></div>', // required! used for scrollbar size calculation !
                    '<div class="scroll-element_inner-wrapper">',
                    '<div class="scroll-element_inner scroll-element_track">', // used for handling scrollbar click
                    '<div class="scroll-element_inner-bottom"></div>',
                    '</div>',
                    '</div>',
                    '<div class="scroll-bar">', // required
                    '<div class="scroll-bar_body">',
                    '<div class="scroll-bar_body-inner"></div>',
                    '</div>',
                    '<div class="scroll-bar_bottom"></div>',
                    '<div class="scroll-bar_center"></div>',
                    '</div>',
                    '</div>',
                    '</div>'
                ].join(''),
                simple: [
                    '<div class="scroll-element">',
                    '<div class="scroll-element_outer">',
                    '<div class="scroll-element_size"></div>', // required! used for scrollbar size calculation !
                    '<div class="scroll-element_track"></div>', // used for handling scrollbar click
                    '<div class="scroll-bar"></div>', // required
                    '</div>',
                    '</div>'
                ].join('')
            };
            if (types[scroll]) {
                scroll = types[scroll];
            }
            if (!scroll) {
                scroll = types['simple'];
            }
            if (typeof(scroll) == 'string') {
                scroll = $(scroll).appendTo(this.wrapper);
            } else {
                scroll = $(scroll);
            }
            $.extend(scroll, {
                bar: scroll.find('.scroll-bar'),
                size: scroll.find('.scroll-element_size'),
                track: scroll.find('.scroll-element_track')
            });
            return scroll;
        },

        _handleMouseDown: function(callback, event) {

            var namespace = this.namespace;

            $(document).on('blur' + namespace, function() {
                $(document).add('body').off(namespace);
                callback && callback();
            });
            $(document).on('dragstart' + namespace, function(event) {
                event.preventDefault();
                return false;
            });
            $(document).on('mouseup' + namespace, function() {
                $(document).add('body').off(namespace);
                callback && callback();
            });
            $('body').on('selectstart' + namespace, function(event) {
                event.preventDefault();
                return false;
            });

            event && event.preventDefault();
            return false;
        },

        _updateScroll: function(d, scrollx) {

            var container = this.container,
                containerWrapper = this.containerWrapper || container,
                scrollClass = 'scroll-scroll' + d + '_visible',
                scrolly = (d === 'x') ? this.scrolly : this.scrollx,
                offset = parseInt(this.container.css((d === 'x') ? 'left' : 'top'), 10) || 0,
                wrapper = this.wrapper;

            var AreaSize = scrollx.size;
            var AreaVisible = scrollx.visible + offset;

            scrollx.isVisible = (AreaSize - AreaVisible) > 1; // bug in IE9/11 with 1px diff
            if (scrollx.isVisible) {
                scrollx.scroll.addClass(scrollClass);
                scrolly.scroll.addClass(scrollClass);
                containerWrapper.addClass(scrollClass);
            } else {
                scrollx.scroll.removeClass(scrollClass);
                scrolly.scroll.removeClass(scrollClass);
                containerWrapper.removeClass(scrollClass);
            }

            if (d === 'y') {
                if (container.is('textarea') || AreaSize < AreaVisible) {
                    containerWrapper.css({
                        "height": (AreaVisible + browser.scroll.height) + 'px',
                        "max-height": "none"
                    });
                } else {
                    containerWrapper.css({
                        //"height": "auto", // do not reset height value: issue with height:100%!
                        "max-height": (AreaVisible + browser.scroll.height) + 'px'
                    });
                }
            }

            if (scrollx.size != container.prop('scrollWidth') ||
                scrolly.size != container.prop('scrollHeight') ||
                scrollx.visible != wrapper.width() ||
                scrolly.visible != wrapper.height() ||
                scrollx.offset != (parseInt(container.css('left'), 10) || 0) ||
                scrolly.offset != (parseInt(container.css('top'), 10) || 0)
            ) {
                $.extend(this.scrollx, {
                    "offset": parseInt(container.css('left'), 10) || 0,
                    "size": container.prop('scrollWidth'),
                    "visible": wrapper.width()
                });
                $.extend(this.scrolly, {
                    "offset": parseInt(container.css('top'), 10) || 0,
                    "size": this.container.prop('scrollHeight'),
                    "visible": wrapper.height()
                });
                this._updateScroll(d === 'x' ? 'y' : 'x', scrolly);
            }
        }
    };

    var CustomScrollbar = BaseScrollbar;

    /*
     * Extend jQuery as plugin
     *
     * @param {Mixed} command to execute
     * @param {Mixed} arguments as Array
     * @return {jQuery}
     */
    $.fn.scrollbar = function(command, args) {
        if (typeof command !== 'string') {
            args = command;
            command = 'init';
        }
        if (typeof args === 'undefined') {
            args = [];
        }
        if (!$.isArray(args)) {
            args = [args];
        }
        this.not('body, .scroll-wrapper').each(function() {
            var element = $(this),
                instance = element.data(browser.data.name);
            if (instance || command === 'init') {
                if (!instance) {
                    instance = new CustomScrollbar(element);
                }
                if (instance[command]) {
                    instance[command].apply(instance, args);
                }
            }
        });
        return this;
    };

    /**
     * Connect default options to global object
     */
    $.fn.scrollbar.options = defaults;


    /**
     * Check if scroll content/container size is changed
     */

    var updateScrollbars = (function() {
        var timer = 0,
            timerCounter = 0;

        return function(force) {
            var i, container, options, scroll, wrapper, scrollx, scrolly;
            for (i = 0; i < browser.scrolls.length; i++) {
                scroll = browser.scrolls[i];
                container = scroll.container;
                options = scroll.options;
                wrapper = scroll.wrapper;
                scrollx = scroll.scrollx;
                scrolly = scroll.scrolly;
                if (force || (options.autoUpdate && wrapper && wrapper.is(':visible') &&
                        (container.prop('scrollWidth') != scrollx.size || container.prop('scrollHeight') != scrolly.size || wrapper.width() != scrollx.visible || wrapper.height() != scrolly.visible))) {
                    scroll.init();

                    if (options.debug) {
                        window.console && console.log({
                            scrollHeight: container.prop('scrollHeight') + ':' + scroll.scrolly.size,
                            scrollWidth: container.prop('scrollWidth') + ':' + scroll.scrollx.size,
                            visibleHeight: wrapper.height() + ':' + scroll.scrolly.visible,
                            visibleWidth: wrapper.width() + ':' + scroll.scrollx.visible
                        }, true);
                        timerCounter++;
                    }
                }
            }
            if (debug && timerCounter > 10) {
                window.console && console.log('Scroll updates exceed 10');
                updateScrollbars = function() {};
            } else {
                clearTimeout(timer);
                timer = setTimeout(updateScrollbars, 300);
            }
        };
    })();

    /* ADDITIONAL FUNCTIONS */
    /**
     * Get native browser scrollbar size (height/width)
     *
     * @param {Boolean} actual size or CSS size, default - CSS size
     * @returns {Object} with height, width
     */
    function getBrowserScrollSize(actualSize) {

        if (browser.webkit && !actualSize) {
            return {
                "height": 0,
                "width": 0
            };
        }

        if (!browser.data.outer) {
            var css = {
                "border": "none",
                "box-sizing": "content-box",
                "height": "200px",
                "margin": "0",
                "padding": "0",
                "width": "200px"
            };
            browser.data.inner = $("<div>").css($.extend({}, css));
            browser.data.outer = $("<div>").css($.extend({
                "left": "-1000px",
                "overflow": "scroll",
                "position": "absolute",
                "top": "-1000px"
            }, css)).append(browser.data.inner).appendTo("body");
        }

        browser.data.outer.scrollLeft(1000).scrollTop(1000);

        return {
            "height": Math.ceil((browser.data.outer.offset().top - browser.data.inner.offset().top) || 0),
            "width": Math.ceil((browser.data.outer.offset().left - browser.data.inner.offset().left) || 0)
        };
    }

    /**
     * Check if native browser scrollbars overlay content
     *
     * @returns {Boolean}
     */
    function isScrollOverlaysContent() {
        var scrollSize = getBrowserScrollSize(true);
        return !(scrollSize.height || scrollSize.width);
    }

    function isVerticalScroll(event) {
        var e = event.originalEvent;
        if (e.axis && e.axis === e.HORIZONTAL_AXIS)
            return false;
        if (e.wheelDeltaX)
            return false;
        return true;
    }


    /**
     * Extend AngularJS as UI directive
     * and expose a provider for override default config
     *
     */
    if (window.angular) {
        (function(angular) {
            angular.module('jQueryScrollbar', [])
                .provider('jQueryScrollbar', function() {
                    var defaultOptions = defaults;
                    return {
                        setOptions: function(options) {
                            angular.extend(defaultOptions, options);
                        },
                        $get: function() {
                            return {
                                options: angular.copy(defaultOptions)
                            };
                        }
                    };
                })
                .directive('jqueryScrollbar', ['jQueryScrollbar', '$parse', function(jQueryScrollbar, $parse) {
                    return {
                        "restrict": "AC",
                        "link": function(scope, element, attrs) {
                            var model = $parse(attrs.jqueryScrollbar),
                                options = model(scope);
                            element.scrollbar(options || jQueryScrollbar.options)
                                .on('$destroy', function() {
                                    element.scrollbar('destroy');
                                });
                        }
                    };
                }]);
        })(window.angular);
    }
}));

/*!
 * jQuery Validation Plugin v1.15.0
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2016 Jörn Zaefferer
 * Released under the MIT license
 */
(function(factory) {
    if (typeof define === "function" && define.amd) {
        define(["jquery"], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
}(function($) {

    $.extend($.fn, {

        // http://jqueryvalidation.org/validate/
        validate: function(options) {

            // If nothing is selected, return nothing; can't chain anyway
            if (!this.length) {
                if (options && options.debug && window.console) {
                    console.warn("Nothing selected, can't validate, returning nothing.");
                }
                return;
            }

            // Check if a validator for this form was already created
            var validator = $.data(this[0], "validator");
            if (validator) {
                return validator;
            }

            // Add novalidate tag if HTML5.
            this.attr("novalidate", "novalidate");

            validator = new $.validator(options, this[0]);
            $.data(this[0], "validator", validator);

            if (validator.settings.onsubmit) {

                this.on("click.validate", ":submit", function(event) {
                    if (validator.settings.submitHandler) {
                        validator.submitButton = event.target;
                    }

                    // Allow suppressing validation by adding a cancel class to the submit button
                    if ($(this).hasClass("cancel")) {
                        validator.cancelSubmit = true;
                    }

                    // Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
                    if ($(this).attr("formnovalidate") !== undefined) {
                        validator.cancelSubmit = true;
                    }
                });

                // Validate the form on submit
                this.on("submit.validate", function(event) {
                    if (validator.settings.debug) {

                        // Prevent form submit to be able to see console output
                        event.preventDefault();
                    }

                    function handle() {
                        var hidden, result;
                        if (validator.settings.submitHandler) {
                            if (validator.submitButton) {

                                // Insert a hidden input as a replacement for the missing submit button
                                hidden = $("<input type='hidden'/>")
                                    .attr("name", validator.submitButton.name)
                                    .val($(validator.submitButton).val())
                                    .appendTo(validator.currentForm);
                            }
                            result = validator.settings.submitHandler.call(validator, validator.currentForm, event);
                            if (validator.submitButton) {

                                // And clean up afterwards; thanks to no-block-scope, hidden can be referenced
                                hidden.remove();
                            }
                            if (result !== undefined) {
                                return result;
                            }
                            return false;
                        }
                        return true;
                    }

                    // Prevent submit for invalid forms or custom submit handlers
                    if (validator.cancelSubmit) {
                        validator.cancelSubmit = false;
                        return handle();
                    }
                    if (validator.form()) {
                        if (validator.pendingRequest) {
                            validator.formSubmitted = true;
                            return false;
                        }
                        return handle();
                    } else {
                        validator.focusInvalid();
                        return false;
                    }
                });
            }

            return validator;
        },

        // http://jqueryvalidation.org/valid/
        valid: function() {
            var valid, validator, errorList;

            if ($(this[0]).is("form")) {
                valid = this.validate().form();
            } else {
                errorList = [];
                valid = true;
                validator = $(this[0].form).validate();
                this.each(function() {
                    valid = validator.element(this) && valid;
                    if (!valid) {
                        errorList = errorList.concat(validator.errorList);
                    }
                });
                validator.errorList = errorList;
            }
            return valid;
        },

        // http://jqueryvalidation.org/rules/
        rules: function(command, argument) {

            // If nothing is selected, return nothing; can't chain anyway
            if (!this.length) {
                return;
            }

            var element = this[0],
                settings, staticRules, existingRules, data, param, filtered;

            if (command) {
                settings = $.data(element.form, "validator").settings;
                staticRules = settings.rules;
                existingRules = $.validator.staticRules(element);
                switch (command) {
                    case "add":
                        $.extend(existingRules, $.validator.normalizeRule(argument));

                        // Remove messages from rules, but allow them to be set separately
                        delete existingRules.messages;
                        staticRules[element.name] = existingRules;
                        if (argument.messages) {
                            settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);
                        }
                        break;
                    case "remove":
                        if (!argument) {
                            delete staticRules[element.name];
                            return existingRules;
                        }
                        filtered = {};
                        $.each(argument.split(/\s/), function(index, method) {
                            filtered[method] = existingRules[method];
                            delete existingRules[method];
                            if (method === "required") {
                                $(element).removeAttr("aria-required");
                            }
                        });
                        return filtered;
                }
            }

            data = $.validator.normalizeRules(
                $.extend({},
                    $.validator.classRules(element),
                    $.validator.attributeRules(element),
                    $.validator.dataRules(element),
                    $.validator.staticRules(element)
                ), element);

            // Make sure required is at front
            if (data.required) {
                param = data.required;
                delete data.required;
                data = $.extend({
                    required: param
                }, data);
                $(element).attr("aria-required", "true");
            }

            // Make sure remote is at back
            if (data.remote) {
                param = data.remote;
                delete data.remote;
                data = $.extend(data, {
                    remote: param
                });
            }

            return data;
        }
    });

    // Custom selectors
    $.extend($.expr[":"], {

        // http://jqueryvalidation.org/blank-selector/
        blank: function(a) {
            return !$.trim("" + $(a).val());
        },

        // http://jqueryvalidation.org/filled-selector/
        filled: function(a) {
            var val = $(a).val();
            return val !== null && !!$.trim("" + val);
        },

        // http://jqueryvalidation.org/unchecked-selector/
        unchecked: function(a) {
            return !$(a).prop("checked");
        }
    });

    // Constructor for validator
    $.validator = function(options, form) {
        this.settings = $.extend(true, {}, $.validator.defaults, options);
        this.currentForm = form;
        this.init();
    };

    // http://jqueryvalidation.org/jQuery.validator.format/
    $.validator.format = function(source, params) {
        if (arguments.length === 1) {
            return function() {
                var args = $.makeArray(arguments);
                args.unshift(source);
                return $.validator.format.apply(this, args);
            };
        }
        if (params === undefined) {
            return source;
        }
        if (arguments.length > 2 && params.constructor !== Array) {
            params = $.makeArray(arguments).slice(1);
        }
        if (params.constructor !== Array) {
            params = [params];
        }
        $.each(params, function(i, n) {
            source = source.replace(new RegExp("\\{" + i + "\\}", "g"), function() {
                return n;
            });
        });
        return source;
    };

    $.extend($.validator, {

        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            pendingClass: "pending",
            validClass: "valid",
            errorElement: "label",
            focusCleanup: false,
            focusInvalid: true,
            errorContainer: $([]),
            errorLabelContainer: $([]),
            onsubmit: true,
            ignore: ":hidden",
            ignoreTitle: false,
            onfocusin: function(element) {
                this.lastActive = element;

                // Hide error label and remove error class on focus if enabled
                if (this.settings.focusCleanup) {
                    if (this.settings.unhighlight) {
                        this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
                    }
                    this.hideThese(this.errorsFor(element));
                }
            },
            onfocusout: function(element) {
                if (!this.checkable(element) && (element.name in this.submitted || !this.optional(element))) {
                    this.element(element);
                }
            },
            onkeyup: function(element, event) {

                // Avoid revalidate the field when pressing one of the following keys
                // Shift       => 16
                // Ctrl        => 17
                // Alt         => 18
                // Caps lock   => 20
                // End         => 35
                // Home        => 36
                // Left arrow  => 37
                // Up arrow    => 38
                // Right arrow => 39
                // Down arrow  => 40
                // Insert      => 45
                // Num lock    => 144
                // AltGr key   => 225
                var excludedKeys = [
                    16, 17, 18, 20, 35, 36, 37,
                    38, 39, 40, 45, 144, 225
                ];

                if (event.which === 9 && this.elementValue(element) === "" || $.inArray(event.keyCode, excludedKeys) !== -1) {
                    return;
                } else if (element.name in this.submitted || element.name in this.invalid) {
                    this.element(element);
                }
            },
            onclick: function(element) {

                // Click on selects, radiobuttons and checkboxes
                if (element.name in this.submitted) {
                    this.element(element);

                    // Or option elements, check parent select in that case
                } else if (element.parentNode.name in this.submitted) {
                    this.element(element.parentNode);
                }
            },
            highlight: function(element, errorClass, validClass) {
                if (element.type === "radio") {
                    this.findByName(element.name).addClass(errorClass).removeClass(validClass);
                } else {
                    $(element).addClass(errorClass).removeClass(validClass);
                }
            },
            unhighlight: function(element, errorClass, validClass) {
                if (element.type === "radio") {
                    this.findByName(element.name).removeClass(errorClass).addClass(validClass);
                } else {
                    $(element).removeClass(errorClass).addClass(validClass);
                }
            }
        },

        // http://jqueryvalidation.org/jQuery.validator.setDefaults/
        setDefaults: function(settings) {
            $.extend($.validator.defaults, settings);
        },

        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date ( ISO ).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            equalTo: "Please enter the same value again.",
            maxlength: $.validator.format("Please enter no more than {0} characters."),
            minlength: $.validator.format("Please enter at least {0} characters."),
            rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
            range: $.validator.format("Please enter a value between {0} and {1}."),
            max: $.validator.format("Please enter a value less than or equal to {0}."),
            min: $.validator.format("Please enter a value greater than or equal to {0}."),
            step: $.validator.format("Please enter a multiple of {0}.")
        },

        autoCreateRanges: false,

        prototype: {

            init: function() {
                this.labelContainer = $(this.settings.errorLabelContainer);
                this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
                this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
                this.submitted = {};
                this.valueCache = {};
                this.pendingRequest = 0;
                this.pending = {};
                this.invalid = {};
                this.reset();

                var groups = (this.groups = {}),
                    rules;
                $.each(this.settings.groups, function(key, value) {
                    if (typeof value === "string") {
                        value = value.split(/\s/);
                    }
                    $.each(value, function(index, name) {
                        groups[name] = key;
                    });
                });
                rules = this.settings.rules;
                $.each(rules, function(key, value) {
                    rules[key] = $.validator.normalizeRule(value);
                });

                function delegate(event) {
                    var validator = $.data(this.form, "validator"),
                        eventType = "on" + event.type.replace(/^validate/, ""),
                        settings = validator.settings;
                    if (settings[eventType] && !$(this).is(settings.ignore)) {
                        settings[eventType].call(validator, this, event);
                    }
                }

                $(this.currentForm)
                    .on("focusin.validate focusout.validate keyup.validate",
                        ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
                        "[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
                        "[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
                        "[type='radio'], [type='checkbox'], [contenteditable]", delegate)

                // Support: Chrome, oldIE
                // "select" is provided as event.target when clicking a option
                .on("click.validate", "select, option, [type='radio'], [type='checkbox']", delegate);

                if (this.settings.invalidHandler) {
                    $(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler);
                }

                // Add aria-required to any Static/Data/Class required fields before first validation
                // Screen readers require this attribute to be present before the initial submission http://www.w3.org/TR/WCAG-TECHS/ARIA2.html
                $(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true");
            },

            // http://jqueryvalidation.org/Validator.form/
            form: function() {
                this.checkForm();
                $.extend(this.submitted, this.errorMap);
                this.invalid = $.extend({}, this.errorMap);
                if (!this.valid()) {
                    $(this.currentForm).triggerHandler("invalid-form", [this]);
                }
                this.showErrors();
                return this.valid();
            },

            checkForm: function() {
                this.prepareForm();
                for (var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++) {
                    this.check(elements[i]);
                }
                return this.valid();
            },

            // http://jqueryvalidation.org/Validator.element/
            element: function(element) {
                var cleanElement = this.clean(element),
                    checkElement = this.validationTargetFor(cleanElement),
                    v = this,
                    result = true,
                    rs, group;

                if (checkElement === undefined) {
                    delete this.invalid[cleanElement.name];
                } else {
                    this.prepareElement(checkElement);
                    this.currentElements = $(checkElement);

                    // If this element is grouped, then validate all group elements already
                    // containing a value
                    group = this.groups[checkElement.name];
                    if (group) {
                        $.each(this.groups, function(name, testgroup) {
                            if (testgroup === group && name !== checkElement.name) {
                                cleanElement = v.validationTargetFor(v.clean(v.findByName(name)));
                                if (cleanElement && cleanElement.name in v.invalid) {
                                    v.currentElements.push(cleanElement);
                                    result = result && v.check(cleanElement);
                                }
                            }
                        });
                    }

                    rs = this.check(checkElement) !== false;
                    result = result && rs;
                    if (rs) {
                        this.invalid[checkElement.name] = false;
                    } else {
                        this.invalid[checkElement.name] = true;
                    }

                    if (!this.numberOfInvalids()) {

                        // Hide error containers on last error
                        this.toHide = this.toHide.add(this.containers);
                    }
                    this.showErrors();

                    // Add aria-invalid status for screen readers
                    $(element).attr("aria-invalid", !rs);
                }

                return result;
            },

            // http://jqueryvalidation.org/Validator.showErrors/
            showErrors: function(errors) {
                if (errors) {
                    var validator = this;

                    // Add items to error list and map
                    $.extend(this.errorMap, errors);
                    this.errorList = $.map(this.errorMap, function(message, name) {
                        return {
                            message: message,
                            element: validator.findByName(name)[0]
                        };
                    });

                    // Remove items from success list
                    this.successList = $.grep(this.successList, function(element) {
                        return !(element.name in errors);
                    });
                }
                if (this.settings.showErrors) {
                    this.settings.showErrors.call(this, this.errorMap, this.errorList);
                } else {
                    this.defaultShowErrors();
                }
            },

            // http://jqueryvalidation.org/Validator.resetForm/
            resetForm: function() {
                if ($.fn.resetForm) {
                    $(this.currentForm).resetForm();
                }
                this.invalid = {};
                this.submitted = {};
                this.prepareForm();
                this.hideErrors();
                var elements = this.elements()
                    .removeData("previousValue")
                    .removeAttr("aria-invalid");

                this.resetElements(elements);
            },

            resetElements: function(elements) {
                var i;

                if (this.settings.unhighlight) {
                    for (i = 0; elements[i]; i++) {
                        this.settings.unhighlight.call(this, elements[i],
                            this.settings.errorClass, "");
                        this.findByName(elements[i].name).removeClass(this.settings.validClass);
                    }
                } else {
                    elements
                        .removeClass(this.settings.errorClass)
                        .removeClass(this.settings.validClass);
                }
            },

            numberOfInvalids: function() {
                return this.objectLength(this.invalid);
            },

            objectLength: function(obj) {
                /* jshint unused: false */
                var count = 0,
                    i;
                for (i in obj) {
                    if (obj[i]) {
                        count++;
                    }
                }
                return count;
            },

            hideErrors: function() {
                this.hideThese(this.toHide);
            },

            hideThese: function(errors) {
                errors.not(this.containers).text("");
                this.addWrapper(errors).hide();
            },

            valid: function() {
                return this.size() === 0;
            },

            size: function() {
                return this.errorList.length;
            },

            focusInvalid: function() {
                if (this.settings.focusInvalid) {
                    try {
                        $(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])
                            .filter(":visible")
                            .focus()

                        // Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
                        .trigger("focusin");
                    } catch (e) {

                        // Ignore IE throwing errors when focusing hidden elements
                    }
                }
            },

            findLastActive: function() {
                var lastActive = this.lastActive;
                return lastActive && $.grep(this.errorList, function(n) {
                    return n.element.name === lastActive.name;
                }).length === 1 && lastActive;
            },

            elements: function() {
                var validator = this,
                    rulesCache = {};

                // Select all valid inputs inside the form (no submit or reset buttons)
                return $(this.currentForm)
                    .find("input, select, textarea, [contenteditable]")
                    .not(":submit, :reset, :image, :disabled")
                    .not(this.settings.ignore)
                    .filter(function() {
                        var name = this.name || $(this).attr("name"); // For contenteditable
                        if (!name && validator.settings.debug && window.console) {
                            console.error("%o has no name assigned", this);
                        }

                        // Set form expando on contenteditable
                        if (this.hasAttribute("contenteditable")) {
                            this.form = $(this).closest("form")[0];
                        }

                        // Select only the first element for each name, and only those with rules specified
                        if (name in rulesCache || !validator.objectLength($(this).rules())) {
                            return false;
                        }

                        rulesCache[name] = true;
                        return true;
                    });
            },

            clean: function(selector) {
                return $(selector)[0];
            },

            errors: function() {
                var errorClass = this.settings.errorClass.split(" ").join(".");
                return $(this.settings.errorElement + "." + errorClass, this.errorContext);
            },

            resetInternals: function() {
                this.successList = [];
                this.errorList = [];
                this.errorMap = {};
                this.toShow = $([]);
                this.toHide = $([]);
            },

            reset: function() {
                this.resetInternals();
                this.currentElements = $([]);
            },

            prepareForm: function() {
                this.reset();
                this.toHide = this.errors().add(this.containers);
            },

            prepareElement: function(element) {
                this.reset();
                this.toHide = this.errorsFor(element);
            },

            elementValue: function(element) {
                var $element = $(element),
                    type = element.type,
                    val, idx;

                if (type === "radio" || type === "checkbox") {
                    return this.findByName(element.name).filter(":checked").val();
                } else if (type === "number" && typeof element.validity !== "undefined") {
                    return element.validity.badInput ? "NaN" : $element.val();
                }

                if (element.hasAttribute("contenteditable")) {
                    val = $element.text();
                } else {
                    val = $element.val();
                }

                if (type === "file") {

                    // Modern browser (chrome & safari)
                    if (val.substr(0, 12) === "C:\\fakepath\\") {
                        return val.substr(12);
                    }

                    // Legacy browsers
                    // Unix-based path
                    idx = val.lastIndexOf("/");
                    if (idx >= 0) {
                        return val.substr(idx + 1);
                    }

                    // Windows-based path
                    idx = val.lastIndexOf("\\");
                    if (idx >= 0) {
                        return val.substr(idx + 1);
                    }

                    // Just the file name
                    return val;
                }

                if (typeof val === "string") {
                    return val.replace(/\r/g, "");
                }
                return val;
            },

            check: function(element) {
                element = this.validationTargetFor(this.clean(element));

                var rules = $(element).rules(),
                    rulesCount = $.map(rules, function(n, i) {
                        return i;
                    }).length,
                    dependencyMismatch = false,
                    val = this.elementValue(element),
                    result, method, rule;

                // If a normalizer is defined for this element, then
                // call it to retreive the changed value instead
                // of using the real one.
                // Note that `this` in the normalizer is `element`.
                if (typeof rules.normalizer === "function") {
                    val = rules.normalizer.call(element, val);

                    if (typeof val !== "string") {
                        throw new TypeError("The normalizer should return a string value.");
                    }

                    // Delete the normalizer from rules to avoid treating
                    // it as a pre-defined method.
                    delete rules.normalizer;
                }

                for (method in rules) {
                    rule = {
                        method: method,
                        parameters: rules[method]
                    };
                    try {
                        result = $.validator.methods[method].call(this, val, element, rule.parameters);

                        // If a method indicates that the field is optional and therefore valid,
                        // don't mark it as valid when there are no other rules
                        if (result === "dependency-mismatch" && rulesCount === 1) {
                            dependencyMismatch = true;
                            continue;
                        }
                        dependencyMismatch = false;

                        if (result === "pending") {
                            this.toHide = this.toHide.not(this.errorsFor(element));
                            return;
                        }

                        if (!result) {
                            this.formatAndAdd(element, rule);
                            return false;
                        }
                    } catch (e) {
                        if (this.settings.debug && window.console) {
                            console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e);
                        }
                        if (e instanceof TypeError) {
                            e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
                        }

                        throw e;
                    }
                }
                if (dependencyMismatch) {
                    return;
                }
                if (this.objectLength(rules)) {
                    this.successList.push(element);
                }
                return true;
            },

            // Return the custom message for the given element and validation method
            // specified in the element's HTML5 data attribute
            // return the generic message if present and no method specific message is present
            customDataMessage: function(element, method) {
                return $(element).data("msg" + method.charAt(0).toUpperCase() +
                    method.substring(1).toLowerCase()) || $(element).data("msg");
            },

            // Return the custom message for the given element name and validation method
            customMessage: function(name, method) {
                var m = this.settings.messages[name];
                return m && (m.constructor === String ? m : m[method]);
            },

            // Return the first defined argument, allowing empty strings
            findDefined: function() {
                for (var i = 0; i < arguments.length; i++) {
                    if (arguments[i] !== undefined) {
                        return arguments[i];
                    }
                }
                return undefined;
            },

            defaultMessage: function(element, rule) {
                var message = this.findDefined(
                        this.customMessage(element.name, rule.method),
                        this.customDataMessage(element, rule.method),

                        // 'title' is never undefined, so handle empty string as undefined
                        !this.settings.ignoreTitle && element.title || undefined,
                        $.validator.messages[rule.method],
                        "<strong>Warning: No message defined for " + element.name + "</strong>"
                    ),
                    theregex = /\$?\{(\d+)\}/g;
                if (typeof message === "function") {
                    message = message.call(this, rule.parameters, element);
                } else if (theregex.test(message)) {
                    message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);
                }

                return message;
            },

            formatAndAdd: function(element, rule) {
                var message = this.defaultMessage(element, rule);

                this.errorList.push({
                    message: message,
                    element: element,
                    method: rule.method
                });

                this.errorMap[element.name] = message;
                this.submitted[element.name] = message;
            },

            addWrapper: function(toToggle) {
                if (this.settings.wrapper) {
                    toToggle = toToggle.add(toToggle.parent(this.settings.wrapper));
                }
                return toToggle;
            },

            defaultShowErrors: function() {
                var i, elements, error;
                for (i = 0; this.errorList[i]; i++) {
                    error = this.errorList[i];
                    if (this.settings.highlight) {
                        this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                    }
                    this.showLabel(error.element, error.message);
                }
                if (this.errorList.length) {
                    this.toShow = this.toShow.add(this.containers);
                }
                if (this.settings.success) {
                    for (i = 0; this.successList[i]; i++) {
                        this.showLabel(this.successList[i]);
                    }
                }
                if (this.settings.unhighlight) {
                    for (i = 0, elements = this.validElements(); elements[i]; i++) {
                        this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
                    }
                }
                this.toHide = this.toHide.not(this.toShow);
                this.hideErrors();
                this.addWrapper(this.toShow).show();
            },

            validElements: function() {
                return this.currentElements.not(this.invalidElements());
            },

            invalidElements: function() {
                return $(this.errorList).map(function() {
                    return this.element;
                });
            },

            showLabel: function(element, message) {
                var place, group, errorID, v,
                    error = this.errorsFor(element),
                    elementID = this.idOrName(element),
                    describedBy = $(element).attr("aria-describedby");

                if (error.length) {

                    // Refresh error/success class
                    error.removeClass(this.settings.validClass).addClass(this.settings.errorClass);

                    // Replace message on existing label
                    error.html(message);
                } else {

                    // Create error element
                    error = $("<" + this.settings.errorElement + ">")
                        .attr("id", elementID + "-error")
                        .addClass(this.settings.errorClass)
                        .html(message || "");

                    // Maintain reference to the element to be placed into the DOM
                    place = error;
                    if (this.settings.wrapper) {

                        // Make sure the element is visible, even in IE
                        // actually showing the wrapped element is handled elsewhere
                        place = error.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
                    }
                    if (this.labelContainer.length) {
                        this.labelContainer.append(place);
                    } else if (this.settings.errorPlacement) {
                        this.settings.errorPlacement(place, $(element));
                    } else {
                        place.insertAfter(element);
                    }

                    // Link error back to the element
                    if (error.is("label")) {

                        // If the error is a label, then associate using 'for'
                        error.attr("for", elementID);

                        // If the element is not a child of an associated label, then it's necessary
                        // to explicitly apply aria-describedby
                    } else if (error.parents("label[for='" + this.escapeCssMeta(elementID) + "']").length === 0) {
                        errorID = error.attr("id");

                        // Respect existing non-error aria-describedby
                        if (!describedBy) {
                            describedBy = errorID;
                        } else if (!describedBy.match(new RegExp("\\b" + this.escapeCssMeta(errorID) + "\\b"))) {

                            // Add to end of list if not already present
                            describedBy += " " + errorID;
                        }
                        $(element).attr("aria-describedby", describedBy);

                        // If this element is grouped, then assign to all elements in the same group
                        group = this.groups[element.name];
                        if (group) {
                            v = this;
                            $.each(v.groups, function(name, testgroup) {
                                if (testgroup === group) {
                                    $("[name='" + v.escapeCssMeta(name) + "']", v.currentForm)
                                        .attr("aria-describedby", error.attr("id"));
                                }
                            });
                        }
                    }
                }
                if (!message && this.settings.success) {
                    error.text("");
                    if (typeof this.settings.success === "string") {
                        error.addClass(this.settings.success);
                    } else {
                        this.settings.success(error, element);
                    }
                }
                this.toShow = this.toShow.add(error);
            },

            errorsFor: function(element) {
                var name = this.escapeCssMeta(this.idOrName(element)),
                    describer = $(element).attr("aria-describedby"),
                    selector = "label[for='" + name + "'], label[for='" + name + "'] *";

                // 'aria-describedby' should directly reference the error element
                if (describer) {
                    selector = selector + ", #" + this.escapeCssMeta(describer)
                        .replace(/\s+/g, ", #");
                }

                return this
                    .errors()
                    .filter(selector);
            },

            // See https://api.jquery.com/category/selectors/, for CSS
            // meta-characters that should be escaped in order to be used with JQuery
            // as a literal part of a name/id or any selector.
            escapeCssMeta: function(string) {
                return string.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1");
            },

            idOrName: function(element) {
                return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
            },

            validationTargetFor: function(element) {

                // If radio/checkbox, validate first element in group instead
                if (this.checkable(element)) {
                    element = this.findByName(element.name);
                }

                // Always apply ignore filter
                return $(element).not(this.settings.ignore)[0];
            },

            checkable: function(element) {
                return (/radio|checkbox/i).test(element.type);
            },

            findByName: function(name) {
                return $(this.currentForm).find("[name='" + this.escapeCssMeta(name) + "']");
            },

            getLength: function(value, element) {
                switch (element.nodeName.toLowerCase()) {
                    case "select":
                        return $("option:selected", element).length;
                    case "input":
                        if (this.checkable(element)) {
                            return this.findByName(element.name).filter(":checked").length;
                        }
                }
                return value.length;
            },

            depend: function(param, element) {
                return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
            },

            dependTypes: {
                "boolean": function(param) {
                    return param;
                },
                "string": function(param, element) {
                    return !!$(param, element.form).length;
                },
                "function": function(param, element) {
                    return param(element);
                }
            },

            optional: function(element) {
                var val = this.elementValue(element);
                return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
            },

            startRequest: function(element) {
                if (!this.pending[element.name]) {
                    this.pendingRequest++;
                    $(element).addClass(this.settings.pendingClass);
                    this.pending[element.name] = true;
                }
            },

            stopRequest: function(element, valid) {
                this.pendingRequest--;

                // Sometimes synchronization fails, make sure pendingRequest is never < 0
                if (this.pendingRequest < 0) {
                    this.pendingRequest = 0;
                }
                delete this.pending[element.name];
                $(element).removeClass(this.settings.pendingClass);
                if (valid && this.pendingRequest === 0 && this.formSubmitted && this.form()) {
                    $(this.currentForm).submit();
                    this.formSubmitted = false;
                } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
                    $(this.currentForm).triggerHandler("invalid-form", [this]);
                    this.formSubmitted = false;
                }
            },

            previousValue: function(element, method) {
                return $.data(element, "previousValue") || $.data(element, "previousValue", {
                    old: null,
                    valid: true,
                    message: this.defaultMessage(element, {
                        method: method
                    })
                });
            },

            // Cleans up all forms and elements, removes validator-specific events
            destroy: function() {
                this.resetForm();

                $(this.currentForm)
                    .off(".validate")
                    .removeData("validator")
                    .find(".validate-equalTo-blur")
                    .off(".validate-equalTo")
                    .removeClass("validate-equalTo-blur");
            }

        },

        classRuleSettings: {
            required: {
                required: true
            },
            email: {
                email: true
            },
            url: {
                url: true
            },
            date: {
                date: true
            },
            dateISO: {
                dateISO: true
            },
            number: {
                number: true
            },
            digits: {
                digits: true
            },
            creditcard: {
                creditcard: true
            }
        },

        addClassRules: function(className, rules) {
            if (className.constructor === String) {
                this.classRuleSettings[className] = rules;
            } else {
                $.extend(this.classRuleSettings, className);
            }
        },

        classRules: function(element) {
            var rules = {},
                classes = $(element).attr("class");

            if (classes) {
                $.each(classes.split(" "), function() {
                    if (this in $.validator.classRuleSettings) {
                        $.extend(rules, $.validator.classRuleSettings[this]);
                    }
                });
            }
            return rules;
        },

        normalizeAttributeRule: function(rules, type, method, value) {

            // Convert the value to a number for number inputs, and for text for backwards compability
            // allows type="date" and others to be compared as strings
            if (/min|max|step/.test(method) && (type === null || /number|range|text/.test(type))) {
                value = Number(value);

                // Support Opera Mini, which returns NaN for undefined minlength
                if (isNaN(value)) {
                    value = undefined;
                }
            }

            if (value || value === 0) {
                rules[method] = value;
            } else if (type === method && type !== "range") {

                // Exception: the jquery validate 'range' method
                // does not test for the html5 'range' type
                rules[method] = true;
            }
        },

        attributeRules: function(element) {
            var rules = {},
                $element = $(element),
                type = element.getAttribute("type"),
                method, value;

            for (method in $.validator.methods) {

                // Support for <input required> in both html5 and older browsers
                if (method === "required") {
                    value = element.getAttribute(method);

                    // Some browsers return an empty string for the required attribute
                    // and non-HTML5 browsers might have required="" markup
                    if (value === "") {
                        value = true;
                    }

                    // Force non-HTML5 browsers to return bool
                    value = !!value;
                } else {
                    value = $element.attr(method);
                }

                this.normalizeAttributeRule(rules, type, method, value);
            }

            // 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
            if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
                delete rules.maxlength;
            }

            return rules;
        },

        dataRules: function(element) {
            var rules = {},
                $element = $(element),
                type = element.getAttribute("type"),
                method, value;

            for (method in $.validator.methods) {
                value = $element.data("rule" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase());
                this.normalizeAttributeRule(rules, type, method, value);
            }
            return rules;
        },

        staticRules: function(element) {
            var rules = {},
                validator = $.data(element.form, "validator");

            if (validator.settings.rules) {
                rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
            }
            return rules;
        },

        normalizeRules: function(rules, element) {

            // Handle dependency check
            $.each(rules, function(prop, val) {

                // Ignore rule when param is explicitly false, eg. required:false
                if (val === false) {
                    delete rules[prop];
                    return;
                }
                if (val.param || val.depends) {
                    var keepRule = true;
                    switch (typeof val.depends) {
                        case "string":
                            keepRule = !!$(val.depends, element.form).length;
                            break;
                        case "function":
                            keepRule = val.depends.call(element, element);
                            break;
                    }
                    if (keepRule) {
                        rules[prop] = val.param !== undefined ? val.param : true;
                    } else {
                        $.data(element.form, "validator").resetElements($(element));
                        delete rules[prop];
                    }
                }
            });

            // Evaluate parameters
            $.each(rules, function(rule, parameter) {
                rules[rule] = $.isFunction(parameter) && rule !== "normalizer" ? parameter(element) : parameter;
            });

            // Clean number parameters
            $.each(["minlength", "maxlength"], function() {
                if (rules[this]) {
                    rules[this] = Number(rules[this]);
                }
            });
            $.each(["rangelength", "range"], function() {
                var parts;
                if (rules[this]) {
                    if ($.isArray(rules[this])) {
                        rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
                    } else if (typeof rules[this] === "string") {
                        parts = rules[this].replace(/[\[\]]/g, "").split(/[\s,]+/);
                        rules[this] = [Number(parts[0]), Number(parts[1])];
                    }
                }
            });

            if ($.validator.autoCreateRanges) {

                // Auto-create ranges
                if (rules.min != null && rules.max != null) {
                    rules.range = [rules.min, rules.max];
                    delete rules.min;
                    delete rules.max;
                }
                if (rules.minlength != null && rules.maxlength != null) {
                    rules.rangelength = [rules.minlength, rules.maxlength];
                    delete rules.minlength;
                    delete rules.maxlength;
                }
            }

            return rules;
        },

        // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
        normalizeRule: function(data) {
            if (typeof data === "string") {
                var transformed = {};
                $.each(data.split(/\s/), function() {
                    transformed[this] = true;
                });
                data = transformed;
            }
            return data;
        },

        // http://jqueryvalidation.org/jQuery.validator.addMethod/
        addMethod: function(name, method, message) {
            $.validator.methods[name] = method;
            $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
            if (method.length < 3) {
                $.validator.addClassRules(name, $.validator.normalizeRule(name));
            }
        },

        // http://jqueryvalidation.org/jQuery.validator.methods/
        methods: {

            // http://jqueryvalidation.org/required-method/
            required: function(value, element, param) {

                // Check if dependency is met
                if (!this.depend(param, element)) {
                    return "dependency-mismatch";
                }
                if (element.nodeName.toLowerCase() === "select") {

                    // Could be an array for select-multiple or a string, both are fine this way
                    var val = $(element).val();
                    return val && val.length > 0;
                }
                if (this.checkable(element)) {
                    return this.getLength(value, element) > 0;
                }
                return value.length > 0;
            },

            // http://jqueryvalidation.org/email-method/
            email: function(value, element) {

                // From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address
                // Retrieved 2014-01-14
                // If you have a problem with this implementation, report a bug against the above spec
                // Or use custom methods to implement your own email validation
                return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);
            },

            // http://jqueryvalidation.org/url-method/
            url: function(value, element) {

                // Copyright (c) 2010-2013 Diego Perini, MIT licensed
                // https://gist.github.com/dperini/729294
                // see also https://mathiasbynens.be/demo/url-regex
                // modified to allow protocol-relative URLs
                return this.optional(element) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(value);
            },

            // http://jqueryvalidation.org/date-method/
            date: function(value, element) {
                return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
            },

            // http://jqueryvalidation.org/dateISO-method/
            dateISO: function(value, element) {
                return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
            },

            // http://jqueryvalidation.org/number-method/
            number: function(value, element) {
                return this.optional(element) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
            },

            // http://jqueryvalidation.org/digits-method/
            digits: function(value, element) {
                return this.optional(element) || /^\d+$/.test(value);
            },

            // http://jqueryvalidation.org/minlength-method/
            minlength: function(value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length >= param;
            },

            // http://jqueryvalidation.org/maxlength-method/
            maxlength: function(value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length <= param;
            },

            // http://jqueryvalidation.org/rangelength-method/
            rangelength: function(value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || (length >= param[0] && length <= param[1]);
            },

            // http://jqueryvalidation.org/min-method/
            min: function(value, element, param) {
                return this.optional(element) || value >= param;
            },

            // http://jqueryvalidation.org/max-method/
            max: function(value, element, param) {
                return this.optional(element) || value <= param;
            },

            // http://jqueryvalidation.org/range-method/
            range: function(value, element, param) {
                return this.optional(element) || (value >= param[0] && value <= param[1]);
            },

            // http://jqueryvalidation.org/step-method/
            step: function(value, element, param) {
                var type = $(element).attr("type"),
                    errorMessage = "Step attribute on input type " + type + " is not supported.",
                    supportedTypes = ["text", "number", "range"],
                    re = new RegExp("\\b" + type + "\\b"),
                    notSupported = type && !re.test(supportedTypes.join());

                // Works only for text, number and range input types
                // TODO find a way to support input types date, datetime, datetime-local, month, time and week
                if (notSupported) {
                    throw new Error(errorMessage);
                }
                return this.optional(element) || (value % param === 0);
            },

            // http://jqueryvalidation.org/equalTo-method/
            equalTo: function(value, element, param) {

                // Bind to the blur event of the target in order to revalidate whenever the target field is updated
                var target = $(param);
                if (this.settings.onfocusout && target.not(".validate-equalTo-blur").length) {
                    target.addClass("validate-equalTo-blur").on("blur.validate-equalTo", function() {
                        $(element).valid();
                    });
                }
                return value === target.val();
            },

            // http://jqueryvalidation.org/remote-method/
            remote: function(value, element, param, method) {
                if (this.optional(element)) {
                    return "dependency-mismatch";
                }

                method = typeof method === "string" && method || "remote";

                var previous = this.previousValue(element, method),
                    validator, data, optionDataString;

                if (!this.settings.messages[element.name]) {
                    this.settings.messages[element.name] = {};
                }
                previous.originalMessage = previous.originalMessage || this.settings.messages[element.name][method];
                this.settings.messages[element.name][method] = previous.message;

                param = typeof param === "string" && {
                    url: param
                } || param;
                optionDataString = $.param($.extend({
                    data: value
                }, param.data));
                if (previous.old === optionDataString) {
                    return previous.valid;
                }

                previous.old = optionDataString;
                validator = this;
                this.startRequest(element);
                data = {};
                data[element.name] = value;
                $.ajax($.extend(true, {
                    mode: "abort",
                    port: "validate" + element.name,
                    dataType: "json",
                    data: data,
                    context: validator.currentForm,
                    success: function(response) {
                        var valid = response === true || response === "true",
                            errors, message, submitted;

                        validator.settings.messages[element.name][method] = previous.originalMessage;
                        if (valid) {
                            submitted = validator.formSubmitted;
                            validator.resetInternals();
                            validator.toHide = validator.errorsFor(element);
                            validator.formSubmitted = submitted;
                            validator.successList.push(element);
                            validator.invalid[element.name] = false;
                            validator.showErrors();
                        } else {
                            errors = {};
                            message = response || validator.defaultMessage(element, {
                                method: method,
                                parameters: value
                            });
                            errors[element.name] = previous.message = message;
                            validator.invalid[element.name] = true;
                            validator.showErrors(errors);
                        }
                        previous.valid = valid;
                        validator.stopRequest(element, valid);
                    }
                }, param));
                return "pending";
            }
        }

    });

    // Ajax mode: abort
    // usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
    // if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

    var pendingRequests = {},
        ajax;

    // Use a prefilter if available (1.5+)
    if ($.ajaxPrefilter) {
        $.ajaxPrefilter(function(settings, _, xhr) {
            var port = settings.port;
            if (settings.mode === "abort") {
                if (pendingRequests[port]) {
                    pendingRequests[port].abort();
                }
                pendingRequests[port] = xhr;
            }
        });
    } else {

        // Proxy ajax
        ajax = $.ajax;
        $.ajax = function(settings) {
            var mode = ("mode" in settings ? settings : $.ajaxSettings).mode,
                port = ("port" in settings ? settings : $.ajaxSettings).port;
            if (mode === "abort") {
                if (pendingRequests[port]) {
                    pendingRequests[port].abort();
                }
                pendingRequests[port] = ajax.apply(this, arguments);
                return pendingRequests[port];
            }
            return ajax.apply(this, arguments);
        };
    }

}));
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
        global.moment = factory()
}(this, function() {
    'use strict';

    var hookCallback;

    function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {}

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
            module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet(unit, keepTime) {
        return function(value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set(mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet(units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function() {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function() {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function(mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1 = /\d/; //       0 - 9
    var match2 = /\d\d/; //      00 - 99
    var match3 = /\d{3}/; //     000 - 999
    var match4 = /\d{4}/; //    0000 - 9999
    var match6 = /[+-]?\d{6}/; // -999999 - 999999
    var match1to2 = /\d\d?/; //       0 - 99
    var match1to3 = /\d{1,3}/; //       0 - 999
    var match1to4 = /\d{1,4}/; //       0 - 9999
    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf
    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction(sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function(input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function() {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function(format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow(m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11 ? MONTH :
                a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE :
                a[SECOND] < 0 || a[SECOND] > 59 ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function() {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function(config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function() {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function(input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function(input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6 // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function(input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear,
            janX = createUTCDate(year, 0, 1 + week1Jan),
            d = janX.getUTCDay(),
            dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i, date, input = [],
            currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function() {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
            config._a[HOUR] <= 12 &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({
                nullInput: true
            });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
        function() {
            var other = local__createLocal.apply(null, arguments);
            return other < this ? this : other;
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function() {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function() {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return !this._isUTC;
    }

    function isUtcOffset() {
        return this._isUTC;
    }

    function isUtc() {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                d: parseIso(match[4], sign),
                h: parseIso(match[5], sign),
                m: parseIso(match[6], sign),
                s: parseIso(match[7], sign),
                w: parseIso(match[8], sign)
            };
        } else if (duration == null) { // checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val;
                val = period;
                period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar(time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore(input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween(from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame(input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff(input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format(inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({
            to: this,
            from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({
            from: this,
            to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function(key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    function startOf(units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf() {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix() {
        return Math.floor(+this / 1000);
    }

    function toDate() {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid() {
        return valid__isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function() {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function() {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear(input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear(input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', matchWord);
    addRegexToken('ddd', matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse(weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function() {
        return this.hours() % 12 || 12;
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function() {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function() {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function() {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function() {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function() {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function() {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = getSet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = getSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toObject = toObject;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = moment_format__toISOString;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;

    // Year
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix(input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
    };

    function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat(string) {
        return string;
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
    };

    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar = defaultCalendar;
    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto._invalidDate = defaultInvalidDate;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto._ordinal = defaultOrdinal;
    prototype__proto.ordinal = ordinal;
    prototype__proto._ordinalParse = defaultOrdinalParse;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto._relativeTime = defaultRelativeTime;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;

    // Month
    prototype__proto.months = localeMonths;
    prototype__proto._months = defaultLocaleMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto._weekdays = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list(format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths(format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort(format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays(format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort(format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin(format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf() {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asYears = makeAs('y');

    function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function() {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45, // seconds to minute
        m: 45, // minutes to hour
        h: 22, // hours to day
        d: 26, // days to month
        M: 11 // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds] ||
            minutes === 1 && ['m'] ||
            minutes < thresholds.m && ['mm', minutes] ||
            hours === 1 && ['h'] ||
            hours < thresholds.h && ['hh', hours] ||
            days === 1 && ['d'] ||
            days < thresholds.d && ['dd', days] ||
            months === 1 && ['M'] ||
            months < thresholds.M && ['MM', months] ||
            years === 1 && ['y'] || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days = iso_string__abs(this._days);
        var months = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function(input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
/*!
 * Pikaday
 *
 * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
 */

(function(root, factory) {
    'use strict';

    var moment;
    if (typeof exports === 'object') {
        // CommonJS module
        // Load moment.js as an optional dependency
        try {
            moment = require('moment');
        } catch (e) {}
        module.exports = factory(moment);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(function(req) {
            // Load moment.js as an optional dependency
            var id = 'moment';
            try {
                moment = req(id);
            } catch (e) {}
            return factory(moment);
        });
    } else {
        root.Pikaday = factory(root.moment);
    }
}(this, function(moment) {
    'use strict';

    /**
     * feature detection and helper functions
     */
    var hasMoment = typeof moment === 'function',

        hasEventListeners = !!window.addEventListener,

        document = window.document,

        sto = window.setTimeout,

        addEvent = function(el, e, callback, capture) {
            if (hasEventListeners) {
                el.addEventListener(e, callback, !!capture);
            } else {
                el.attachEvent('on' + e, callback);
            }
        },

        removeEvent = function(el, e, callback, capture) {
            if (hasEventListeners) {
                el.removeEventListener(e, callback, !!capture);
            } else {
                el.detachEvent('on' + e, callback);
            }
        },

        fireEvent = function(el, eventName, data) {
            var ev;

            if (document.createEvent) {
                ev = document.createEvent('HTMLEvents');
                ev.initEvent(eventName, true, false);
                ev = extend(ev, data);
                el.dispatchEvent(ev);
            } else if (document.createEventObject) {
                ev = document.createEventObject();
                ev = extend(ev, data);
                el.fireEvent('on' + eventName, ev);
            }
        },

        trim = function(str) {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        },

        hasClass = function(el, cn) {
            return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
        },

        addClass = function(el, cn) {
            if (!hasClass(el, cn)) {
                el.className = (el.className === '') ? cn : el.className + ' ' + cn;
            }
        },

        removeClass = function(el, cn) {
            el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
        },

        isArray = function(obj) {
            return (/Array/).test(Object.prototype.toString.call(obj));
        },

        isDate = function(obj) {
            return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
        },

        isWeekend = function(date) {
            var day = date.getDay();
            return day === 0 || day === 6;
        },

        isLeapYear = function(year) {
            // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },

        getDaysInMonth = function(year, month) {
            return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
        },

        setToStartOfDay = function(date) {
            if (isDate(date)) date.setHours(0, 0, 0, 0);
        },

        compareDates = function(a, b) {
            // weak date comparison (use setToStartOfDay(date) to ensure correct result)
            return a.getTime() === b.getTime();
        },

        extend = function(to, from, overwrite) {
            var prop, hasProp;
            for (prop in from) {
                hasProp = to[prop] !== undefined;
                if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                    if (isDate(from[prop])) {
                        if (overwrite) {
                            to[prop] = new Date(from[prop].getTime());
                        }
                    } else if (isArray(from[prop])) {
                        if (overwrite) {
                            to[prop] = from[prop].slice(0);
                        }
                    } else {
                        to[prop] = extend({}, from[prop], overwrite);
                    }
                } else if (overwrite || !hasProp) {
                    to[prop] = from[prop];
                }
            }
            return to;
        },

        adjustCalendar = function(calendar) {
            if (calendar.month < 0) {
                calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
                calendar.month += 12;
            }
            if (calendar.month > 11) {
                calendar.year += Math.floor(Math.abs(calendar.month) / 12);
                calendar.month -= 12;
            }
            return calendar;
        },

        /**
         * defaults and localisation
         */
        defaults = {

            // bind the picker to a form field
            field: null,

            // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
            bound: undefined,

            // position of the datepicker, relative to the field (default to bottom & left)
            // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
            position: 'bottom left',

            // automatically fit in the viewport even if it means repositioning from the position option
            reposition: true,

            // the default output format for `.toString()` and `field` value
            format: 'YYYY-MM-DD',

            // the initial date to view when first opened
            defaultDate: null,

            // make the `defaultDate` the initial selected value
            setDefaultDate: false,

            // first day of week (0: Sunday, 1: Monday etc)
            firstDay: 0,

            // the minimum/earliest date that can be selected
            minDate: null,
            // the maximum/latest date that can be selected
            maxDate: null,

            // number of years either side, or array of upper/lower range
            yearRange: 10,

            // show week numbers at head of row
            showWeekNumber: false,

            // used internally (don't config outside)
            minYear: 0,
            maxYear: 9999,
            minMonth: undefined,
            maxMonth: undefined,

            startRange: null,
            endRange: null,

            isRTL: false,

            // Additional text to append to the year in the calendar title
            yearSuffix: '',

            // Render the month after year in the calendar title
            showMonthAfterYear: false,

            // how many months are visible
            numberOfMonths: 1,

            // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
            // only used for the first display or when a selected date is not visible
            mainCalendar: 'left',

            // Specify a DOM element to render the calendar in
            container: undefined,

            // internationalization
            i18n: {
                previousMonth: 'Previous Month',
                nextMonth: 'Next Month',
                months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
            },

            // Theme Classname
            theme: null,

            // callback function
            onSelect: null,
            onOpen: null,
            onClose: null,
            onDraw: null
        },


        /**
         * templating functions to abstract HTML rendering
         */
        renderDayName = function(opts, day, abbr) {
            day += opts.firstDay;
            while (day >= 7) {
                day -= 7;
            }
            return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
        },

        renderDay = function(opts) {
            if (opts.isEmpty) {
                return '<td class="is-empty"></td>';
            }
            var arr = [];
            if (opts.isDisabled) {
                arr.push('is-disabled');
            }
            if (opts.isToday) {
                arr.push('is-today');
            }
            if (opts.isSelected) {
                arr.push('is-selected');
            }
            if (opts.isInRange) {
                arr.push('is-inrange');
            }
            if (opts.isStartRange) {
                arr.push('is-startrange');
            }
            if (opts.isEndRange) {
                arr.push('is-endrange');
            }
            return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '">' +
                '<button class="pika-button pika-day" type="button" ' +
                'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                opts.day +
                '</button>' +
                '</td>';
        },

        renderWeek = function(d, m, y) {
            // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
            var onejan = new Date(y, 0, 1),
                weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay() + 1) / 7);
            return '<td class="pika-week">' + weekNum + '</td>';
        },

        renderRow = function(days, isRTL) {
            return '<tr>' + (isRTL ? days.reverse() : days).join('') + '</tr>';
        },

        renderBody = function(rows) {
            return '<tbody>' + rows.join('') + '</tbody>';
        },

        renderHead = function(opts) {
            var i, arr = [];
            if (opts.showWeekNumber) {
                arr.push('<th></th>');
            }
            for (i = 0; i < 7; i++) {
                arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
            }
            return '<thead>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</thead>';
        },

        renderTitle = function(instance, c, year, month, refYear) {
            var i, j, arr,
                opts = instance._o,
                isMinYear = year === opts.minYear,
                isMaxYear = year === opts.maxYear,
                html = '<div class="pika-title">',
                monthHtml,
                yearHtml,
                prev = true,
                next = true;

            for (arr = [], i = 0; i < 12; i++) {
                arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                    (i === month ? ' selected' : '') +
                    ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled' : '') + '>' +
                    opts.i18n.months[i] + '</option>');
            }
            monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

            if (isArray(opts.yearRange)) {
                i = opts.yearRange[0];
                j = opts.yearRange[1] + 1;
            } else {
                i = year - opts.yearRange;
                j = 1 + year + opts.yearRange;
            }

            for (arr = []; i < j && i <= opts.maxYear; i++) {
                if (i >= opts.minYear) {
                    arr.push('<option value="' + i + '"' + (i === year ? ' selected' : '') + '>' + (i) + '</option>');
                }
            }
            yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

            if (opts.showMonthAfterYear) {
                html += yearHtml + monthHtml;
            } else {
                html += monthHtml + yearHtml;
            }

            if (isMinYear && (month === 0 || opts.minMonth >= month)) {
                prev = false;
            }

            if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
                next = false;
            }

            if (c === 0) {
                html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
            }
            if (c === (instance._o.numberOfMonths - 1)) {
                html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
            }

            return html += '</div>';
        },

        renderTable = function(opts, data) {
            return '<table cellpadding="0" cellspacing="0" class="pika-table">' + renderHead(opts) + renderBody(data) + '</table>';
        },


        /**
         * Pikaday constructor
         */
        Pikaday = function(options) {
            var self = this,
                opts = self.config(options);

            self._onMouseDown = function(e) {
                if (!self._v) {
                    return;
                }
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }

                if (!hasClass(target.parentNode, 'is-disabled')) {
                    if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty')) {
                        self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                        if (opts.bound) {
                            sto(function() {
                                self.hide();
                                if (opts.field) {
                                    opts.field.blur();
                                }
                            }, 100);
                        }
                        return;
                    } else if (hasClass(target, 'pika-prev')) {
                        self.prevMonth();
                    } else if (hasClass(target, 'pika-next')) {
                        self.nextMonth();
                    }
                }
                if (!hasClass(target, 'pika-select')) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                        return false;
                    }
                } else {
                    self._c = true;
                }
            };

            self._onChange = function(e) {
                e = e || window.event;
                var target = e.target || e.srcElement;
                if (!target) {
                    return;
                }
                if (hasClass(target, 'pika-select-month')) {
                    self.gotoMonth(target.value);
                } else if (hasClass(target, 'pika-select-year')) {
                    self.gotoYear(target.value);
                }
            };

            self._onInputChange = function(e) {
                var date;

                if (e.firedBy === self) {
                    return;
                }
                if (hasMoment) {
                    date = moment(opts.field.value, opts.format);
                    date = (date && date.isValid()) ? date.toDate() : null;
                } else {
                    date = new Date(Date.parse(opts.field.value));
                }
                if (isDate(date)) {
                    self.setDate(date);
                }
                if (!self._v) {
                    self.show();
                }
            };

            self._onInputFocus = function() {
                self.show();
            };

            self._onInputClick = function() {
                self.show();
            };

            self._onInputBlur = function() {
                // IE allows pika div to gain focus; catch blur the input field
                var pEl = document.activeElement;
                do {
                    if (hasClass(pEl, 'pika-single')) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));

                if (!self._c) {
                    self._b = sto(function() {
                        self.hide();
                    }, 50);
                }
                self._c = false;
            };

            self._onClick = function(e) {
                e = e || window.event;
                var target = e.target || e.srcElement,
                    pEl = target;
                if (!target) {
                    return;
                }
                if (!hasEventListeners && hasClass(target, 'pika-select')) {
                    if (!target.onchange) {
                        target.setAttribute('onchange', 'return;');
                        addEvent(target, 'change', self._onChange);
                    }
                }
                do {
                    if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                        return;
                    }
                }
                while ((pEl = pEl.parentNode));
                if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                    self.hide();
                }
            };

            self.el = document.createElement('div');
            self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

            addEvent(self.el, 'ontouchend' in document ? 'touchend' : 'mousedown', self._onMouseDown, true);
            addEvent(self.el, 'change', self._onChange);

            if (opts.field) {
                if (opts.container) {
                    opts.container.appendChild(self.el);
                } else if (opts.bound) {
                    document.body.appendChild(self.el);
                } else {
                    opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
                }
                addEvent(opts.field, 'change', self._onInputChange);

                if (!opts.defaultDate) {
                    if (hasMoment && opts.field.value) {
                        opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                    } else {
                        opts.defaultDate = new Date(Date.parse(opts.field.value));
                    }
                    opts.setDefaultDate = true;
                }
            }

            var defDate = opts.defaultDate;

            if (isDate(defDate)) {
                if (opts.setDefaultDate) {
                    self.setDate(defDate, true);
                } else {
                    self.gotoDate(defDate);
                }
            } else {
                self.gotoDate(new Date());
            }

            if (opts.bound) {
                this.hide();
                self.el.className += ' is-bound';
                addEvent(opts.trigger, 'click', self._onInputClick);
                addEvent(opts.trigger, 'focus', self._onInputFocus);
                addEvent(opts.trigger, 'blur', self._onInputBlur);
            } else {
                this.show();
            }
        };


    /**
     * public Pikaday API
     */
    Pikaday.prototype = {


        /**
         * configure functionality
         */
        config: function(options) {
            if (!this._o) {
                this._o = extend({}, defaults, true);
            }

            var opts = extend(this._o, options, true);

            opts.isRTL = !!opts.isRTL;

            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

            opts.disableWeekends = !!opts.disableWeekends;

            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;

            if (!isDate(opts.minDate)) {
                opts.minDate = false;
            }
            if (!isDate(opts.maxDate)) {
                opts.maxDate = false;
            }
            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                opts.maxDate = opts.minDate = false;
            }
            if (opts.minDate) {
                this.setMinDate(opts.minDate);
            }
            if (opts.maxDate) {
                setToStartOfDay(opts.maxDate);
                opts.maxYear = opts.maxDate.getFullYear();
                opts.maxMonth = opts.maxDate.getMonth();
            }

            if (isArray(opts.yearRange)) {
                var fallback = new Date().getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) {
                    opts.yearRange = 100;
                }
            }

            return opts;
        },

        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format) {
            return !isDate(this._d) ? '' : hasMoment ? moment(this._d).format(format || this._o.format) : this._d.toDateString();
        },

        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function() {
            return hasMoment ? moment(this._d) : null;
        },

        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect) {
            if (hasMoment && moment.isMoment(date)) {
                this.setDate(date.toDate(), preventOnSelect);
            }
        },

        /**
         * return a Date object of the current selection
         */
        getDate: function() {
            return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },

        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect) {
            if (!date) {
                this._d = null;

                if (this._o.field) {
                    this._o.field.value = '';
                    fireEvent(this._o.field, 'change', {
                        firedBy: this
                    });
                }

                return this.draw();
            }
            if (typeof date === 'string') {
                date = new Date(Date.parse(date));
            }
            if (!isDate(date)) {
                return;
            }

            var min = this._o.minDate,
                max = this._o.maxDate;

            if (isDate(min) && date < min) {
                date = min;
            } else if (isDate(max) && date > max) {
                date = max;
            }

            this._d = new Date(date.getTime());
            setToStartOfDay(this._d);
            this.gotoDate(this._d);

            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, 'change', {
                    firedBy: this
                });
            }
            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                this._o.onSelect.call(this, this.getDate());
            }
        },

        /**
         * change view to a specific date
         */
        gotoDate: function(date) {
            var newCalendar = true;

            if (!isDate(date)) {
                return;
            }

            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                    lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1),
                    visibleDate = date.getTime();
                // get the end of the month
                lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
                lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
            }

            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear()
                }];
                if (this._o.mainCalendar === 'right') {
                    this.calendars[0].month += 1 - this._o.numberOfMonths;
                }
            }

            this.adjustCalendars();
        },

        adjustCalendars: function() {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) {
                this.calendars[c] = adjustCalendar({
                    month: this.calendars[0].month + c,
                    year: this.calendars[0].year
                });
            }
            this.draw();
        },

        gotoToday: function() {
            this.gotoDate(new Date());
        },

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month) {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars();
            }
        },

        nextMonth: function() {
            this.calendars[0].month++;
            this.adjustCalendars();
        },

        prevMonth: function() {
            this.calendars[0].month--;
            this.adjustCalendars();
        },

        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year) {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars();
            }
        },

        /**
         * change the minDate
         */
        setMinDate: function(value) {
            setToStartOfDay(value);
            this._o.minDate = value;
            this._o.minYear = value.getFullYear();
            this._o.minMonth = value.getMonth();
        },

        /**
         * change the maxDate
         */
        setMaxDate: function(value) {
            this._o.maxDate = value;
        },

        setStartRange: function(value) {
            this._o.startRange = value;
        },

        setEndRange: function(value) {
            this._o.endRange = value;
        },

        /**
         * refresh the HTML
         */
        draw: function(force) {
            if (!this._v && !force) {
                return;
            }
            var opts = this._o,
                minYear = opts.minYear,
                maxYear = opts.maxYear,
                minMonth = opts.minMonth,
                maxMonth = opts.maxMonth,
                html = '';

            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) {
                    this._m = minMonth;
                }
            }
            if (this._y >= maxYear) {
                this._y = maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) {
                    this._m = maxMonth;
                }
            }

            for (var c = 0; c < opts.numberOfMonths; c++) {
                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year) + this.render(this.calendars[c].year, this.calendars[c].month) + '</div>';
            }

            this.el.innerHTML = html;

            if (opts.bound) {
                if (opts.field.type !== 'hidden') {
                    sto(function() {
                        opts.trigger.focus();
                    }, 1);
                }
            }

            if (typeof this._o.onDraw === 'function') {
                var self = this;
                sto(function() {
                    self._o.onDraw.call(self);
                }, 0);
            }
        },

        adjustPosition: function() {
            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;

            if (this._o.container) return;

            this.el.style.position = 'absolute';

            field = this._o.trigger;
            pEl = field;
            width = this.el.offsetWidth;
            height = this.el.offsetHeight;
            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

            if (typeof field.getBoundingClientRect === 'function') {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset;
            } else {
                left = pEl.offsetLeft;
                top = pEl.offsetTop + pEl.offsetHeight;
                while ((pEl = pEl.offsetParent)) {
                    left += pEl.offsetLeft;
                    top += pEl.offsetTop;
                }
            }

            // default position is bottom & left
            if ((this._o.reposition && left + width > viewportWidth) ||
                (
                    this._o.position.indexOf('right') > -1 &&
                    left - width + field.offsetWidth > 0
                )
            ) {
                left = left - width + field.offsetWidth;
            }
            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                (
                    this._o.position.indexOf('top') > -1 &&
                    top - height - field.offsetHeight > 0
                )
            ) {
                top = top - height - field.offsetHeight;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';
        },

        /**
         * render HTML for a particular month
         */
        render: function(year, month) {
            var opts = this._o,
                now = new Date(),
                days = getDaysInMonth(year, month),
                before = new Date(year, month, 1).getDay(),
                data = [],
                row = [];
            setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) {
                    before += 7;
                }
            }
            var cells = days + before,
                after = cells;
            while (after > 7) {
                after -= 7;
            }
            cells += 7 - after;
            for (var i = 0, r = 0; i < cells; i++) {
                var dayConfig,
                    day = new Date(year, month, 1 + (i - before)),
                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                    isToday = compareDates(day, now),
                    isEmpty = i < before || i >= (days + before),
                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                    isDisabled = (opts.minDate && day < opts.minDate) ||
                    (opts.maxDate && day > opts.maxDate) ||
                    (opts.disableWeekends && isWeekend(day)) ||
                    (opts.disableDayFn && opts.disableDayFn(day)),
                    dayConfig = {
                        day: 1 + (i - before),
                        month: month,
                        year: year,
                        isSelected: isSelected,
                        isToday: isToday,
                        isDisabled: isDisabled,
                        isEmpty: isEmpty,
                        isStartRange: isStartRange,
                        isEndRange: isEndRange,
                        isInRange: isInRange
                    };

                row.push(renderDay(dayConfig));

                if (++r === 7) {
                    if (opts.showWeekNumber) {
                        row.unshift(renderWeek(i - before, month, year));
                    }
                    data.push(renderRow(row, opts.isRTL));
                    row = [];
                    r = 0;
                }
            }
            return renderTable(opts, data);
        },

        isVisible: function() {
            return this._v;
        },

        show: function() {
            if (!this._v) {
                removeClass(this.el, 'is-hidden');
                this._v = true;
                this.draw();
                if (this._o.bound) {
                    addEvent(document, 'click', this._onClick);
                    this.adjustPosition();
                }
                if (typeof this._o.onOpen === 'function') {
                    this._o.onOpen.call(this);
                }
            }
        },

        hide: function() {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) {
                    removeEvent(document, 'click', this._onClick);
                }
                this.el.style.position = 'static'; // reset
                this.el.style.left = 'auto';
                this.el.style.top = 'auto';
                addClass(this.el, 'is-hidden');
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === 'function') {
                    this._o.onClose.call(this);
                }
            }
        },

        /**
         * GAME OVER
         */
        destroy: function() {
            this.hide();
            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
            removeEvent(this.el, 'change', this._onChange);
            if (this._o.field) {
                removeEvent(this._o.field, 'change', this._onInputChange);
                if (this._o.bound) {
                    removeEvent(this._o.trigger, 'click', this._onInputClick);
                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);
                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);
                }
            }
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

    };

    return Pikaday;

}));

/*!
 * Pikaday jQuery plugin.
 *
 * Copyright © 2013 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
 */

(function(root, factory) {
    'use strict';

    if (typeof exports === 'object') {
        // CommonJS module
        factory(require('jquery'), require('../pikaday'));
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery', 'pikaday'], factory);
    } else {
        // Browser globals
        factory(root.jQuery, root.Pikaday);
    }
}(this, function($, Pikaday) {
    'use strict';

    $.fn.pikaday = function() {
        var args = arguments;

        if (!args || !args.length) {
            args = [{}];
        }

        return this.each(function() {
            var self = $(this),
                plugin = self.data('pikaday');

            if (!(plugin instanceof Pikaday)) {
                if (typeof args[0] === 'object') {
                    var options = $.extend({}, args[0]);
                    options.field = self[0];
                    self.data('pikaday', new Pikaday(options));
                }
            } else {
                if (typeof args[0] === 'string' && typeof plugin[args[0]] === 'function') {
                    plugin[args[0]].apply(plugin, Array.prototype.slice.call(args, 1));
                }
            }
        });
    };

}));

/*
 *  jQuery OwlCarousel v1.3.2
 *
 *  Copyright (c) 2013 Bartosz Wojciechowski
 *  http://www.owlgraphic.com/owlcarousel/
 *
 *  Licensed under MIT
 *
 */

/*JS Lint helpers: */
/*global dragMove: false, dragEnd: false, $, jQuery, alert, window, document */
/*jslint nomen: true, continue:true */

if (typeof Object.create !== "function") {
    Object.create = function(obj) {
        function F() {}
        F.prototype = obj;
        return new F();
    };
}
(function($, window, document) {

    var Carousel = {
        init: function(options, el) {
            var base = this;

            base.$elem = $(el);
            base.options = $.extend({}, $.fn.owlCarousel.options, base.$elem.data(), options);

            base.userOptions = options;
            base.loadContent();
        },

        loadContent: function() {
            var base = this,
                url;

            function getData(data) {
                var i, content = "";
                if (typeof base.options.jsonSuccess === "function") {
                    base.options.jsonSuccess.apply(this, [data]);
                } else {
                    for (i in data.owl) {
                        if (data.owl.hasOwnProperty(i)) {
                            content += data.owl[i].item;
                        }
                    }
                    base.$elem.html(content);
                }
                base.logIn();
            }

            if (typeof base.options.beforeInit === "function") {
                base.options.beforeInit.apply(this, [base.$elem]);
            }

            if (typeof base.options.jsonPath === "string") {
                url = base.options.jsonPath;
                $.getJSON(url, getData);
            } else {
                base.logIn();
            }
        },

        logIn: function() {
            var base = this;

            base.$elem.data("owl-originalStyles", base.$elem.attr("style"))
                .data("owl-originalClasses", base.$elem.attr("class"));

            base.$elem.css({
                opacity: 0
            });
            base.orignalItems = base.options.items;
            base.checkBrowser();
            base.wrapperWidth = 0;
            base.checkVisible = null;
            base.setVars();
        },

        setVars: function() {
            var base = this;
            if (base.$elem.children().length === 0) {
                return false;
            }
            base.baseClass();
            base.eventTypes();
            base.$userItems = base.$elem.children();
            base.itemsAmount = base.$userItems.length;
            base.wrapItems();
            base.$owlItems = base.$elem.find(".owl-item");
            base.$owlWrapper = base.$elem.find(".owl-wrapper");
            base.playDirection = "next";
            base.prevItem = 0;
            base.prevArr = [0];
            base.currentItem = 0;
            base.customEvents();
            base.onStartup();
        },

        onStartup: function() {
            var base = this;
            base.updateItems();
            base.calculateAll();
            base.buildControls();
            base.updateControls();
            base.response();
            base.moveEvents();
            base.stopOnHover();
            base.owlStatus();

            if (base.options.transitionStyle !== false) {
                base.transitionTypes(base.options.transitionStyle);
            }
            if (base.options.autoPlay === true) {
                base.options.autoPlay = 5000;
            }
            base.play();

            base.$elem.find(".owl-wrapper").css("display", "block");

            if (!base.$elem.is(":visible")) {
                base.watchVisibility();
            } else {
                base.$elem.css("opacity", 1);
            }
            base.onstartup = false;
            base.eachMoveUpdate();
            if (typeof base.options.afterInit === "function") {
                base.options.afterInit.apply(this, [base.$elem]);
            }
        },

        eachMoveUpdate: function() {
            var base = this;

            if (base.options.lazyLoad === true) {
                base.lazyLoad();
            }
            if (base.options.autoHeight === true) {
                base.autoHeight();
            }
            base.onVisibleItems();

            if (typeof base.options.afterAction === "function") {
                base.options.afterAction.apply(this, [base.$elem]);
            }
        },

        updateVars: function() {
            var base = this;
            if (typeof base.options.beforeUpdate === "function") {
                base.options.beforeUpdate.apply(this, [base.$elem]);
            }
            base.watchVisibility();
            base.updateItems();
            base.calculateAll();
            base.updatePosition();
            base.updateControls();
            base.eachMoveUpdate();
            if (typeof base.options.afterUpdate === "function") {
                base.options.afterUpdate.apply(this, [base.$elem]);
            }
        },

        reload: function() {
            var base = this;
            window.setTimeout(function() {
                base.updateVars();
            }, 0);
        },

        watchVisibility: function() {
            var base = this;

            if (base.$elem.is(":visible") === false) {
                base.$elem.css({
                    opacity: 0
                });
                window.clearInterval(base.autoPlayInterval);
                window.clearInterval(base.checkVisible);
            } else {
                return false;
            }
            base.checkVisible = window.setInterval(function() {
                if (base.$elem.is(":visible")) {
                    base.reload();
                    base.$elem.animate({
                        opacity: 1
                    }, 200);
                    window.clearInterval(base.checkVisible);
                }
            }, 500);
        },

        wrapItems: function() {
            var base = this;
            base.$userItems.wrapAll("<div class=\"owl-wrapper\">").wrap("<div class=\"owl-item\"></div>");
            base.$elem.find(".owl-wrapper").wrap("<div class=\"owl-wrapper-outer\">");
            base.wrapperOuter = base.$elem.find(".owl-wrapper-outer");
            base.$elem.css("display", "block");
        },

        baseClass: function() {
            var base = this,
                hasBaseClass = base.$elem.hasClass(base.options.baseClass),
                hasThemeClass = base.$elem.hasClass(base.options.theme);

            if (!hasBaseClass) {
                base.$elem.addClass(base.options.baseClass);
            }

            if (!hasThemeClass) {
                base.$elem.addClass(base.options.theme);
            }
        },

        updateItems: function() {
            var base = this,
                width, i;

            if (base.options.responsive === false) {
                return false;
            }
            if (base.options.singleItem === true) {
                base.options.items = base.orignalItems = 1;
                base.options.itemsCustom = false;
                base.options.itemsDesktop = false;
                base.options.itemsDesktopSmall = false;
                base.options.itemsTablet = false;
                base.options.itemsTabletSmall = false;
                base.options.itemsMobile = false;
                return false;
            }

            width = $(base.options.responsiveBaseWidth).width();

            if (width > (base.options.itemsDesktop[0] || base.orignalItems)) {
                base.options.items = base.orignalItems;
            }
            if (base.options.itemsCustom !== false) {
                //Reorder array by screen size
                base.options.itemsCustom.sort(function(a, b) {
                    return a[0] - b[0];
                });

                for (i = 0; i < base.options.itemsCustom.length; i += 1) {
                    if (base.options.itemsCustom[i][0] <= width) {
                        base.options.items = base.options.itemsCustom[i][1];
                    }
                }

            } else {

                if (width <= base.options.itemsDesktop[0] && base.options.itemsDesktop !== false) {
                    base.options.items = base.options.itemsDesktop[1];
                }

                if (width <= base.options.itemsDesktopSmall[0] && base.options.itemsDesktopSmall !== false) {
                    base.options.items = base.options.itemsDesktopSmall[1];
                }

                if (width <= base.options.itemsTablet[0] && base.options.itemsTablet !== false) {
                    base.options.items = base.options.itemsTablet[1];
                }

                if (width <= base.options.itemsTabletSmall[0] && base.options.itemsTabletSmall !== false) {
                    base.options.items = base.options.itemsTabletSmall[1];
                }

                if (width <= base.options.itemsMobile[0] && base.options.itemsMobile !== false) {
                    base.options.items = base.options.itemsMobile[1];
                }
            }

            //if number of items is less than declared
            if (base.options.items > base.itemsAmount && base.options.itemsScaleUp === true) {
                base.options.items = base.itemsAmount;
            }
        },

        response: function() {
            var base = this,
                smallDelay,
                lastWindowWidth;

            if (base.options.responsive !== true) {
                return false;
            }
            lastWindowWidth = $(window).width();

            base.resizer = function() {
                if ($(window).width() !== lastWindowWidth) {
                    if (base.options.autoPlay !== false) {
                        window.clearInterval(base.autoPlayInterval);
                    }
                    window.clearTimeout(smallDelay);
                    smallDelay = window.setTimeout(function() {
                        lastWindowWidth = $(window).width();
                        base.updateVars();
                    }, base.options.responsiveRefreshRate);
                }
            };
            $(window).resize(base.resizer);
        },

        updatePosition: function() {
            var base = this;
            base.jumpTo(base.currentItem);
            if (base.options.autoPlay !== false) {
                base.checkAp();
            }
        },

        appendItemsSizes: function() {
            var base = this,
                roundPages = 0,
                lastItem = base.itemsAmount - base.options.items;

            base.$owlItems.each(function(index) {
                var $this = $(this);
                $this
                    .css({
                        "width": base.itemWidth
                    })
                    .data("owl-item", Number(index));

                if (index % base.options.items === 0 || index === lastItem) {
                    if (!(index > lastItem)) {
                        roundPages += 1;
                    }
                }
                $this.data("owl-roundPages", roundPages);
            });
        },

        appendWrapperSizes: function() {
            var base = this,
                width = base.$owlItems.length * base.itemWidth;

            base.$owlWrapper.css({
                "width": width * 2,
                "left": 0
            });
            base.appendItemsSizes();
        },

        calculateAll: function() {
            var base = this;
            base.calculateWidth();
            base.appendWrapperSizes();
            base.loops();
            base.max();
        },

        calculateWidth: function() {
            var base = this;
            base.itemWidth = Math.round(base.$elem.width() / base.options.items);
        },

        max: function() {
            var base = this,
                maximum = ((base.itemsAmount * base.itemWidth) - base.options.items * base.itemWidth) * -1;
            if (base.options.items > base.itemsAmount) {
                base.maximumItem = 0;
                maximum = 0;
                base.maximumPixels = 0;
            } else {
                base.maximumItem = base.itemsAmount - base.options.items;
                base.maximumPixels = maximum;
            }
            return maximum;
        },

        min: function() {
            return 0;
        },

        loops: function() {
            var base = this,
                prev = 0,
                elWidth = 0,
                i,
                item,
                roundPageNum;

            base.positionsInArray = [0];
            base.pagesInArray = [];

            for (i = 0; i < base.itemsAmount; i += 1) {
                elWidth += base.itemWidth;
                base.positionsInArray.push(-elWidth);

                if (base.options.scrollPerPage === true) {
                    item = $(base.$owlItems[i]);
                    roundPageNum = item.data("owl-roundPages");
                    if (roundPageNum !== prev) {
                        base.pagesInArray[prev] = base.positionsInArray[i];
                        prev = roundPageNum;
                    }
                }
            }
        },

        buildControls: function() {
            var base = this;
            if (base.options.navigation === true || base.options.pagination === true) {
                base.owlControls = $("<div class=\"owl-controls\"/>").toggleClass("clickable", !base.browser.isTouch).appendTo(base.$elem);
            }
            if (base.options.pagination === true) {
                base.buildPagination();
            }
            if (base.options.navigation === true) {
                base.buildButtons();
            }
        },

        buildButtons: function() {
            var base = this,
                buttonsWrapper = $("<div class=\"owl-buttons\"/>");
            base.owlControls.append(buttonsWrapper);

            base.buttonPrev = $("<div/>", {
                "class": "owl-prev",
                "html": base.options.navigationText[0] || ""
            });

            base.buttonNext = $("<div/>", {
                "class": "owl-next",
                "html": base.options.navigationText[1] || ""
            });

            buttonsWrapper
                .append(base.buttonPrev)
                .append(base.buttonNext);

            buttonsWrapper.on("touchstart.owlControls mousedown.owlControls", "div[class^=\"owl\"]", function(event) {
                event.preventDefault();
            });

            buttonsWrapper.on("touchend.owlControls mouseup.owlControls", "div[class^=\"owl\"]", function(event) {
                event.preventDefault();
                if ($(this).hasClass("owl-next")) {
                    base.next();
                } else {
                    base.prev();
                }
            });
        },

        buildPagination: function() {
            var base = this;

            base.paginationWrapper = $("<div class=\"owl-pagination\"/>");
            base.owlControls.append(base.paginationWrapper);

            base.paginationWrapper.on("touchend.owlControls mouseup.owlControls", ".owl-page", function(event) {
                event.preventDefault();
                if (Number($(this).data("owl-page")) !== base.currentItem) {
                    base.goTo(Number($(this).data("owl-page")), true);
                }
            });
        },

        updatePagination: function() {
            var base = this,
                counter,
                lastPage,
                lastItem,
                i,
                paginationButton,
                paginationButtonInner;

            if (base.options.pagination === false) {
                return false;
            }

            base.paginationWrapper.html("");

            counter = 0;
            lastPage = base.itemsAmount - base.itemsAmount % base.options.items;

            for (i = 0; i < base.itemsAmount; i += 1) {
                if (i % base.options.items === 0) {
                    counter += 1;
                    if (lastPage === i) {
                        lastItem = base.itemsAmount - base.options.items;
                    }
                    paginationButton = $("<div/>", {
                        "class": "owl-page"
                    });
                    paginationButtonInner = $("<span></span>", {
                        "text": base.options.paginationNumbers === true ? counter : "",
                        "class": base.options.paginationNumbers === true ? "owl-numbers" : ""
                    });
                    paginationButton.append(paginationButtonInner);

                    paginationButton.data("owl-page", lastPage === i ? lastItem : i);
                    paginationButton.data("owl-roundPages", counter);

                    base.paginationWrapper.append(paginationButton);
                }
            }
            base.checkPagination();
        },
        checkPagination: function() {
            var base = this;
            if (base.options.pagination === false) {
                return false;
            }
            base.paginationWrapper.find(".owl-page").each(function() {
                if ($(this).data("owl-roundPages") === $(base.$owlItems[base.currentItem]).data("owl-roundPages")) {
                    base.paginationWrapper
                        .find(".owl-page")
                        .removeClass("active");
                    $(this).addClass("active");
                }
            });
        },

        checkNavigation: function() {
            var base = this;

            if (base.options.navigation === false) {
                return false;
            }
            if (base.options.rewindNav === false) {
                if (base.currentItem === 0 && base.maximumItem === 0) {
                    base.buttonPrev.addClass("disabled");
                    base.buttonNext.addClass("disabled");
                } else if (base.currentItem === 0 && base.maximumItem !== 0) {
                    base.buttonPrev.addClass("disabled");
                    base.buttonNext.removeClass("disabled");
                } else if (base.currentItem === base.maximumItem) {
                    base.buttonPrev.removeClass("disabled");
                    base.buttonNext.addClass("disabled");
                } else if (base.currentItem !== 0 && base.currentItem !== base.maximumItem) {
                    base.buttonPrev.removeClass("disabled");
                    base.buttonNext.removeClass("disabled");
                }
            }
        },

        updateControls: function() {
            var base = this;
            base.updatePagination();
            base.checkNavigation();
            if (base.owlControls) {
                if (base.options.items >= base.itemsAmount) {
                    base.owlControls.hide();
                } else {
                    base.owlControls.show();
                }
            }
        },

        destroyControls: function() {
            var base = this;
            if (base.owlControls) {
                base.owlControls.remove();
            }
        },

        next: function(speed) {
            var base = this;

            if (base.isTransition) {
                return false;
            }

            base.currentItem += base.options.scrollPerPage === true ? base.options.items : 1;
            if (base.currentItem > base.maximumItem + (base.options.scrollPerPage === true ? (base.options.items - 1) : 0)) {
                if (base.options.rewindNav === true) {
                    base.currentItem = 0;
                    speed = "rewind";
                } else {
                    base.currentItem = base.maximumItem;
                    return false;
                }
            }
            base.goTo(base.currentItem, speed);
        },

        prev: function(speed) {
            var base = this;

            if (base.isTransition) {
                return false;
            }

            if (base.options.scrollPerPage === true && base.currentItem > 0 && base.currentItem < base.options.items) {
                base.currentItem = 0;
            } else {
                base.currentItem -= base.options.scrollPerPage === true ? base.options.items : 1;
            }
            if (base.currentItem < 0) {
                if (base.options.rewindNav === true) {
                    base.currentItem = base.maximumItem;
                    speed = "rewind";
                } else {
                    base.currentItem = 0;
                    return false;
                }
            }
            base.goTo(base.currentItem, speed);
        },

        goTo: function(position, speed, drag) {
            var base = this,
                goToPixel;

            if (base.isTransition) {
                return false;
            }
            if (typeof base.options.beforeMove === "function") {
                base.options.beforeMove.apply(this, [base.$elem]);
            }
            if (position >= base.maximumItem) {
                position = base.maximumItem;
            } else if (position <= 0) {
                position = 0;
            }

            base.currentItem = base.owl.currentItem = position;
            if (base.options.transitionStyle !== false && drag !== "drag" && base.options.items === 1 && base.browser.support3d === true) {
                base.swapSpeed(0);
                if (base.browser.support3d === true) {
                    base.transition3d(base.positionsInArray[position]);
                } else {
                    base.css2slide(base.positionsInArray[position], 1);
                }
                base.afterGo();
                base.singleItemTransition();
                return false;
            }
            goToPixel = base.positionsInArray[position];

            if (base.browser.support3d === true) {
                base.isCss3Finish = false;

                if (speed === true) {
                    base.swapSpeed("paginationSpeed");
                    window.setTimeout(function() {
                        base.isCss3Finish = true;
                    }, base.options.paginationSpeed);

                } else if (speed === "rewind") {
                    base.swapSpeed(base.options.rewindSpeed);
                    window.setTimeout(function() {
                        base.isCss3Finish = true;
                    }, base.options.rewindSpeed);

                } else {
                    base.swapSpeed("slideSpeed");
                    window.setTimeout(function() {
                        base.isCss3Finish = true;
                    }, base.options.slideSpeed);
                }
                base.transition3d(goToPixel);
            } else {
                if (speed === true) {
                    base.css2slide(goToPixel, base.options.paginationSpeed);
                } else if (speed === "rewind") {
                    base.css2slide(goToPixel, base.options.rewindSpeed);
                } else {
                    base.css2slide(goToPixel, base.options.slideSpeed);
                }
            }
            base.afterGo();
        },

        jumpTo: function(position) {
            var base = this;
            if (typeof base.options.beforeMove === "function") {
                base.options.beforeMove.apply(this, [base.$elem]);
            }
            if (position >= base.maximumItem || position === -1) {
                position = base.maximumItem;
            } else if (position <= 0) {
                position = 0;
            }
            base.swapSpeed(0);
            if (base.browser.support3d === true) {
                base.transition3d(base.positionsInArray[position]);
            } else {
                base.css2slide(base.positionsInArray[position], 1);
            }
            base.currentItem = base.owl.currentItem = position;
            base.afterGo();
        },

        afterGo: function() {
            var base = this;

            base.prevArr.push(base.currentItem);
            base.prevItem = base.owl.prevItem = base.prevArr[base.prevArr.length - 2];
            base.prevArr.shift(0);

            if (base.prevItem !== base.currentItem) {
                base.checkPagination();
                base.checkNavigation();
                base.eachMoveUpdate();

                if (base.options.autoPlay !== false) {
                    base.checkAp();
                }
            }
            if (typeof base.options.afterMove === "function" && base.prevItem !== base.currentItem) {
                base.options.afterMove.apply(this, [base.$elem]);
            }
        },

        stop: function() {
            var base = this;
            base.apStatus = "stop";
            window.clearInterval(base.autoPlayInterval);
        },

        checkAp: function() {
            var base = this;
            if (base.apStatus !== "stop") {
                base.play();
            }
        },

        play: function() {
            var base = this;
            base.apStatus = "play";
            if (base.options.autoPlay === false) {
                return false;
            }
            window.clearInterval(base.autoPlayInterval);
            base.autoPlayInterval = window.setInterval(function() {
                base.next(true);
            }, base.options.autoPlay);
        },

        swapSpeed: function(action) {
            var base = this;
            if (action === "slideSpeed") {
                base.$owlWrapper.css(base.addCssSpeed(base.options.slideSpeed));
            } else if (action === "paginationSpeed") {
                base.$owlWrapper.css(base.addCssSpeed(base.options.paginationSpeed));
            } else if (typeof action !== "string") {
                base.$owlWrapper.css(base.addCssSpeed(action));
            }
        },

        addCssSpeed: function(speed) {
            return {
                "-webkit-transition": "all " + speed + "ms ease",
                "-moz-transition": "all " + speed + "ms ease",
                "-o-transition": "all " + speed + "ms ease",
                "transition": "all " + speed + "ms ease"
            };
        },

        removeTransition: function() {
            return {
                "-webkit-transition": "",
                "-moz-transition": "",
                "-o-transition": "",
                "transition": ""
            };
        },

        doTranslate: function(pixels) {
            return {
                "-webkit-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-moz-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-o-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-ms-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "transform": "translate3d(" + pixels + "px, 0px,0px)"
            };
        },

        transition3d: function(value) {
            var base = this;
            base.$owlWrapper.css(base.doTranslate(value));
        },

        css2move: function(value) {
            var base = this;
            base.$owlWrapper.css({
                "left": value
            });
        },

        css2slide: function(value, speed) {
            var base = this;

            base.isCssFinish = false;
            base.$owlWrapper.stop(true, true).animate({
                "left": value
            }, {
                duration: speed || base.options.slideSpeed,
                complete: function() {
                    base.isCssFinish = true;
                }
            });
        },

        checkBrowser: function() {
            var base = this,
                translate3D = "translate3d(0px, 0px, 0px)",
                tempElem = document.createElement("div"),
                regex,
                asSupport,
                support3d,
                isTouch;

            tempElem.style.cssText = "  -moz-transform:" + translate3D +
                "; -ms-transform:" + translate3D +
                "; -o-transform:" + translate3D +
                "; -webkit-transform:" + translate3D +
                "; transform:" + translate3D;
            regex = /translate3d\(0px, 0px, 0px\)/g;
            asSupport = tempElem.style.cssText.match(regex);
            support3d = (asSupport !== null && asSupport.length === 1);

            isTouch = "ontouchstart" in window || window.navigator.msMaxTouchPoints;

            base.browser = {
                "support3d": support3d,
                "isTouch": isTouch
            };
        },

        moveEvents: function() {
            var base = this;
            if (base.options.mouseDrag !== false || base.options.touchDrag !== false) {
                base.gestures();
                base.disabledEvents();
            }
        },

        eventTypes: function() {
            var base = this,
                types = ["s", "e", "x"];

            base.ev_types = {};

            if (base.options.mouseDrag === true && base.options.touchDrag === true) {
                types = [
                    "touchstart.owl mousedown.owl",
                    "touchmove.owl mousemove.owl",
                    "touchend.owl touchcancel.owl mouseup.owl"
                ];
            } else if (base.options.mouseDrag === false && base.options.touchDrag === true) {
                types = [
                    "touchstart.owl",
                    "touchmove.owl",
                    "touchend.owl touchcancel.owl"
                ];
            } else if (base.options.mouseDrag === true && base.options.touchDrag === false) {
                types = [
                    "mousedown.owl",
                    "mousemove.owl",
                    "mouseup.owl"
                ];
            }

            base.ev_types.start = types[0];
            base.ev_types.move = types[1];
            base.ev_types.end = types[2];
        },

        disabledEvents: function() {
            var base = this;
            base.$elem.on("dragstart.owl", function(event) {
                event.preventDefault();
            });
            base.$elem.on("mousedown.disableTextSelect", function(e) {
                return $(e.target).is('input, textarea, select, option');
            });
        },

        gestures: function() {
            /*jslint unparam: true*/
            var base = this,
                locals = {
                    offsetX: 0,
                    offsetY: 0,
                    baseElWidth: 0,
                    relativePos: 0,
                    position: null,
                    minSwipe: null,
                    maxSwipe: null,
                    sliding: null,
                    dargging: null,
                    targetElement: null
                };

            base.isCssFinish = true;

            function getTouches(event) {
                if (event.touches !== undefined) {
                    return {
                        x: event.touches[0].pageX,
                        y: event.touches[0].pageY
                    };
                }

                if (event.touches === undefined) {
                    if (event.pageX !== undefined) {
                        return {
                            x: event.pageX,
                            y: event.pageY
                        };
                    }
                    if (event.pageX === undefined) {
                        return {
                            x: event.clientX,
                            y: event.clientY
                        };
                    }
                }
            }

            function swapEvents(type) {
                if (type === "on") {
                    $(document).on(base.ev_types.move, dragMove);
                    $(document).on(base.ev_types.end, dragEnd);
                } else if (type === "off") {
                    $(document).off(base.ev_types.move);
                    $(document).off(base.ev_types.end);
                }
            }

            function dragStart(event) {
                var ev = event.originalEvent || event || window.event,
                    position;

                if (ev.which === 3) {
                    return false;
                }
                if (base.itemsAmount <= base.options.items) {
                    return;
                }
                if (base.isCssFinish === false && !base.options.dragBeforeAnimFinish) {
                    return false;
                }
                if (base.isCss3Finish === false && !base.options.dragBeforeAnimFinish) {
                    return false;
                }

                if (base.options.autoPlay !== false) {
                    window.clearInterval(base.autoPlayInterval);
                }

                if (base.browser.isTouch !== true && !base.$owlWrapper.hasClass("grabbing")) {
                    base.$owlWrapper.addClass("grabbing");
                }

                base.newPosX = 0;
                base.newRelativeX = 0;

                $(this).css(base.removeTransition());

                position = $(this).position();
                locals.relativePos = position.left;

                locals.offsetX = getTouches(ev).x - position.left;
                locals.offsetY = getTouches(ev).y - position.top;

                swapEvents("on");

                locals.sliding = false;
                locals.targetElement = ev.target || ev.srcElement;
            }

            function dragMove(event) {
                var ev = event.originalEvent || event || window.event,
                    minSwipe,
                    maxSwipe;

                base.newPosX = getTouches(ev).x - locals.offsetX;
                base.newPosY = getTouches(ev).y - locals.offsetY;
                base.newRelativeX = base.newPosX - locals.relativePos;

                if (typeof base.options.startDragging === "function" && locals.dragging !== true && base.newRelativeX !== 0) {
                    locals.dragging = true;
                    base.options.startDragging.apply(base, [base.$elem]);
                }

                if ((base.newRelativeX > 8 || base.newRelativeX < -8) && (base.browser.isTouch === true)) {
                    if (ev.preventDefault !== undefined) {
                        ev.preventDefault();
                    } else {
                        ev.returnValue = false;
                    }
                    locals.sliding = true;
                }

                if ((base.newPosY > 10 || base.newPosY < -10) && locals.sliding === false) {
                    $(document).off("touchmove.owl");
                }

                minSwipe = function() {
                    return base.newRelativeX / 5;
                };

                maxSwipe = function() {
                    return base.maximumPixels + base.newRelativeX / 5;
                };

                base.newPosX = Math.max(Math.min(base.newPosX, minSwipe()), maxSwipe());
                if (base.browser.support3d === true) {
                    base.transition3d(base.newPosX);
                } else {
                    base.css2move(base.newPosX);
                }
            }

            function dragEnd(event) {
                var ev = event.originalEvent || event || window.event,
                    newPosition,
                    handlers,
                    owlStopEvent;

                ev.target = ev.target || ev.srcElement;

                locals.dragging = false;

                if (base.browser.isTouch !== true) {
                    base.$owlWrapper.removeClass("grabbing");
                }

                if (base.newRelativeX < 0) {
                    base.dragDirection = base.owl.dragDirection = "left";
                } else {
                    base.dragDirection = base.owl.dragDirection = "right";
                }

                if (base.newRelativeX !== 0) {
                    newPosition = base.getNewPosition();
                    base.goTo(newPosition, false, "drag");
                    if (locals.targetElement === ev.target && base.browser.isTouch !== true) {
                        $(ev.target).on("click.disable", function(ev) {
                            ev.stopImmediatePropagation();
                            ev.stopPropagation();
                            ev.preventDefault();
                            $(ev.target).off("click.disable");
                        });
                        handlers = $._data(ev.target, "events").click;
                        owlStopEvent = handlers.pop();
                        handlers.splice(0, 0, owlStopEvent);
                    }
                }
                swapEvents("off");
            }
            base.$elem.on(base.ev_types.start, ".owl-wrapper", dragStart);
        },

        getNewPosition: function() {
            var base = this,
                newPosition = base.closestItem();

            if (newPosition > base.maximumItem) {
                base.currentItem = base.maximumItem;
                newPosition = base.maximumItem;
            } else if (base.newPosX >= 0) {
                newPosition = 0;
                base.currentItem = 0;
            }
            return newPosition;
        },
        closestItem: function() {
            var base = this,
                array = base.options.scrollPerPage === true ? base.pagesInArray : base.positionsInArray,
                goal = base.newPosX,
                closest = null;

            $.each(array, function(i, v) {
                if (goal - (base.itemWidth / 20) > array[i + 1] && goal - (base.itemWidth / 20) < v && base.moveDirection() === "left") {
                    closest = v;
                    if (base.options.scrollPerPage === true) {
                        base.currentItem = $.inArray(closest, base.positionsInArray);
                    } else {
                        base.currentItem = i;
                    }
                } else if (goal + (base.itemWidth / 20) < v && goal + (base.itemWidth / 20) > (array[i + 1] || array[i] - base.itemWidth) && base.moveDirection() === "right") {
                    if (base.options.scrollPerPage === true) {
                        closest = array[i + 1] || array[array.length - 1];
                        base.currentItem = $.inArray(closest, base.positionsInArray);
                    } else {
                        closest = array[i + 1];
                        base.currentItem = i + 1;
                    }
                }
            });
            return base.currentItem;
        },

        moveDirection: function() {
            var base = this,
                direction;
            if (base.newRelativeX < 0) {
                direction = "right";
                base.playDirection = "next";
            } else {
                direction = "left";
                base.playDirection = "prev";
            }
            return direction;
        },

        customEvents: function() {
            /*jslint unparam: true*/
            var base = this;
            base.$elem.on("owl.next", function() {
                base.next();
            });
            base.$elem.on("owl.prev", function() {
                base.prev();
            });
            base.$elem.on("owl.play", function(event, speed) {
                base.options.autoPlay = speed;
                base.play();
                base.hoverStatus = "play";
            });
            base.$elem.on("owl.stop", function() {
                base.stop();
                base.hoverStatus = "stop";
            });
            base.$elem.on("owl.goTo", function(event, item) {
                base.goTo(item);
            });
            base.$elem.on("owl.jumpTo", function(event, item) {
                base.jumpTo(item);
            });
        },

        stopOnHover: function() {
            var base = this;
            if (base.options.stopOnHover === true && base.browser.isTouch !== true && base.options.autoPlay !== false) {
                base.$elem.on("mouseover", function() {
                    base.stop();
                });
                base.$elem.on("mouseout", function() {
                    if (base.hoverStatus !== "stop") {
                        base.play();
                    }
                });
            }
        },

        lazyLoad: function() {
            var base = this,
                i,
                $item,
                itemNumber,
                $lazyImg,
                follow;

            if (base.options.lazyLoad === false) {
                return false;
            }
            for (i = 0; i < base.itemsAmount; i += 1) {
                $item = $(base.$owlItems[i]);

                if ($item.data("owl-loaded") === "loaded") {
                    continue;
                }

                itemNumber = $item.data("owl-item");
                $lazyImg = $item.find(".lazyOwl");

                if (typeof $lazyImg.data("src") !== "string") {
                    $item.data("owl-loaded", "loaded");
                    continue;
                }
                if ($item.data("owl-loaded") === undefined) {
                    $lazyImg.hide();
                    $item.addClass("loading").data("owl-loaded", "checked");
                }
                if (base.options.lazyFollow === true) {
                    follow = itemNumber >= base.currentItem;
                } else {
                    follow = true;
                }
                if (follow && itemNumber < base.currentItem + base.options.items && $lazyImg.length) {
                    base.lazyPreload($item, $lazyImg);
                }
            }
        },

        lazyPreload: function($item, $lazyImg) {
            var base = this,
                iterations = 0,
                isBackgroundImg;

            if ($lazyImg.prop("tagName") === "DIV") {
                $lazyImg.css("background-image", "url(" + $lazyImg.data("src") + ")");
                isBackgroundImg = true;
            } else {
                $lazyImg[0].src = $lazyImg.data("src");
            }

            function showImage() {
                $item.data("owl-loaded", "loaded").removeClass("loading");
                $lazyImg.removeAttr("data-src");
                if (base.options.lazyEffect === "fade") {
                    $lazyImg.fadeIn(400);
                } else {
                    $lazyImg.show();
                }
                if (typeof base.options.afterLazyLoad === "function") {
                    base.options.afterLazyLoad.apply(this, [base.$elem]);
                }
            }

            function checkLazyImage() {
                iterations += 1;
                if (base.completeImg($lazyImg.get(0)) || isBackgroundImg === true) {
                    showImage();
                } else if (iterations <= 100) { //if image loads in less than 10 seconds 
                    window.setTimeout(checkLazyImage, 100);
                } else {
                    showImage();
                }
            }

            checkLazyImage();
        },

        autoHeight: function() {
            var base = this,
                $currentimg = $(base.$owlItems[base.currentItem]).find("img"),
                iterations;

            function addHeight() {
                var $currentItem = $(base.$owlItems[base.currentItem]).height();
                base.wrapperOuter.css("height", $currentItem + "px");
                if (!base.wrapperOuter.hasClass("autoHeight")) {
                    window.setTimeout(function() {
                        base.wrapperOuter.addClass("autoHeight");
                    }, 0);
                }
            }

            function checkImage() {
                iterations += 1;
                if (base.completeImg($currentimg.get(0))) {
                    addHeight();
                } else if (iterations <= 100) { //if image loads in less than 10 seconds 
                    window.setTimeout(checkImage, 100);
                } else {
                    base.wrapperOuter.css("height", ""); //Else remove height attribute
                }
            }

            if ($currentimg.get(0) !== undefined) {
                iterations = 0;
                checkImage();
            } else {
                addHeight();
            }
        },

        completeImg: function(img) {
            var naturalWidthType;

            if (!img.complete) {
                return false;
            }
            naturalWidthType = typeof img.naturalWidth;
            if (naturalWidthType !== "undefined" && img.naturalWidth === 0) {
                return false;
            }
            return true;
        },

        onVisibleItems: function() {
            var base = this,
                i;

            if (base.options.addClassActive === true) {
                base.$owlItems.removeClass("active");
            }
            base.visibleItems = [];
            for (i = base.currentItem; i < base.currentItem + base.options.items; i += 1) {
                base.visibleItems.push(i);

                if (base.options.addClassActive === true) {
                    $(base.$owlItems[i]).addClass("active");
                }
            }
            base.owl.visibleItems = base.visibleItems;
        },

        transitionTypes: function(className) {
            var base = this;
            //Currently available: "fade", "backSlide", "goDown", "fadeUp"
            base.outClass = "owl-" + className + "-out";
            base.inClass = "owl-" + className + "-in";
        },

        singleItemTransition: function() {
            var base = this,
                outClass = base.outClass,
                inClass = base.inClass,
                $currentItem = base.$owlItems.eq(base.currentItem),
                $prevItem = base.$owlItems.eq(base.prevItem),
                prevPos = Math.abs(base.positionsInArray[base.currentItem]) + base.positionsInArray[base.prevItem],
                origin = Math.abs(base.positionsInArray[base.currentItem]) + base.itemWidth / 2,
                animEnd = 'webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend';

            base.isTransition = true;

            base.$owlWrapper
                .addClass('owl-origin')
                .css({
                    "-webkit-transform-origin": origin + "px",
                    "-moz-perspective-origin": origin + "px",
                    "perspective-origin": origin + "px"
                });

            function transStyles(prevPos) {
                return {
                    "position": "relative",
                    "left": prevPos + "px"
                };
            }

            $prevItem
                .css(transStyles(prevPos, 10))
                .addClass(outClass)
                .on(animEnd, function() {
                    base.endPrev = true;
                    $prevItem.off(animEnd);
                    base.clearTransStyle($prevItem, outClass);
                });

            $currentItem
                .addClass(inClass)
                .on(animEnd, function() {
                    base.endCurrent = true;
                    $currentItem.off(animEnd);
                    base.clearTransStyle($currentItem, inClass);
                });
        },

        clearTransStyle: function(item, classToRemove) {
            var base = this;
            item.css({
                "position": "",
                "left": ""
            }).removeClass(classToRemove);

            if (base.endPrev && base.endCurrent) {
                base.$owlWrapper.removeClass('owl-origin');
                base.endPrev = false;
                base.endCurrent = false;
                base.isTransition = false;
            }
        },

        owlStatus: function() {
            var base = this;
            base.owl = {
                "userOptions": base.userOptions,
                "baseElement": base.$elem,
                "userItems": base.$userItems,
                "owlItems": base.$owlItems,
                "currentItem": base.currentItem,
                "prevItem": base.prevItem,
                "visibleItems": base.visibleItems,
                "isTouch": base.browser.isTouch,
                "browser": base.browser,
                "dragDirection": base.dragDirection
            };
        },

        clearEvents: function() {
            var base = this;
            base.$elem.off(".owl owl mousedown.disableTextSelect");
            $(document).off(".owl owl");
            $(window).off("resize", base.resizer);
        },

        unWrap: function() {
            var base = this;
            if (base.$elem.children().length !== 0) {
                base.$owlWrapper.unwrap();
                base.$userItems.unwrap().unwrap();
                if (base.owlControls) {
                    base.owlControls.remove();
                }
            }
            base.clearEvents();
            base.$elem
                .attr("style", base.$elem.data("owl-originalStyles") || "")
                .attr("class", base.$elem.data("owl-originalClasses"));
        },

        destroy: function() {
            var base = this;
            base.stop();
            window.clearInterval(base.checkVisible);
            base.unWrap();
            base.$elem.removeData();
        },

        reinit: function(newOptions) {
            var base = this,
                options = $.extend({}, base.userOptions, newOptions);
            base.unWrap();
            base.init(options, base.$elem);
        },

        addItem: function(htmlString, targetPosition) {
            var base = this,
                position;

            if (!htmlString) {
                return false;
            }

            if (base.$elem.children().length === 0) {
                base.$elem.append(htmlString);
                base.setVars();
                return false;
            }
            base.unWrap();
            if (targetPosition === undefined || targetPosition === -1) {
                position = -1;
            } else {
                position = targetPosition;
            }
            if (position >= base.$userItems.length || position === -1) {
                base.$userItems.eq(-1).after(htmlString);
            } else {
                base.$userItems.eq(position).before(htmlString);
            }

            base.setVars();
        },

        removeItem: function(targetPosition) {
            var base = this,
                position;

            if (base.$elem.children().length === 0) {
                return false;
            }
            if (targetPosition === undefined || targetPosition === -1) {
                position = -1;
            } else {
                position = targetPosition;
            }

            base.unWrap();
            base.$userItems.eq(position).remove();
            base.setVars();
        }

    };

    $.fn.owlCarousel = function(options) {
        return this.each(function() {
            if ($(this).data("owl-init") === true) {
                return false;
            }
            $(this).data("owl-init", true);
            var carousel = Object.create(Carousel);
            carousel.init(options, this);
            $.data(this, "owlCarousel", carousel);
        });
    };

    $.fn.owlCarousel.options = {

        items: 5,
        itemsCustom: false,
        itemsDesktop: [1199, 4],
        itemsDesktopSmall: [979, 3],
        itemsTablet: [768, 2],
        itemsTabletSmall: false,
        itemsMobile: [479, 1],
        singleItem: false,
        itemsScaleUp: false,

        slideSpeed: 200,
        paginationSpeed: 800,
        rewindSpeed: 1000,

        autoPlay: false,
        stopOnHover: false,

        navigation: false,
        navigationText: ["prev", "next"],
        rewindNav: true,
        scrollPerPage: false,

        pagination: true,
        paginationNumbers: false,

        responsive: true,
        responsiveRefreshRate: 200,
        responsiveBaseWidth: window,

        baseClass: "owl-carousel",
        theme: "owl-theme",

        lazyLoad: false,
        lazyFollow: true,
        lazyEffect: "fade",

        autoHeight: false,

        jsonPath: false,
        jsonSuccess: false,

        dragBeforeAnimFinish: true,
        mouseDrag: true,
        touchDrag: true,

        addClassActive: false,
        transitionStyle: false,

        beforeUpdate: false,
        afterUpdate: false,
        beforeInit: false,
        afterInit: false,
        beforeMove: false,
        afterMove: false,
        afterAction: false,
        startDragging: false,
        afterLazyLoad: false
    };
}(jQuery, window, document));
/*! Magnific Popup - v1.0.1 - 2015-12-30
 * http://dimsemenov.com/plugins/magnific-popup/
 * Copyright (c) 2015 Dmitry Semenov; */
;
(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module. 
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS 
        factory(require('jquery'));
    } else {
        // Browser globals 
        factory(window.jQuery || window.Zepto);
    }
}(function($) {

    /*>>core*/
    /**
     * 
     * Magnific Popup Core JS file
     * 
     */


    /**
     * Private static constants
     */
    var CLOSE_EVENT = 'Close',
        BEFORE_CLOSE_EVENT = 'BeforeClose',
        AFTER_CLOSE_EVENT = 'AfterClose',
        BEFORE_APPEND_EVENT = 'BeforeAppend',
        MARKUP_PARSE_EVENT = 'MarkupParse',
        OPEN_EVENT = 'Open',
        CHANGE_EVENT = 'Change',
        NS = 'mfp',
        EVENT_NS = '.' + NS,
        READY_CLASS = 'mfp-ready',
        REMOVING_CLASS = 'mfp-removing',
        PREVENT_CLOSE_CLASS = 'mfp-prevent-close';


    /**
     * Private vars 
     */
    /*jshint -W079 */
    var mfp, // As we have only one instance of MagnificPopup object, we define it locally to not to use 'this'
        MagnificPopup = function() {},
        _isJQ = !!(window.jQuery),
        _prevStatus,
        _window = $(window),
        _document,
        _prevContentType,
        _wrapClasses,
        _currPopupType;


    /**
     * Private functions
     */
    var _mfpOn = function(name, f) {
            mfp.ev.on(NS + name + EVENT_NS, f);
        },
        _getEl = function(className, appendTo, html, raw) {
            var el = document.createElement('div');
            el.className = 'mfp-' + className;
            if (html) {
                el.innerHTML = html;
            }
            if (!raw) {
                el = $(el);
                if (appendTo) {
                    el.appendTo(appendTo);
                }
            } else if (appendTo) {
                appendTo.appendChild(el);
            }
            return el;
        },
        _mfpTrigger = function(e, data) {
            mfp.ev.triggerHandler(NS + e, data);

            if (mfp.st.callbacks) {
                // converts "mfpEventName" to "eventName" callback and triggers it if it's present
                e = e.charAt(0).toLowerCase() + e.slice(1);
                if (mfp.st.callbacks[e]) {
                    mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data]);
                }
            }
        },
        _getCloseBtn = function(type) {
            if (type !== _currPopupType || !mfp.currTemplate.closeBtn) {
                mfp.currTemplate.closeBtn = $(mfp.st.closeMarkup.replace('%title%', mfp.st.tClose));
                _currPopupType = type;
            }
            return mfp.currTemplate.closeBtn;
        },
        // Initialize Magnific Popup only when called at least once
        _checkInstance = function() {
            if (!$.magnificPopup.instance) {
                /*jshint -W020 */
                mfp = new MagnificPopup();
                mfp.init();
                $.magnificPopup.instance = mfp;
            }
        },
        // CSS transition detection, http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr
        supportsTransitions = function() {
            var s = document.createElement('p').style, // 's' for style. better to create an element if body yet to exist
                v = ['ms', 'O', 'Moz', 'Webkit']; // 'v' for vendor

            if (s['transition'] !== undefined) {
                return true;
            }

            while (v.length) {
                if (v.pop() + 'Transition' in s) {
                    return true;
                }
            }

            return false;
        };



    /**
     * Public functions
     */
    MagnificPopup.prototype = {

        constructor: MagnificPopup,

        /**
         * Initializes Magnific Popup plugin. 
         * This function is triggered only once when $.fn.magnificPopup or $.magnificPopup is executed
         */
        init: function() {
            var appVersion = navigator.appVersion;
            mfp.isIE7 = appVersion.indexOf("MSIE 7.") !== -1;
            mfp.isIE8 = appVersion.indexOf("MSIE 8.") !== -1;
            mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
            mfp.isAndroid = (/android/gi).test(appVersion);
            mfp.isIOS = (/iphone|ipad|ipod/gi).test(appVersion);
            mfp.supportsTransition = supportsTransitions();

            // We disable fixed positioned lightbox on devices that don't handle it nicely.
            // If you know a better way of detecting this - let me know.
            mfp.probablyMobile = (mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent));
            _document = $(document);

            mfp.popupsCache = {};
        },

        /**
         * Opens popup
         * @param  data [description]
         */
        open: function(data) {

            var i;

            if (data.isObj === false) {
                // convert jQuery collection to array to avoid conflicts later
                mfp.items = data.items.toArray();

                mfp.index = 0;
                var items = data.items,
                    item;
                for (i = 0; i < items.length; i++) {
                    item = items[i];
                    if (item.parsed) {
                        item = item.el[0];
                    }
                    if (item === data.el[0]) {
                        mfp.index = i;
                        break;
                    }
                }
            } else {
                mfp.items = $.isArray(data.items) ? data.items : [data.items];
                mfp.index = data.index || 0;
            }

            // if popup is already opened - we just update the content
            if (mfp.isOpen) {
                mfp.updateItemHTML();
                return;
            }

            mfp.types = [];
            _wrapClasses = '';
            if (data.mainEl && data.mainEl.length) {
                mfp.ev = data.mainEl.eq(0);
            } else {
                mfp.ev = _document;
            }

            if (data.key) {
                if (!mfp.popupsCache[data.key]) {
                    mfp.popupsCache[data.key] = {};
                }
                mfp.currTemplate = mfp.popupsCache[data.key];
            } else {
                mfp.currTemplate = {};
            }



            mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data);
            mfp.fixedContentPos = mfp.st.fixedContentPos === 'auto' ? !mfp.probablyMobile : mfp.st.fixedContentPos;

            if (mfp.st.modal) {
                mfp.st.closeOnContentClick = false;
                mfp.st.closeOnBgClick = false;
                mfp.st.showCloseBtn = false;
                mfp.st.enableEscapeKey = false;
            }


            // Building markup
            // main containers are created only once
            if (!mfp.bgOverlay) {

                // Dark overlay
                mfp.bgOverlay = _getEl('bg').on('click' + EVENT_NS, function() {
                    mfp.close();
                });

                mfp.wrap = _getEl('wrap').attr('tabindex', -1).on('click' + EVENT_NS, function(e) {
                    if (mfp._checkIfClose(e.target)) {
                        mfp.close();
                    }
                });

                mfp.container = _getEl('container', mfp.wrap);
            }

            mfp.contentContainer = _getEl('content');
            if (mfp.st.preloader) {
                mfp.preloader = _getEl('preloader', mfp.container, mfp.st.tLoading);
            }


            // Initializing modules
            var modules = $.magnificPopup.modules;
            for (i = 0; i < modules.length; i++) {
                var n = modules[i];
                n = n.charAt(0).toUpperCase() + n.slice(1);
                mfp['init' + n].call(mfp);
            }
            _mfpTrigger('BeforeOpen');


            if (mfp.st.showCloseBtn) {
                // Close button
                if (!mfp.st.closeBtnInside) {
                    mfp.wrap.append(_getCloseBtn());
                } else {
                    _mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
                        values.close_replaceWith = _getCloseBtn(item.type);
                    });
                    _wrapClasses += ' mfp-close-btn-in';
                }
            }

            if (mfp.st.alignTop) {
                _wrapClasses += ' mfp-align-top';
            }



            if (mfp.fixedContentPos) {
                mfp.wrap.css({
                    overflow: mfp.st.overflowY,
                    overflowX: 'hidden',
                    overflowY: mfp.st.overflowY
                });
            } else {
                mfp.wrap.css({
                    top: _window.scrollTop(),
                    position: 'absolute'
                });
            }
            if (mfp.st.fixedBgPos === false || (mfp.st.fixedBgPos === 'auto' && !mfp.fixedContentPos)) {
                mfp.bgOverlay.css({
                    height: _document.height(),
                    position: 'absolute'
                });
            }



            if (mfp.st.enableEscapeKey) {
                // Close on ESC key
                _document.on('keyup' + EVENT_NS, function(e) {
                    if (e.keyCode === 27) {
                        mfp.close();
                    }
                });
            }

            _window.on('resize' + EVENT_NS, function() {
                mfp.updateSize();
            });


            if (!mfp.st.closeOnContentClick) {
                _wrapClasses += ' mfp-auto-cursor';
            }

            if (_wrapClasses)
                mfp.wrap.addClass(_wrapClasses);


            // this triggers recalculation of layout, so we get it once to not to trigger twice
            var windowHeight = mfp.wH = _window.height();


            var windowStyles = {};

            if (mfp.fixedContentPos) {
                if (mfp._hasScrollBar(windowHeight)) {
                    var s = mfp._getScrollbarSize();
                    if (s) {
                        windowStyles.marginRight = s;
                    }
                }
            }

            if (mfp.fixedContentPos) {
                if (!mfp.isIE7) {
                    windowStyles.overflow = 'hidden';
                } else {
                    // ie7 double-scroll bug
                    $('body, html').css('overflow', 'hidden');
                }
            }



            var classesToadd = mfp.st.mainClass;
            if (mfp.isIE7) {
                classesToadd += ' mfp-ie7';
            }
            if (classesToadd) {
                mfp._addClassToMFP(classesToadd);
            }

            // add content
            mfp.updateItemHTML();

            _mfpTrigger('BuildControls');

            // remove scrollbar, add margin e.t.c
            $('html').css(windowStyles);

            // add everything to DOM
            mfp.bgOverlay.add(mfp.wrap).prependTo(mfp.st.prependTo || $(document.body));

            // Save last focused element
            mfp._lastFocusedEl = document.activeElement;

            // Wait for next cycle to allow CSS transition
            setTimeout(function() {

                if (mfp.content) {
                    mfp._addClassToMFP(READY_CLASS);
                    mfp._setFocus();
                } else {
                    // if content is not defined (not loaded e.t.c) we add class only for BG
                    mfp.bgOverlay.addClass(READY_CLASS);
                }

                // Trap the focus in popup
                _document.on('focusin' + EVENT_NS, mfp._onFocusIn);

            }, 16);

            mfp.isOpen = true;
            mfp.updateSize(windowHeight);
            _mfpTrigger(OPEN_EVENT);

            return data;
        },

        /**
         * Closes the popup
         */
        close: function() {
            if (!mfp.isOpen) return;
            _mfpTrigger(BEFORE_CLOSE_EVENT);

            mfp.isOpen = false;
            // for CSS3 animation
            if (mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition) {
                mfp._addClassToMFP(REMOVING_CLASS);
                setTimeout(function() {
                    mfp._close();
                }, mfp.st.removalDelay);
            } else {
                mfp._close();
            }
        },

        /**
         * Helper for close() function
         */
        _close: function() {
            _mfpTrigger(CLOSE_EVENT);

            var classesToRemove = REMOVING_CLASS + ' ' + READY_CLASS + ' ';

            mfp.bgOverlay.detach();
            mfp.wrap.detach();
            mfp.container.empty();

            if (mfp.st.mainClass) {
                classesToRemove += mfp.st.mainClass + ' ';
            }

            mfp._removeClassFromMFP(classesToRemove);

            if (mfp.fixedContentPos) {
                var windowStyles = {
                    marginRight: ''
                };
                if (mfp.isIE7) {
                    $('body, html').css('overflow', '');
                } else {
                    windowStyles.overflow = '';
                }
                $('html').css(windowStyles);
            }

            _document.off('keyup' + EVENT_NS + ' focusin' + EVENT_NS);
            mfp.ev.off(EVENT_NS);

            // clean up DOM elements that aren't removed
            mfp.wrap.attr('class', 'mfp-wrap').removeAttr('style');
            mfp.bgOverlay.attr('class', 'mfp-bg');
            mfp.container.attr('class', 'mfp-container');

            // remove close button from target element
            if (mfp.st.showCloseBtn &&
                (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
                if (mfp.currTemplate.closeBtn)
                    mfp.currTemplate.closeBtn.detach();
            }


            if (mfp.st.autoFocusLast && mfp._lastFocusedEl) {
                $(mfp._lastFocusedEl).focus(); // put tab focus back
            }
            mfp.currItem = null;
            mfp.content = null;
            mfp.currTemplate = null;
            mfp.prevHeight = 0;

            _mfpTrigger(AFTER_CLOSE_EVENT);
        },

        updateSize: function(winHeight) {

            if (mfp.isIOS) {
                // fixes iOS nav bars https://github.com/dimsemenov/Magnific-Popup/issues/2
                var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
                var height = window.innerHeight * zoomLevel;
                mfp.wrap.css('height', height);
                mfp.wH = height;
            } else {
                mfp.wH = winHeight || _window.height();
            }
            // Fixes #84: popup incorrectly positioned with position:relative on body
            if (!mfp.fixedContentPos) {
                mfp.wrap.css('height', mfp.wH);
            }

            _mfpTrigger('Resize');

        },

        /**
         * Set content of popup based on current index
         */
        updateItemHTML: function() {
            var item = mfp.items[mfp.index];

            // Detach and perform modifications
            mfp.contentContainer.detach();

            if (mfp.content)
                mfp.content.detach();

            if (!item.parsed) {
                item = mfp.parseEl(mfp.index);
            }

            var type = item.type;

            _mfpTrigger('BeforeChange', [mfp.currItem ? mfp.currItem.type : '', type]);
            // BeforeChange event works like so:
            // _mfpOn('BeforeChange', function(e, prevType, newType) { });

            mfp.currItem = item;




            if (!mfp.currTemplate[type]) {
                var markup = mfp.st[type] ? mfp.st[type].markup : false;

                // allows to modify markup
                _mfpTrigger('FirstMarkupParse', markup);

                if (markup) {
                    mfp.currTemplate[type] = $(markup);
                } else {
                    // if there is no markup found we just define that template is parsed
                    mfp.currTemplate[type] = true;
                }
            }

            if (_prevContentType && _prevContentType !== item.type) {
                mfp.container.removeClass('mfp-' + _prevContentType + '-holder');
            }

            var newContent = mfp['get' + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
            mfp.appendContent(newContent, type);

            item.preloaded = true;

            _mfpTrigger(CHANGE_EVENT, item);
            _prevContentType = item.type;

            // Append container back after its content changed
            mfp.container.prepend(mfp.contentContainer);

            _mfpTrigger('AfterChange');
        },


        /**
         * Set HTML content of popup
         */
        appendContent: function(newContent, type) {
            mfp.content = newContent;

            if (newContent) {
                if (mfp.st.showCloseBtn && mfp.st.closeBtnInside &&
                    mfp.currTemplate[type] === true) {
                    // if there is no markup, we just append close button element inside
                    if (!mfp.content.find('.mfp-close').length) {
                        mfp.content.append(_getCloseBtn());
                    }
                } else {
                    mfp.content = newContent;
                }
            } else {
                mfp.content = '';
            }

            _mfpTrigger(BEFORE_APPEND_EVENT);
            mfp.container.addClass('mfp-' + type + '-holder');

            mfp.contentContainer.append(mfp.content);
        },




        /**
         * Creates Magnific Popup data object based on given data
         * @param  {int} index Index of item to parse
         */
        parseEl: function(index) {
            var item = mfp.items[index],
                type;

            if (item.tagName) {
                item = {
                    el: $(item)
                };
            } else {
                type = item.type;
                item = {
                    data: item,
                    src: item.src
                };
            }

            if (item.el) {
                var types = mfp.types;

                // check for 'mfp-TYPE' class
                for (var i = 0; i < types.length; i++) {
                    if (item.el.hasClass('mfp-' + types[i])) {
                        type = types[i];
                        break;
                    }
                }

                item.src = item.el.attr('data-mfp-src');
                if (!item.src) {
                    item.src = item.el.attr('href');
                }
            }

            item.type = type || mfp.st.type || 'inline';
            item.index = index;
            item.parsed = true;
            mfp.items[index] = item;
            _mfpTrigger('ElementParse', item);

            return mfp.items[index];
        },


        /**
         * Initializes single popup or a group of popups
         */
        addGroup: function(el, options) {
            var eHandler = function(e) {
                e.mfpEl = this;
                mfp._openClick(e, el, options);
            };

            if (!options) {
                options = {};
            }

            var eName = 'click.magnificPopup';
            options.mainEl = el;

            if (options.items) {
                options.isObj = true;
                el.off(eName).on(eName, eHandler);
            } else {
                options.isObj = false;
                if (options.delegate) {
                    el.off(eName).on(eName, options.delegate, eHandler);
                } else {
                    options.items = el;
                    el.off(eName).on(eName, eHandler);
                }
            }
        },
        _openClick: function(e, el, options) {
            var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;


            if (!midClick && (e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey)) {
                return;
            }

            var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;

            if (disableOn) {
                if ($.isFunction(disableOn)) {
                    if (!disableOn.call(mfp)) {
                        return true;
                    }
                } else { // else it's number
                    if (_window.width() < disableOn) {
                        return true;
                    }
                }
            }

            if (e.type) {
                e.preventDefault();

                // This will prevent popup from closing if element is inside and popup is already opened
                if (mfp.isOpen) {
                    e.stopPropagation();
                }
            }


            options.el = $(e.mfpEl);
            if (options.delegate) {
                options.items = el.find(options.delegate);
            }
            mfp.open(options);
        },


        /**
         * Updates text on preloader
         */
        updateStatus: function(status, text) {

            if (mfp.preloader) {
                if (_prevStatus !== status) {
                    mfp.container.removeClass('mfp-s-' + _prevStatus);
                }

                if (!text && status === 'loading') {
                    text = mfp.st.tLoading;
                }

                var data = {
                    status: status,
                    text: text
                };
                // allows to modify status
                _mfpTrigger('UpdateStatus', data);

                status = data.status;
                text = data.text;

                mfp.preloader.html(text);

                mfp.preloader.find('a').on('click', function(e) {
                    e.stopImmediatePropagation();
                });

                mfp.container.addClass('mfp-s-' + status);
                _prevStatus = status;
            }
        },


        /*
        	"Private" helpers that aren't private at all
         */
        // Check to close popup or not
        // "target" is an element that was clicked
        _checkIfClose: function(target) {

            if ($(target).hasClass(PREVENT_CLOSE_CLASS)) {
                return;
            }

            var closeOnContent = mfp.st.closeOnContentClick;
            var closeOnBg = mfp.st.closeOnBgClick;

            if (closeOnContent && closeOnBg) {
                return true;
            } else {

                // We close the popup if click is on close button or on preloader. Or if there is no content.
                if (!mfp.content || $(target).hasClass('mfp-close') || (mfp.preloader && target === mfp.preloader[0])) {
                    return true;
                }

                // if click is outside the content
                if ((target !== mfp.content[0] && !$.contains(mfp.content[0], target))) {
                    if (closeOnBg) {
                        // last check, if the clicked element is in DOM, (in case it's removed onclick)
                        if ($.contains(document, target)) {
                            return true;
                        }
                    }
                } else if (closeOnContent) {
                    return true;
                }

            }
            return false;
        },
        _addClassToMFP: function(cName) {
            mfp.bgOverlay.addClass(cName);
            mfp.wrap.addClass(cName);
        },
        _removeClassFromMFP: function(cName) {
            this.bgOverlay.removeClass(cName);
            mfp.wrap.removeClass(cName);
        },
        _hasScrollBar: function(winHeight) {
            return ((mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height()));
        },
        _setFocus: function() {
            (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
        },
        _onFocusIn: function(e) {
            if (e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target)) {
                mfp._setFocus();
                return false;
            }
        },
        _parseMarkup: function(template, values, item) {
            var arr;
            if (item.data) {
                values = $.extend(item.data, values);
            }
            _mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item]);

            $.each(values, function(key, value) {
                if (value === undefined || value === false) {
                    return true;
                }
                arr = key.split('_');
                if (arr.length > 1) {
                    var el = template.find(EVENT_NS + '-' + arr[0]);

                    if (el.length > 0) {
                        var attr = arr[1];
                        if (attr === 'replaceWith') {
                            if (el[0] !== value[0]) {
                                el.replaceWith(value);
                            }
                        } else if (attr === 'img') {
                            if (el.is('img')) {
                                el.attr('src', value);
                            } else {
                                el.replaceWith('<img src="' + value + '" class="' + el.attr('class') + '" />');
                            }
                        } else {
                            el.attr(arr[1], value);
                        }
                    }

                } else {
                    template.find(EVENT_NS + '-' + key).html(value);
                }
            });
        },

        _getScrollbarSize: function() {
            // thx David
            if (mfp.scrollbarSize === undefined) {
                var scrollDiv = document.createElement("div");
                scrollDiv.style.cssText = 'width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;';
                document.body.appendChild(scrollDiv);
                mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
                document.body.removeChild(scrollDiv);
            }
            return mfp.scrollbarSize;
        }

    }; /* MagnificPopup core prototype end */




    /**
     * Public static functions
     */
    $.magnificPopup = {
        instance: null,
        proto: MagnificPopup.prototype,
        modules: [],

        open: function(options, index) {
            _checkInstance();

            if (!options) {
                options = {};
            } else {
                options = $.extend(true, {}, options);
            }


            options.isObj = true;
            options.index = index || 0;
            return this.instance.open(options);
        },

        close: function() {
            return $.magnificPopup.instance && $.magnificPopup.instance.close();
        },

        registerModule: function(name, module) {
            if (module.options) {
                $.magnificPopup.defaults[name] = module.options;
            }
            $.extend(this.proto, module.proto);
            this.modules.push(name);
        },

        defaults: {

            // Info about options is in docs:
            // http://dimsemenov.com/plugins/magnific-popup/documentation.html#options

            disableOn: 0,

            key: null,

            midClick: false,

            mainClass: '',

            preloader: true,

            focus: '', // CSS selector of input to focus after popup is opened

            closeOnContentClick: false,

            closeOnBgClick: true,

            closeBtnInside: true,

            showCloseBtn: true,

            enableEscapeKey: true,

            modal: false,

            alignTop: false,

            removalDelay: 0,

            prependTo: null,

            fixedContentPos: 'auto',

            fixedBgPos: 'auto',

            overflowY: 'auto',

            closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',

            tClose: 'Close (Esc)',

            tLoading: 'Loading...',

            autoFocusLast: true

        }
    };



    $.fn.magnificPopup = function(options) {
        _checkInstance();

        var jqEl = $(this);

        // We call some API method of first param is a string
        if (typeof options === "string") {

            if (options === 'open') {
                var items,
                    itemOpts = _isJQ ? jqEl.data('magnificPopup') : jqEl[0].magnificPopup,
                    index = parseInt(arguments[1], 10) || 0;

                if (itemOpts.items) {
                    items = itemOpts.items[index];
                } else {
                    items = jqEl;
                    if (itemOpts.delegate) {
                        items = items.find(itemOpts.delegate);
                    }
                    items = items.eq(index);
                }
                mfp._openClick({
                    mfpEl: items
                }, jqEl, itemOpts);
            } else {
                if (mfp.isOpen)
                    mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
            }

        } else {
            // clone options obj
            options = $.extend(true, {}, options);

            /*
             * As Zepto doesn't support .data() method for objects 
             * and it works only in normal browsers
             * we assign "options" object directly to the DOM element. FTW!
             */
            if (_isJQ) {
                jqEl.data('magnificPopup', options);
            } else {
                jqEl[0].magnificPopup = options;
            }

            mfp.addGroup(jqEl, options);

        }
        return jqEl;
    };


    //Quick benchmark
    /*
    var start = performance.now(),
    	i,
    	rounds = 1000;

    for(i = 0; i < rounds; i++) {

    }
    console.log('Test #1:', performance.now() - start);

    start = performance.now();
    for(i = 0; i < rounds; i++) {

    }
    console.log('Test #2:', performance.now() - start);
    */


    /*>>core*/

    /*>>inline*/

    var INLINE_NS = 'inline',
        _hiddenClass,
        _inlinePlaceholder,
        _lastInlineElement,
        _putInlineElementsBack = function() {
            if (_lastInlineElement) {
                _inlinePlaceholder.after(_lastInlineElement.addClass(_hiddenClass)).detach();
                _lastInlineElement = null;
            }
        };

    $.magnificPopup.registerModule(INLINE_NS, {
        options: {
            hiddenClass: 'hide', // will be appended with `mfp-` prefix
            markup: '',
            tNotFound: 'Content not found'
        },
        proto: {

            initInline: function() {
                mfp.types.push(INLINE_NS);

                _mfpOn(CLOSE_EVENT + '.' + INLINE_NS, function() {
                    _putInlineElementsBack();
                });
            },

            getInline: function(item, template) {

                _putInlineElementsBack();

                if (item.src) {
                    var inlineSt = mfp.st.inline,
                        el = $(item.src);

                    if (el.length) {

                        // If target element has parent - we replace it with placeholder and put it back after popup is closed
                        var parent = el[0].parentNode;
                        if (parent && parent.tagName) {
                            if (!_inlinePlaceholder) {
                                _hiddenClass = inlineSt.hiddenClass;
                                _inlinePlaceholder = _getEl(_hiddenClass);
                                _hiddenClass = 'mfp-' + _hiddenClass;
                            }
                            // replace target inline element with placeholder
                            _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
                        }

                        mfp.updateStatus('ready');
                    } else {
                        mfp.updateStatus('error', inlineSt.tNotFound);
                        el = $('<div>');
                    }

                    item.inlineElement = el;
                    return el;
                }

                mfp.updateStatus('ready');
                mfp._parseMarkup(template, {}, item);
                return template;
            }
        }
    });

    /*>>inline*/

    /*>>ajax*/
    var AJAX_NS = 'ajax',
        _ajaxCur,
        _removeAjaxCursor = function() {
            if (_ajaxCur) {
                $(document.body).removeClass(_ajaxCur);
            }
        },
        _destroyAjaxRequest = function() {
            _removeAjaxCursor();
            if (mfp.req) {
                mfp.req.abort();
            }
        };

    $.magnificPopup.registerModule(AJAX_NS, {

        options: {
            settings: null,
            cursor: 'mfp-ajax-cur',
            tError: '<a href="%url%">The content</a> could not be loaded.'
        },

        proto: {
            initAjax: function() {
                mfp.types.push(AJAX_NS);
                _ajaxCur = mfp.st.ajax.cursor;

                _mfpOn(CLOSE_EVENT + '.' + AJAX_NS, _destroyAjaxRequest);
                _mfpOn('BeforeChange.' + AJAX_NS, _destroyAjaxRequest);
            },
            getAjax: function(item) {

                if (_ajaxCur) {
                    $(document.body).addClass(_ajaxCur);
                }

                mfp.updateStatus('loading');

                var opts = $.extend({
                    url: item.src,
                    success: function(data, textStatus, jqXHR) {
                        var temp = {
                            data: data,
                            xhr: jqXHR
                        };

                        _mfpTrigger('ParseAjax', temp);

                        mfp.appendContent($(temp.data), AJAX_NS);

                        item.finished = true;

                        _removeAjaxCursor();

                        mfp._setFocus();

                        setTimeout(function() {
                            mfp.wrap.addClass(READY_CLASS);
                        }, 16);

                        mfp.updateStatus('ready');

                        _mfpTrigger('AjaxContentAdded');
                    },
                    error: function() {
                        _removeAjaxCursor();
                        item.finished = item.loadError = true;
                        mfp.updateStatus('error', mfp.st.ajax.tError.replace('%url%', item.src));
                    }
                }, mfp.st.ajax.settings);

                mfp.req = $.ajax(opts);

                return '';
            }
        }
    });




    /*>>ajax*/

    /*>>image*/
    var _imgInterval,
        _getTitle = function(item) {
            if (item.data && item.data.title !== undefined)
                return item.data.title;

            var src = mfp.st.image.titleSrc;

            if (src) {
                if ($.isFunction(src)) {
                    return src.call(mfp, item);
                } else if (item.el) {
                    return item.el.attr(src) || '';
                }
            }
            return '';
        };

    $.magnificPopup.registerModule('image', {

        options: {
            markup: '<div class="mfp-figure">' +
                '<div class="mfp-close"></div>' +
                '<figure>' +
                '<div class="mfp-img"></div>' +
                '<figcaption>' +
                '<div class="mfp-bottom-bar">' +
                '<div class="mfp-title"></div>' +
                '<div class="mfp-counter"></div>' +
                '</div>' +
                '</figcaption>' +
                '</figure>' +
                '</div>',
            cursor: 'mfp-zoom-out-cur',
            titleSrc: 'title',
            verticalFit: true,
            tError: '<a href="%url%">The image</a> could not be loaded.'
        },

        proto: {
            initImage: function() {
                var imgSt = mfp.st.image,
                    ns = '.image';

                mfp.types.push('image');

                _mfpOn(OPEN_EVENT + ns, function() {
                    if (mfp.currItem.type === 'image' && imgSt.cursor) {
                        $(document.body).addClass(imgSt.cursor);
                    }
                });

                _mfpOn(CLOSE_EVENT + ns, function() {
                    if (imgSt.cursor) {
                        $(document.body).removeClass(imgSt.cursor);
                    }
                    _window.off('resize' + EVENT_NS);
                });

                _mfpOn('Resize' + ns, mfp.resizeImage);
                if (mfp.isLowIE) {
                    _mfpOn('AfterChange', mfp.resizeImage);
                }
            },
            resizeImage: function() {
                var item = mfp.currItem;
                if (!item || !item.img) return;

                if (mfp.st.image.verticalFit) {
                    var decr = 0;
                    // fix box-sizing in ie7/8
                    if (mfp.isLowIE) {
                        decr = parseInt(item.img.css('padding-top'), 10) + parseInt(item.img.css('padding-bottom'), 10);
                    }
                    item.img.css('max-height', mfp.wH - decr);
                }
            },
            _onImageHasSize: function(item) {
                if (item.img) {

                    item.hasSize = true;

                    if (_imgInterval) {
                        clearInterval(_imgInterval);
                    }

                    item.isCheckingImgSize = false;

                    _mfpTrigger('ImageHasSize', item);

                    if (item.imgHidden) {
                        if (mfp.content)
                            mfp.content.removeClass('mfp-loading');

                        item.imgHidden = false;
                    }

                }
            },

            /**
             * Function that loops until the image has size to display elements that rely on it asap
             */
            findImageSize: function(item) {

                var counter = 0,
                    img = item.img[0],
                    mfpSetInterval = function(delay) {

                        if (_imgInterval) {
                            clearInterval(_imgInterval);
                        }
                        // decelerating interval that checks for size of an image
                        _imgInterval = setInterval(function() {
                            if (img.naturalWidth > 0) {
                                mfp._onImageHasSize(item);
                                return;
                            }

                            if (counter > 200) {
                                clearInterval(_imgInterval);
                            }

                            counter++;
                            if (counter === 3) {
                                mfpSetInterval(10);
                            } else if (counter === 40) {
                                mfpSetInterval(50);
                            } else if (counter === 100) {
                                mfpSetInterval(500);
                            }
                        }, delay);
                    };

                mfpSetInterval(1);
            },

            getImage: function(item, template) {

                var guard = 0,

                    // image load complete handler
                    onLoadComplete = function() {
                        if (item) {
                            if (item.img[0].complete) {
                                item.img.off('.mfploader');

                                if (item === mfp.currItem) {
                                    mfp._onImageHasSize(item);

                                    mfp.updateStatus('ready');
                                }

                                item.hasSize = true;
                                item.loaded = true;

                                _mfpTrigger('ImageLoadComplete');

                            } else {
                                // if image complete check fails 200 times (20 sec), we assume that there was an error.
                                guard++;
                                if (guard < 200) {
                                    setTimeout(onLoadComplete, 100);
                                } else {
                                    onLoadError();
                                }
                            }
                        }
                    },

                    // image error handler
                    onLoadError = function() {
                        if (item) {
                            item.img.off('.mfploader');
                            if (item === mfp.currItem) {
                                mfp._onImageHasSize(item);
                                mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src));
                            }

                            item.hasSize = true;
                            item.loaded = true;
                            item.loadError = true;
                        }
                    },
                    imgSt = mfp.st.image;


                var el = template.find('.mfp-img');
                if (el.length) {
                    var img = document.createElement('img');
                    img.className = 'mfp-img';
                    if (item.el && item.el.find('img').length) {
                        img.alt = item.el.find('img').attr('alt');
                    }
                    item.img = $(img).on('load.mfploader', onLoadComplete).on('error.mfploader', onLoadError);
                    img.src = item.src;

                    // without clone() "error" event is not firing when IMG is replaced by new IMG
                    // TODO: find a way to avoid such cloning
                    if (el.is('img')) {
                        item.img = item.img.clone();
                    }

                    img = item.img[0];
                    if (img.naturalWidth > 0) {
                        item.hasSize = true;
                    } else if (!img.width) {
                        item.hasSize = false;
                    }
                }

                mfp._parseMarkup(template, {
                    title: _getTitle(item),
                    img_replaceWith: item.img
                }, item);

                mfp.resizeImage();

                if (item.hasSize) {
                    if (_imgInterval) clearInterval(_imgInterval);

                    if (item.loadError) {
                        template.addClass('mfp-loading');
                        mfp.updateStatus('error', imgSt.tError.replace('%url%', item.src));
                    } else {
                        template.removeClass('mfp-loading');
                        mfp.updateStatus('ready');
                    }
                    return template;
                }

                mfp.updateStatus('loading');
                item.loading = true;

                if (!item.hasSize) {
                    item.imgHidden = true;
                    template.addClass('mfp-loading');
                    mfp.findImageSize(item);
                }

                return template;
            }
        }
    });



    /*>>image*/

    /*>>zoom*/
    var hasMozTransform,
        getHasMozTransform = function() {
            if (hasMozTransform === undefined) {
                hasMozTransform = document.createElement('p').style.MozTransform !== undefined;
            }
            return hasMozTransform;
        };

    $.magnificPopup.registerModule('zoom', {

        options: {
            enabled: false,
            easing: 'ease-in-out',
            duration: 300,
            opener: function(element) {
                return element.is('img') ? element : element.find('img');
            }
        },

        proto: {

            initZoom: function() {
                var zoomSt = mfp.st.zoom,
                    ns = '.zoom',
                    image;

                if (!zoomSt.enabled || !mfp.supportsTransition) {
                    return;
                }

                var duration = zoomSt.duration,
                    getElToAnimate = function(image) {
                        var newImg = image.clone().removeAttr('style').removeAttr('class').addClass('mfp-animated-image'),
                            transition = 'all ' + (zoomSt.duration / 1000) + 's ' + zoomSt.easing,
                            cssObj = {
                                position: 'fixed',
                                zIndex: 9999,
                                left: 0,
                                top: 0,
                                '-webkit-backface-visibility': 'hidden'
                            },
                            t = 'transition';

                        cssObj['-webkit-' + t] = cssObj['-moz-' + t] = cssObj['-o-' + t] = cssObj[t] = transition;

                        newImg.css(cssObj);
                        return newImg;
                    },
                    showMainContent = function() {
                        mfp.content.css('visibility', 'visible');
                    },
                    openTimeout,
                    animatedImg;

                _mfpOn('BuildControls' + ns, function() {
                    if (mfp._allowZoom()) {

                        clearTimeout(openTimeout);
                        mfp.content.css('visibility', 'hidden');

                        // Basically, all code below does is clones existing image, puts in on top of the current one and animated it

                        image = mfp._getItemToZoom();

                        if (!image) {
                            showMainContent();
                            return;
                        }

                        animatedImg = getElToAnimate(image);

                        animatedImg.css(mfp._getOffset());

                        mfp.wrap.append(animatedImg);

                        openTimeout = setTimeout(function() {
                            animatedImg.css(mfp._getOffset(true));
                            openTimeout = setTimeout(function() {

                                showMainContent();

                                setTimeout(function() {
                                    animatedImg.remove();
                                    image = animatedImg = null;
                                    _mfpTrigger('ZoomAnimationEnded');
                                }, 16); // avoid blink when switching images 

                            }, duration); // this timeout equals animation duration

                        }, 16); // by adding this timeout we avoid short glitch at the beginning of animation


                        // Lots of timeouts...
                    }
                });
                _mfpOn(BEFORE_CLOSE_EVENT + ns, function() {
                    if (mfp._allowZoom()) {

                        clearTimeout(openTimeout);

                        mfp.st.removalDelay = duration;

                        if (!image) {
                            image = mfp._getItemToZoom();
                            if (!image) {
                                return;
                            }
                            animatedImg = getElToAnimate(image);
                        }


                        animatedImg.css(mfp._getOffset(true));
                        mfp.wrap.append(animatedImg);
                        mfp.content.css('visibility', 'hidden');

                        setTimeout(function() {
                            animatedImg.css(mfp._getOffset());
                        }, 16);
                    }

                });

                _mfpOn(CLOSE_EVENT + ns, function() {
                    if (mfp._allowZoom()) {
                        showMainContent();
                        if (animatedImg) {
                            animatedImg.remove();
                        }
                        image = null;
                    }
                });
            },

            _allowZoom: function() {
                return mfp.currItem.type === 'image';
            },

            _getItemToZoom: function() {
                if (mfp.currItem.hasSize) {
                    return mfp.currItem.img;
                } else {
                    return false;
                }
            },

            // Get element postion relative to viewport
            _getOffset: function(isLarge) {
                var el;
                if (isLarge) {
                    el = mfp.currItem.img;
                } else {
                    el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem);
                }

                var offset = el.offset();
                var paddingTop = parseInt(el.css('padding-top'), 10);
                var paddingBottom = parseInt(el.css('padding-bottom'), 10);
                offset.top -= ($(window).scrollTop() - paddingTop);


                /*
			
                Animating left + top + width/height looks glitchy in Firefox, but perfect in Chrome. And vice-versa.

                 */
                var obj = {
                    width: el.width(),
                    // fix Zepto height+padding issue
                    height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
                };

                // I hate to do this, but there is no another option
                if (getHasMozTransform()) {
                    obj['-moz-transform'] = obj['transform'] = 'translate(' + offset.left + 'px,' + offset.top + 'px)';
                } else {
                    obj.left = offset.left;
                    obj.top = offset.top;
                }
                return obj;
            }

        }
    });



    /*>>zoom*/

    /*>>iframe*/

    var IFRAME_NS = 'iframe',
        _emptyPage = '//about:blank',

        _fixIframeBugs = function(isShowing) {
            if (mfp.currTemplate[IFRAME_NS]) {
                var el = mfp.currTemplate[IFRAME_NS].find('iframe');
                if (el.length) {
                    // reset src after the popup is closed to avoid "video keeps playing after popup is closed" bug
                    if (!isShowing) {
                        el[0].src = _emptyPage;
                    }

                    // IE8 black screen bug fix
                    if (mfp.isIE8) {
                        el.css('display', isShowing ? 'block' : 'none');
                    }
                }
            }
        };

    $.magnificPopup.registerModule(IFRAME_NS, {

        options: {
            markup: '<div class="mfp-iframe-scaler">' +
                '<div class="mfp-close"></div>' +
                '<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>' +
                '</div>',

            srcAction: 'iframe_src',

            // we don't care and support only one default type of URL by default
            patterns: {
                youtube: {
                    index: 'youtube.com',
                    id: 'v=',
                    src: '//www.youtube.com/embed/%id%?autoplay=1'
                },
                vimeo: {
                    index: 'vimeo.com/',
                    id: '/',
                    src: '//player.vimeo.com/video/%id%?autoplay=1'
                },
                gmaps: {
                    index: '//maps.google.',
                    src: '%id%&output=embed'
                }
            }
        },

        proto: {
            initIframe: function() {
                mfp.types.push(IFRAME_NS);

                _mfpOn('BeforeChange', function(e, prevType, newType) {
                    if (prevType !== newType) {
                        if (prevType === IFRAME_NS) {
                            _fixIframeBugs(); // iframe if removed
                        } else if (newType === IFRAME_NS) {
                            _fixIframeBugs(true); // iframe is showing
                        }
                    } // else {
                    // iframe source is switched, don't do anything
                    //}
                });

                _mfpOn(CLOSE_EVENT + '.' + IFRAME_NS, function() {
                    _fixIframeBugs();
                });
            },

            getIframe: function(item, template) {
                var embedSrc = item.src;
                var iframeSt = mfp.st.iframe;

                $.each(iframeSt.patterns, function() {
                    if (embedSrc.indexOf(this.index) > -1) {
                        if (this.id) {
                            if (typeof this.id === 'string') {
                                embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length);
                            } else {
                                embedSrc = this.id.call(this, embedSrc);
                            }
                        }
                        embedSrc = this.src.replace('%id%', embedSrc);
                        return false; // break;
                    }
                });

                var dataObj = {};
                if (iframeSt.srcAction) {
                    dataObj[iframeSt.srcAction] = embedSrc;
                }
                mfp._parseMarkup(template, dataObj, item);

                mfp.updateStatus('ready');

                return template;
            }
        }
    });



    /*>>iframe*/

    /*>>gallery*/
    /**
     * Get looped index depending on number of slides
     */
    var _getLoopedId = function(index) {
            var numSlides = mfp.items.length;
            if (index > numSlides - 1) {
                return index - numSlides;
            } else if (index < 0) {
                return numSlides + index;
            }
            return index;
        },
        _replaceCurrTotal = function(text, curr, total) {
            return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total);
        };

    $.magnificPopup.registerModule('gallery', {

        options: {
            enabled: false,
            arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
            preload: [0, 2],
            navigateByImgClick: true,
            arrows: true,

            tPrev: 'Previous (Left arrow key)',
            tNext: 'Next (Right arrow key)',
            tCounter: '%curr% of %total%'
        },

        proto: {
            initGallery: function() {

                var gSt = mfp.st.gallery,
                    ns = '.mfp-gallery',
                    supportsFastClick = Boolean($.fn.mfpFastClick);

                mfp.direction = true; // true - next, false - prev

                if (!gSt || !gSt.enabled) return false;

                _wrapClasses += ' mfp-gallery';

                _mfpOn(OPEN_EVENT + ns, function() {

                    if (gSt.navigateByImgClick) {
                        mfp.wrap.on('click' + ns, '.mfp-img', function() {
                            if (mfp.items.length > 1) {
                                mfp.next();
                                return false;
                            }
                        });
                    }

                    _document.on('keydown' + ns, function(e) {
                        if (e.keyCode === 37) {
                            mfp.prev();
                        } else if (e.keyCode === 39) {
                            mfp.next();
                        }
                    });
                });

                _mfpOn('UpdateStatus' + ns, function(e, data) {
                    if (data.text) {
                        data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
                    }
                });

                _mfpOn(MARKUP_PARSE_EVENT + ns, function(e, element, values, item) {
                    var l = mfp.items.length;
                    values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : '';
                });

                _mfpOn('BuildControls' + ns, function() {
                    if (mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
                        var markup = gSt.arrowMarkup,
                            arrowLeft = mfp.arrowLeft = $(markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, 'left')).addClass(PREVENT_CLOSE_CLASS),
                            arrowRight = mfp.arrowRight = $(markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, 'right')).addClass(PREVENT_CLOSE_CLASS);

                        var eName = supportsFastClick ? 'mfpFastClick' : 'click';
                        arrowLeft[eName](function() {
                            mfp.prev();
                        });
                        arrowRight[eName](function() {
                            mfp.next();
                        });

                        // Polyfill for :before and :after (adds elements with classes mfp-a and mfp-b)
                        if (mfp.isIE7) {
                            _getEl('b', arrowLeft[0], false, true);
                            _getEl('a', arrowLeft[0], false, true);
                            _getEl('b', arrowRight[0], false, true);
                            _getEl('a', arrowRight[0], false, true);
                        }

                        mfp.container.append(arrowLeft.add(arrowRight));
                    }
                });

                _mfpOn(CHANGE_EVENT + ns, function() {
                    if (mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);

                    mfp._preloadTimeout = setTimeout(function() {
                        mfp.preloadNearbyImages();
                        mfp._preloadTimeout = null;
                    }, 16);
                });


                _mfpOn(CLOSE_EVENT + ns, function() {
                    _document.off(ns);
                    mfp.wrap.off('click' + ns);

                    if (mfp.arrowLeft && supportsFastClick) {
                        mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
                    }
                    mfp.arrowRight = mfp.arrowLeft = null;
                });

            },
            next: function() {
                mfp.direction = true;
                mfp.index = _getLoopedId(mfp.index + 1);
                mfp.updateItemHTML();
            },
            prev: function() {
                mfp.direction = false;
                mfp.index = _getLoopedId(mfp.index - 1);
                mfp.updateItemHTML();
            },
            goTo: function(newIndex) {
                mfp.direction = (newIndex >= mfp.index);
                mfp.index = newIndex;
                mfp.updateItemHTML();
            },
            preloadNearbyImages: function() {
                var p = mfp.st.gallery.preload,
                    preloadBefore = Math.min(p[0], mfp.items.length),
                    preloadAfter = Math.min(p[1], mfp.items.length),
                    i;

                for (i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
                    mfp._preloadItem(mfp.index + i);
                }
                for (i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
                    mfp._preloadItem(mfp.index - i);
                }
            },
            _preloadItem: function(index) {
                index = _getLoopedId(index);

                if (mfp.items[index].preloaded) {
                    return;
                }

                var item = mfp.items[index];
                if (!item.parsed) {
                    item = mfp.parseEl(index);
                }

                _mfpTrigger('LazyLoad', item);

                if (item.type === 'image') {
                    item.img = $('<img class="mfp-img" />').on('load.mfploader', function() {
                        item.hasSize = true;
                    }).on('error.mfploader', function() {
                        item.hasSize = true;
                        item.loadError = true;
                        _mfpTrigger('LazyLoadError', item);
                    }).attr('src', item.src);
                }


                item.preloaded = true;
            }
        }
    });

    /*
    Touch Support that might be implemented some day

    addSwipeGesture: function() {
    	var startX,
    		moved,
    		multipleTouches;

    		return;

    	var namespace = '.mfp',
    		addEventNames = function(pref, down, move, up, cancel) {
    			mfp._tStart = pref + down + namespace;
    			mfp._tMove = pref + move + namespace;
    			mfp._tEnd = pref + up + namespace;
    			mfp._tCancel = pref + cancel + namespace;
    		};

    	if(window.navigator.msPointerEnabled) {
    		addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
    	} else if('ontouchstart' in window) {
    		addEventNames('touch', 'start', 'move', 'end', 'cancel');
    	} else {
    		return;
    	}
    	_window.on(mfp._tStart, function(e) {
    		var oE = e.originalEvent;
    		multipleTouches = moved = false;
    		startX = oE.pageX || oE.changedTouches[0].pageX;
    	}).on(mfp._tMove, function(e) {
    		if(e.originalEvent.touches.length > 1) {
    			multipleTouches = e.originalEvent.touches.length;
    		} else {
    			//e.preventDefault();
    			moved = true;
    		}
    	}).on(mfp._tEnd + ' ' + mfp._tCancel, function(e) {
    		if(moved && !multipleTouches) {
    			var oE = e.originalEvent,
    				diff = startX - (oE.pageX || oE.changedTouches[0].pageX);

    			if(diff > 20) {
    				mfp.next();
    			} else if(diff < -20) {
    				mfp.prev();
    			}
    		}
    	});
    },
    */


    /*>>gallery*/

    /*>>retina*/

    var RETINA_NS = 'retina';

    $.magnificPopup.registerModule(RETINA_NS, {
        options: {
            replaceSrc: function(item) {
                return item.src.replace(/\.\w+$/, function(m) {
                    return '@2x' + m;
                });
            },
            ratio: 1 // Function or number.  Set to 1 to disable.
        },
        proto: {
            initRetina: function() {
                if (window.devicePixelRatio > 1) {

                    var st = mfp.st.retina,
                        ratio = st.ratio;

                    ratio = !isNaN(ratio) ? ratio : ratio();

                    if (ratio > 1) {
                        _mfpOn('ImageHasSize' + '.' + RETINA_NS, function(e, item) {
                            item.img.css({
                                'max-width': item.img[0].naturalWidth / ratio,
                                'width': '100%'
                            });
                        });
                        _mfpOn('ElementParse' + '.' + RETINA_NS, function(e, item) {
                            item.src = st.replaceSrc(item, ratio);
                        });
                    }
                }

            }
        }
    });

    /*>>retina*/

    /*>>fastclick*/
    /**
     * FastClick event implementation. (removes 300ms delay on touch devices)
     * Based on https://developers.google.com/mobile/articles/fast_buttons
     *
     * You may use it outside the Magnific Popup by calling just:
     *
     * $('.your-el').mfpFastClick(function() {
     *     console.log('Clicked!');
     * });
     *
     * To unbind:
     * $('.your-el').destroyMfpFastClick();
     * 
     * 
     * Note that it's a very basic and simple implementation, it blocks ghost click on the same element where it was bound.
     * If you need something more advanced, use plugin by FT Labs https://github.com/ftlabs/fastclick
     * 
     */

    (function() {
        var ghostClickDelay = 1000,
            supportsTouch = 'ontouchstart' in window,
            unbindTouchMove = function() {
                _window.off('touchmove' + ns + ' touchend' + ns);
            },
            eName = 'mfpFastClick',
            ns = '.' + eName;


        // As Zepto.js doesn't have an easy way to add custom events (like jQuery), so we implement it in this way
        $.fn.mfpFastClick = function(callback) {

            return $(this).each(function() {

                var elem = $(this),
                    lock;

                if (supportsTouch) {

                    var timeout,
                        startX,
                        startY,
                        pointerMoved,
                        point,
                        numPointers;

                    elem.on('touchstart' + ns, function(e) {
                        pointerMoved = false;
                        numPointers = 1;

                        point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
                        startX = point.clientX;
                        startY = point.clientY;

                        _window.on('touchmove' + ns, function(e) {
                            point = e.originalEvent ? e.originalEvent.touches : e.touches;
                            numPointers = point.length;
                            point = point[0];
                            if (Math.abs(point.clientX - startX) > 10 ||
                                Math.abs(point.clientY - startY) > 10) {
                                pointerMoved = true;
                                unbindTouchMove();
                            }
                        }).on('touchend' + ns, function(e) {
                            unbindTouchMove();
                            if (pointerMoved || numPointers > 1) {
                                return;
                            }
                            lock = true;
                            e.preventDefault();
                            clearTimeout(timeout);
                            timeout = setTimeout(function() {
                                lock = false;
                            }, ghostClickDelay);
                            callback();
                        });
                    });

                }

                elem.on('click' + ns, function() {
                    if (!lock) {
                        callback();
                    }
                });
            });
        };

        $.fn.destroyMfpFastClick = function() {
            $(this).off('touchstart' + ns + ' click' + ns);
            if (supportsTouch) _window.off('touchmove' + ns + ' touchend' + ns);
        };
    })();

    /*>>fastclick*/
    _checkInstance();
}));
/*!
 * @fileOverview TouchSwipe - jQuery Plugin
 * @version 1.6.18
 *
 * @author Matt Bryson http://www.github.com/mattbryson
 * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
 * @see http://labs.rampinteractive.co.uk/touchSwipe/
 * @see http://plugins.jquery.com/project/touchSwipe
 * @license
 * Copyright (c) 2010-2015 Matt Bryson
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 */
! function(factory) {
    "function" == typeof define && define.amd && define.amd.jQuery ? define(["jquery"], factory) : factory("undefined" != typeof module && module.exports ? require("jquery") : jQuery)
}(function($) {
    "use strict";

    function init(options) {
        return !options || void 0 !== options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE), void 0 !== options.click && void 0 === options.tap && (options.tap = options.click), options || (options = {}), options = $.extend({}, $.fn.swipe.defaults, options), this.each(function() {
            var $this = $(this),
                plugin = $this.data(PLUGIN_NS);
            plugin || (plugin = new TouchSwipe(this, options), $this.data(PLUGIN_NS, plugin))
        })
    }

    function TouchSwipe(element, options) {
        function touchStart(jqEvent) {
            if (!(getTouchInProgress() || $(jqEvent.target).closest(options.excludedElements, $element).length > 0)) {
                var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
                if (!event.pointerType || "mouse" != event.pointerType || 0 != options.fallbackToMouseEvents) {
                    var ret, touches = event.touches,
                        evt = touches ? touches[0] : event;
                    return phase = PHASE_START, touches ? fingerCount = touches.length : options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), distance = 0, direction = null, currentDirection = null, pinchDirection = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, maximumsMap = createMaximumsData(), cancelMultiFingerRelease(), createFingerData(0, evt), !touches || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (startTime = getTimeStamp(), 2 == fingerCount && (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase))) : ret = !1, ret === !1 ? (phase = PHASE_CANCEL, triggerHandler(event, phase), ret) : (options.hold && (holdTimeout = setTimeout($.proxy(function() {
                        $element.trigger("hold", [event.target]), options.hold && (ret = options.hold.call($element, event, event.target))
                    }, this), options.longTapThreshold)), setTouchInProgress(!0), null)
                }
            }
        }

        function touchMove(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            if (phase !== PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease()) {
                var ret, touches = event.touches,
                    evt = touches ? touches[0] : event,
                    currentFinger = updateFingerData(evt);
                if (endTime = getTimeStamp(), touches && (fingerCount = touches.length), options.hold && clearTimeout(holdTimeout), phase = PHASE_MOVE, 2 == fingerCount && (0 == startTouchesDistance ? (createFingerData(1, touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)) : (updateFingerData(touches[1]), endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end), pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)), pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance), pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)), fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) {
                    if (direction = calculateDirection(currentFinger.start, currentFinger.end), currentDirection = calculateDirection(currentFinger.last, currentFinger.end), validateDefaultEvent(jqEvent, currentDirection), distance = calculateDistance(currentFinger.start, currentFinger.end), duration = calculateDuration(), setMaxDistance(direction, distance), ret = triggerHandler(event, phase), !options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
                        var inBounds = !0;
                        if (options.triggerOnTouchLeave) {
                            var bounds = getbounds(this);
                            inBounds = isInBounds(currentFinger.end, bounds)
                        }!options.triggerOnTouchEnd && inBounds ? phase = getNextPhase(PHASE_MOVE) : options.triggerOnTouchLeave && !inBounds && (phase = getNextPhase(PHASE_END)), phase != PHASE_CANCEL && phase != PHASE_END || triggerHandler(event, phase)
                    }
                } else phase = PHASE_CANCEL, triggerHandler(event, phase);
                ret === !1 && (phase = PHASE_CANCEL, triggerHandler(event, phase))
            }
        }

        function touchEnd(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,
                touches = event.touches;
            if (touches) {
                if (touches.length && !inMultiFingerRelease()) return startMultiFingerRelease(event), !0;
                if (touches.length && inMultiFingerRelease()) return !0
            }
            return inMultiFingerRelease() && (fingerCount = fingerCountAtRelease), endTime = getTimeStamp(), duration = calculateDuration(), didSwipeBackToCancel() || !validateSwipeDistance() ? (phase = PHASE_CANCEL, triggerHandler(event, phase)) : options.triggerOnTouchEnd || options.triggerOnTouchEnd === !1 && phase === PHASE_MOVE ? (options.preventDefaultEvents !== !1 && jqEvent.preventDefault(), phase = PHASE_END, triggerHandler(event, phase)) : !options.triggerOnTouchEnd && hasTap() ? (phase = PHASE_END, triggerHandlerForGesture(event, phase, TAP)) : phase === PHASE_MOVE && (phase = PHASE_CANCEL, triggerHandler(event, phase)), setTouchInProgress(!1), null
        }

        function touchCancel() {
            fingerCount = 0, endTime = 0, startTime = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, cancelMultiFingerRelease(), setTouchInProgress(!1)
        }

        function touchLeave(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            options.triggerOnTouchLeave && (phase = getNextPhase(PHASE_END), triggerHandler(event, phase))
        }

        function removeListeners() {
            $element.unbind(START_EV, touchStart), $element.unbind(CANCEL_EV, touchCancel), $element.unbind(MOVE_EV, touchMove), $element.unbind(END_EV, touchEnd), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave), setTouchInProgress(!1)
        }

        function getNextPhase(currentPhase) {
            var nextPhase = currentPhase,
                validTime = validateSwipeTime(),
                validDistance = validateSwipeDistance(),
                didCancel = didSwipeBackToCancel();
            return !validTime || didCancel ? nextPhase = PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END, nextPhase
        }

        function triggerHandler(event, phase) {
            var ret, touches = event.touches;
            return (didSwipe() || hasSwipes()) && (ret = triggerHandlerForGesture(event, phase, SWIPE)), (didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, PINCH)), didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, TAP)), phase === PHASE_CANCEL && touchCancel(event), phase === PHASE_END && (touches ? touches.length || touchCancel(event) : touchCancel(event)), ret
        }

        function triggerHandlerForGesture(event, phase, gesture) {
            var ret;
            if (gesture == SWIPE) {
                if ($element.trigger("swipeStatus", [phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection]), options.swipeStatus && (ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection), ret === !1)) return !1;
                if (phase == PHASE_END && validateSwipe()) {
                    if (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), $element.trigger("swipe", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipe && (ret = options.swipe.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection), ret === !1)) return !1;
                    switch (direction) {
                        case LEFT:
                            $element.trigger("swipeLeft", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeLeft && (ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                            break;
                        case RIGHT:
                            $element.trigger("swipeRight", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeRight && (ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                            break;
                        case UP:
                            $element.trigger("swipeUp", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeUp && (ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection));
                            break;
                        case DOWN:
                            $element.trigger("swipeDown", [direction, distance, duration, fingerCount, fingerData, currentDirection]), options.swipeDown && (ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection))
                    }
                }
            }
            if (gesture == PINCH) {
                if ($element.trigger("pinchStatus", [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchStatus && (ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData), ret === !1)) return !1;
                if (phase == PHASE_END && validatePinch()) switch (pinchDirection) {
                    case IN:
                        $element.trigger("pinchIn", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchIn && (ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData));
                        break;
                    case OUT:
                        $element.trigger("pinchOut", [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]), options.pinchOut && (ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData))
                }
            }
            return gesture == TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(), singleTapTimeout = setTimeout($.proxy(function() {
                doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target))
            }, this), options.doubleTapThreshold)) : (doubleTapStartTime = null, $element.trigger("tap", [event.target]), options.tap && (ret = options.tap.call($element, event, event.target)))) : gesture == DOUBLE_TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), clearTimeout(holdTimeout), doubleTapStartTime = null, $element.trigger("doubletap", [event.target]), options.doubleTap && (ret = options.doubleTap.call($element, event, event.target))) : gesture == LONG_TAP && (phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout), doubleTapStartTime = null, $element.trigger("longtap", [event.target]), options.longTap && (ret = options.longTap.call($element, event, event.target)))), ret
        }

        function validateSwipeDistance() {
            var valid = !0;
            return null !== options.threshold && (valid = distance >= options.threshold), valid
        }

        function didSwipeBackToCancel() {
            var cancelled = !1;
            return null !== options.cancelThreshold && null !== direction && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold), cancelled
        }

        function validatePinchDistance() {
            return null !== options.pinchThreshold ? pinchDistance >= options.pinchThreshold : !0
        }

        function validateSwipeTime() {
            var result;
            return result = options.maxTimeThreshold ? !(duration >= options.maxTimeThreshold) : !0
        }

        function validateDefaultEvent(jqEvent, direction) {
            if (options.preventDefaultEvents !== !1)
                if (options.allowPageScroll === NONE) jqEvent.preventDefault();
                else {
                    var auto = options.allowPageScroll === AUTO;
                    switch (direction) {
                        case LEFT:
                            (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                            break;
                        case RIGHT:
                            (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                            break;
                        case UP:
                            (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                            break;
                        case DOWN:
                            (options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                            break;
                        case NONE:
                    }
                }
        }

        function validatePinch() {
            var hasCorrectFingerCount = validateFingers(),
                hasEndPoint = validateEndPoint(),
                hasCorrectDistance = validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance
        }

        function hasPinches() {
            return !!(options.pinchStatus || options.pinchIn || options.pinchOut)
        }

        function didPinch() {
            return !(!validatePinch() || !hasPinches())
        }

        function validateSwipe() {
            var hasValidTime = validateSwipeTime(),
                hasValidDistance = validateSwipeDistance(),
                hasCorrectFingerCount = validateFingers(),
                hasEndPoint = validateEndPoint(),
                didCancel = didSwipeBackToCancel(),
                valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
            return valid
        }

        function hasSwipes() {
            return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown)
        }

        function didSwipe() {
            return !(!validateSwipe() || !hasSwipes())
        }

        function validateFingers() {
            return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH
        }

        function validateEndPoint() {
            return 0 !== fingerData[0].end.x
        }

        function hasTap() {
            return !!options.tap
        }

        function hasDoubleTap() {
            return !!options.doubleTap
        }

        function hasLongTap() {
            return !!options.longTap
        }

        function validateDoubleTap() {
            if (null == doubleTapStartTime) return !1;
            var now = getTimeStamp();
            return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold
        }

        function inDoubleTap() {
            return validateDoubleTap()
        }

        function validateTap() {
            return (1 === fingerCount || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold)
        }

        function validateLongTap() {
            return duration > options.longTapThreshold && DOUBLE_TAP_THRESHOLD > distance
        }

        function didTap() {
            return !(!validateTap() || !hasTap())
        }

        function didDoubleTap() {
            return !(!validateDoubleTap() || !hasDoubleTap())
        }

        function didLongTap() {
            return !(!validateLongTap() || !hasLongTap())
        }

        function startMultiFingerRelease(event) {
            previousTouchEndTime = getTimeStamp(), fingerCountAtRelease = event.touches.length + 1
        }

        function cancelMultiFingerRelease() {
            previousTouchEndTime = 0, fingerCountAtRelease = 0
        }

        function inMultiFingerRelease() {
            var withinThreshold = !1;
            if (previousTouchEndTime) {
                var diff = getTimeStamp() - previousTouchEndTime;
                diff <= options.fingerReleaseThreshold && (withinThreshold = !0)
            }
            return withinThreshold
        }

        function getTouchInProgress() {
            return !($element.data(PLUGIN_NS + "_intouch") !== !0)
        }

        function setTouchInProgress(val) {
            $element && (val === !0 ? ($element.bind(MOVE_EV, touchMove), $element.bind(END_EV, touchEnd), LEAVE_EV && $element.bind(LEAVE_EV, touchLeave)) : ($element.unbind(MOVE_EV, touchMove, !1), $element.unbind(END_EV, touchEnd, !1), LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave, !1)), $element.data(PLUGIN_NS + "_intouch", val === !0))
        }

        function createFingerData(id, evt) {
            var f = {
                start: {
                    x: 0,
                    y: 0
                },
                last: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                }
            };
            return f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX, f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY, fingerData[id] = f, f
        }

        function updateFingerData(evt) {
            var id = void 0 !== evt.identifier ? evt.identifier : 0,
                f = getFingerData(id);
            return null === f && (f = createFingerData(id, evt)), f.last.x = f.end.x, f.last.y = f.end.y, f.end.x = evt.pageX || evt.clientX, f.end.y = evt.pageY || evt.clientY, f
        }

        function getFingerData(id) {
            return fingerData[id] || null
        }

        function setMaxDistance(direction, distance) {
            direction != NONE && (distance = Math.max(distance, getMaxDistance(direction)), maximumsMap[direction].distance = distance)
        }

        function getMaxDistance(direction) {
            return maximumsMap[direction] ? maximumsMap[direction].distance : void 0
        }

        function createMaximumsData() {
            var maxData = {};
            return maxData[LEFT] = createMaximumVO(LEFT), maxData[RIGHT] = createMaximumVO(RIGHT), maxData[UP] = createMaximumVO(UP), maxData[DOWN] = createMaximumVO(DOWN), maxData
        }

        function createMaximumVO(dir) {
            return {
                direction: dir,
                distance: 0
            }
        }

        function calculateDuration() {
            return endTime - startTime
        }

        function calculateTouchesDistance(startPoint, endPoint) {
            var diffX = Math.abs(startPoint.x - endPoint.x),
                diffY = Math.abs(startPoint.y - endPoint.y);
            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY))
        }

        function calculatePinchZoom(startDistance, endDistance) {
            var percent = endDistance / startDistance * 1;
            return percent.toFixed(2)
        }

        function calculatePinchDirection() {
            return 1 > pinchZoom ? OUT : IN
        }

        function calculateDistance(startPoint, endPoint) {
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)))
        }

        function calculateAngle(startPoint, endPoint) {
            var x = startPoint.x - endPoint.x,
                y = endPoint.y - startPoint.y,
                r = Math.atan2(y, x),
                angle = Math.round(180 * r / Math.PI);
            return 0 > angle && (angle = 360 - Math.abs(angle)), angle
        }

        function calculateDirection(startPoint, endPoint) {
            if (comparePoints(startPoint, endPoint)) return NONE;
            var angle = calculateAngle(startPoint, endPoint);
            return 45 >= angle && angle >= 0 ? LEFT : 360 >= angle && angle >= 315 ? LEFT : angle >= 135 && 225 >= angle ? RIGHT : angle > 45 && 135 > angle ? DOWN : UP
        }

        function getTimeStamp() {
            var now = new Date;
            return now.getTime()
        }

        function getbounds(el) {
            el = $(el);
            var offset = el.offset(),
                bounds = {
                    left: offset.left,
                    right: offset.left + el.outerWidth(),
                    top: offset.top,
                    bottom: offset.top + el.outerHeight()
                };
            return bounds
        }

        function isInBounds(point, bounds) {
            return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom
        }

        function comparePoints(pointA, pointB) {
            return pointA.x == pointB.x && pointA.y == pointB.y
        }
        var options = $.extend({}, options),
            useTouchEvents = SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents,
            START_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerDown" : "pointerdown" : "touchstart" : "mousedown",
            MOVE_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerMove" : "pointermove" : "touchmove" : "mousemove",
            END_EV = useTouchEvents ? SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerUp" : "pointerup" : "touchend" : "mouseup",
            LEAVE_EV = useTouchEvents ? SUPPORTS_POINTER ? "mouseleave" : null : "mouseleave",
            CANCEL_EV = SUPPORTS_POINTER ? SUPPORTS_POINTER_IE10 ? "MSPointerCancel" : "pointercancel" : "touchcancel",
            distance = 0,
            direction = null,
            currentDirection = null,
            duration = 0,
            startTouchesDistance = 0,
            endTouchesDistance = 0,
            pinchZoom = 1,
            pinchDistance = 0,
            pinchDirection = 0,
            maximumsMap = null,
            $element = $(element),
            phase = "start",
            fingerCount = 0,
            fingerData = {},
            startTime = 0,
            endTime = 0,
            previousTouchEndTime = 0,
            fingerCountAtRelease = 0,
            doubleTapStartTime = 0,
            singleTapTimeout = null,
            holdTimeout = null;
        try {
            $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel)
        } catch (e) {
            $.error("events not supported " + START_EV + "," + CANCEL_EV + " on jQuery.swipe")
        }
        this.enable = function() {
            return this.disable(), $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel), $element
        }, this.disable = function() {
            return removeListeners(), $element
        }, this.destroy = function() {
            removeListeners(), $element.data(PLUGIN_NS, null), $element = null
        }, this.option = function(property, value) {
            if ("object" == typeof property) options = $.extend(options, property);
            else if (void 0 !== options[property]) {
                if (void 0 === value) return options[property];
                options[property] = value
            } else {
                if (!property) return options;
                $.error("Option " + property + " does not exist on jQuery.swipe.options")
            }
            return null
        }
    }
    var VERSION = "1.6.18",
        LEFT = "left",
        RIGHT = "right",
        UP = "up",
        DOWN = "down",
        IN = "in",
        OUT = "out",
        NONE = "none",
        AUTO = "auto",
        SWIPE = "swipe",
        PINCH = "pinch",
        TAP = "tap",
        DOUBLE_TAP = "doubletap",
        LONG_TAP = "longtap",
        HORIZONTAL = "horizontal",
        VERTICAL = "vertical",
        ALL_FINGERS = "all",
        DOUBLE_TAP_THRESHOLD = 10,
        PHASE_START = "start",
        PHASE_MOVE = "move",
        PHASE_END = "end",
        PHASE_CANCEL = "cancel",
        SUPPORTS_TOUCH = "ontouchstart" in window,
        SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !SUPPORTS_TOUCH,
        SUPPORTS_POINTER = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH,
        PLUGIN_NS = "TouchSwipe",
        defaults = {
            fingers: 1,
            threshold: 75,
            cancelThreshold: null,
            pinchThreshold: 20,
            maxTimeThreshold: null,
            fingerReleaseThreshold: 250,
            longTapThreshold: 500,
            doubleTapThreshold: 200,
            swipe: null,
            swipeLeft: null,
            swipeRight: null,
            swipeUp: null,
            swipeDown: null,
            swipeStatus: null,
            pinchIn: null,
            pinchOut: null,
            pinchStatus: null,
            click: null,
            tap: null,
            doubleTap: null,
            longTap: null,
            hold: null,
            triggerOnTouchEnd: !0,
            triggerOnTouchLeave: !1,
            allowPageScroll: "auto",
            fallbackToMouseEvents: !0,
            excludedElements: ".noSwipe",
            preventDefaultEvents: !0
        };
    $.fn.swipe = function(method) {
        var $this = $(this),
            plugin = $this.data(PLUGIN_NS);
        if (plugin && "string" == typeof method) {
            if (plugin[method]) return plugin[method].apply(plugin, Array.prototype.slice.call(arguments, 1));
            $.error("Method " + method + " does not exist on jQuery.swipe")
        } else if (plugin && "object" == typeof method) plugin.option.apply(plugin, arguments);
        else if (!(plugin || "object" != typeof method && method)) return init.apply(this, arguments);
        return $this
    }, $.fn.swipe.version = VERSION, $.fn.swipe.defaults = defaults, $.fn.swipe.phases = {
        PHASE_START: PHASE_START,
        PHASE_MOVE: PHASE_MOVE,
        PHASE_END: PHASE_END,
        PHASE_CANCEL: PHASE_CANCEL
    }, $.fn.swipe.directions = {
        LEFT: LEFT,
        RIGHT: RIGHT,
        UP: UP,
        DOWN: DOWN,
        IN: IN,
        OUT: OUT
    }, $.fn.swipe.pageScroll = {
        NONE: NONE,
        HORIZONTAL: HORIZONTAL,
        VERTICAL: VERTICAL,
        AUTO: AUTO
    }, $.fn.swipe.fingers = {
        ONE: 1,
        TWO: 2,
        THREE: 3,
        FOUR: 4,
        FIVE: 5,
        ALL: ALL_FINGERS
    }
});
/*
 *  webui popover plugin  - v1.1.7
 *  A lightWeight popover plugin with jquery ,enchance the  popover plugin of bootstrap with some awesome new features. It works well with bootstrap ,but bootstrap is not necessary!
 *  https://github.com/sandywalker/webui-popover
 *
 *  Made by Sandy Duan
 *  Under MIT License
 */
! function(a, b, c) {
    "use strict";

    function d(b, c) {
        this.$element = a(b), c && ("string" === a.type(c.delay) || "number" === a.type(c.delay)) && (c.delay = {
            show: c.delay,
            hide: c.delay
        }), this.options = a.extend({}, h, c), this._defaults = h, this._name = e, this._targetclick = !1, this.init(), i.push(this.$element)
    }
    var e = "webuiPopover",
        f = "webui-popover",
        g = "webui.popover",
        h = {
            placement: "auto",
            width: "auto",
            height: "auto",
            trigger: "click",
            style: "",
            delay: {
                show: null,
                hide: null
            },
            async: {
                before: null,
                success: null
            },
            cache: !0,
            multi: !1,
            arrow: !0,
            title: "",
            content: "",
            closeable: !1,
            padding: !0,
            url: "",
            type: "html",
            animation: null,
            template: '<div class="webui-popover"><div class="arrow"></div><div class="webui-popover-inner"><a href="#" class="close">x</a><h3 class="webui-popover-title"></h3><div class="webui-popover-content"><i class="icon-refresh"></i> <p>&nbsp;</p></div></div></div>',
            backdrop: !1,
            dismissible: !0,
            onShow: null,
            onHide: null,
            abortXHR: !0,
            autoHide: !1
        },
        i = [],
        j = a('<div class="webui-popover-backdrop"></div>'),
        k = 0,
        l = a(c);
    d.prototype = {
        init: function() {
            "click" === this.getTrigger() ? this.$element.off("click").on("click", a.proxy(this.toggle, this)) : "hover" === this.getTrigger() && this.$element.off("mouseenter mouseleave click").on("mouseenter", a.proxy(this.mouseenterHandler, this)).on("mouseleave", a.proxy(this.mouseleaveHandler, this)), this._poped = !1, this._inited = !0, this._opened = !1, this._idSeed = k, this.options.backdrop && j.appendTo(c.body).hide(), k++, "sticky" === this.getTrigger() && this.show()
        },
        destroy: function() {
            for (var a = -1, b = 0; b < i.length; b++)
                if (i[b] === this.$element) {
                    a = b;
                    break
                }
            i.splice(a, 1), this.hide(), this.$element.data("plugin_" + e, null), "click" === this.getTrigger() ? this.$element.off("click") : "hover" === this.getTrigger() && this.$element.off("mouseenter mouseleave"), this.$target && this.$target.remove()
        },
        hide: function(b, c) {
            if ((b || "sticky" !== this.getTrigger()) && this._opened) {
                c && (c.preventDefault(), c.stopPropagation()), this.xhr && this.options.abortXHR === !0 && (this.xhr.abort(), this.xhr = null);
                var d = a.Event("hide." + g);
                if (this.$element.trigger(d, [this.$target]), this.$target) {
                    this.$target.removeClass("in").addClass(this.getHideAnimation());
                    var e = this;
                    setTimeout(function() {
                        e.$target.hide()
                    }, 300)
                }
                this.options.backdrop && j.hide(), this._opened = !1, this.$element.trigger("hidden." + g, [this.$target]), this.options.onHide && this.options.onHide(this.$target)
            }
        },
        resetAutoHide: function() {
            var a = this,
                b = a.getAutoHide();
            b && (a.autoHideHandler && clearTimeout(a.autoHideHandler), a.autoHideHandler = setTimeout(function() {
                a.hide()
            }, b))
        },
        toggle: function(a) {
            a && (a.preventDefault(), a.stopPropagation()), this[this.getTarget().hasClass("in") ? "hide" : "show"]()
        },
        hideAll: function() {
            for (var a = 0; a < i.length; a++) i[a].webuiPopover("hide");
            l.trigger("hiddenAll." + g)
        },
        show: function() {
            var a = this.getTarget().removeClass().addClass(f).addClass(this._customTargetClass);
            this.options.multi || this.hideAll(), this._opened || (this.getCache() && this._poped && "" !== this.content || (this.content = "", this.setTitle(this.getTitle()), this.options.closeable || a.find(".close").off("click").remove(), this.isAsync() ? this.setContentASync(this.options.content) : this.setContent(this.getContent()), a.show()), this.displayContent(), this.options.onShow && this.options.onShow(a), this.bindBodyEvents(), this.options.backdrop && j.show(), this._opened = !0, this.resetAutoHide())
        },
        displayContent: function() {
            var b = this.getElementPosition(),
                d = this.getTarget().removeClass().addClass(f).addClass(this._customTargetClass),
                e = this.getContentElement(),
                h = d[0].offsetWidth,
                i = d[0].offsetHeight,
                j = "bottom",
                k = a.Event("show." + g);
            this.$element.trigger(k, [d]), "auto" !== this.options.width && d.width(this.options.width), "auto" !== this.options.height && e.height(this.options.height), this.options.style && this.$target.addClass(f + "-" + this.options.style), this.options.arrow || d.find(".arrow").remove(), d.detach().css({
                top: -2e3,
                left: -2e3,
                display: "block"
            }), this.getAnimation() && d.addClass(this.getAnimation()), d.appendTo(c.body), h = d[0].offsetWidth, i = d[0].offsetHeight, j = this.getPlacement(b), this.$element.trigger("added." + g), this.initTargetEvents();
            var l = this.getTargetPositin(b, j, h, i);
            if (this.$target.css(l.position).addClass(j).addClass("in"), "iframe" === this.options.type) {
                var m = d.find("iframe");
                m.width(d.width()).height(m.parent().height())
            }
            if (this.options.padding || (e.css("height", e.outerHeight()), this.$target.addClass("webui-no-padding")), this.options.arrow || this.$target.css({
                    margin: 0
                }), this.options.arrow) {
                var n = this.$target.find(".arrow");
                n.removeAttr("style"), l.arrowOffset && (-1 === l.arrowOffset.left || -1 === l.arrowOffset.top ? n.hide() : n.css(l.arrowOffset))
            }
            this._poped = !0, this.$element.trigger("shown." + g, [this.$target])
        },
        isTargetLoaded: function() {
            return 0 === this.getTarget().find("i.glyphicon-refresh").length
        },
        getTriggerElement: function() {
            return this.$element
        },
        getTarget: function() {
            if (!this.$target) {
                var b = e + this._idSeed;
                this.$target = a(this.options.template).attr("id", b).data("trigger-element", this.getTriggerElement()), this._customTargetClass = this.$target.attr("class") !== f ? this.$target.attr("class") : null, this.getTriggerElement().attr("data-target", b)
            }
            return this.$target
        },
        getTitleElement: function() {
            return this.getTarget().find("." + f + "-title")
        },
        getContentElement: function() {
            return this.getTarget().find("." + f + "-content")
        },
        getTitle: function() {
            return this.$element.attr("data-title") || this.options.title || this.$element.attr("title")
        },
        getUrl: function() {
            return this.$element.attr("data-url") || this.options.url
        },
        getAutoHide: function() {
            return this.$element.attr("data-auto-hide") || this.options.autoHide
        },
        getCache: function() {
            var a = this.$element.attr("data-cache");
            if ("undefined" != typeof a) switch (a.toLowerCase()) {
                case "true":
                case "yes":
                case "1":
                    return !0;
                case "false":
                case "no":
                case "0":
                    return !1
            }
            return this.options.cache
        },
        getTrigger: function() {
            return this.$element.attr("data-trigger") || this.options.trigger
        },
        getDelayShow: function() {
            var a = this.$element.attr("data-delay-show");
            return "undefined" != typeof a ? a : 0 === this.options.delay.show ? 0 : this.options.delay.show || 100
        },
        getHideDelay: function() {
            var a = this.$element.attr("data-delay-hide");
            return "undefined" != typeof a ? a : 0 === this.options.delay.hide ? 0 : this.options.delay.hide || 100
        },
        getAnimation: function() {
            var a = this.$element.attr("data-animation");
            return a || this.options.animation
        },
        getHideAnimation: function() {
            var a = this.getAnimation();
            return a ? a + "-out" : "out"
        },
        setTitle: function(a) {
            var b = this.getTitleElement();
            a ? b.html(a) : b.remove()
        },
        hasContent: function() {
            return this.getContent()
        },
        getContent: function() {
            if (this.getUrl()) "iframe" === this.options.type && (this.content = a('<iframe frameborder="0"></iframe>').attr("src", this.getUrl()));
            else if (!this.content) {
                var b = "";
                b = a.isFunction(this.options.content) ? this.options.content.apply(this.$element[0], [this]) : this.options.content, this.content = this.$element.attr("data-content") || b
            }
            return this.content
        },
        setContent: function(a) {
            var b = this.getTarget();
            this.getContentElement().html(a), this.$target = b
        },
        isAsync: function() {
            return "async" === this.options.type
        },
        setContentASync: function(b) {
            var c = this;
            this.xhr || (this.xhr = a.ajax({
                url: this.getUrl(),
                type: "GET",
                cache: this.getCache(),
                beforeSend: function(a) {
                    c.options.async.before && c.options.async.before(c, a)
                },
                success: function(d) {
                    c.bindBodyEvents(), c.content = b && a.isFunction(b) ? b.apply(c.$element[0], [d]) : d, c.setContent(c.content);
                    var e = c.getContentElement();
                    e.removeAttr("style"), c.displayContent(), c.options.async.success && c.options.async.success(c, d)
                },
                complete: function() {
                    c.xhr = null
                }
            }))
        },
        bindBodyEvents: function() {
            this.options.dismissible && (a("body").off("keyup.webui-popover").on("keyup.webui-popover", a.proxy(this.escapeHandler, this)), a("body").off("click.webui-popover").on("click.webui-popover", a.proxy(this.bodyClickHandler, this)))
        },
        mouseenterHandler: function() {
            var a = this;
            a._timeout && clearTimeout(a._timeout), a._enterTimeout = setTimeout(function() {
                a.getTarget().is(":visible") || a.show()
            }, this.getDelayShow())
        },
        mouseleaveHandler: function() {
            var a = this;
            clearTimeout(a._enterTimeout), a._timeout = setTimeout(function() {
                a.hide()
            }, this.getHideDelay())
        },
        escapeHandler: function(a) {
            27 === a.keyCode && this.hideAll()
        },
        bodyClickHandler: function() {
            "click" === this.getTrigger() && (this._targetclick ? this._targetclick = !1 : this.hideAll())
        },
        targetClickHandler: function() {
            this._targetclick = !0
        },
        initTargetEvents: function() {
            "hover" === this.getTrigger() && this.$target.off("mouseenter mouseleave").on("mouseenter", a.proxy(this.mouseenterHandler, this)).on("mouseleave", a.proxy(this.mouseleaveHandler, this)), this.$target.find(".close").off("click").on("click", a.proxy(this.hide, this, !0)), this.$target.off("click.webui-popover").on("click.webui-popover", a.proxy(this.targetClickHandler, this))
        },
        getPlacement: function(a) {
            var b, d = c.documentElement,
                e = c.body,
                f = d.clientWidth,
                g = d.clientHeight,
                h = Math.max(e.scrollTop, d.scrollTop),
                i = Math.max(e.scrollLeft, d.scrollLeft),
                j = Math.max(0, a.left - i),
                k = Math.max(0, a.top - h);
            b = "function" == typeof this.options.placement ? this.options.placement.call(this, this.getTarget()[0], this.$element[0]) : this.$element.data("placement") || this.options.placement;
            var l = "horizontal" === b,
                m = "vertical" === b,
                n = "auto" === b || l || m;
            return n ? b = f / 3 > j ? g / 3 > k ? l ? "right-bottom" : "bottom-right" : 2 * g / 3 > k ? m ? g / 2 >= k ? "bottom-right" : "top-right" : "right" : l ? "right-top" : "top-right" : 2 * f / 3 > j ? g / 3 > k ? l ? f / 2 >= j ? "right-bottom" : "left-bottom" : "bottom" : 2 * g / 3 > k ? l ? f / 2 >= j ? "right" : "left" : g / 2 >= k ? "bottom" : "top" : l ? f / 2 >= j ? "right-top" : "left-top" : "top" : g / 3 > k ? l ? "left-bottom" : "bottom-left" : 2 * g / 3 > k ? m ? g / 2 >= k ? "bottom-left" : "top-left" : "left" : l ? "left-top" : "top-left" : "auto-top" === b ? b = f / 3 > j ? "top-right" : 2 * f / 3 > j ? "top" : "top-left" : "auto-bottom" === b ? b = f / 3 > j ? "bottom-right" : 2 * f / 3 > j ? "bottom" : "bottom-left" : "auto-left" === b ? b = g / 3 > k ? "left-top" : 2 * g / 3 > k ? "left" : "left-bottom" : "auto-right" === b && (b = g / 3 > k ? "right-top" : 2 * g / 3 > k ? "right" : "right-bottom"), b
        },
        getElementPosition: function() {
            return a.extend({}, this.$element.offset(), {
                width: this.$element[0].offsetWidth,
                height: this.$element[0].offsetHeight
            })
        },
        getTargetPositin: function(a, b, d, e) {
            var f = a,
                g = c.documentElement,
                h = c.body,
                i = g.clientWidth,
                j = g.clientHeight,
                k = this.$element.outerWidth(),
                l = this.$element.outerHeight(),
                m = Math.max(h.scrollTop, g.scrollTop),
                n = Math.max(h.scrollLeft, g.scrollLeft),
                o = {},
                p = null,
                q = this.options.arrow ? 20 : 0,
                r = q + 10 > k ? q : 0,
                s = q + 10 > l ? q : 0,
                t = 10;
            switch (b) {
                case "bottom":
                    o = {
                        top: f.top + f.height,
                        left: f.left + f.width / 2 - d / 2
                    };
                    break;
                case "top":
                    o = {
                        top: f.top - e,
                        left: f.left + f.width / 2 - d / 2
                    };
                    break;
                case "left":
                    o = {
                        top: f.top + f.height / 2 - e / 2,
                        left: f.left - d
                    };
                    break;
                case "right":
                    o = {
                        top: f.top + f.height / 2 - e / 2,
                        left: f.left + f.width
                    };
                    break;
                case "top-right":
                    o = {
                        top: f.top - e,
                        left: f.left - r
                    }, p = {
                        left: Math.min(k, d) / 2 + r
                    };
                    break;
                case "top-left":
                    o = {
                        top: f.top - e,
                        left: f.left - d + f.width + r
                    }, p = {
                        left: d - Math.min(k, d) / 2 - r
                    };
                    break;
                case "bottom-right":
                    o = {
                        top: f.top + f.height,
                        left: f.left - r
                    }, p = {
                        left: Math.min(k, d) / 2 + r
                    };
                    break;
                case "bottom-left":
                    o = {
                        top: f.top + f.height,
                        left: f.left - d + f.width + r
                    }, p = {
                        left: d - Math.min(k, d) / 2 - r
                    };
                    break;
                case "right-top":
                    o = {
                        top: f.top - e + f.height + s,
                        left: f.left + f.width
                    }, p = {
                        top: e - Math.min(l, e) / 2 - s
                    };
                    break;
                case "right-bottom":
                    o = {
                        top: f.top - s,
                        left: f.left + f.width
                    }, p = {
                        top: Math.min(l, e) / 2 + s
                    };
                    break;
                case "left-top":
                    o = {
                        top: f.top - e + f.height + s,
                        left: f.left - d
                    }, p = {
                        top: e - Math.min(l, e) / 2 - s
                    };
                    break;
                case "left-bottom":
                    o = {
                        top: f.top - s,
                        left: f.left - d
                    }, p = {
                        top: Math.min(l, e) / 2 + s
                    }
            }
            var u = j + m,
                v = i + n;
            return o.left < 0 && (o.left = t, p = {
                left: -1
            }), o.left + d > v && (o.left = v - d - k - t, o.left < 0 && (o.left = t), p = {
                left: -1
            }), o.top < 0 && (o.top = l + t, p = {
                top: -1
            }), o.top + e > u && (o.top = u - e - l - t, p = {
                top: -1
            }), {
                position: o,
                arrowOffset: p
            }
        }
    }, a.fn[e] = function(b, c) {
        var f = [],
            g = this.each(function() {
                var g = a.data(this, "plugin_" + e);
                g ? "destroy" === b ? g.destroy() : "string" == typeof b && f.push(g[b]()) : (b ? "string" == typeof b ? "destroy" !== b && (c || (g = new d(this, null), f.push(g[b]()))) : "object" == typeof b && (g = new d(this, b)) : g = new d(this, null), a.data(this, "plugin_" + e, g))
            });
        return f.length ? f : g
    }
}(jQuery, window, document);
/*!  - v - 2015-06-08 */
! function(ELEMENT) {
    ELEMENT.matches = ELEMENT.matches || ELEMENT.mozMatchesSelector || ELEMENT.msMatchesSelector || ELEMENT.oMatchesSelector || ELEMENT.webkitMatchesSelector || function(selector) {
        for (var element = this, elements = (element.document || element.ownerDocument).querySelectorAll(selector), index = 0; elements[index] && elements[index] !== element;) ++index;
        return elements[index] ? !0 : !1
    }, ELEMENT.closest = ELEMENT.closest || function(selector) {
        for (var element = this; element && !element.matches(selector);) element = element.parentElement;
        return element
    }
}(Element.prototype),
function() {
    if ("function" != typeof window.getMatchedCSSRules) {
        var ELEMENT_RE = /[\w-]+/g,
            ID_RE = /#[\w-]+/g,
            CLASS_RE = /\.[\w-]+/g,
            ATTR_RE = /\[[^\]]+\]/g,
            PSEUDO_CLASSES_RE = /\:(?!not)[\w-]+(\(.*\))?/g,
            PSEUDO_ELEMENTS_RE = /\:\:?(after|before|first-letter|first-line|selection)/g,
            toArray = function(list) {
                for (var items = [], i = 0, listLength = list.length; listLength > i; i++) items.push(list[i]);
                return items
            },
            getCSSHost = function(href) {
                var fakeLinkOfSheet = document.createElement("a");
                return fakeLinkOfSheet.href = href, fakeLinkOfSheet.host
            },
            getSheetRules = function(stylesheet) {
                var sheetHost, sheetMedia = stylesheet.media && stylesheet.media.mediaText;
                if ("true" == objectFit.disableCrossDomain && (sheetHost = getCSSHost(stylesheet.href), sheetHost !== window.location.host)) return [];
                if (stylesheet.disabled) return [];
                if (window.matchMedia) {
                    if (sheetMedia && sheetMedia.length && !window.matchMedia(sheetMedia).matches) return []
                } else if (sheetMedia && sheetMedia.length) return [];
                return toArray(stylesheet.cssRules)
            },
            _find = function(string, re) {
                string.match(re);
                return re ? re.length : 0
            },
            calculateScore = function(selector) {
                for (var part, match, score = [0, 0, 0], parts = selector.split(" "); part = parts.shift(), "string" == typeof part;) match = _find(part, PSEUDO_ELEMENTS_RE), score[2] = match, match && (part = part.replace(PSEUDO_ELEMENTS_RE, "")), match = _find(part, PSEUDO_CLASSES_RE), score[1] = match, match && (part = part.replace(PSEUDO_CLASSES_RE, "")), match = _find(part, ATTR_RE), score[1] += match, match && (part = part.replace(ATTR_RE, "")), match = _find(part, ID_RE), score[0] = match, match && (part = part.replace(ID_RE, "")), match = _find(part, CLASS_RE), score[1] += match, match && (part = part.replace(CLASS_RE, "")), score[2] += _find(part, ELEMENT_RE);
                return parseInt(score.join(""), 10)
            },
            getSpecificityScore = function(element, selectorText) {
                for (var selector, score, selectors = selectorText.split(","), result = 0; selector = selectors.shift();) element.closest(selector) && (score = calculateScore(selector), result = score > result ? score : result);
                return result
            },
            sortBySpecificity = function(element, rules) {
                var compareSpecificity = function(a, b) {
                    return getSpecificityScore(element, b.selectorText) - getSpecificityScore(element, a.selectorText)
                };
                return rules.sort(compareSpecificity)
            };
        window.getMatchedCSSRules = function(element) {
            var styleSheets, sheet, rules, rule, result = [];
            for (styleSheets = toArray(window.document.styleSheets); sheet = styleSheets.shift();)
                for (rules = getSheetRules(sheet); rule = rules.shift();) rule.styleSheet ? rules = getSheetRules(rule.styleSheet).concat(rules) : rule.media ? rules = getSheetRules(rule).concat(rules) : element.closest(rule.selectorText) && result.push(rule);
            return sortBySpecificity(element, result)
        }
    }
}(),
function(window) {
    for (var lastTime = 0, vendors = ["webkit", "moz"], requestAnimationFrame = window.requestAnimationFrame, cancelAnimationFrame = window.cancelAnimationFrame, i = vendors.length; --i >= 0 && !requestAnimationFrame;) requestAnimationFrame = window[vendors[i] + "RequestAnimationFrame"], cancelAnimationFrame = window[vendors[i] + "CancelAnimationFrame"];
    requestAnimationFrame && cancelAnimationFrame || (requestAnimationFrame = function(callback) {
        var now = +new Date,
            nextTime = Math.max(lastTime + 16, now);
        return setTimeout(function() {
            callback(lastTime = nextTime)
        }, nextTime - now)
    }, cancelAnimationFrame = clearTimeout), window.requestAnimationFrame = requestAnimationFrame, window.cancelAnimationFrame = cancelAnimationFrame
}(window),
function(global) {
    "use strict";
    var objectFit = {};
    objectFit._debug = !1, objectFit.observer = null, objectFit.disableCrossDomain = "false", objectFit.getComputedStyle = function(element, context) {
        return context = context || window, context.getComputedStyle ? context.getComputedStyle(element, null) : element.currentStyle
    }, objectFit.getDefaultComputedStyle = function(element) {
        var newelement = element.cloneNode(!0),
            styles = {},
            iframe = document.createElement("iframe");
        document.body.appendChild(iframe), iframe.contentWindow.document.open(), iframe.contentWindow.document.write("<body></body>"), iframe.contentWindow.document.body.appendChild(newelement), iframe.contentWindow.document.close();
        var value, property, defaultElement = iframe.contentWindow.document.querySelectorAll(element.nodeName.toLowerCase())[0],
            defaultComputedStyle = this.getComputedStyle(defaultElement, iframe.contentWindow);
        for (property in defaultComputedStyle)
            if (value = defaultComputedStyle.getPropertyValue === !0 ? defaultComputedStyle.getPropertyValue(property) : defaultComputedStyle[property], null !== value) switch (property) {
                default: styles[property] = value;
                break;
                case "width":
                        case "height":
                        case "minWidth":
                        case "minHeight":
                        case "maxWidth":
                        case "maxHeight":
            }
            return document.body.removeChild(iframe), styles
    }, objectFit.getMatchedStyle = function(element, property) {
        var val = null,
            inlineval = null;
        element.style.getPropertyValue ? inlineval = element.style.getPropertyValue(property) : element.currentStyle && (inlineval = element.currentStyle[property]);
        var r, important, rules = window.getMatchedCSSRules(element),
            i = rules.length;
        if (i)
            for (; i-- > 0 && (r = rules[i], important = r.style.getPropertyPriority(property), null !== val && !important || (val = r.style.getPropertyValue(property), !important)););
        return val || null === inlineval || (val = inlineval), val
    }, objectFit.orientation = function(replacedElement) {
        if (replacedElement.parentNode && "x-object-fit" === replacedElement.parentNode.nodeName.toLowerCase()) {
            var width = replacedElement.naturalWidth || replacedElement.clientWidth,
                height = replacedElement.naturalHeight || replacedElement.clientHeight,
                parentWidth = replacedElement.parentNode.clientWidth,
                parentHeight = replacedElement.parentNode.clientHeight;
            !height || width / height > parentWidth / parentHeight ? "wider" !== replacedElement.getAttribute("data-x-object-relation") && (replacedElement.setAttribute("data-x-object-relation", "wider"), replacedElement.className = "x-object-fit-wider", this._debug && window.console && console.log("x-object-fit-wider")) : "taller" !== replacedElement.getAttribute("data-x-object-relation") && (replacedElement.setAttribute("data-x-object-relation", "taller"), replacedElement.className = "x-object-fit-taller", this._debug && window.console && console.log("x-object-fit-taller"))
        }
    }, objectFit.process = function(args) {
        if (args.selector && args.replacedElements) {
            switch (objectFit.disableCrossDomain = args.disableCrossDomain || "false", args.fittype = args.fittype || "none", args.fittype) {
                default: return;
                case "none":
                        case "fill":
                        case "contain":
                        case "cover":
            }
            var replacedElements = args.replacedElements;
            if (replacedElements.length)
                for (var i = 0, replacedElementsLength = replacedElements.length; replacedElementsLength > i; i++) this.processElement(replacedElements[i], args)
        }
    }, objectFit.processElement = function(replacedElement, args) {
        var property, value, replacedElementStyles = objectFit.getComputedStyle(replacedElement),
            replacedElementDefaultStyles = objectFit.getDefaultComputedStyle(replacedElement),
            wrapperElement = document.createElement("x-object-fit");
        objectFit._debug && window.console && console.log("Applying to WRAPPER-------------------------------------------------------");
        for (property in replacedElementStyles) switch (property) {
            default: value = objectFit.getMatchedStyle(replacedElement, property),
            null !== value && "" !== value && (objectFit._debug && window.console && console.log(property + ": " + value), wrapperElement.style[property] = value);
            break;
            case "length":
                    case "parentRule":
        }
        objectFit._debug && window.console && console.log("Applying to REPLACED ELEMENT-------------------------------------------------------");
        for (property in replacedElementDefaultStyles) switch (property) {
            default: value = replacedElementDefaultStyles[property],
            objectFit._debug && window.console && "" !== value && (console.log(property + ": " + value), void 0 === replacedElement.style[property] && console.log("Indexed style properties (`" + property + "`) not supported in: " + window.navigator.userAgent)),
            replacedElement.style[property] ? replacedElement.style[property] = value : replacedElement.style.property = value;
            break;
            case "length":
                    case "parentRule":
        }
        wrapperElement.setAttribute("class", "x-object-fit-" + args.fittype), replacedElement.parentNode.insertBefore(wrapperElement, replacedElement), wrapperElement.appendChild(replacedElement), objectFit.orientation(replacedElement);
        var resizeTimer = null,
            resizeAction = function() {
                null !== resizeTimer && window.cancelAnimationFrame(resizeTimer), resizeTimer = window.requestAnimationFrame(function() {
                    objectFit.orientation(replacedElement)
                })
            };
        switch (args.fittype) {
            default: break;
            case "contain":
                    case "cover":
                    window.addEventListener ? (replacedElement.addEventListener("load", resizeAction, !1), window.addEventListener("resize", resizeAction, !1), window.addEventListener("orientationchange", resizeAction, !1)) : (replacedElement.attachEvent("onload", resizeAction), window.attachEvent("onresize", resizeAction))
        }
    }, objectFit.listen = function(args) {
        var domInsertedAction = function(element) {
                for (var i = 0, argsLength = args.length; argsLength > i; i++)(element.mozMatchesSelector && element.mozMatchesSelector(args[i].selector) || element.msMatchesSelector && element.msMatchesSelector(args[i].selector) || element.oMatchesSelector && element.oMatchesSelector(args[i].selector) || element.webkitMatchesSelector && element.webkitMatchesSelector(args[i].selector)) && (args[i].replacedElements = [element], objectFit.process(args[i]), objectFit._debug && window.console && console.log("Matching node inserted: " + element.nodeName))
            },
            domInsertedObserverFunction = function(element) {
                objectFit.observer.disconnect(), domInsertedAction(element), objectFit.observer.observe(document.documentElement, {
                    childList: !0,
                    subtree: !0
                })
            },
            domInsertedEventFunction = function(event) {
                window.removeEventListener("DOMNodeInserted", domInsertedEventFunction, !1), domInsertedAction(event.target), window.addEventListener("DOMNodeInserted", domInsertedEventFunction, !1)
            },
            domRemovedAction = function(element) {
                "x-object-fit" === element.nodeName.toLowerCase() && (element.parentNode.removeChild(element), objectFit._debug && window.console && console.log("Matching node removed: " + element.nodeName))
            },
            domRemovedObserverFunction = function(element) {
                objectFit.observer.disconnect(), domRemovedAction(element), objectFit.observer.observe(document.documentElement, {
                    childList: !0,
                    subtree: !0
                })
            },
            domRemovedEventFunction = function(event) {
                window.removeEventListener("DOMNodeRemoved", domRemovedEventFunction, !1), domRemovedAction(event.target.parentNode), window.addEventListener("DOMNodeRemoved", domRemovedEventFunction, !1)
            };
        window.MutationObserver ? (objectFit._debug && window.console && console.log("DOM MutationObserver"), this.observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.addedNodes && mutation.addedNodes.length)
                    for (var nodes = mutation.addedNodes, i = 0, nodesLength = nodes.length; nodesLength > i; i++) domInsertedObserverFunction(nodes[i]);
                mutation.removedNodes && mutation.removedNodes.length && domRemovedObserverFunction(mutation.target)
            })
        }), this.observer.observe(document.documentElement, {
            childList: !0,
            subtree: !0
        })) : window.addEventListener && (objectFit._debug && window.console && console.log("DOM Mutation Events"), window.addEventListener("DOMNodeInserted", domInsertedEventFunction, !1), window.addEventListener("DOMNodeRemoved", domRemovedEventFunction, !1))
    }, objectFit.init = function(args) {
        if (args) {
            args instanceof Array || (args = [args]);
            for (var i = 0, argsLength = args.length; argsLength > i; i++) args[i].replacedElements = document.querySelectorAll(args[i].selector), this.process(args[i]);
            this.listen(args)
        }
    }, objectFit.polyfill = function(args) {
        "objectFit" in document.documentElement.style == !1 ? (objectFit._debug && window.console && console.log("object-fit not natively supported"), "complete" === document.readyState ? objectFit.init(args) : window.addEventListener ? window.addEventListener("load", function() {
            objectFit.init(args)
        }, !1) : window.attachEvent("onload", function() {
            objectFit.init(args)
        })) : objectFit._debug && window.console && console.log("object-fit natively supported")
    }, "object" == typeof module && module && "object" == typeof module.exports ? module.exports = objectFit : "function" == typeof define && define.amd ? define([], function() {
        return objectFit
    }) : "object" == typeof global && "object" == typeof global.document && (global.objectFit = objectFit)
}(window);
(function(t, i, e) {
    var h, r = [],
        o = function() {
            var t = e.createElement("modernizr").style,
                i = "objectFit",
                h = "Webkit Moz O ms",
                r = h.split(" "),
                o = i.charAt(0).toUpperCase() + i.slice(1),
                n = (i + " " + r.join(o + " ") + o).split(" ");
            for (var a in n) {
                var i = n[a];
                if (~("" + i).indexOf("-") && void 0 !== t[i]) return "pfx" == prefixed ? i : !0
            }
            return !1
        },
        n = function(i) {
            var i = i || "contain",
                e = o();
            return this.each(function() {
                e ? t(this).css("object-fit", i) : a(this, i)
            })
        },
        a = function(i, e) {
            function h(t) {
                var i = t.parent(),
                    e = i.css("display");
                return "block" == e || "-webkit-box" == e && i.width() > 0 ? {
                    obj: i,
                    width: i.width(),
                    height: i.height(),
                    ratio: i.width() / i.height()
                } : h(i)
            }
            var o = "string" == typeof e ? e : e.type,
                n = void 0 === e.hideOverflow ? !0 : e.hideOverflow;
            r.push({
                elem: i,
                params: {
                    type: o,
                    hideOverflow: n
                }
            });
            var a, d, c = t(i),
                s = c.data("ratio"),
                f = h(c),
                w = t("<img/>").load(function() {
                    a = this.width, d = this.height, void 0 === s && (s = a / d, c.data("ratio", s)), "contain" === o ? f.ratio > s ? c.width(f.height * s) : c.height(f.width / s).width("100%") : "cover" === o && ((f.width > a || f.height > d) && (f.ratio > s ? c.width(f.width).height(f.height * s) : c.height(f.height).width(f.width * s)), n && f.obj.css("overflow", "hidden"))
                });
            w.attr("src", c.attr("src"))
        };
    t.fn.objectFit = n, t(i).resize(function() {
        clearTimeout(h);
        for (var t = 0, i = r.length; i > t; t++) {
            var e = r[t];
            h = setTimeout(function() {
                a(e.elem, e.params)
            }, 100)
        }
    })
})(jQuery, window, document);